{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/google9015e32577ccc55d.html","path":"google9015e32577ccc55d.html","modified":1,"renderable":0},{"_id":"source/baidu_verify_Us10aoTC4p.html","path":"baidu_verify_Us10aoTC4p.html","modified":1,"renderable":0},{"_id":"source/baidu_verify_XBpkZYVjlD.html","path":"baidu_verify_XBpkZYVjlD.html","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/sw.zip","path":"sw.zip","modified":1,"renderable":0},{"_id":"themes/next/source/manifest.json","path":"manifest.json","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.jpg","path":"images/apple-touch-icon-next.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg.bak","path":"images/avatar.jpg.bak","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.jpg","path":"images/favicon-16x16-next.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.jpg","path":"images/favicon-32x32-next.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/M2Jd71oPJhLKp0zdtTvoM40tgx99jmYGv_xzYuwd1rU.woff2","path":"fonts/M2Jd71oPJhLKp0zdtTvoM40tgx99jmYGv_xzYuwd1rU.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechatpay.png","path":"images/wechatpay.png","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/M2Jd71oPJhLKp0zdtTvoM7YHq4FgHI02B8rPccK0FJQ.woff2","path":"fonts/M2Jd71oPJhLKp0zdtTvoM7YHq4FgHI02B8rPccK0FJQ.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/M2Jd71oPJhLKp0zdtTvoMxgy2Fsj5sj3EzlXpqVXRKo.woff2","path":"fonts/M2Jd71oPJhLKp0zdtTvoMxgy2Fsj5sj3EzlXpqVXRKo.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/ODelI1aHBYDBqgeIAH2zlC2Q8seG17bfDXYR_jUsrzg.woff2","path":"fonts/ODelI1aHBYDBqgeIAH2zlC2Q8seG17bfDXYR_jUsrzg.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/ODelI1aHBYDBqgeIAH2zlNOAHFN6BivSraYkjhveRHY.woff2","path":"fonts/ODelI1aHBYDBqgeIAH2zlNOAHFN6BivSraYkjhveRHY.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/ODelI1aHBYDBqgeIAH2zlNV_2ngZ8dMf8fLgjYEouxg.woff2","path":"fonts/ODelI1aHBYDBqgeIAH2zlNV_2ngZ8dMf8fLgjYEouxg.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/fonts.css","path":"fonts/fonts.css","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6MAjkyiewWYrWZc50I8hK7I.woff2","path":"fonts/fpTVHK8qsXbIeTHTrnQH6MAjkyiewWYrWZc50I8hK7I.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6E78GtRp3lhchupCJNw8t58.woff2","path":"fonts/fpTVHK8qsXbIeTHTrnQH6E78GtRp3lhchupCJNw8t58.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6CzM2XYAq8cDhaXsrN8WXcA.woff2","path":"fonts/fpTVHK8qsXbIeTHTrnQH6CzM2XYAq8cDhaXsrN8WXcA.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6Lpx497t94oDua8KfAL9f-E.woff2","path":"fonts/fpTVHK8qsXbIeTHTrnQH6Lpx497t94oDua8KfAL9f-E.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6GQKuzMuncr0JB710wa2dPI.woff2","path":"fonts/fpTVHK8qsXbIeTHTrnQH6GQKuzMuncr0JB710wa2dPI.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGCOFnW3Jk0f09zW_Yln67Ac.woff2","path":"fonts/toadOcfmlt9b38dHJxOBGCOFnW3Jk0f09zW_Yln67Ac.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6OXKTZYPNtG1yMB_YJSqlic.woff2","path":"fonts/fpTVHK8qsXbIeTHTrnQH6OXKTZYPNtG1yMB_YJSqlic.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGClYwVOhDRq2vbpGRTZ7bbs.woff2","path":"fonts/toadOcfmlt9b38dHJxOBGClYwVOhDRq2vbpGRTZ7bbs.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGD_j0nMiB9fPhg_k1wdK2h0.woff2","path":"fonts/toadOcfmlt9b38dHJxOBGD_j0nMiB9fPhg_k1wdK2h0.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGDRVvBvQIc1z78c__uoBcyI.woff2","path":"fonts/toadOcfmlt9b38dHJxOBGDRVvBvQIc1z78c__uoBcyI.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGDovqjS_dXPZszO_XltPdNg.woff2","path":"fonts/toadOcfmlt9b38dHJxOBGDovqjS_dXPZszO_XltPdNg.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGEo0As1BFRXtCDhS66znb_k.woff2","path":"fonts/toadOcfmlt9b38dHJxOBGEo0As1BFRXtCDhS66znb_k.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGFKFh1TDTPrUZWzVp6FtpG8.woff2","path":"fonts/toadOcfmlt9b38dHJxOBGFKFh1TDTPrUZWzVp6FtpG8.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGFxe-GPfKKFmiXaJ_Q0GFr8.woff2","path":"fonts/toadOcfmlt9b38dHJxOBGFxe-GPfKKFmiXaJ_Q0GFr8.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGOode0-EuMkY--TSyExeINg.woff2","path":"fonts/toadOcfmlt9b38dHJxOBGOode0-EuMkY--TSyExeINg.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/说明.txt","path":"fonts/说明.txt","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/原始.css","path":"fonts/原始.css","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"80bac6651cde15bc1daeb1296526888b7f0d249d","modified":1617441483038},{"_id":"source/google9015e32577ccc55d.html","hash":"a29d3a3e36e5097b6876cb98d5a76a31bd8afe88","modified":1615691090726},{"_id":"source/baidu_verify_Us10aoTC4p.html","hash":"5468c418816642d5d5844786df828f7b79c3a5d3","modified":1615691090726},{"_id":"source/baidu_verify_XBpkZYVjlD.html","hash":"657a60f6bed3e71f60efc4173460aa8f01cd2fe2","modified":1615691090726},{"_id":"source/sw.js","hash":"7195a555aa8d4429f0b5cb0840c2f22d11f45ca9","modified":1615691090727},{"_id":"source/manifest.json","hash":"b3db5e3ff3977a2d6f603992599c291de57d600d","modified":1615691090726},{"_id":"source/robots.txt","hash":"bfe9e3f48c650224f72e292643aacc53b29bbd94","modified":1615691090727},{"_id":"source/sw.zip","hash":"f903be80cf2cddc000e23c58e35e40b7c776a31e","modified":1615691090727},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1615691090745},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1615691090745},{"_id":"themes/next/.all-contributorsrc","hash":"e32dc4075e304af04b98d0726d489081bea722c0","modified":1615691090745},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1615691090745},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1615691090745},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1615691090747},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1615691090747},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1615691090747},{"_id":"themes/next/.DS_Store","hash":"700c37091f8b140398334115e7ce25e855ab3334","modified":1616287471346},{"_id":"themes/next/bower.json","hash":"087eb7b81c0aa77a2b07c2ecf411ceb5ee00386d","modified":1615691090748},{"_id":"themes/next/README.md","hash":"ee7119baf976616a84d3c9c10fcab567995dc98e","modified":1615691090747},{"_id":"themes/next/_config.yml","hash":"eff31c8fb6194094aa7cd21388b837cabd785fcd","modified":1615691090748},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1615691090753},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1615691090748},{"_id":"themes/next/package.json","hash":"cf079447c126a9ad760f1457441f31803ef0470b","modified":1615691090767},{"_id":"source/_posts/.DS_Store","hash":"30fb9ba5d123aed146ecb0d0ddfc2a534c8c8e95","modified":1617441483039},{"_id":"source/about/index.md","hash":"cde61e75fcbb6b0ea552299e73509b476fccbea3","modified":1615691090726},{"_id":"source/categories/index.md","hash":"9199ca08fbeda58daf82ba7583a2437caf64b602","modified":1615691090726},{"_id":"source/tags/index.md","hash":"1faf62cdf5fe38fbbc6a294620f0ad111aceac4e","modified":1615691090727},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1615691090746},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1615691090746},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1615691090746},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1615691090746},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1615691090746},{"_id":"themes/next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1615691090747},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1615691090748},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1615691090749},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1615691090749},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1615691090749},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1615691090749},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1615691090749},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1615691090749},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1615691090750},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1615691090750},{"_id":"themes/next/layout/.DS_Store","hash":"ae2a0516cd79db3eb88217b43131b95bc141dac0","modified":1616287701867},{"_id":"themes/next/layout/_layout.swig","hash":"f7478d930841b2e0483c86a31f5a5a6ac83754ae","modified":1615691090755},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1615691090766},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1615691090766},{"_id":"themes/next/layout/index.swig","hash":"f7bc897e328c00423c3da4efa4e2da70e213e0b0","modified":1615691090766},{"_id":"themes/next/layout/page.swig","hash":"862b361852fb6d7a95bfb6077922410a33cd3126","modified":1615691090766},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1615691090766},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1615691090766},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1615691090753},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1615691090753},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1615691090753},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1615691090753},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1615691090753},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1615691090753},{"_id":"themes/next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1615691090753},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1615691090754},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1615691090754},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1615691090754},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1615691090754},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1615691090754},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1615691090754},{"_id":"themes/next/layout/post.swig","hash":"b7c71e98a1485150f083ab720aa7fe272262a32d","modified":1616297861235},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1615691090754},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1615691090767},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1615691090767},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1615691090754},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1615691090754},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1615691090754},{"_id":"source/_posts/jenkins/NET实现持续集成与自动化部署1-Jenkins.md","hash":"845d091144fa4e98e511b60fc48602b2e0bad8e1","modified":1615691090697},{"_id":"source/_posts/jenkins/NET实现持续集成与自动化部署2-NuGet.md","hash":"35fbaa03fa8b827b0dbbffa65401eee3c8878d80","modified":1615691090698},{"_id":"source/_posts/jenkins/NET实现持续集成与自动化部署3-测试环境到生产环境策略.md","hash":"28bf5de26189787d882f60c02e3a4b3231cf46e2","modified":1615691090698},{"_id":"themes/next/source/manifest.json","hash":"666df92b12f4f7b158def412450cf7b03ed68e92","modified":1615691090812},{"_id":"source/_posts/log/NET日志记录-log4net.md","hash":"f3e8026772e7e79b10620f023945ed3cd33f0fda","modified":1615691090698},{"_id":"source/_posts/log/NET下日志系统的搭建—log4net-kafka-elk.md","hash":"ba818847c3a3d454917405b8df0a6bbb728812cb","modified":1615691090698},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1615691090812},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1615691090812},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1615691090812},{"_id":"source/_posts/效能管理/.DS_Store","hash":"cc59d06c2fa815e3fd04178216fedcd214fd9fb8","modified":1616311484576},{"_id":"source/_posts/技术实践/.DS_Store","hash":"a8c6326ca31ad52961e9c95c51fcff6ba2782b2c","modified":1617441546119},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615691090783},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1615691090755},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1615691090755},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1615691090751},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1615691090755},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1615691090751},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1615691090751},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1615691090751},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1615691090752},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"8ac2f5d2a023211d8d8ea626cbf6b8dea67ac201","modified":1615691090752},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1615691090752},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1615691090752},{"_id":"themes/next/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1615691090752},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1615691090750},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1615691090750},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1615691090751},{"_id":"themes/next/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1615691090751},{"_id":"themes/next/layout/_macro/my-copyright.swig","hash":"e7245d7cefcb4dc80398d0141da58878a408c6c5","modified":1615691090755},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"82f9e238bac68dfe592915631d1ff0cca7b9da95","modified":1615691090756},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1615691090756},{"_id":"themes/next/layout/_macro/reward.swig","hash":"64d65d9ad0cc94734ac6ded279e2b5dc870a1cab","modified":1615691090756},{"_id":"themes/next/layout/_macro/post.swig","hash":"e581bc7f2988a244a76e238e09385dfe6ccfbf86","modified":1615691090756},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1615691090756},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"7de45148881b9d857ad45bc9e5ee3bd5809aef7f","modified":1615691090756},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1615691090757},{"_id":"themes/next/layout/_partials/comments.swig","hash":"e6ecc7e727b6cc35d9931bf65514ced329d6c535","modified":1615691090757},{"_id":"themes/next/layout/_partials/aside.swig","hash":"4c39ec6c47719deca0c1313cb5f3349671e2dc63","modified":1615691090756},{"_id":"themes/next/layout/_partials/footer.swig","hash":"07f88421bda86d9d5ff32d130b1cb1196b99a326","modified":1615691090757},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1615691090758},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1615691090758},{"_id":"themes/next/layout/_partials/post-copyright.swig","hash":"2f73cc9ffb63534f0b6d8f0e9ee853c1af1b1244","modified":1615691090758},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1615691090759},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1615691090759},{"_id":"themes/next/layout/_scripts/lean-analytics.swig","hash":"59fb1164da849b98ef62e1a996a4d935f5aab74d","modified":1615691090759},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1615691090759},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"f380a10c792411eff82204305b097a288ed0b423","modified":1615691090760},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1615691090763},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1615691090762},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1615691090763},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"c0f6f02d7d7eb20eb216003c6cfb4ea52060f791","modified":1615691090763},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1615691090764},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1615691090764},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1615691090764},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"def2736c8c10170712ff36dea220243b0c1858af","modified":1615691090764},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1615691090765},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1615691090765},{"_id":"themes/next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1615691090767},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"15582e823d228c0b2288543c1eb460c40afad29b","modified":1615691090767},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1615691090768},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1615691090768},{"_id":"themes/next/scripts/tags/exturl.js","hash":"7ded3e7a78380b32de3e12f156e0978ef5c2890a","modified":1615691090768},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1615691090768},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1615691090768},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1615691090768},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1615691090768},{"_id":"themes/next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1615691090768},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1615691090768},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1615691090783},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1615691090786},{"_id":"themes/next/source/images/apple-touch-icon-next.jpg","hash":"631175b35e275927c09eea70acc41f00c223d677","modified":1615691090786},{"_id":"themes/next/source/images/alipay.jpg","hash":"729213e8f4d61d2ccf607467d3b474d4842c347d","modified":1615691090786},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1615691090786},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1615691090786},{"_id":"themes/next/source/images/avatar.jpg","hash":"6f02591359265c7142c9244d3282b7c199e4d954","modified":1615691090787},{"_id":"themes/next/source/images/avatar.jpg.bak","hash":"d47363a17a313f7193b7981b2f7e33d29aa5d55f","modified":1615691090787},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1615691090787},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1615691090787},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1615691090787},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1615691090787},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1615691090787},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1615691090787},{"_id":"themes/next/source/images/favicon-16x16-next.jpg","hash":"df39d619611cab6d2db0cab1c16e189e47bbee19","modified":1615691090788},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1615691090787},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"df39d619611cab6d2db0cab1c16e189e47bbee19","modified":1615691090788},{"_id":"themes/next/source/images/favicon-192x192.png","hash":"1b63d6389fe13db6f6dd45eac7b07268e86a1ead","modified":1615691090788},{"_id":"themes/next/source/images/favicon-32x32-next.jpg","hash":"7fce0752fd932e247ca6f9fc92ec1017ecde7441","modified":1615691090788},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"7fce0752fd932e247ca6f9fc92ec1017ecde7441","modified":1615691090788},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1615691090788},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1615691090788},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1615691090788},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1615691090789},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1615691090789},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1615691090789},{"_id":"themes/next/source/fonts/M2Jd71oPJhLKp0zdtTvoM40tgx99jmYGv_xzYuwd1rU.woff2","hash":"d9b2ef60d14299632660b1f14156bc8d33e84f10","modified":1615691090783},{"_id":"themes/next/source/images/wechatpay.png","hash":"73162ca6c31a588e1f1240c39a405a91004ab922","modified":1615691090789},{"_id":"themes/next/source/fonts/M2Jd71oPJhLKp0zdtTvoM7YHq4FgHI02B8rPccK0FJQ.woff2","hash":"80c635636e0fd0d1ddbd5a4f60f846b1773fcd4d","modified":1615691090783},{"_id":"themes/next/source/fonts/M2Jd71oPJhLKp0zdtTvoMxgy2Fsj5sj3EzlXpqVXRKo.woff2","hash":"90675f06fbecae812d4e4161630f9e71268d53aa","modified":1615691090783},{"_id":"themes/next/source/fonts/ODelI1aHBYDBqgeIAH2zlC2Q8seG17bfDXYR_jUsrzg.woff2","hash":"869ef1d25cef6143e4b9298cc841de0d8410d488","modified":1615691090783},{"_id":"themes/next/source/fonts/ODelI1aHBYDBqgeIAH2zlNOAHFN6BivSraYkjhveRHY.woff2","hash":"ffd2de23ffff227247b5417bc454ca5de452c7d1","modified":1615691090784},{"_id":"themes/next/source/fonts/ODelI1aHBYDBqgeIAH2zlNV_2ngZ8dMf8fLgjYEouxg.woff2","hash":"235c384b9599ed2099f8fda87ba7bc8917eb1aa4","modified":1615691090784},{"_id":"themes/next/source/fonts/fonts.css","hash":"33eb87aea06200c294cba9cae54cdd3978de5e36","modified":1615691090784},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6MAjkyiewWYrWZc50I8hK7I.woff2","hash":"19e0f393f7f44463d5677f41a52763c2a5902362","modified":1615691090784},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6E78GtRp3lhchupCJNw8t58.woff2","hash":"3f609717d5e58e73e0162a94908faf7e036ad2a2","modified":1615691090784},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6CzM2XYAq8cDhaXsrN8WXcA.woff2","hash":"b52dd0120b00d2c5c39dfbbc44161f8e4d48ffba","modified":1615691090784},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6Lpx497t94oDua8KfAL9f-E.woff2","hash":"9e79ab1cfb1c8847a5ed7417bbb82a251e5aa6ce","modified":1615691090784},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6GQKuzMuncr0JB710wa2dPI.woff2","hash":"36a2ad3968ec04260f99a9bafc65b3e1e1442178","modified":1615691090784},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGCOFnW3Jk0f09zW_Yln67Ac.woff2","hash":"a8eb7a7729f7f69f145d0505b9f3219d3b8b1a9a","modified":1615691090784},{"_id":"themes/next/source/fonts/fpTVHK8qsXbIeTHTrnQH6OXKTZYPNtG1yMB_YJSqlic.woff2","hash":"2d331a887214a102602a3b871dddc1645a8c0346","modified":1615691090784},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGClYwVOhDRq2vbpGRTZ7bbs.woff2","hash":"68963ed662dca9c862418db1ff81565b3585a951","modified":1615691090785},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGD_j0nMiB9fPhg_k1wdK2h0.woff2","hash":"4d907d9d7c2a3ec3d5b450cc5b5e9adfd805d4c8","modified":1615691090785},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGDRVvBvQIc1z78c__uoBcyI.woff2","hash":"6a94f553d70d2f6a33c937172ac28230b0f43691","modified":1615691090785},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGDovqjS_dXPZszO_XltPdNg.woff2","hash":"8779f0a3e92c789016a138614a9ff51cb07e0b92","modified":1615691090785},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGEo0As1BFRXtCDhS66znb_k.woff2","hash":"b380e9f3dc4dfb061e70a88e1156ec89b008808a","modified":1615691090785},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGFKFh1TDTPrUZWzVp6FtpG8.woff2","hash":"26b54eaef53d7ef184f7804090aca31683ddca90","modified":1615691090785},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGFxe-GPfKKFmiXaJ_Q0GFr8.woff2","hash":"b63fa29c4b1b9e04b21c58aecb2b77b527167821","modified":1615691090785},{"_id":"themes/next/source/fonts/toadOcfmlt9b38dHJxOBGOode0-EuMkY--TSyExeINg.woff2","hash":"b9c7821c54dad58ca7f53e42cb17cb7b85f37d0a","modified":1615691090785},{"_id":"themes/next/source/fonts/说明.txt","hash":"58ef10f355ef7209f486789aadcf34695280c77e","modified":1615691090786},{"_id":"themes/next/source/fonts/原始.css","hash":"c80fc6b6229581f3873d55d147be1c60d36f59b3","modified":1615691090785},{"_id":"source/_posts/redis_command/bitmap/bitcount.md","hash":"dfc49d3d91429b3a33d38d3617fef8dc43a363dc","modified":1615691090699},{"_id":"source/_posts/redis_command/bitmap/bitop.md","hash":"42b72389c1bfc979b05869a3ec41bc401b208f82","modified":1615691090700},{"_id":"source/_posts/redis_command/bitmap/bitpos.md","hash":"56e74e56ae2841165db5a037949b45e7e00873df","modified":1615691090700},{"_id":"source/_posts/redis_command/bitmap/bitfield.md","hash":"e07db9dbef0ce04f0dc048e4ad9eb719c991a237","modified":1615691090699},{"_id":"source/_posts/redis_command/bitmap/setbit.md","hash":"9159937827183e61232e717308ee46049f7189e8","modified":1615691090700},{"_id":"source/_posts/redis_command/bitmap/getbit.md","hash":"65ec1a9ab872e7271deb08bb82d479df2c3847d9","modified":1615691090700},{"_id":"source/_posts/redis_command/set/scard.md","hash":"dd7172cfdf8624a4529a69959ef2f48a2bcdcbc2","modified":1615691090705},{"_id":"source/_posts/redis_command/set/sadd.md","hash":"792fb9c922ffa1496c6024e6aa21d08293fd10fa","modified":1615691090705},{"_id":"source/_posts/redis_command/set/sdiff.md","hash":"a0f949402f6ce3a6396523da032d3859d1f48eba","modified":1615691090705},{"_id":"source/_posts/redis_command/set/sdiffstore.md","hash":"0a934cc30a7f7bb92c4908545f7d2bbf511fec89","modified":1615691090705},{"_id":"source/_posts/redis_command/set/sinterstore.md","hash":"7d521564fb989e034b3ec8377755bcef79e84643","modified":1615691090706},{"_id":"source/_posts/redis_command/set/sinter.md","hash":"0edeea2805237453bdb4903647389885c2c0aca0","modified":1615691090705},{"_id":"source/_posts/redis_command/set/smembers.md","hash":"35a7dc604b1a3a0326ac8d3451476fd2392d9caf","modified":1615691090706},{"_id":"source/_posts/redis_command/set/sismember.md","hash":"2aceb520a70175d7a1118fe084de3b05fad2b36b","modified":1615691090706},{"_id":"source/_posts/redis_command/set/spop.md","hash":"08b0da1b3dd4169dc677bee832ad305306198584","modified":1615691090706},{"_id":"source/_posts/redis_command/set/smove.md","hash":"d1a8d557e823ca22d4a65d52501065cbe00371ab","modified":1615691090706},{"_id":"source/_posts/redis_command/set/srandmember.md","hash":"bffd8571036371809bb180a0003e07c0891e146a","modified":1615691090706},{"_id":"source/_posts/redis_command/set/srem.md","hash":"49777df540df7bbd606ad54780da350008ac5b6c","modified":1615691090706},{"_id":"source/_posts/redis_command/set/sunion.md","hash":"71bb772a79972f2807974b906e02b79cc5c11a5c","modified":1615691090707},{"_id":"source/_posts/redis_command/set/sscan.md","hash":"402b53db6f8b21a9c4cce9e0de14fbf0cc559db4","modified":1615691090706},{"_id":"source/_posts/redis_command/set/sunionstore.md","hash":"c5634d2d5c1914527f82198d916a0cc8a1e78590","modified":1615691090707},{"_id":"source/_posts/redis_command/list/brpoplpush.md","hash":"5ba19d75035af999f0b535210fd3ae25b36a877a","modified":1615691090702},{"_id":"source/_posts/redis_command/list/brpop.md","hash":"799dbd9f176b72bc0889343a3d3e6fc42653ae2f","modified":1615691090702},{"_id":"source/_posts/redis_command/list/lindex.md","hash":"e03276a7ddfb83b6fe09b473cc9a45760944beef","modified":1615691090703},{"_id":"source/_posts/redis_command/list/llen.md","hash":"2d0bbadc2368ab432612d712a08aa8ed32e1b808","modified":1615691090703},{"_id":"source/_posts/redis_command/list/linsert.md","hash":"5b183129dd784c7fb4f2e88496607edef0c0826e","modified":1615691090703},{"_id":"source/_posts/redis_command/list/blpop.md","hash":"9d11c42fea09a42662e8b50d659560fead003e05","modified":1615691090702},{"_id":"source/_posts/redis_command/list/lpush.md","hash":"b1926796cc892d7e9835d3d2ac7f4f7ff15976a7","modified":1615691090703},{"_id":"source/_posts/redis_command/list/lpop.md","hash":"a2848d7ad410c55c1d382bf7e21799f728413e4a","modified":1615691090703},{"_id":"source/_posts/redis_command/list/lpushx.md","hash":"6375dd4a42e425252b10fab841dfdd719456e8e7","modified":1615691090703},{"_id":"source/_posts/redis_command/list/lrange.md","hash":"f2e78ea3574cc272413ff6a9aeaec97402d35e2a","modified":1615691090703},{"_id":"source/_posts/redis_command/list/lset.md","hash":"90ae649696cb06d9fe297e797a71236c65c41cf5","modified":1615691090704},{"_id":"source/_posts/redis_command/list/ltrim.md","hash":"c05469233343b53517e1505ae5c5e1964065610c","modified":1615691090704},{"_id":"source/_posts/redis_command/list/lrem.md","hash":"ccc770e09fb1b7c1f94eddac6d11cdb37635c516","modified":1615691090704},{"_id":"source/_posts/redis_command/list/rpop.md","hash":"fc8273f8ffafd1a6d41fb99abc2be7f7ad941c95","modified":1615691090704},{"_id":"source/_posts/redis_command/list/rpoplpush.md","hash":"fc23d71f0c6abd1dfab49bf74714e1eaa726db66","modified":1615691090704},{"_id":"source/_posts/redis_command/list/rpush.md","hash":"c4f5df348c7762494ef4e3784e0f4bb48919410d","modified":1615691090705},{"_id":"source/_posts/redis_command/list/rpushx.md","hash":"964e061d2caaf289f90f91bfffff15d22e330b0f","modified":1615691090705},{"_id":"source/_posts/redis_command/sorted_set/bzpopmax.md","hash":"2e4919a41422902b0ce79efcd03e445819b1e8a1","modified":1615691090707},{"_id":"source/_posts/redis_command/sorted_set/bzpopmin.md","hash":"b68133b8e373502d6b56d9b8a0a6468d9bd34330","modified":1615691090707},{"_id":"source/_posts/redis_command/sorted_set/zadd.md","hash":"e2ef4467b15674887cd08650500f005b16876d38","modified":1615691090707},{"_id":"source/_posts/redis_command/sorted_set/zcard.md","hash":"17028e151e004a6d61ac4454e0a7dedc2feede32","modified":1615691090707},{"_id":"source/_posts/redis_command/sorted_set/zcount.md","hash":"e426665de3a71680bae5933acdeb0da63abc200d","modified":1615691090707},{"_id":"source/_posts/redis_command/sorted_set/zinterstore.md","hash":"0dc9d9c0793736ff1eb58327b37ccbceae54b6a1","modified":1615691090708},{"_id":"source/_posts/redis_command/sorted_set/zincrby.md","hash":"64c94962805bab6463dda477438259f9c7669b1c","modified":1615691090707},{"_id":"source/_posts/redis_command/sorted_set/zlexcount.md","hash":"01a87201809f08cb7579737fa1981b6b43d07483","modified":1615691090708},{"_id":"source/_posts/redis_command/sorted_set/zpopmin.md","hash":"cf888539c97a98315466b789d74b254ccf72f6dd","modified":1615691090708},{"_id":"source/_posts/redis_command/sorted_set/zpopmax.md","hash":"5cb41feaa4c9cc5452249f141dbbbe0a423c0a20","modified":1615691090708},{"_id":"source/_posts/redis_command/sorted_set/zrange.md","hash":"6d0b773898c38291e463f9ee1c7de138e296c823","modified":1615691090708},{"_id":"source/_posts/redis_command/sorted_set/zrangebylex.md","hash":"f804dd01b1fad75e2ff49f0a3ab1e8ffac537c72","modified":1615691090709},{"_id":"source/_posts/redis_command/sorted_set/zrangebyscore.md","hash":"b562461a1a6dea73c1ac76746857a56dfab0427b","modified":1615691090709},{"_id":"source/_posts/redis_command/sorted_set/zrem.md","hash":"98d8665afffda432b6e334445291f1a004c48ac4","modified":1615691090709},{"_id":"source/_posts/redis_command/sorted_set/zrank.md","hash":"c84ca5ff5674fea19d457d8f40a52fee5cebde6c","modified":1615691090709},{"_id":"source/_posts/redis_command/sorted_set/zremrangebylex.md","hash":"6dd406c837a4d0a7b5dc5e587c76aa0f0cd90d2b","modified":1615691090709},{"_id":"source/_posts/redis_command/sorted_set/zremrangebyrank.md","hash":"325b844a8079d0de6f85ddadfc1e23fb1d6279bb","modified":1615691090709},{"_id":"source/_posts/redis_command/sorted_set/zrevrange.md","hash":"8191e1bf0b8e5e177fcde8f49d48007617a61d78","modified":1615691090710},{"_id":"source/_posts/redis_command/sorted_set/zrevrangebyscore.md","hash":"6ae14d4d191ca2c5b19d5d87ac158781aa79edb7","modified":1615691090710},{"_id":"source/_posts/redis_command/sorted_set/zremrangebyscore.md","hash":"2ab1cd3b5415488d2f58b49ee633a2697d6f97df","modified":1615691090710},{"_id":"source/_posts/redis_command/sorted_set/zrevrangebylex.md","hash":"2f9011557ad7c2fb5046f9a475958076956cd630","modified":1615691090710},{"_id":"source/_posts/redis_command/sorted_set/zrevrank.md","hash":"a139f10c932d889c550cdec140b3578e1d388735","modified":1615691090710},{"_id":"source/_posts/redis_command/sorted_set/zscore.md","hash":"d8593bba111a07374e975bf64456d327fbf6c801","modified":1615691090710},{"_id":"source/_posts/redis_command/sorted_set/zunionstore.md","hash":"8453432d93ff878b19fe72c538561952e133454d","modified":1615691090711},{"_id":"source/_posts/redis_command/sorted_set/zscan.md","hash":"885a0805283e1f08f0e235ae1dafd2072e80800c","modified":1615691090710},{"_id":"source/_posts/redis_command/hash/hdel.md","hash":"3253c65a7e3501d62675ca147697df493684098d","modified":1615691090700},{"_id":"source/_posts/redis_command/hash/hexists.md","hash":"f26ada1cb077b05b9b4eb902f783a02f643b5cad","modified":1615691090700},{"_id":"source/_posts/redis_command/hash/hgetall.md","hash":"ecec532ff29dfd41e70cbd92953f1f6c1628bf48","modified":1615691090700},{"_id":"source/_posts/redis_command/hash/hget.md","hash":"6863957df9d5c6de3b4912eeb01806ab74ef30d5","modified":1615691090700},{"_id":"source/_posts/redis_command/hash/hincrby.md","hash":"1d647e7553240c5ea1b564f6187024f2de7d4c07","modified":1615691090701},{"_id":"source/_posts/redis_command/hash/hincrbyfloat.md","hash":"90d1070509301fd6446f97be16167536b85f4e6c","modified":1615691090701},{"_id":"source/_posts/redis_command/hash/hlen.md","hash":"c072146382bf40d656c2be5d9667575c8affeb95","modified":1615691090701},{"_id":"source/_posts/redis_command/hash/hmget.md","hash":"390b33730fb8ed161e066b0029811ba61f9cb83b","modified":1615691090701},{"_id":"source/_posts/redis_command/hash/hkeys.md","hash":"e4e5ea01a492c9db08a4e113d7c012fd58ebf649","modified":1615691090701},{"_id":"source/_posts/redis_command/hash/hmset.md","hash":"b57eb1ad3f64ab358b6b58614257baa4f2b17f47","modified":1615691090701},{"_id":"source/_posts/redis_command/hash/hscan.md","hash":"aeb740ab83f2357c0597be61a495e75de4cfe5f1","modified":1615691090701},{"_id":"source/_posts/redis_command/hash/hset.md","hash":"dd5c4e15a550c53b89b1fb60f6cfcec43bf0d783","modified":1615691090701},{"_id":"source/_posts/redis_command/hash/hsetnx.md","hash":"48ef390d75379fe5ee7d18c64376bae97b91e910","modified":1615691090702},{"_id":"source/_posts/redis_command/hash/hstrlen.md","hash":"c2e43ac128502738089a6141b94ed135e8846627","modified":1615691090702},{"_id":"source/_posts/redis_command/hash/hvals.md","hash":"7da21a2cdce10b2510dfdaab3a70403609d3db0f","modified":1615691090702},{"_id":"source/_posts/redis_command/string/append.md","hash":"e99d93c9dd0f8c27099b5f112e75fbf529cb51ae","modified":1615691090711},{"_id":"source/_posts/redis_command/string/decr.md","hash":"45ee526238e49550431875a00208fec517439da3","modified":1615691090711},{"_id":"source/_posts/redis_command/string/decrby.md","hash":"dd48896f3572a0c9a5d1cc6d0bb1937c22c135d3","modified":1615691090711},{"_id":"source/_posts/redis_command/string/get.md","hash":"de9f96d78efcde334e62d0d0d28c1bebb26b96c4","modified":1615691090711},{"_id":"source/_posts/redis_command/string/getrange.md","hash":"efef97cc3a5f1e35fd1e2cf3b85088f9af77a779","modified":1615691090711},{"_id":"source/_posts/redis_command/string/getset.md","hash":"fd2746c89715eca58cafda6fac383eb99699ca3d","modified":1615691090712},{"_id":"source/_posts/redis_command/string/incr.md","hash":"a417f47401dedee6c97beda74ab2f11a83797028","modified":1615691090712},{"_id":"source/_posts/redis_command/string/incrby.md","hash":"063ea5ab02cbc647fc579c9a94c12b00434ac79f","modified":1615691090712},{"_id":"source/_posts/redis_command/string/incrbyfloat.md","hash":"bdc7dd5b898c7a17abafa19f4cd4e05061281e55","modified":1615691090712},{"_id":"source/_posts/redis_command/string/mget.md","hash":"d84ba4d39cfcdc7285d8469e2596a7154700e934","modified":1615691090712},{"_id":"source/_posts/redis_command/string/mset.md","hash":"31f3481695ad16db865ff738c98700b599592660","modified":1615691090712},{"_id":"source/_posts/redis_command/string/msetnx.md","hash":"b187b00305ae687ca2a0e78e4baa13ca119bfc45","modified":1615691090713},{"_id":"source/_posts/redis_command/string/psetex.md","hash":"6f8a693ac9e96160c8dd612a8c50dcd5a08e184d","modified":1615691090713},{"_id":"source/_posts/redis_command/string/set.md","hash":"ffef32281436daaddea7e6765b42a7cef7838aac","modified":1615691090713},{"_id":"source/_posts/redis_command/string/setex.md","hash":"548dac75da7488d5a659379220aa88396080dded","modified":1615691090713},{"_id":"source/_posts/redis_command/string/setnx.md","hash":"59d5510901172739918bada0bd4a22d52399f933","modified":1615691090714},{"_id":"source/_posts/redis_command/string/setrange.md","hash":"958f657ffe37e470aff15be4bf475c4de305cf83","modified":1615691090714},{"_id":"source/_posts/redis_command/string/strlen.md","hash":"d385e703257059aff6bac9a0c3c928f27bba6a63","modified":1615691090714},{"_id":"source/_posts/notes/大型网站技术架构/大型网站架构(一)大型网站的特点.md","hash":"5105e973d4a2cc471df976db441bc3a33fe41a1b","modified":1615691090699},{"_id":"source/_posts/notes/大型网站技术架构/大型网站架构(三)大型网站的演化下.md","hash":"6d203e956c6e9fbb72161404f7138e4671d2086d","modified":1615691090699},{"_id":"source/_posts/notes/大型网站技术架构/大型网站架构(二)大型网站的演化上.md","hash":"ee1342e149ac12912f282859ac8caee2ca882b61","modified":1615691090699},{"_id":"source/_posts/notes/大型网站技术架构/大型网站架构(四)大型网站的模式.md","hash":"750e17bde3af3239db7ae26ec4c50a46122052ad","modified":1615691090699},{"_id":"source/_posts/效能管理/团队方法论/蓝绿红黑灰常用的发布方式.md","hash":"6c090994462e7538710db79cbd01f6449d376f19","modified":1615691090725},{"_id":"source/_posts/效能管理/团队方法论/软件-敏捷-开发中工作量工时评估方法.md","hash":"1b50b10c99d3263ebda9d93c139b73448413766a","modified":1615691090725},{"_id":"source/_posts/效能管理/团队方法论/两种Web开发中常用的分层架构及其代码模型.md","hash":"52f441498c314fa60ce4c287bc40216b45c208e0","modified":1615691090725},{"_id":"source/_posts/技术实践/rabbitmq/RabbitMQ的使用思考篇.md","hash":"d5e1dafeccb5c7c02479202e052a95be62f8180f","modified":1615691090718},{"_id":"source/_posts/技术实践/redis/Redis对象——Redis对象系统简介.md","hash":"d8759ae7e3cecb9be051b75fc8c4994f78add824","modified":1615691090719},{"_id":"source/_posts/效能管理/团队方法论/2020年工作上的最大收获——监控告警体系.md","hash":"696d9056ecadfcc486aeff42a74da3370118d83b","modified":1616315382008},{"_id":"source/_posts/技术实践/rabbitmq/RabbitMQ的使用进阶篇.md","hash":"af199f553a9a7b0733203d25d779e61debdf6d40","modified":1615691090718},{"_id":"source/_posts/技术实践/rabbitmq/RabbitMQ的使用基础篇.md","hash":"b0798d0b9b3c21826d8b71cb591830858545750a","modified":1616315716692},{"_id":"source/_posts/技术实践/redis/Redis对象——列表(List).md","hash":"44c6db0e05465f360bdf2e06277380a8f706d7a6","modified":1615691090719},{"_id":"source/_posts/技术实践/redis/Redis持久化——AOF日志.md","hash":"ddf955f4c8279fe173b260bc34f6e07774dab63e","modified":1617454095550},{"_id":"source/_posts/技术实践/redis/Redis对象——哈希(Hash).md","hash":"3bc821cb99287b81382c48e22b1192b165b73c4c","modified":1615691090719},{"_id":"source/_posts/技术实践/redis/Redis对象——有序集合(ZSet).md","hash":"63dbf468adba42ad55d84a684396df4283287b55","modified":1615691090720},{"_id":"source/_posts/技术实践/redis/Redis持久化——内存快照(RDB).md","hash":"76694198109dda7d3bcf90633e839461e52fd848","modified":1617454111515},{"_id":"source/_posts/技术实践/redis/Redis持久化——如何选择合适的持久化方式.md","hash":"baa7e2a0d15ba3fcc58c29811cc41c8452d00923","modified":1617454024301},{"_id":"source/_posts/技术实践/redis/Redis对象——字符串(String).md","hash":"d1803d7092130a23500deff1ac9c71f517c46ecc","modified":1616315583511},{"_id":"source/_posts/技术实践/redis/Redis对象——集合(Set).md","hash":"394732c2a28068a91db5b6b3f9b5cc3986740425","modified":1615691090720},{"_id":"source/_posts/技术实践/redis/Redis数据结构——quicklist.md","hash":"a5fc56e33f4cb260dc7d3585c37c7cc5876811c2","modified":1617423226392},{"_id":"source/_posts/技术实践/redis/Redis数据结构——压缩列表.md","hash":"3325a28ae5b315a05d1e937cc255fd0f8181d343","modified":1615691090720},{"_id":"source/_posts/技术实践/redis/Redis数据结构——字典.md","hash":"e9e3e9870ddd84e4f0e9bdb01f0c5b860ec00910","modified":1615691090721},{"_id":"source/_posts/技术实践/redis/Redis数据结构——整数集合.md","hash":"cdcff70e17ef5cc2f5a4661c17eab120964c1c68","modified":1615691090721},{"_id":"source/_posts/技术实践/redis/Redis数据结构——简单动态字符串SDS.md","hash":"0afa6980e18a0ec8a9dbd27c44bb806060bdbbb3","modified":1615691090721},{"_id":"source/_posts/技术实践/redis/Redis数据结构——链表.md","hash":"1ab38d92421e36138d3a8670fa59c9e5b16c5dd9","modified":1615691090721},{"_id":"source/_posts/技术实践/redis/Redi数据结构——跳跃表.md","hash":"9d3327a75378e54e4981ae829d99cee2b3e511cf","modified":1615691090722},{"_id":"source/_posts/技术实践/redis/一文回顾Reids五大对象(数据类型).md","hash":"018a20f5cbd42a954c26a368254b7b47b9e75a68","modified":1615691090722},{"_id":"source/_posts/技术实践/spring-boot/Spring Boot(一) Hello World.md","hash":"f2f34677dc7e1015fda4b63dceb3f433476f2457","modified":1615691090722},{"_id":"source/_posts/技术实践/spring-boot/Spring Boot(三) 使用Lombok.md","hash":"111a1948d147b59357760e0177bb2d54cd54b998","modified":1615691090722},{"_id":"source/_posts/技术实践/spring-boot/Spring Boot(二) 读取配置文件.md","hash":"3663b72f3c9593bf48cdd0a1569ee5ca3edcb9b0","modified":1615691090723},{"_id":"source/_posts/技术实践/spring-boot/Spring Boot(四) Mybatis-MySql.md","hash":"282723fc27410e05ffe60b75265790b8b755fd40","modified":1615691090723},{"_id":"source/_posts/技术实践/代码的艺术/恪尽职守，行分内之事——高质量代码.md","hash":"c3ed743ba562b63621200922c28bd50a9ca58831","modified":1615691090723},{"_id":"source/_posts/技术实践/代码的艺术/理解RESTful API.md","hash":"855d736520b83c161b6654d993d56ac78d266eb1","modified":1615691090723},{"_id":"source/_posts/技术实践/代码的艺术/设计原则_单一职责(SRP).md","hash":"7b58c284a750f4a6aee9df646b2255f61503b105","modified":1615691090723},{"_id":"source/_posts/技术实践/单元测试/.DS_Store","hash":"05c5100c1da15e5424b02dfe38d392a9af85309a","modified":1616315594887},{"_id":"source/_posts/技术实践/单元测试/伪对象、桩对象、模拟对象.md","hash":"01c63c3602c285ecb24d4aad824de38435e2797c","modified":1616315564649},{"_id":"source/_posts/技术实践/单元测试/单元测试基础.md","hash":"73621c124ed67963bad4bbd5ee605f0ca8963608","modified":1616315538639},{"_id":"source/_posts/技术实践/单元测试/如何提高代码的可测试性.md","hash":"01b87b919cc923d3187c6eccdf2160c07997e1ab","modified":1616315556091},{"_id":"source/_posts/技术实践/单元测试/如何编写优秀的测试代码.md","hash":"1db315ff53291aa3e3747339ac1f7521773672c5","modified":1616315547843},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615691090760},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615691090760},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615691090782},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615691090783},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615691090779},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615691090779},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1615691090780},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"495fb08875b2e1e04f9c4f3e9e593cdf5c32cc31","modified":1615691090755},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1615691090755},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1615691090757},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1615691090757},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"4fb0af30700bb68df433267cbe7922f6d972fc9f","modified":1615691090757},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1615691090757},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1615691090757},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1615691090758},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1615691090758},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1615691090758},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1615691090758},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1615691090759},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1615691090758},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1615691090759},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1615691090759},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1615691090759},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1615691090760},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1615691090760},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1615691090760},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1615691090760},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1615691090761},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1615691090761},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1615691090761},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1615691090761},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1615691090761},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1615691090761},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1615691090761},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1615691090761},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5dbeb640707a9c91357e373b9063a48c8e78f439","modified":1615691090761},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1615691090762},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1615691090762},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1615691090762},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1615691090762},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1615691090762},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1615691090762},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1615691090763},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1615691090763},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1615691090763},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1615691090763},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1615691090764},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1615691090764},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1615691090764},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1615691090765},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1615691090765},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1615691090765},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1615691090765},{"_id":"themes/next/scripts/filters/after_post_render/exturl.js","hash":"9c9f61b7bfb3349b03b1e61355f20232044b5fd8","modified":1615691090767},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1615691090782},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1615691090782},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1615691090783},{"_id":"themes/next/source/css/_variables/base.styl","hash":"70b612051dfe26a0cb69066ae9ded42d5485c267","modified":1615691090783},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"5d0058dc23df21d32cd01ade33bb72f26df38787","modified":1615691090779},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1615691090779},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1615691090780},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"086f5979b3de091c3378512e6c5c2f8fcb4f6298","modified":1615691090780},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1615691090789},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1615691090789},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1615691090790},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1615691090790},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1615691090790},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1615691090790},{"_id":"themes/next/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1615691090790},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1615691090790},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1615691090790},{"_id":"themes/next/source/js/src/utils.js","hash":"28a79d317b7f4012917a54cac770551596bf6241","modified":1615691090791},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1615691090795},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1615691090793},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1615691090795},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1615691090795},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1615691090795},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1615691090802},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1615691090803},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1615691090803},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1615691090804},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1615691090803},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1615691090803},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1615691090804},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1615691090798},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1615691090798},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1615691090798},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1615691090799},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1615691090799},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1615691090797},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1615691090798},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1615691090798},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1615691090798},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1615691090810},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1615691090810},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1615691090812},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1615691090812},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1615691090812},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1615691090807},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1615691090807},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1615691090805},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1615691090808},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1615691090805},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1615691090805},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1615691090805},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1615691090806},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1615691090805},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1615691090806},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1615691090806},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1615691090806},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1615691090806},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1615691090806},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1615691090807},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1615691090806},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1615691090807},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1615691090804},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1615691090805},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1615691090804},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1615691090803},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1615691090765},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1615691090765},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1615691090769},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1615691090769},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1615691090769},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"b4a2f1d031fe44452cf55ded8211cf018235073a","modified":1615691090769},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1615691090769},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1615691090772},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"f6ddbb1b2976f34c07900e3bafea9850fa25aaa7","modified":1615691090778},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"ec2a62400642bb69edd9259e74e8f1c8ed53c42b","modified":1615691090778},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1615691090775},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1615691090779},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1615691090779},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1615691090779},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1615691090779},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1615691090779},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"665b1813a1d6fbc3c5549a76e4f26cd62a804dde","modified":1615691090780},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1615691090781},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1615691090781},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"936132428a0d35b3947ccedd4c379940abcf223a","modified":1615691090781},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1615691090781},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1615691090781},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1615691090782},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1615691090782},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"74c7dccf0a3ee9fc2ca25ad8e998243191813a0e","modified":1615691090782},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1615691090782},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"f26860978fc4e011758945db5d0f79105ac84fae","modified":1615691090782},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1615691090782},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1615691090782},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1615691090780},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1615691090780},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fe2dc74726a515549956d233becda188da64f948","modified":1615691090780},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1615691090780},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1615691090780},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1615691090781},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"72037e8c4202a73b0c6ff7d81b57cd349e836837","modified":1615691090790},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1615691090792},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1615691090795},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1615691090796},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1615691090796},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1615691090796},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1615691090796},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1615691090792},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1615691090793},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1615691090796},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1615691090797},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1615691090797},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1615691090797},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1615691090799},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1615691090799},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1615691090799},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1615691090798},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1615691090798},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1615691090810},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1615691090810},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1615691090780},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1615691090792},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1615691090802},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1615691090802},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1615691090770},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1615691090770},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1615691090770},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1615691090770},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1615691090770},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1615691090770},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"05e68adae13f4d99a6ac6493daab39c92e39a6bd","modified":1615691090770},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1615691090774},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1615691090774},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1615691090774},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1615691090774},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"b34bb2ea4d16e47e6fdc06cd4feb32d93ccbd779","modified":1615691090774},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1615691090774},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1615691090775},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1615691090775},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1615691090775},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1615691090775},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1615691090772},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"3b5a37ba5e70f92c1ee707c8053524e38adbb710","modified":1615691090772},{"_id":"themes/next/source/css/_common/components/post/my-post-copyright.styl","hash":"e23bdae89cc8b2c8ebd93ba5b8df1f395d3072b8","modified":1615691090772},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1615691090772},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1615691090772},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1615691090772},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1615691090772},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1615691090773},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1615691090772},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1615691090773},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1615691090773},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1615691090773},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1615691090773},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1615691090773},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1615691090773},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1615691090773},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"7b386c051f3776e840d9bb63a5127c4e90bbb96f","modified":1615691090773},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"a1eeceea4b88fba184408cb2507bbef1f5e7b0e0","modified":1615691090771},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1615691090771},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1615691090771},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1615691090771},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f2911a048e5c20ca2a059bd1087d98ac1c51681c","modified":1615691090772},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1615691090772},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1615691090771},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1615691090771},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1615691090771},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1615691090776},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1615691090775},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1615691090776},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1615691090776},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1615691090776},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1615691090776},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1615691090776},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1615691090777},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1615691090777},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1615691090777},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1615691090777},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1615691090778},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1615691090778},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1615691090778},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1615691090778},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1615691090778},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1615691090781},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1615691090781},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1615691090781},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1615691090791},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1615691090791},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1615691090791},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1615691090791},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1615691090791},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1615691090796},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1615691090796},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1615691090797},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1615691090797},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1615691090797},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1615691090797},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1615691090799},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1615691090801},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1615691090800},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1615691090811},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1615691090795},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1615691090810},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1615691090801},{"_id":"public/manifest.json","hash":"376d0bee536b6b97e11af5d22acf460da00d2875","modified":1617454157132},{"_id":"public/sw.js","hash":"7195a555aa8d4429f0b5cb0840c2f22d11f45ca9","modified":1617454157132},{"_id":"public/baidusitemap.xml","hash":"f30513aabff7d80a34f1ba56c454f28dee1ecaf8","modified":1617454157204},{"_id":"public/sitemap.xml","hash":"9c0a7de613e21813e45b6bf89a206e50dc53b4aa","modified":1617454157205},{"_id":"public/atom.xml","hash":"c96b04391dcc019be5f5ab105463827568623717","modified":1617454157205},{"_id":"public/tags/index.html","hash":"c7c0779386510f569fc68326ab09e5c87bab9eec","modified":1617454157226},{"_id":"public/categories/index.html","hash":"4994c2ca9707a6328d2ec2e13119faa3a237f183","modified":1617454157226},{"_id":"public/about/index.html","hash":"766a3fbc5ea7147e2075efd2f7dc96d0e1c6a77c","modified":1617454157226},{"_id":"public/2021/技术实践/redis/Redis持久化——如何选择合适的持久化方式/index.html","hash":"acfa86466ed9e6af96ca087ad557f7f08b5b5f28","modified":1617454157226},{"_id":"public/2021/技术实践/redis/Redis持久化——AOF日志/index.html","hash":"996122644081519d621b3197fa3d06ed24539971","modified":1617454157226},{"_id":"public/2021/技术实践/redis/Redis持久化——内存快照(RDB)/index.html","hash":"9bc4069565a271add6d4b792643e192944b0daf5","modified":1617454157226},{"_id":"public/2021/效能管理/团队方法论/蓝绿红黑灰常用的发布方式/index.html","hash":"f9f2912ecafd9c7c41e70e277718cd3282a6919f","modified":1617454157226},{"_id":"public/2021/效能管理/团队方法论/2020年工作上的最大收获——监控告警体系/index.html","hash":"48bfd6262e1f4a7a90daf9ba89f657805bfc2abe","modified":1617454157226},{"_id":"public/2021/技术实践/代码的艺术/设计原则_单一职责(SRP)/index.html","hash":"3ac27b95c5974ace22273951e539c9f82cb51b6c","modified":1617454157226},{"_id":"public/2021/技术实践/代码的艺术/恪尽职守，行分内之事——高质量代码/index.html","hash":"d263bdcbd4471e58f9bde350e995cf2283742d46","modified":1617454157226},{"_id":"public/2021/技术实践/单元测试/如何提高代码的可测试性/index.html","hash":"ac355f8e0a504ed5157b2877573d0aa07cbd8607","modified":1617454157226},{"_id":"public/2021/技术实践/单元测试/伪对象、桩对象、模拟对象/index.html","hash":"bda21f94787ca2967ac579e359679a7e3b8074ec","modified":1617454157226},{"_id":"public/2021/技术实践/单元测试/如何编写优秀的测试代码/index.html","hash":"cf88a4d3f57ac9daa8772855779ebd352f55730c","modified":1617454157226},{"_id":"public/2021/技术实践/单元测试/单元测试基础/index.html","hash":"b3032ea86c2b21a7dce2405e02da87308f0a15e1","modified":1617454157226},{"_id":"public/2020/notes/大型网站技术架构/大型网站架构(四)大型网站的模式/index.html","hash":"133ddc57fd3398d928c86d0b7a5533a6e066ccf8","modified":1617454157226},{"_id":"public/2020/notes/大型网站技术架构/大型网站架构(二)大型网站的演化上/index.html","hash":"404cb62ca3de3c74d90546461b5d1e8f2fcfcdee","modified":1617454157226},{"_id":"public/2020/notes/大型网站技术架构/大型网站架构(三)大型网站的演化下/index.html","hash":"c764b4b595353875c4ed62dc5549c87aa5377c45","modified":1617454157226},{"_id":"public/2020/效能管理/团队方法论/两种Web开发中常用的分层架构及其代码模型/index.html","hash":"d14b520e0d2bda61f65e2a9c3415d7c58d2506fe","modified":1617454157227},{"_id":"public/2020/技术实践/代码的艺术/理解RESTful API/index.html","hash":"a53cf76b1a771ad87e168805a6ca3216de5c3f90","modified":1617454157227},{"_id":"public/2020/notes/大型网站技术架构/大型网站架构(一)大型网站的特点/index.html","hash":"d74a65564267b280db8e925ef1d77bd7c3e8de1d","modified":1617454157227},{"_id":"public/2020/技术实践/redis/一文回顾Reids五大对象(数据类型)/index.html","hash":"87d39d71ef5c465826a587df6412f9f98557b6e7","modified":1617454157227},{"_id":"public/2020/redis_command/string/append/index.html","hash":"a0c278a5bf7484656940a86c51c061754388f801","modified":1617454157227},{"_id":"public/2020/redis_command/string/decr/index.html","hash":"803793d5724f607a4b5a5fa89ba4ae959075a7d6","modified":1617454157227},{"_id":"public/2020/redis_command/string/decrby/index.html","hash":"803bbdca14f9a2f1c56b65aac39b59769941f8f8","modified":1617454157227},{"_id":"public/2020/redis_command/string/get/index.html","hash":"c23fe332569bb1c49b48239fcaf3f2126851c3ff","modified":1617454157227},{"_id":"public/2020/redis_command/string/getrange/index.html","hash":"c5944aa31ca8d87bc683fd211d7eae32c877c340","modified":1617454157227},{"_id":"public/2020/redis_command/string/getset/index.html","hash":"d5435f22b3d81759d80ca72a86e9fc3bd0b6ad99","modified":1617454157227},{"_id":"public/2020/redis_command/string/incr/index.html","hash":"7ce792ce0113a86f0be8c5fb216096dc5a4e280f","modified":1617454157227},{"_id":"public/2020/redis_command/string/incrby/index.html","hash":"af27269f5fe1a540a409b5ac239a1896c422b9a7","modified":1617454157227},{"_id":"public/2020/redis_command/string/incrbyfloat/index.html","hash":"c174c34a2e69b162ead69c5a24d0c8897f012b0e","modified":1617454157227},{"_id":"public/2020/redis_command/string/mget/index.html","hash":"4c3d2a99426ee1680a7d8687972f154d0f6bd94b","modified":1617454157227},{"_id":"public/2020/redis_command/string/mset/index.html","hash":"d663ddd2ff6e69bea3b7361c7eebdae1ed1881c9","modified":1617454157227},{"_id":"public/2020/redis_command/string/msetnx/index.html","hash":"4864bd5f10afd85fb701c3f874a55adb75ce14c1","modified":1617454157227},{"_id":"public/2020/redis_command/string/psetex/index.html","hash":"45a0a099a42d81dadc3bee02f36e083a74a3f233","modified":1617454157227},{"_id":"public/2020/redis_command/string/set/index.html","hash":"2e64e7a3e9a231d8e63a42a28cd3e7739d319aad","modified":1617454157227},{"_id":"public/2020/redis_command/string/setnx/index.html","hash":"4f306fa01a04a19f8f973e707aee214632214a34","modified":1617454157227},{"_id":"public/2020/redis_command/string/setex/index.html","hash":"c60986a02bd2dcf472be5c335e59e4192c9936b1","modified":1617454157227},{"_id":"public/2020/redis_command/string/setrange/index.html","hash":"c33c3028c86101ace0ce57a3b1543d45ca53f634","modified":1617454157227},{"_id":"public/2020/redis_command/string/strlen/index.html","hash":"1f226b636b84e296678eea45d07c0930e8ee7828","modified":1617454157227},{"_id":"public/2020/redis_command/sorted_set/zadd/index.html","hash":"37b855094b04ea0ec4cc0c446b8b18a6370a1ca1","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/bzpopmax/index.html","hash":"a96a0cf57fd436cdde41b615e8d24cb76142110a","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/bzpopmin/index.html","hash":"5e870adc13dbc52a6155d8205a4b95dd296aaca8","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zcard/index.html","hash":"1adff0d5339aef716965baa2e4359dc0a66a1dca","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zcount/index.html","hash":"32f7d09c23659b69a62bfcc7c059e3f2d42326df","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zincrby/index.html","hash":"865c9a3b0937267e7bb909a3172c147936ddaf7b","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zinterstore/index.html","hash":"dc5e877f4fa45c7a39da591c6127183480d43c4d","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zlexcount/index.html","hash":"cdd76f92fe29b0fcda99315e5d506d45010a42bc","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zpopmax/index.html","hash":"1cf1abc38782468976292a9945cc589e52cb16da","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zpopmin/index.html","hash":"77970c304b3fb1d081bac80724c4f1581fcaa291","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zrange/index.html","hash":"49b05d9597174efb0a536e2e4b565be8f5ec8574","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zrangebylex/index.html","hash":"0dfe37b4c787deb4454831883a6aa52c326bed43","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zrevrangebylex/index.html","hash":"48bb1e163055cd87c7e8afe1e09baeeee3205734","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zrangebyscore/index.html","hash":"fa27d91fe6a65ca6206857b765004d0d3a5c1f81","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zrank/index.html","hash":"6d779296001cb7b3273061b91b84864180bbb096","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zrem/index.html","hash":"2618303556e77215a1f395685a700efb9473d034","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zremrangebylex/index.html","hash":"e72595b47b7cf310a5ca03340734c7586a809067","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zremrangebyrank/index.html","hash":"6a470672a88a7e5abbf0a34571d6fe394d6ce096","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zremrangebyscore/index.html","hash":"ff53faaf79f811165b91952ab249e237101d5359","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zrevrange/index.html","hash":"6e13ee85fa650388a63c4034bf05fefdda9b9bf0","modified":1617454157228},{"_id":"public/2020/redis_command/sorted_set/zrevrangebyscore/index.html","hash":"6f6f1822d0db243e171cf3a76ae851391915877c","modified":1617454157229},{"_id":"public/2020/redis_command/sorted_set/zrevrank/index.html","hash":"df733e1620d765ec6a2803db315304a13a1250e7","modified":1617454157229},{"_id":"public/2020/redis_command/sorted_set/zscore/index.html","hash":"e22635aa886a7b20ced5a07b5dd6ad2357497cd5","modified":1617454157229},{"_id":"public/2020/redis_command/sorted_set/zunionstore/index.html","hash":"beff7aca738f283d80f955664fbb744fc39c610b","modified":1617454157229},{"_id":"public/2020/redis_command/sorted_set/zscan/index.html","hash":"1609efecb015cd9dc4080a29ac74982dc631dc72","modified":1617454157229},{"_id":"public/2020/redis_command/set/sadd/index.html","hash":"3983b5a32752f694d01aabd8229095d091e5a4ca","modified":1617454157229},{"_id":"public/2020/redis_command/set/scard/index.html","hash":"e290ea45929a26656c3b52ad8ff1bfb91ba7dc4c","modified":1617454157229},{"_id":"public/2020/redis_command/set/sdiff/index.html","hash":"3a34557a27925504277ea1102a3257bcf9ae5a6b","modified":1617454157229},{"_id":"public/2020/redis_command/set/sdiffstore/index.html","hash":"6a5f6d2b68f67447b7eb71438586f30dd6a4396d","modified":1617454157229},{"_id":"public/2020/redis_command/set/sinter/index.html","hash":"b3058e53751910bf9f7fe741638b447a5fc9e4fc","modified":1617454157229},{"_id":"public/2020/redis_command/set/sinterstore/index.html","hash":"f99ef8c54c64eb97230b822fb53db8bf870477a0","modified":1617454157229},{"_id":"public/2020/redis_command/set/sismember/index.html","hash":"fd8571e13a2c3e47d9e615626cbcac59d0e7263c","modified":1617454157229},{"_id":"public/2020/redis_command/set/smembers/index.html","hash":"aa3c4c47f5742b7d6326ec2e985e9cc846d92aac","modified":1617454157229},{"_id":"public/2020/redis_command/set/smove/index.html","hash":"db45378f2e35b228938bdcbaea15e8f1a99ec5b5","modified":1617454157229},{"_id":"public/2020/redis_command/set/spop/index.html","hash":"aeea461bec5771ce95b53c8974e380a985d22cb3","modified":1617454157229},{"_id":"public/2020/redis_command/set/srandmember/index.html","hash":"eb87f37fcd4a03619459ed24a94c5eb1237a7b4c","modified":1617454157229},{"_id":"public/2020/redis_command/set/srem/index.html","hash":"3478e5f950340221609393e74c7f245de8028c03","modified":1617454157229},{"_id":"public/2020/redis_command/set/sunion/index.html","hash":"d6cca2dac8372f2d52715f9e6cd76e809e0d6ddf","modified":1617454157230},{"_id":"public/2020/redis_command/set/sunionstore/index.html","hash":"e1a918ab85f9ee8de2084cc5df022146f77e635c","modified":1617454157230},{"_id":"public/2020/redis_command/set/sscan/index.html","hash":"feb4976b35ac13cc4776e5af18433e5411a60d43","modified":1617454157230},{"_id":"public/2020/技术实践/redis/Redis对象——集合(Set)/index.html","hash":"6282e1f530f97bffe7ac67937db8d017dc2acce4","modified":1617454157230},{"_id":"public/2020/技术实践/redis/Redis对象——有序集合(ZSet)/index.html","hash":"712919ce46cba9bd2e7ce706cf3b1b9dc0bfccc4","modified":1617454157230},{"_id":"public/2020/技术实践/redis/Redis对象——列表(List)/index.html","hash":"8e83125786c564f6a4227496f60a7c6a4e2379d5","modified":1617454157230},{"_id":"public/2020/redis_command/list/blpop/index.html","hash":"940b6572b674a36d5bf3111cd66e41cfb3dc124c","modified":1617454157230},{"_id":"public/2020/redis_command/list/brpop/index.html","hash":"c7a1ea7fa063a2d6bdfb6eb9c0da6b6aeb56a4ee","modified":1617454157230},{"_id":"public/2020/redis_command/list/brpoplpush/index.html","hash":"e257acd84792cb5efd6f7ba81edd8cf2d122d451","modified":1617454157230},{"_id":"public/2020/redis_command/list/lindex/index.html","hash":"b45a1860bf5cca3e9bdbf0af14ed6afd431b7216","modified":1617454157230},{"_id":"public/2020/redis_command/list/linsert/index.html","hash":"4e35b7e74f64f63506d645476090103b1ecd606d","modified":1617454157230},{"_id":"public/2020/redis_command/list/llen/index.html","hash":"a34f0c0b3f8f348344cab35ee2a57fdf63fda47b","modified":1617454157230},{"_id":"public/2020/redis_command/list/lpushx/index.html","hash":"bfa6fc155290555fd89efc7bdcf45d2aba89426d","modified":1617454157230},{"_id":"public/2020/redis_command/list/lrange/index.html","hash":"feca13291610b5607de4578f6d4ac0b30d76a2ad","modified":1617454157230},{"_id":"public/2020/redis_command/list/lrem/index.html","hash":"ed9df0615a735a0a76f13de9cfc42ea10034fda3","modified":1617454157230},{"_id":"public/2020/redis_command/list/lset/index.html","hash":"3a9dbca84d458a2c16f99890cc8d7d718759f151","modified":1617454157230},{"_id":"public/2020/redis_command/list/ltrim/index.html","hash":"bb7c8c9ff6e6c8739ebb1d6d65c76cf889e698f9","modified":1617454157230},{"_id":"public/2020/redis_command/list/rpop/index.html","hash":"f9503264134c1a7b1926964cb6738b9e4be39b44","modified":1617454157230},{"_id":"public/2020/redis_command/list/rpoplpush/index.html","hash":"ae16d7020dccb3a81e72e63ec268d41c5c343d76","modified":1617454157230},{"_id":"public/2020/redis_command/list/rpush/index.html","hash":"a2cb12cdbd25ef41797cfcc214bd6e05dd749e29","modified":1617454157230},{"_id":"public/2020/redis_command/list/rpushx/index.html","hash":"dc46d031ff54287bd87b7b535d1271a0f57908c3","modified":1617454157230},{"_id":"public/2020/redis_command/list/lpop/index.html","hash":"4d19e00a38efa4f45a2a9e606088ad4026f1bf96","modified":1617454157230},{"_id":"public/2020/redis_command/list/lpush/index.html","hash":"89fef13c6d0935f21c0a3db7973ee9a523935f14","modified":1617454157231},{"_id":"public/2020/技术实践/redis/Redis数据结构——quicklist/index.html","hash":"191f0d7aae3c8825b3bb5f8659df5111ecb0ddde","modified":1617454157231},{"_id":"public/2020/技术实践/redis/Redis对象——哈希(Hash)/index.html","hash":"bc5506096361d51040376b8928dfea18c44cf36c","modified":1617454157231},{"_id":"public/2020/技术实践/spring-boot/Spring Boot(四) Mybatis-MySql/index.html","hash":"aae55952924d0de12b5db72006654ad5b59f24d6","modified":1617454157231},{"_id":"public/2020/redis_command/bitmap/bitcount/index.html","hash":"ba45072729257ed3842472ad81c88464837cc3b0","modified":1617454157231},{"_id":"public/2020/redis_command/bitmap/bitfield/index.html","hash":"8fa3aa88910c5c7dbfb1ccd3d0d1b56ae1fd3053","modified":1617454157231},{"_id":"public/2020/redis_command/bitmap/bitop/index.html","hash":"d802eedd261b54c3fe7155d531a6e2973c951ab0","modified":1617454157231},{"_id":"public/2020/redis_command/bitmap/bitpos/index.html","hash":"90ef439f637dd926f205a3830d262ec8c11d2a6f","modified":1617454157231},{"_id":"public/2020/redis_command/bitmap/getbit/index.html","hash":"0496298fa5db8d05c6a3b59d96a501ed7cd986fa","modified":1617454157231},{"_id":"public/2020/redis_command/bitmap/setbit/index.html","hash":"8d2a1cebeb4bae20e6f91404f99d3e32b4ff8487","modified":1617454157231},{"_id":"public/2020/技术实践/spring-boot/Spring Boot(三) 使用Lombok/index.html","hash":"0762e9448fc4816b6444055c8df32ae838e3ed11","modified":1617454157231},{"_id":"public/2020/技术实践/spring-boot/Spring Boot(二) 读取配置文件/index.html","hash":"df1d6dffa84c4bf12efcb34108813e330d1a1a5b","modified":1617454157231},{"_id":"public/2020/技术实践/spring-boot/Spring Boot(一) Hello World/index.html","hash":"e159cf9a9d25ac41b0f4b09d32372ce37ecd492f","modified":1617454157231},{"_id":"public/2020/redis_command/hash/hdel/index.html","hash":"d70058bfccf1f97b785c9c499ccfc8a415f4083b","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hexists/index.html","hash":"383c36aa7e0088bc755bfccd2937e2a23938894c","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hget/index.html","hash":"0a339fbee98ec1101cc021629962f5fbb8e33cd4","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hgetall/index.html","hash":"6bc32d24bb7ae25ceeca4b4eea2a1e589f6175e9","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hincrby/index.html","hash":"40a9792cf2f1c763b3c8054a1be6a5450b9276d2","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hincrbyfloat/index.html","hash":"d955c4ecbaa3d4b305f833a56e7a9f99fc3eea17","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hkeys/index.html","hash":"3b9b64a4152af8b210ab3d844c9c028683d70367","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hlen/index.html","hash":"306493ad484b1b32c03f0c30e77c830ee5a02209","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hmget/index.html","hash":"9a44a7325146d2fb0e03ff0fc5eb1e5d21824cf5","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hmset/index.html","hash":"f01adc3df3bd392f49b26d4ea0f9a1111dbdcc15","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hset/index.html","hash":"a07c57d83c126893333d04655e81a1f23936fbef","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hsetnx/index.html","hash":"2b112f9038b280d38648e694ea9484130f79d85e","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hstrlen/index.html","hash":"383ffba7b81d05619bb43848de33852c173a7f9f","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hvals/index.html","hash":"f33153fe4495f0c07cd267ef818478853abb66db","modified":1617454157232},{"_id":"public/2020/redis_command/hash/hscan/index.html","hash":"252674ee2471214ad7136208264792280022398b","modified":1617454157232},{"_id":"public/2019/技术实践/redis/Redis对象——字符串(String)/index.html","hash":"e2cf92a3798a0e5b848deb6b6f4a44cfa5bcffe4","modified":1617454157232},{"_id":"public/2019/技术实践/redis/Redis对象——Redis对象系统简介/index.html","hash":"5c5597700d08eef403b8239556a58adb42df94c4","modified":1617454157232},{"_id":"public/2019/技术实践/redis/Redis数据结构——压缩列表/index.html","hash":"4d6069479cb312682bd3e2688226fb22b7e96f09","modified":1617454157232},{"_id":"public/2019/技术实践/redis/Redis数据结构——整数集合/index.html","hash":"c26c49a1bfdd0e92ad5984166169fe2ae75e4c31","modified":1617454157232},{"_id":"public/2019/技术实践/redis/Redi数据结构——跳跃表/index.html","hash":"d07006ac2ebf360d7dc55215fd682415bf5c1702","modified":1617454157232},{"_id":"public/2018/技术实践/redis/Redis数据结构——字典/index.html","hash":"0e78768aafaa0aed63b2437f496be02a6b9a883e","modified":1617454157233},{"_id":"public/2018/技术实践/redis/Redis数据结构——链表/index.html","hash":"b0fb0b004280186dbdb96ba70bcdc78423e75042","modified":1617454157233},{"_id":"public/2018/效能管理/团队方法论/软件-敏捷-开发中工作量工时评估方法/index.html","hash":"5291cbee0b40a41c2f32cfee9ebc83dff511cadb","modified":1617454157233},{"_id":"public/2018/jenkins/NET实现持续集成与自动化部署3-测试环境到生产环境策略/index.html","hash":"d130a6a36998881d2b6b7f2e617703ea51a16916","modified":1617454157233},{"_id":"public/2018/jenkins/NET实现持续集成与自动化部署2-NuGet/index.html","hash":"82fbc7547e0f1c0f518a6d933a03af752dd80157","modified":1617454157233},{"_id":"public/2018/jenkins/NET实现持续集成与自动化部署1-Jenkins/index.html","hash":"879f3d0492d967df4740146bf5508d8bc1faa804","modified":1617454157233},{"_id":"public/2018/log/NET下日志系统的搭建—log4net-kafka-elk/index.html","hash":"5f278b8962e0d5ddf8dcb1bf6eb0a76d3bf9c300","modified":1617454157233},{"_id":"public/2018/log/NET日志记录-log4net/index.html","hash":"2004bfa8e054f0f12b57392a9e866fa84f133d04","modified":1617454157233},{"_id":"public/2018/技术实践/rabbitmq/RabbitMQ的使用思考篇/index.html","hash":"0d3d0e0093f2657ca0fc2f665f6dae85ac0c1617","modified":1617454157233},{"_id":"public/2018/技术实践/rabbitmq/RabbitMQ的使用进阶篇/index.html","hash":"edfb850b82bbb54a7268260a2adb5e39db9fbc97","modified":1617454157233},{"_id":"public/2018/技术实践/rabbitmq/RabbitMQ的使用基础篇/index.html","hash":"0fa6a6411a982add8a7504cd76c3f6ce84f5386c","modified":1617454157233},{"_id":"public/2018/技术实践/redis/Redis数据结构——简单动态字符串SDS/index.html","hash":"e7aab2f7ed49e2ad86cf17eed54cc60fd932ec29","modified":1617454157233},{"_id":"public/categories/持续集成-Jenkins-自动化发布/index.html","hash":"b5e72dffc6fce122c93b8834222dab932271e95a","modified":1617454157233},{"_id":"public/categories/日志/index.html","hash":"79b4170b98c6abcbe4792e71def4603eb1dec79b","modified":1617454157233},{"_id":"public/categories/Redis命令大全/index.html","hash":"e3503b6b6ec881a22d33a7ff518c10989e0b71c8","modified":1617454157233},{"_id":"public/categories/Redis命令大全/page/2/index.html","hash":"2698a316f2ed9dc89b46788813fbb5588f58072a","modified":1617454157233},{"_id":"public/categories/Redis命令大全/page/3/index.html","hash":"57033685262cb1e00c537a4000f5d4459c98768b","modified":1617454157233},{"_id":"public/categories/Redis命令大全/page/4/index.html","hash":"f980fecb69e194baf018b5ef5cb71e5c30f0cab6","modified":1617454157234},{"_id":"public/categories/Redis命令大全/page/5/index.html","hash":"c651202ee8fa15120f8bb61c171fdb26104327d1","modified":1617454157234},{"_id":"public/categories/Redis命令大全/Bitmap/index.html","hash":"8d2f58a4718f14210aadf15c3956d97a7b3139ac","modified":1617454157234},{"_id":"public/categories/Redis命令大全/Set/index.html","hash":"9be00132dd42607fe2d9411c980061c7c9b4a55c","modified":1617454157234},{"_id":"public/categories/Redis命令大全/List/index.html","hash":"d563d48560d547af8079b85dc40fd664105f5d37","modified":1617454157234},{"_id":"public/categories/Redis命令大全/ZSet/index.html","hash":"90e78f5c583624eddc7ce0d0484bc9f28c2694b3","modified":1617454157234},{"_id":"public/categories/Redis命令大全/ZSet/page/2/index.html","hash":"ac2782db9a368da7f1f95dd7976fcf4a26ada0cc","modified":1617454157234},{"_id":"public/categories/Redis命令大全/Hash/index.html","hash":"9e99a70597cfc066f603530f32e26dd725aa837b","modified":1617454157234},{"_id":"public/categories/Redis命令大全/String/index.html","hash":"077426854d2eb4030ea81697f3c00c4888bcceb8","modified":1617454157234},{"_id":"public/categories/读书笔记/index.html","hash":"756885322d05a15296413d452109b9859ec29cb1","modified":1617454157234},{"_id":"public/categories/Redis/index.html","hash":"ead94d93feaebc2f5e6e081691dab5fe31141222","modified":1617454157234},{"_id":"public/categories/Spring-Boot/index.html","hash":"f6756e5f34a0c99e62614ed1e9248fac2b0b8f75","modified":1617454157234},{"_id":"public/categories/代码的艺术/index.html","hash":"c6a47c7ef40d56a74229fc94ba675775867f8179","modified":1617454157234},{"_id":"public/categories/单元测试/index.html","hash":"d36427eae2003a209db249c3f7c06dfaa86622d9","modified":1617454157234},{"_id":"public/categories/读书笔记/大型网站技术架构/index.html","hash":"695f09143904e01bc899f12fdb5324a30417710f","modified":1617454157234},{"_id":"public/categories/项目管理/index.html","hash":"5a4df0d1a34e0701f950374e7820b42bc7956af5","modified":1617454157234},{"_id":"public/categories/团队方法论/index.html","hash":"b54aa3a038fdbbf0a5a85ce7f9783d46f9bc6755","modified":1617454157234},{"_id":"public/categories/分层架构/index.html","hash":"c4e7116ecab4a33b2cf812208ee6f49c6041958d","modified":1617454157235},{"_id":"public/categories/团队方法论/发布方式/index.html","hash":"1522bb1857cc74db61c918d401f55c0f3bfa9f32","modified":1617454157235},{"_id":"public/categories/团队方法论/监控告警体系/index.html","hash":"1b000d9f2b2c16ee4474fdd3249793e1cebdf039","modified":1617454157235},{"_id":"public/categories/消息队列/index.html","hash":"b038297248bb4efecc6998aed10330c13d4dac8f","modified":1617454157235},{"_id":"public/archives/index.html","hash":"9af7060fa09d2abbf4748e6ec92bbf174881f15a","modified":1617454157235},{"_id":"public/archives/page/2/index.html","hash":"cf5feb9efa69d7046b56a14f9d7cae6a9ba30cbb","modified":1617454157235},{"_id":"public/archives/page/3/index.html","hash":"c7e10d1911a8c104117185d8a64324a14478f252","modified":1617454157235},{"_id":"public/archives/page/4/index.html","hash":"4d90017ea3d871c306001f8ee94f757dcd891c25","modified":1617454157235},{"_id":"public/archives/page/5/index.html","hash":"2b36fb8164c038e01e44c940e3bedcf35c9b63d4","modified":1617454157235},{"_id":"public/archives/page/6/index.html","hash":"406caf6e9a3d195e5353e11dd63b4df667c21aad","modified":1617454157235},{"_id":"public/archives/page/7/index.html","hash":"d3bf431b764bf4a2005671c076043268f2519081","modified":1617454157235},{"_id":"public/archives/2018/index.html","hash":"cb11b5266ca21432ceca87afac527fc9c0f95ea2","modified":1617454157235},{"_id":"public/archives/2018/07/index.html","hash":"b59df5c9e3cde02ee92bc0f3882f3b669af506a5","modified":1617454157235},{"_id":"public/archives/2018/11/index.html","hash":"f1b8076e33169656779868222cefecc44760d0e9","modified":1617454157235},{"_id":"public/archives/2019/index.html","hash":"16ce8242af24028b8addbcc0310ade43c95ade90","modified":1617454157235},{"_id":"public/archives/2019/07/index.html","hash":"73f3678c9cab3db737b966aab0bde8aefdcbc17b","modified":1617454157235},{"_id":"public/archives/2019/08/index.html","hash":"41a5d1316fd9e0aa46ee21a86f4d1ef55e6da22f","modified":1617454157236},{"_id":"public/archives/2019/11/index.html","hash":"3a73115f4b03515aad48e797938b0fdbbf7e3dfd","modified":1617454157236},{"_id":"public/archives/2019/12/index.html","hash":"6956ae4f7046623657364e609a5b9c22711931b8","modified":1617454157236},{"_id":"public/archives/2020/index.html","hash":"ef010b19d6bed8f524d9409eccc643ae8d71864c","modified":1617454157236},{"_id":"public/archives/2020/page/2/index.html","hash":"088398d0ec4156a187d381054e6dcc2a898827a0","modified":1617454157236},{"_id":"public/archives/2020/page/3/index.html","hash":"b82c26ceac6812ba1ac1104bbea809335250abf6","modified":1617454157236},{"_id":"public/archives/2020/page/4/index.html","hash":"53594fefcd8cb730b802ea7504a6c8b39e3e4b4e","modified":1617454157236},{"_id":"public/archives/2020/page/5/index.html","hash":"d47f04276690f1029f3c0bd92243b239a763209e","modified":1617454157236},{"_id":"public/archives/2020/page/6/index.html","hash":"17eac9a503ffbcf376ba7cd4a7fa49fc61c91bb4","modified":1617454157236},{"_id":"public/archives/2020/03/index.html","hash":"e31ccc566039f9f33da7c55e367e11e8272d49bb","modified":1617454157236},{"_id":"public/archives/2020/03/page/2/index.html","hash":"39eaf58d8702af5f24e78bf953b9cc36f68c1714","modified":1617454157236},{"_id":"public/archives/2020/03/page/3/index.html","hash":"215c0072776f2f1cebdb4589fbe14417ce5ec786","modified":1617454157236},{"_id":"public/archives/2020/03/page/4/index.html","hash":"5130a395ab521915099f33a460b8d84c85d7f394","modified":1617454157236},{"_id":"public/archives/2020/03/page/5/index.html","hash":"39de8b81a87639e4440800993973dd99ddb00c10","modified":1617454157236},{"_id":"public/archives/2020/04/index.html","hash":"215ca7a20e1134339c2c8042f4cd147994dd7199","modified":1617454157236},{"_id":"public/archives/2020/04/page/2/index.html","hash":"2a61c732f82c15d23ebad50918e70411620a38ef","modified":1617454157236},{"_id":"public/archives/2020/05/index.html","hash":"6e6723d2d89ed43ad3ced4bfae058e8e81bbc65f","modified":1617454157236},{"_id":"public/archives/2021/index.html","hash":"9ce0644dd51b66b6b197e2d798b5002835f424b4","modified":1617454157236},{"_id":"public/archives/2021/01/index.html","hash":"ede94d147f05fd2965aac98c6a69bb6163c39890","modified":1617454157236},{"_id":"public/archives/2021/02/index.html","hash":"511bc2e7b1b8f36b3c0d5008178e000daebddf29","modified":1617454157236},{"_id":"public/archives/2021/03/index.html","hash":"493b2d040ea2e0b7132dcf3f4db585172bc7a657","modified":1617454157236},{"_id":"public/archives/2021/04/index.html","hash":"930c42d9910d6a36801351d627b6b5086d703e82","modified":1617454157236},{"_id":"public/index.html","hash":"65b3626edd65b0122dc2765147935b446e391bde","modified":1617454157236},{"_id":"public/page/2/index.html","hash":"7a1e93ccb932ce10b7397092d929676a25ad7b17","modified":1617454157236},{"_id":"public/page/3/index.html","hash":"432d84f7310ca0ed226d9bffbed79e157e6f5f59","modified":1617454157236},{"_id":"public/page/4/index.html","hash":"5cb17047e5bfee7ee264f15e338284305ba7d1c3","modified":1617454157237},{"_id":"public/page/5/index.html","hash":"f60fd4ab46a4932e5db0e8a0aa938a54fbd3f883","modified":1617454157237},{"_id":"public/page/6/index.html","hash":"627c29a96ea981c884d0f2b3d05a760610ff568e","modified":1617454157237},{"_id":"public/page/7/index.html","hash":"a0764822aadd711b3f84f81a1b0b3f6164545e31","modified":1617454157237},{"_id":"public/page/8/index.html","hash":"409a3c9358fa656b0c4ccdbc5c8a8e2cb11e4e4b","modified":1617454157237},{"_id":"public/page/9/index.html","hash":"61525a7b0ed4190b0bceba46519ff770b600db75","modified":1617454157237},{"_id":"public/page/11/index.html","hash":"d0825a2bfc5cf870d254cf280160645b143a0f0c","modified":1617454157237},{"_id":"public/page/10/index.html","hash":"2b42365f3a5679908d29f9e7db946488b5537b99","modified":1617454157237},{"_id":"public/page/12/index.html","hash":"a51dc65f1cf6d63cfd5c7e1e2994fd50c9c16476","modified":1617454157237},{"_id":"public/page/13/index.html","hash":"18bab4a1f7e60d712f897d1093e660aa325fece8","modified":1617454157237},{"_id":"public/page/14/index.html","hash":"1d7d0d33d222cc61494df24edd4697c571554423","modified":1617454157237},{"_id":"public/tags/持续集成/index.html","hash":"392fab687657124d73c05cfe0c21dbff8921e218","modified":1617454157237},{"_id":"public/tags/Jenkins/index.html","hash":"eea8ebe2a6a5b9a015e1050332a1987be1a40253","modified":1617454157237},{"_id":"public/tags/自动化发布/index.html","hash":"cf589cfd6df16358ab564d6263f18e09b2fc1f6a","modified":1617454157237},{"_id":"public/tags/NuGet/index.html","hash":"eb47c83ce678918cebac2f0f512d2c2f0f8ffc2b","modified":1617454157237},{"_id":"public/tags/日志/index.html","hash":"04b7b5040e735a6028986c070ae512fb40ff5858","modified":1617454157237},{"_id":"public/tags/kafka/index.html","hash":"5a2d9f9c2324cb8456aab7c0a38c9cb736ed7721","modified":1617454157238},{"_id":"public/tags/elk/index.html","hash":"61973c040732010ef0262718e6bdef816522b6da","modified":1617454157238},{"_id":"public/tags/log4net/index.html","hash":"81657c10fb71e303a311c4776a778721f713444b","modified":1617454157238},{"_id":"public/tags/读书笔记/index.html","hash":"9aa916122db78c0e08b2ba38d9d8284622a42d2c","modified":1617454157238},{"_id":"public/tags/大型网站技术架构/index.html","hash":"517812a300d58653964fc7ca3e3e320bda93b3ec","modified":1617454157238},{"_id":"public/tags/Redis/index.html","hash":"71af4e52343028bfc7cbe3195d332fd6336517af","modified":1617454157238},{"_id":"public/tags/数据结构/index.html","hash":"d81dadac900c8218505420c362b4e39f49ea5c41","modified":1617454157238},{"_id":"public/tags/代码的艺术/index.html","hash":"0c69c41370109f683927bda3361e102673e4f8a9","modified":1617454157238},{"_id":"public/tags/设计原则/index.html","hash":"928ff3480a9fdb7ccc5f6499cd6125c30bfea3b8","modified":1617454157238},{"_id":"public/tags/单元测试/index.html","hash":"45865bbf0f03ef40dfe9547ce23b419801d17ed5","modified":1617454157238},{"_id":"public/tags/项目管理/index.html","hash":"097546c8a581447db8c3026d17c501f02934eab4","modified":1617454157238},{"_id":"public/tags/敏捷开发/index.html","hash":"f238d8507153b528ceec597a9e7551972cbd723f","modified":1617454157238},{"_id":"public/tags/工时评估/index.html","hash":"1a06ad59ec53943baddde18ca7ab583a45943eff","modified":1617454157238},{"_id":"public/tags/团队方法论/index.html","hash":"73b1283b7a4b63f3620d994382d1ddd31d2192fe","modified":1617454157238},{"_id":"public/tags/监控告警体系/index.html","hash":"dac0f4c676f6766304ea18e81dd7b720a401dc90","modified":1617454157238},{"_id":"public/tags/分层架构、DDD/index.html","hash":"22d6f7c202a23e1ae1c75584f2f884527b2044fe","modified":1617454157238},{"_id":"public/tags/RESTful/index.html","hash":"39c0aa4b6992c2b494d3ca5857dc89b559e5f985","modified":1617454157238},{"_id":"public/tags/消息队列/index.html","hash":"63034ef0bbea9855b482512d0258a42514f595f8","modified":1617454157238},{"_id":"public/tags/RabbitMQ/index.html","hash":"ae4c84202736c898cfd3986a57c5109a68645e01","modified":1617454157238},{"_id":"public/tags/散列表/index.html","hash":"1eb98a7913ec68823b8c0d2f02739d369c538c6f","modified":1617454157238},{"_id":"public/google9015e32577ccc55d.html","hash":"a29d3a3e36e5097b6876cb98d5a76a31bd8afe88","modified":1617454157254},{"_id":"public/baidu_verify_XBpkZYVjlD.html","hash":"657a60f6bed3e71f60efc4173460aa8f01cd2fe2","modified":1617454157254},{"_id":"public/baidu_verify_Us10aoTC4p.html","hash":"5468c418816642d5d5844786df828f7b79c3a5d3","modified":1617454157254},{"_id":"public/robots.txt","hash":"bfe9e3f48c650224f72e292643aacc53b29bbd94","modified":1617454157254},{"_id":"public/sw.zip","hash":"f903be80cf2cddc000e23c58e35e40b7c776a31e","modified":1617454157254},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1617454157254},{"_id":"public/images/apple-touch-icon-next.jpg","hash":"631175b35e275927c09eea70acc41f00c223d677","modified":1617454157254},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1617454157254},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1617454157254},{"_id":"public/images/avatar.jpg","hash":"6f02591359265c7142c9244d3282b7c199e4d954","modified":1617454157254},{"_id":"public/images/avatar.jpg.bak","hash":"d47363a17a313f7193b7981b2f7e33d29aa5d55f","modified":1617454157254},{"_id":"public/images/alipay.jpg","hash":"729213e8f4d61d2ccf607467d3b474d4842c347d","modified":1617454157254},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1617454157254},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1617454157254},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1617454157254},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1617454157254},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1617454157254},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1617454157254},{"_id":"public/images/favicon-16x16-next.png","hash":"df39d619611cab6d2db0cab1c16e189e47bbee19","modified":1617454157254},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1617454157254},{"_id":"public/images/favicon-16x16-next.jpg","hash":"df39d619611cab6d2db0cab1c16e189e47bbee19","modified":1617454157254},{"_id":"public/images/favicon-192x192.png","hash":"1b63d6389fe13db6f6dd45eac7b07268e86a1ead","modified":1617454157254},{"_id":"public/images/favicon-32x32-next.jpg","hash":"7fce0752fd932e247ca6f9fc92ec1017ecde7441","modified":1617454157254},{"_id":"public/images/favicon-32x32-next.png","hash":"7fce0752fd932e247ca6f9fc92ec1017ecde7441","modified":1617454157254},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1617454157255},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1617454157255},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1617454157255},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1617454157255},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1617454157255},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1617454157255},{"_id":"public/fonts/M2Jd71oPJhLKp0zdtTvoM40tgx99jmYGv_xzYuwd1rU.woff2","hash":"d9b2ef60d14299632660b1f14156bc8d33e84f10","modified":1617454157255},{"_id":"public/fonts/M2Jd71oPJhLKp0zdtTvoM7YHq4FgHI02B8rPccK0FJQ.woff2","hash":"80c635636e0fd0d1ddbd5a4f60f846b1773fcd4d","modified":1617454157255},{"_id":"public/images/wechatpay.png","hash":"73162ca6c31a588e1f1240c39a405a91004ab922","modified":1617454157255},{"_id":"public/fonts/M2Jd71oPJhLKp0zdtTvoMxgy2Fsj5sj3EzlXpqVXRKo.woff2","hash":"90675f06fbecae812d4e4161630f9e71268d53aa","modified":1617454157255},{"_id":"public/fonts/ODelI1aHBYDBqgeIAH2zlNOAHFN6BivSraYkjhveRHY.woff2","hash":"ffd2de23ffff227247b5417bc454ca5de452c7d1","modified":1617454157255},{"_id":"public/fonts/ODelI1aHBYDBqgeIAH2zlC2Q8seG17bfDXYR_jUsrzg.woff2","hash":"869ef1d25cef6143e4b9298cc841de0d8410d488","modified":1617454157255},{"_id":"public/fonts/ODelI1aHBYDBqgeIAH2zlNV_2ngZ8dMf8fLgjYEouxg.woff2","hash":"235c384b9599ed2099f8fda87ba7bc8917eb1aa4","modified":1617454157255},{"_id":"public/fonts/fpTVHK8qsXbIeTHTrnQH6MAjkyiewWYrWZc50I8hK7I.woff2","hash":"19e0f393f7f44463d5677f41a52763c2a5902362","modified":1617454157255},{"_id":"public/fonts/fpTVHK8qsXbIeTHTrnQH6Lpx497t94oDua8KfAL9f-E.woff2","hash":"9e79ab1cfb1c8847a5ed7417bbb82a251e5aa6ce","modified":1617454157255},{"_id":"public/fonts/fpTVHK8qsXbIeTHTrnQH6E78GtRp3lhchupCJNw8t58.woff2","hash":"3f609717d5e58e73e0162a94908faf7e036ad2a2","modified":1617454157255},{"_id":"public/fonts/fpTVHK8qsXbIeTHTrnQH6CzM2XYAq8cDhaXsrN8WXcA.woff2","hash":"b52dd0120b00d2c5c39dfbbc44161f8e4d48ffba","modified":1617454157255},{"_id":"public/fonts/fpTVHK8qsXbIeTHTrnQH6GQKuzMuncr0JB710wa2dPI.woff2","hash":"36a2ad3968ec04260f99a9bafc65b3e1e1442178","modified":1617454157255},{"_id":"public/fonts/toadOcfmlt9b38dHJxOBGCOFnW3Jk0f09zW_Yln67Ac.woff2","hash":"a8eb7a7729f7f69f145d0505b9f3219d3b8b1a9a","modified":1617454157255},{"_id":"public/fonts/toadOcfmlt9b38dHJxOBGClYwVOhDRq2vbpGRTZ7bbs.woff2","hash":"68963ed662dca9c862418db1ff81565b3585a951","modified":1617454157255},{"_id":"public/fonts/toadOcfmlt9b38dHJxOBGD_j0nMiB9fPhg_k1wdK2h0.woff2","hash":"4d907d9d7c2a3ec3d5b450cc5b5e9adfd805d4c8","modified":1617454157255},{"_id":"public/fonts/toadOcfmlt9b38dHJxOBGDovqjS_dXPZszO_XltPdNg.woff2","hash":"8779f0a3e92c789016a138614a9ff51cb07e0b92","modified":1617454157255},{"_id":"public/fonts/toadOcfmlt9b38dHJxOBGEo0As1BFRXtCDhS66znb_k.woff2","hash":"b380e9f3dc4dfb061e70a88e1156ec89b008808a","modified":1617454157255},{"_id":"public/fonts/toadOcfmlt9b38dHJxOBGFxe-GPfKKFmiXaJ_Q0GFr8.woff2","hash":"b63fa29c4b1b9e04b21c58aecb2b77b527167821","modified":1617454157255},{"_id":"public/fonts/fpTVHK8qsXbIeTHTrnQH6OXKTZYPNtG1yMB_YJSqlic.woff2","hash":"2d331a887214a102602a3b871dddc1645a8c0346","modified":1617454157256},{"_id":"public/fonts/toadOcfmlt9b38dHJxOBGFKFh1TDTPrUZWzVp6FtpG8.woff2","hash":"26b54eaef53d7ef184f7804090aca31683ddca90","modified":1617454157256},{"_id":"public/fonts/说明.txt","hash":"58ef10f355ef7209f486789aadcf34695280c77e","modified":1617454157256},{"_id":"public/fonts/toadOcfmlt9b38dHJxOBGOode0-EuMkY--TSyExeINg.woff2","hash":"b9c7821c54dad58ca7f53e42cb17cb7b85f37d0a","modified":1617454157256},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1617454157256},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1617454157256},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1617454157256},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1617454157256},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1617454157256},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1617454157256},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1617454157256},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1617454157256},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1617454157256},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1617454157256},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1617454157257},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1617454157257},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1617454157257},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1617454157257},{"_id":"public/css/blog-encrypt.css","hash":"22e25b0d16ea053d25eb971e038c817a4c9cb584","modified":1617454157257},{"_id":"public/lib/blog-encrypt.js","hash":"91fda12d550323056762c5408623eb8a1d201ecc","modified":1617454157257},{"_id":"public/fonts/toadOcfmlt9b38dHJxOBGDRVvBvQIc1z78c__uoBcyI.woff2","hash":"6a94f553d70d2f6a33c937172ac28230b0f43691","modified":1617454157697},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1617454157700},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1617454157702},{"_id":"public/fonts/fonts.css","hash":"33eb87aea06200c294cba9cae54cdd3978de5e36","modified":1617454157711},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1617454157711},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1617454157711},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1617454157711},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1617454157712},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1617454157712},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1617454157712},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1617454157712},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1617454157712},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1617454157712},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1617454157712},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1617454157712},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1617454157712},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1617454157712},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1617454157712},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1617454157712},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1617454157712},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1617454157712},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1617454157712},{"_id":"public/js/src/schemes/pisces.js","hash":"72037e8c4202a73b0c6ff7d81b57cd349e836837","modified":1617454157712},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1617454157713},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1617454157713},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1617454157713},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1617454157713},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1617454157713},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1617454157713},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1617454157713},{"_id":"public/lib/jquery_lazyload/README.html","hash":"a08fccd381c8fdb70ba8974b208254c5ba23a95f","modified":1617454157713},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"06811ca2f722dead021493457f27cdc264ef928d","modified":1617454157713},{"_id":"public/lib/fastclick/README.html","hash":"d6e90449a2c09f3033f7e43d68b0cc8208e22e09","modified":1617454157713},{"_id":"public/css/main.css","hash":"1e6ac8915c404d725f483e80bd27016eacd2ed04","modified":1617454157713},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1617454157713},{"_id":"public/fonts/原始.css","hash":"c80fc6b6229581f3873d55d147be1c60d36f59b3","modified":1617454157721},{"_id":"public/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1617454157721},{"_id":"public/js/src/utils.js","hash":"28a79d317b7f4012917a54cac770551596bf6241","modified":1617454157721},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1617454157721},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1617454157721},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1617454157721},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1617454157721},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1617454157721},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1617454157722},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1617454157722},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1617454157722},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1617454157722},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1617454157727},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1617454157727},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1617454157735},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1617454157735},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1617454157746},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1617454157746},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1617454157747},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1617454157747},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1617454157747},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1617454157747},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1617454157747},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1617454157762},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1617454157763},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1617454157763},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1617454157771},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1617454157781},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1617454157788},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1617454157791},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1617454157806},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1617454157812},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1617454157815}],"Category":[{"name":"持续集成&Jenkins&自动化发布","_id":"ckn1qfpq70006hyjfko9kwc5s"},{"name":"日志","_id":"ckn1qfpsp000shyjfkzh2096a"},{"name":"Redis命令大全","_id":"ckn1qfptu001ahyjfk65ykb09"},{"name":"Bitmap","parent":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpu1001khyjfc0ki5aa2"},{"name":"Set","parent":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpu6001vhyjfqkh0nfly"},{"name":"List","parent":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpuv003fhyjf10xhvldp"},{"name":"ZSet","parent":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpvu005nhyjfd9gygce9"},{"name":"Hash","parent":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpww0096hyjfv5w21stz"},{"name":"String","parent":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx800aphyjfhpn0vuzh"},{"name":"读书笔记","_id":"ckn1qfpxf00c8hyjfibnkf85p"},{"name":"Redis","_id":"ckn1qfpxg00cehyjf8t9sm4q5"},{"name":"Spring Boot","_id":"ckn1qfpxh00cqhyjf98ajs8zv"},{"name":"代码的艺术","_id":"ckn1qfpxi00czhyjf4iict7ox"},{"name":"单元测试","_id":"ckn1qfpxj00d3hyjfzn7htzsn"},{"name":"大型网站技术架构","parent":"ckn1qfpxf00c8hyjfibnkf85p","_id":"ckn1qfpxj00d6hyjf0mjtd33r"},{"name":"项目管理","_id":"ckn1qfpzg00dkhyjfekcfczp2"},{"name":"团队方法论","_id":"ckn1qfpzj00dshyjf5xjz933v"},{"name":"分层架构","_id":"ckn1qfpzl00dyhyjfd5dsbme5"},{"name":"发布方式","parent":"ckn1qfpzj00dshyjf5xjz933v","_id":"ckn1qfpzp00eehyjft3vomhrk"},{"name":"监控告警体系","parent":"ckn1qfpzj00dshyjf5xjz933v","_id":"ckn1qfpzr00enhyjf0g4dizim"},{"name":"消息队列","_id":"ckn1qfq0b00g8hyjfzdzgz1cv"}],"Data":[],"Page":[{"_content":"importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js');\n\nif (workbox) {\n    workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' });\n\n    workbox.precaching.precache(['/', '/index.html']);\n\n    workbox.routing.registerRoute(new RegExp('^https?://laoyu.site/?$'), workbox.strategies.networkFirst());\n\n    workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst());\n\n    workbox.routing.registerRoute(new RegExp('.*.(?:js|css)'), workbox.strategies.staleWhileRevalidate());\n\n    workbox.routing.registerRoute(new RegExp('https://blog.laoyu.site/?$'), workbox.strategies.networkFirst());\n\t\n\tworkbox.routing.registerRoute(new RegExp('https://www.laoyu.site/?$'), workbox.strategies.networkFirst());\n}","source":"sw.js","raw":"importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js');\n\nif (workbox) {\n    workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' });\n\n    workbox.precaching.precache(['/', '/index.html']);\n\n    workbox.routing.registerRoute(new RegExp('^https?://laoyu.site/?$'), workbox.strategies.networkFirst());\n\n    workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst());\n\n    workbox.routing.registerRoute(new RegExp('.*.(?:js|css)'), workbox.strategies.staleWhileRevalidate());\n\n    workbox.routing.registerRoute(new RegExp('https://blog.laoyu.site/?$'), workbox.strategies.networkFirst());\n\t\n\tworkbox.routing.registerRoute(new RegExp('https://www.laoyu.site/?$'), workbox.strategies.networkFirst());\n}","date":"2021-03-14T03:04:50.727Z","updated":"2021-03-14T03:04:50.727Z","path":"sw.js","layout":"false","title":"","comments":1,"_id":"ckn1qfpiw0000hyjft89jmvas","content":"importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js');\n\nif (workbox) {\n    workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' });\n\n    workbox.precaching.precache(['/', '/index.html']);\n\n    workbox.routing.registerRoute(new RegExp('^https?://laoyu.site/?$'), workbox.strategies.networkFirst());\n\n    workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst());\n\n    workbox.routing.registerRoute(new RegExp('.*.(?:js|css)'), workbox.strategies.staleWhileRevalidate());\n\n    workbox.routing.registerRoute(new RegExp('https://blog.laoyu.site/?$'), workbox.strategies.networkFirst());\n\t\n\tworkbox.routing.registerRoute(new RegExp('https://www.laoyu.site/?$'), workbox.strategies.networkFirst());\n}","site":{"data":{}},"excerpt":"","more":"importScripts('https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js');\n\nif (workbox) {\n    workbox.setConfig({ modulePathPrefix: 'https://g.alicdn.com/kg/workbox/3.3.0/' });\n\n    workbox.precaching.precache(['/', '/index.html']);\n\n    workbox.routing.registerRoute(new RegExp('^https?://laoyu.site/?$'), workbox.strategies.networkFirst());\n\n    workbox.routing.registerRoute(new RegExp('.*.html'), workbox.strategies.networkFirst());\n\n    workbox.routing.registerRoute(new RegExp('.*.(?:js|css)'), workbox.strategies.staleWhileRevalidate());\n\n    workbox.routing.registerRoute(new RegExp('https://blog.laoyu.site/?$'), workbox.strategies.networkFirst());\n\t\n\tworkbox.routing.registerRoute(new RegExp('https://www.laoyu.site/?$'), workbox.strategies.networkFirst());\n}"},{"_content":"{\n  \"name\": \"老於记\",\n  \"short_name\": \"老於记\",\n  \"theme_color\": \"#2196f3\",\n  \"background_color\": \"#ffffff\",\n  \"display\": \"standalone\",\n  \"Scope\": \"/\",\n  \"start_url\": \"/\",\n  \"icons\": [\n    {\n      \"src\": \"/images/favicon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\",\n      \"density\": 4.0\n    }\n  ],\n  \"splash_pages\": null\n}","source":"manifest.json","raw":"{\n  \"name\": \"老於记\",\n  \"short_name\": \"老於记\",\n  \"theme_color\": \"#2196f3\",\n  \"background_color\": \"#ffffff\",\n  \"display\": \"standalone\",\n  \"Scope\": \"/\",\n  \"start_url\": \"/\",\n  \"icons\": [\n    {\n      \"src\": \"/images/favicon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\",\n      \"density\": 4.0\n    }\n  ],\n  \"splash_pages\": null\n}","date":"2021-03-14T03:04:50.726Z","updated":"2021-03-14T03:04:50.726Z","path":"manifest.json","layout":"false","title":"","comments":1,"_id":"ckn1qfpix0001hyjfkcgmxlw0","content":"{\"name\":\"老於记\",\"short_name\":\"老於记\",\"theme_color\":\"#2196f3\",\"background_color\":\"#ffffff\",\"display\":\"standalone\",\"Scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/images/favicon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\",\"density\":4}],\"splash_pages\":null}","site":{"data":{}},"excerpt":"","more":"{\"name\":\"老於记\",\"short_name\":\"老於记\",\"theme_color\":\"#2196f3\",\"background_color\":\"#ffffff\",\"display\":\"standalone\",\"Scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/images/favicon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\",\"density\":4}],\"splash_pages\":null}"},{"title":"tags","date":"2018-11-12T05:42:39.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-11-12 13:42:39\ntype: tags\ncomments: false\n---\n","updated":"2021-03-14T03:04:50.727Z","path":"tags/index.html","layout":"page","_id":"ckn1qfpkt0002hyjf5jwkkz6z","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2018-11-12T05:42:55.000Z","type":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-11-12 13:42:55\ntype: about\ncomments: false\n---\n","updated":"2021-03-14T03:04:50.726Z","path":"about/index.html","layout":"page","_id":"ckn1qfpku0003hyjfr1foc2fp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2018-11-12T05:42:48.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-11-12 13:42:48\ntype: categories\ncomments: false\n---\n","updated":"2021-03-14T03:04:50.726Z","path":"categories/index.html","layout":"page","_id":"ckn1qfpku0004hyjf6hzm6rpw","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":".NET实现持续集成与自动化部署2-NuGet","copyright":true,"date":"2018-11-13T03:09:33.000Z","keywords":"持续集成,Jenkins,自动化发布,NuGet,.NET","aside":"jenkins","_content":"\n### 前言\n&nbsp;&nbsp;&nbsp;&nbsp;Nuget是一个.NET平台下的开源的项目，它是Visual Studio的扩展。在使用Visual Studio开发基于.NET Framework的应用时，Nuget能把在项目中添加、移除和更新引用的工作变得更加快捷方便。这是维基百科中的定义，实际上Nuget就是一个包管理器，类似于Java的Maven，可以帮助我们更方便的管理dll。<!--more-->\n\n&nbsp;&nbsp;&nbsp;&nbsp;相信每个人都从官方的nuget服务器上下载过一些第三方组件。如:log4net、quartz.net等。实际上随着公司业务慢慢的拓展，项目也会越来越来多，很多项目会依赖其他项目DLL，比如一些底层的技术组件项目多，交叉引用多，这个时候对这些DLL的管理就至关重要。起初我们公司的方案是把这些公共的组件放到SVN的一个目录下，然后大家更新到本地，然后添加引用到项目里。这种方式管理起来较为复杂，而且必须要求所有项目人员的SVN更新路径必须是一致的。起初项目较少，项目之间没什么依赖，可重用的组件也不多，用起来没什么问题，但随着项目越来越多，可重用的组件也越来越多，引用越来越复杂，这个时候这些组件管理起来就很吃力了。<br>\n&nbsp;&nbsp;&nbsp;&nbsp;以上问题并没有意识到，我是在做Jenkisn持续集成与自动化发布的时候发现Jenkins把SVN更新到自己的工作空间内时，并不能更新到这些依赖的组件(因为这些公共的组件不在项目的SVN工作目录内)，导致构建失败的时候，苦思良久才想到搭建我们公司自己的Nuget服务器，来管理这些组件的。等真正用起来之后才觉得，可能正规军都这么玩，我们之前那种方式只是野路子。\n\n### 一、下载Nuget.Server\n&nbsp;&nbsp;&nbsp;&nbsp;从官方Nuget服务器上搜索nuget.server,点击项目url中的github路径。从github中下载nuget.server的源码。\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625113552103-109706720.png)\n下载并解压后的文件路径如下图所示:\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625113951128-1503563884.png)\n\n### 二、搭建Nuget.Server\n1. 打开项目文件NuGet.Server.sln,找到NuGet.Server,右键发布，选择文件系统(跟发布web程序一样，发布到IIS中)。\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625114642621-262211103.png)\n2. IIS新建站点MyNuGet\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625114859263-2006416616.png)\n    启动程序出现以下页面代表搭建成功\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625115218641-1622168019.png)\n3. 注意:若点击here出现404页面如下图所示:\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625115706412-729145768.png)\n    可以通过VS运行起来Nuget.Server项目，然后将bin目录替换IIS下的bin目录，即可解决。出现下图代表搭建成功\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627102545835-1004233709.png)\n    打开VS的Nuget管理器，点击图中设置图标，新建我们自己的nuget服务器\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627103124004-1628086707.png)\n    之后就可以连上我们自己搭建的服务器了\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627103239225-49848535.png)\n### 三、自建NuGet基本使用\n1. 下载NuGet命令行打包工具nuget.exe\n    下载地址:https://www.nuget.org/downloads\n\n2. 打包我们程序\n* 方式1：通过类库文件csproj的方式打包\n  首先打开我们程序的AssemblyInfo.cs文件修改程序集信息\n  ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627104018738-2049830247.png)\n\n使用nuget.exe打包程序集<br>\n在.csproj文件目录下执行命令spec\n```\nnuget.exe spec //spec 在.csproj文件目录下执行命令\n```\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627104333535-1316984971.png)\n此时会生成一个.nuspec文件，打开这个文件\n修改其中的xml属性即可(注意此处一些信息最好和AssemblyInfo.cs中的程序集信息一致)\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627105343352-1672213188.png)\n修改完成后继续执行pack命令\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627105438149-788832720.png)\n这时将生成的.nupkg文件直接copy到nuget服务器IIS目录下的packages文件夹内即可\n也可通过命令push推送至nuget服务器\n```\nnuget push *.nupkg -s http://127.0.0.1:8005 123456 //push 程序包路径 选项 地址 apikey\n//apikey 可以在服务器webconfig中配置\n```\n完成后即可查看或使用我们发布的程序集\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627113647970-1188544280.png)\n\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627113704127-1201145466.png)\n\n### 四、问题\n1. 在刚开始使用的时候经常因为失误或者程序有问题从而导致需要重新发布nuget包，但是发现覆盖掉原来的之后，项目里更新下来的始终还是原来的程序。\n    解决:慎重慎重再慎重打包，需要重新发布包的时候可以升级，不能覆盖。(当时认为这个东西只能升级不能覆盖)\n2. 用了一段时间后，由于当时至提供了nuget管理包的技术方案，却没有相应的使用规范与制度，导致团队nuget包混乱，开发人员胡乱升级，胡乱引用nuget包，终于有一天造成大问题。因此需要制定一个完善的使用规范与制度，包括如何打包，如何发布，谁来打包，谁来发布，慎重打包、升级、专人管理等\n3. 由于问题2引起的问题，因此决定重新整理nuget包(不破不立)，于是重新搭建了一个nuget服务器，重新规整虽有的程序集、组件、重新打包发布等，但是发现迁移到新的后，项目中下载下来的程序集还是原来的。(又遇到了问题1)。这次灵感一来发现问题解决方案。VS2017通过工具->选项->清除所有NuGet缓存 再重新下载包问题即可解决\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627114835612-1565198402.png)\n    若没有VS2017或找不到清楚NuGet缓存选项，也可找到自己机器上nuget的缓存文件夹删除掉里面对应的内容也可以，一般是在C:\\Users\\Administrator\\.nuget\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627115244329-208915392.png)\n    </font>","source":"_posts/jenkins/NET实现持续集成与自动化部署2-NuGet.md","raw":"---\ntitle: .NET实现持续集成与自动化部署2-NuGet\ncopyright: true\ndate: 2018-11-13 11:09:33\ntags: \n- 持续集成 \n- Jenkins \n- 自动化发布 \n- NuGet\ncategories: 持续集成&Jenkins&自动化发布\nkeywords: 持续集成,Jenkins,自动化发布,NuGet,.NET\naside: jenkins\n---\n\n### 前言\n&nbsp;&nbsp;&nbsp;&nbsp;Nuget是一个.NET平台下的开源的项目，它是Visual Studio的扩展。在使用Visual Studio开发基于.NET Framework的应用时，Nuget能把在项目中添加、移除和更新引用的工作变得更加快捷方便。这是维基百科中的定义，实际上Nuget就是一个包管理器，类似于Java的Maven，可以帮助我们更方便的管理dll。<!--more-->\n\n&nbsp;&nbsp;&nbsp;&nbsp;相信每个人都从官方的nuget服务器上下载过一些第三方组件。如:log4net、quartz.net等。实际上随着公司业务慢慢的拓展，项目也会越来越来多，很多项目会依赖其他项目DLL，比如一些底层的技术组件项目多，交叉引用多，这个时候对这些DLL的管理就至关重要。起初我们公司的方案是把这些公共的组件放到SVN的一个目录下，然后大家更新到本地，然后添加引用到项目里。这种方式管理起来较为复杂，而且必须要求所有项目人员的SVN更新路径必须是一致的。起初项目较少，项目之间没什么依赖，可重用的组件也不多，用起来没什么问题，但随着项目越来越多，可重用的组件也越来越多，引用越来越复杂，这个时候这些组件管理起来就很吃力了。<br>\n&nbsp;&nbsp;&nbsp;&nbsp;以上问题并没有意识到，我是在做Jenkisn持续集成与自动化发布的时候发现Jenkins把SVN更新到自己的工作空间内时，并不能更新到这些依赖的组件(因为这些公共的组件不在项目的SVN工作目录内)，导致构建失败的时候，苦思良久才想到搭建我们公司自己的Nuget服务器，来管理这些组件的。等真正用起来之后才觉得，可能正规军都这么玩，我们之前那种方式只是野路子。\n\n### 一、下载Nuget.Server\n&nbsp;&nbsp;&nbsp;&nbsp;从官方Nuget服务器上搜索nuget.server,点击项目url中的github路径。从github中下载nuget.server的源码。\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625113552103-109706720.png)\n下载并解压后的文件路径如下图所示:\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625113951128-1503563884.png)\n\n### 二、搭建Nuget.Server\n1. 打开项目文件NuGet.Server.sln,找到NuGet.Server,右键发布，选择文件系统(跟发布web程序一样，发布到IIS中)。\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625114642621-262211103.png)\n2. IIS新建站点MyNuGet\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625114859263-2006416616.png)\n    启动程序出现以下页面代表搭建成功\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625115218641-1622168019.png)\n3. 注意:若点击here出现404页面如下图所示:\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180625115706412-729145768.png)\n    可以通过VS运行起来Nuget.Server项目，然后将bin目录替换IIS下的bin目录，即可解决。出现下图代表搭建成功\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627102545835-1004233709.png)\n    打开VS的Nuget管理器，点击图中设置图标，新建我们自己的nuget服务器\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627103124004-1628086707.png)\n    之后就可以连上我们自己搭建的服务器了\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627103239225-49848535.png)\n### 三、自建NuGet基本使用\n1. 下载NuGet命令行打包工具nuget.exe\n    下载地址:https://www.nuget.org/downloads\n\n2. 打包我们程序\n* 方式1：通过类库文件csproj的方式打包\n  首先打开我们程序的AssemblyInfo.cs文件修改程序集信息\n  ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627104018738-2049830247.png)\n\n使用nuget.exe打包程序集<br>\n在.csproj文件目录下执行命令spec\n```\nnuget.exe spec //spec 在.csproj文件目录下执行命令\n```\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627104333535-1316984971.png)\n此时会生成一个.nuspec文件，打开这个文件\n修改其中的xml属性即可(注意此处一些信息最好和AssemblyInfo.cs中的程序集信息一致)\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627105343352-1672213188.png)\n修改完成后继续执行pack命令\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627105438149-788832720.png)\n这时将生成的.nupkg文件直接copy到nuget服务器IIS目录下的packages文件夹内即可\n也可通过命令push推送至nuget服务器\n```\nnuget push *.nupkg -s http://127.0.0.1:8005 123456 //push 程序包路径 选项 地址 apikey\n//apikey 可以在服务器webconfig中配置\n```\n完成后即可查看或使用我们发布的程序集\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627113647970-1188544280.png)\n\n![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627113704127-1201145466.png)\n\n### 四、问题\n1. 在刚开始使用的时候经常因为失误或者程序有问题从而导致需要重新发布nuget包，但是发现覆盖掉原来的之后，项目里更新下来的始终还是原来的程序。\n    解决:慎重慎重再慎重打包，需要重新发布包的时候可以升级，不能覆盖。(当时认为这个东西只能升级不能覆盖)\n2. 用了一段时间后，由于当时至提供了nuget管理包的技术方案，却没有相应的使用规范与制度，导致团队nuget包混乱，开发人员胡乱升级，胡乱引用nuget包，终于有一天造成大问题。因此需要制定一个完善的使用规范与制度，包括如何打包，如何发布，谁来打包，谁来发布，慎重打包、升级、专人管理等\n3. 由于问题2引起的问题，因此决定重新整理nuget包(不破不立)，于是重新搭建了一个nuget服务器，重新规整虽有的程序集、组件、重新打包发布等，但是发现迁移到新的后，项目中下载下来的程序集还是原来的。(又遇到了问题1)。这次灵感一来发现问题解决方案。VS2017通过工具->选项->清除所有NuGet缓存 再重新下载包问题即可解决\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627114835612-1565198402.png)\n    若没有VS2017或找不到清楚NuGet缓存选项，也可找到自己机器上nuget的缓存文件夹删除掉里面对应的内容也可以，一般是在C:\\Users\\Administrator\\.nuget\n    ![](https://images2018.cnblogs.com/blog/740814/201806/740814-20180627115244329-208915392.png)\n    </font>","slug":"jenkins/NET实现持续集成与自动化部署2-NuGet","published":1,"updated":"2021-03-14T03:04:50.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpq00005hyjf18zl65g9","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Nuget是一个.NET平台下的开源的项目，它是Visual Studio的扩展。在使用Visual Studio开发基于.NET Framework的应用时，Nuget能把在项目中添加、移除和更新引用的工作变得更加快捷方便。这是维基百科中的定义，实际上Nuget就是一个包管理器，类似于Java的Maven，可以帮助我们更方便的管理dll。<a id=\"more\"></a></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;相信每个人都从官方的nuget服务器上下载过一些第三方组件。如:log4net、quartz.net等。实际上随着公司业务慢慢的拓展，项目也会越来越来多，很多项目会依赖其他项目DLL，比如一些底层的技术组件项目多，交叉引用多，这个时候对这些DLL的管理就至关重要。起初我们公司的方案是把这些公共的组件放到SVN的一个目录下，然后大家更新到本地，然后添加引用到项目里。这种方式管理起来较为复杂，而且必须要求所有项目人员的SVN更新路径必须是一致的。起初项目较少，项目之间没什么依赖，可重用的组件也不多，用起来没什么问题，但随着项目越来越多，可重用的组件也越来越多，引用越来越复杂，这个时候这些组件管理起来就很吃力了。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;以上问题并没有意识到，我是在做Jenkisn持续集成与自动化发布的时候发现Jenkins把SVN更新到自己的工作空间内时，并不能更新到这些依赖的组件(因为这些公共的组件不在项目的SVN工作目录内)，导致构建失败的时候，苦思良久才想到搭建我们公司自己的Nuget服务器，来管理这些组件的。等真正用起来之后才觉得，可能正规军都这么玩，我们之前那种方式只是野路子。</p>\n<h3 id=\"一、下载Nuget-Server\"><a href=\"#一、下载Nuget-Server\" class=\"headerlink\" title=\"一、下载Nuget.Server\"></a>一、下载Nuget.Server</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;从官方Nuget服务器上搜索nuget.server,点击项目url中的github路径。从github中下载nuget.server的源码。<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625113552103-109706720.png\" alt><br>下载并解压后的文件路径如下图所示:<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625113951128-1503563884.png\" alt></p>\n<h3 id=\"二、搭建Nuget-Server\"><a href=\"#二、搭建Nuget-Server\" class=\"headerlink\" title=\"二、搭建Nuget.Server\"></a>二、搭建Nuget.Server</h3><ol>\n<li>打开项目文件NuGet.Server.sln,找到NuGet.Server,右键发布，选择文件系统(跟发布web程序一样，发布到IIS中)。<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625114642621-262211103.png\" alt></li>\n<li>IIS新建站点MyNuGet<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625114859263-2006416616.png\" alt><br> 启动程序出现以下页面代表搭建成功<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625115218641-1622168019.png\" alt></li>\n<li>注意:若点击here出现404页面如下图所示:<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625115706412-729145768.png\" alt><br> 可以通过VS运行起来Nuget.Server项目，然后将bin目录替换IIS下的bin目录，即可解决。出现下图代表搭建成功<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627102545835-1004233709.png\" alt><br> 打开VS的Nuget管理器，点击图中设置图标，新建我们自己的nuget服务器<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627103124004-1628086707.png\" alt><br> 之后就可以连上我们自己搭建的服务器了<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627103239225-49848535.png\" alt><h3 id=\"三、自建NuGet基本使用\"><a href=\"#三、自建NuGet基本使用\" class=\"headerlink\" title=\"三、自建NuGet基本使用\"></a>三、自建NuGet基本使用</h3></li>\n<li><p>下载NuGet命令行打包工具nuget.exe<br> 下载地址:<a href=\"https://www.nuget.org/downloads\" target=\"_blank\" rel=\"noopener\">https://www.nuget.org/downloads</a></p>\n</li>\n<li><p>打包我们程序</p>\n</li>\n</ol>\n<ul>\n<li>方式1：通过类库文件csproj的方式打包<br>首先打开我们程序的AssemblyInfo.cs文件修改程序集信息<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627104018738-2049830247.png\" alt></li>\n</ul>\n<p>使用nuget.exe打包程序集<br><br>在.csproj文件目录下执行命令spec<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nuget.exe spec //spec 在.csproj文件目录下执行命令</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627104333535-1316984971.png\" alt><br>此时会生成一个.nuspec文件，打开这个文件<br>修改其中的xml属性即可(注意此处一些信息最好和AssemblyInfo.cs中的程序集信息一致)<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627105343352-1672213188.png\" alt><br>修改完成后继续执行pack命令<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627105438149-788832720.png\" alt><br>这时将生成的.nupkg文件直接copy到nuget服务器IIS目录下的packages文件夹内即可<br>也可通过命令push推送至nuget服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nuget push *.nupkg -s http://127.0.0.1:8005 123456 //push 程序包路径 选项 地址 apikey</span><br><span class=\"line\">//apikey 可以在服务器webconfig中配置</span><br></pre></td></tr></table></figure></p>\n<p>完成后即可查看或使用我们发布的程序集<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627113647970-1188544280.png\" alt></p>\n<p><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627113704127-1201145466.png\" alt></p>\n<h3 id=\"四、问题\"><a href=\"#四、问题\" class=\"headerlink\" title=\"四、问题\"></a>四、问题</h3><ol>\n<li>在刚开始使用的时候经常因为失误或者程序有问题从而导致需要重新发布nuget包，但是发现覆盖掉原来的之后，项目里更新下来的始终还是原来的程序。<br> 解决:慎重慎重再慎重打包，需要重新发布包的时候可以升级，不能覆盖。(当时认为这个东西只能升级不能覆盖)</li>\n<li>用了一段时间后，由于当时至提供了nuget管理包的技术方案，却没有相应的使用规范与制度，导致团队nuget包混乱，开发人员胡乱升级，胡乱引用nuget包，终于有一天造成大问题。因此需要制定一个完善的使用规范与制度，包括如何打包，如何发布，谁来打包，谁来发布，慎重打包、升级、专人管理等</li>\n<li>由于问题2引起的问题，因此决定重新整理nuget包(不破不立)，于是重新搭建了一个nuget服务器，重新规整虽有的程序集、组件、重新打包发布等，但是发现迁移到新的后，项目中下载下来的程序集还是原来的。(又遇到了问题1)。这次灵感一来发现问题解决方案。VS2017通过工具-&gt;选项-&gt;清除所有NuGet缓存 再重新下载包问题即可解决<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627114835612-1565198402.png\" alt><br> 若没有VS2017或找不到清楚NuGet缓存选项，也可找到自己机器上nuget的缓存文件夹删除掉里面对应的内容也可以，一般是在C:\\Users\\Administrator.nuget<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627115244329-208915392.png\" alt><br> &lt;/font&gt;</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Nuget是一个.NET平台下的开源的项目，它是Visual Studio的扩展。在使用Visual Studio开发基于.NET Framework的应用时，Nuget能把在项目中添加、移除和更新引用的工作变得更加快捷方便。这是维基百科中的定义，实际上Nuget就是一个包管理器，类似于Java的Maven，可以帮助我们更方便的管理dll。","more":"</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;相信每个人都从官方的nuget服务器上下载过一些第三方组件。如:log4net、quartz.net等。实际上随着公司业务慢慢的拓展，项目也会越来越来多，很多项目会依赖其他项目DLL，比如一些底层的技术组件项目多，交叉引用多，这个时候对这些DLL的管理就至关重要。起初我们公司的方案是把这些公共的组件放到SVN的一个目录下，然后大家更新到本地，然后添加引用到项目里。这种方式管理起来较为复杂，而且必须要求所有项目人员的SVN更新路径必须是一致的。起初项目较少，项目之间没什么依赖，可重用的组件也不多，用起来没什么问题，但随着项目越来越多，可重用的组件也越来越多，引用越来越复杂，这个时候这些组件管理起来就很吃力了。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;以上问题并没有意识到，我是在做Jenkisn持续集成与自动化发布的时候发现Jenkins把SVN更新到自己的工作空间内时，并不能更新到这些依赖的组件(因为这些公共的组件不在项目的SVN工作目录内)，导致构建失败的时候，苦思良久才想到搭建我们公司自己的Nuget服务器，来管理这些组件的。等真正用起来之后才觉得，可能正规军都这么玩，我们之前那种方式只是野路子。</p>\n<h3 id=\"一、下载Nuget-Server\"><a href=\"#一、下载Nuget-Server\" class=\"headerlink\" title=\"一、下载Nuget.Server\"></a>一、下载Nuget.Server</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;从官方Nuget服务器上搜索nuget.server,点击项目url中的github路径。从github中下载nuget.server的源码。<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625113552103-109706720.png\" alt><br>下载并解压后的文件路径如下图所示:<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625113951128-1503563884.png\" alt></p>\n<h3 id=\"二、搭建Nuget-Server\"><a href=\"#二、搭建Nuget-Server\" class=\"headerlink\" title=\"二、搭建Nuget.Server\"></a>二、搭建Nuget.Server</h3><ol>\n<li>打开项目文件NuGet.Server.sln,找到NuGet.Server,右键发布，选择文件系统(跟发布web程序一样，发布到IIS中)。<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625114642621-262211103.png\" alt></li>\n<li>IIS新建站点MyNuGet<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625114859263-2006416616.png\" alt><br> 启动程序出现以下页面代表搭建成功<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625115218641-1622168019.png\" alt></li>\n<li>注意:若点击here出现404页面如下图所示:<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180625115706412-729145768.png\" alt><br> 可以通过VS运行起来Nuget.Server项目，然后将bin目录替换IIS下的bin目录，即可解决。出现下图代表搭建成功<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627102545835-1004233709.png\" alt><br> 打开VS的Nuget管理器，点击图中设置图标，新建我们自己的nuget服务器<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627103124004-1628086707.png\" alt><br> 之后就可以连上我们自己搭建的服务器了<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627103239225-49848535.png\" alt><h3 id=\"三、自建NuGet基本使用\"><a href=\"#三、自建NuGet基本使用\" class=\"headerlink\" title=\"三、自建NuGet基本使用\"></a>三、自建NuGet基本使用</h3></li>\n<li><p>下载NuGet命令行打包工具nuget.exe<br> 下载地址:<a href=\"https://www.nuget.org/downloads\" target=\"_blank\" rel=\"noopener\">https://www.nuget.org/downloads</a></p>\n</li>\n<li><p>打包我们程序</p>\n</li>\n</ol>\n<ul>\n<li>方式1：通过类库文件csproj的方式打包<br>首先打开我们程序的AssemblyInfo.cs文件修改程序集信息<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627104018738-2049830247.png\" alt></li>\n</ul>\n<p>使用nuget.exe打包程序集<br><br>在.csproj文件目录下执行命令spec<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nuget.exe spec //spec 在.csproj文件目录下执行命令</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627104333535-1316984971.png\" alt><br>此时会生成一个.nuspec文件，打开这个文件<br>修改其中的xml属性即可(注意此处一些信息最好和AssemblyInfo.cs中的程序集信息一致)<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627105343352-1672213188.png\" alt><br>修改完成后继续执行pack命令<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627105438149-788832720.png\" alt><br>这时将生成的.nupkg文件直接copy到nuget服务器IIS目录下的packages文件夹内即可<br>也可通过命令push推送至nuget服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nuget push *.nupkg -s http://127.0.0.1:8005 123456 //push 程序包路径 选项 地址 apikey</span><br><span class=\"line\">//apikey 可以在服务器webconfig中配置</span><br></pre></td></tr></table></figure></p>\n<p>完成后即可查看或使用我们发布的程序集<br><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627113647970-1188544280.png\" alt></p>\n<p><img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627113704127-1201145466.png\" alt></p>\n<h3 id=\"四、问题\"><a href=\"#四、问题\" class=\"headerlink\" title=\"四、问题\"></a>四、问题</h3><ol>\n<li>在刚开始使用的时候经常因为失误或者程序有问题从而导致需要重新发布nuget包，但是发现覆盖掉原来的之后，项目里更新下来的始终还是原来的程序。<br> 解决:慎重慎重再慎重打包，需要重新发布包的时候可以升级，不能覆盖。(当时认为这个东西只能升级不能覆盖)</li>\n<li>用了一段时间后，由于当时至提供了nuget管理包的技术方案，却没有相应的使用规范与制度，导致团队nuget包混乱，开发人员胡乱升级，胡乱引用nuget包，终于有一天造成大问题。因此需要制定一个完善的使用规范与制度，包括如何打包，如何发布，谁来打包，谁来发布，慎重打包、升级、专人管理等</li>\n<li>由于问题2引起的问题，因此决定重新整理nuget包(不破不立)，于是重新搭建了一个nuget服务器，重新规整虽有的程序集、组件、重新打包发布等，但是发现迁移到新的后，项目中下载下来的程序集还是原来的。(又遇到了问题1)。这次灵感一来发现问题解决方案。VS2017通过工具-&gt;选项-&gt;清除所有NuGet缓存 再重新下载包问题即可解决<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627114835612-1565198402.png\" alt><br> 若没有VS2017或找不到清楚NuGet缓存选项，也可找到自己机器上nuget的缓存文件夹删除掉里面对应的内容也可以，一般是在C:\\Users\\Administrator.nuget<br> <img src=\"https://images2018.cnblogs.com/blog/740814/201806/740814-20180627115244329-208915392.png\" alt><br> &lt;/font&gt;</li>\n</ol>"},{"title":".NET实现持续集成与自动化部署1-Jenkins","copyright":true,"date":"2018-11-13T03:06:33.000Z","keywords":".NET,持续集成,Jenkins,自动化发布,自动化部署","aside":"jenkins","_content":"\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;相信每一位程序员都经历过深夜加班上线的痛苦！而作为一个加班上线如家常便饭的码农，更是深感其痛。由于我们所做的系统业务复杂，系统庞大，设计到多个系统之间的合作，而核心系统更是采用分布式系统架构，由于当时对系统划分的不合理等等原因导致每次发版都会设计到多个系统的发布，小的版本三五个，大的版本十几个甚至几十个系统的同时发布！而我们也没有相应的基础设施的支撑，发版方式更是最传统的，开发人员将发布包发给运维人员，由其讲各个发布包一个一个覆盖到生产环境。因此每次上线仅仅发版就需要2-3个小时。这种方式不仅仅耗时、耗力，更是由于人工操作经常导致一些丢、落的现象。<!--more-->而我们当时的测试也是采用纯手工的测试，发版完毕后一轮回归测试就需要3-4个小时(当时主要是手工测试)。之前也一直提倡持续集成、自动化的测试和运维，但迟迟没有推进落地。终于在一个加班到凌晨四点的夜晚后，我再也受不了。回家后躺在床上迟迟睡不着，心想这个自动化的发布能有多难，他们搞不了，老子自己搞，于是6点爬起来来到公司，正式开始了我的持续集成、自动化部署的研究与推进之路。\n\n### 一、初识Jenkins\n\n&nbsp;&nbsp;&nbsp;&nbsp;由于之前亦没有相关知识的积累，因此也是对如何实现也是一头雾水。于是只能找度娘，关键字\"自动化发布\"。搜索到很多工具和方法，但都是以Java平台居多，.net平台相关资料不多。其中以Jenkins介绍较多，微软也提供一套自动化部署的方式，也有一些其他持续集成工具可以实现自动化的发布，但最终还是选择了Jenkins。主要有以下几个原因：\n\n* 代码开源、插件丰富完善、系统稳定\n* 社区活跃，成功实践和网上资源较为丰富\n* 安装配置简单\n* web形式的可视化的管理页面\n\n#### 1. Jenkins是什么\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。\n\n**  持续集成： **\n\n&nbsp;&nbsp;&nbsp;&nbsp;持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。\n\n#### 2.Jenkins能干什么\n\n&nbsp;&nbsp;&nbsp;&nbsp;众所周知，工业革命解放了人类的双手，使得人们避免了很多重复性的工作，而Jenkins能帮助开发测试运维人员解决很多重复性工作，我们可以将一些重复性的工作，写成脚本，如：代码提交，执行单元测试，程序的编译、构建、发布等封装成脚本，由Jenkins替我们定时或按需执行。事实上Jenkins的众多插件就是如此，究其根本就是执行一个或多个windows或linux命令来完成我们的需求。\n\n#### 3.Jenkins的一个工作流程\n\n&nbsp;&nbsp;&nbsp;&nbsp;通过对Jenkins的简单了解后，对完成自动化发布有了大致思路，如下图为Jenkins的一个工作流程\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/79027010.jpg)\n\n\n\n思路已经有了，接下来就是针对此流程，一步一步简单实现.NET Web应用程序基于Jenkins的自动化部署。\n\n### 二、Jenkins 安装\n\n&nbsp;&nbsp;&nbsp;&nbsp;Jenkins有windows版本也有linux版本，由于我们项目都是基于.net freamwork进行开发，而jenkins构建需要编译.net程序,为了更方便的编译，因此选择安装windows版本。\n\n#### 1.下载\n\n&nbsp;&nbsp;&nbsp;&nbsp;可从Jenkins官网https://jenkins.io/download/下载windows安装包。\n\n#### 2.安装\n\n&nbsp;&nbsp;&nbsp;&nbsp;下载完成后，可按照提示进行安装即可。(windows下傻瓜式安装，注意Jenkins是java开发，因此需先安装对应jdk版本)\n\n#### 3.配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;安装完成后会自动安装并启动一个windows服务，名为Jenkins，打开浏览器localhost:8080(Jenkins默认端口号为8080，如需修改可打开Jenkins安装目录找到Jenkins.xml修改其中端口，然后打开服务重启Jenkins服务即可)之后按照提示进行配置即可！配置完成后看到如下界面代表安装成功!\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/27633802.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;整个安装过程非常简单，基本上是傻瓜式按照提示操作即可，期间并未遇到问题，基本上10分钟左右就搞定了！接下来将介绍如何按照上述流程实现.NET下Jenkins的持续集成与自动化部署!\n\n### 三、通过SVN获取源代码\n\n#### 1.安装插件\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据我们的思路，首先要做的就是获取到我们的源代码。由于我们公司使用的源代码管理工具主要是SVN因此在这里主要介绍SVN的方式方法。根据度娘的指引，我们需要安装一个SVN的插件:Subversion Plug-in(如果：安装Jenkins时选择的安装推荐的插件，则Jenkins会直接给安装上这个插件，无需自己安装)。\n\n#### 2.项目配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;安装插件后，选择新建一个自由风格的软件项目，起个名字，进入到项目配置后，找到源代码管理选项：\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/51220937.jpg)\n\n主要有以下几个选项需要配置:\n\n* Repository URL:要获取的SVN的路径，如:https://127.0.0.1:9666/svn/HS.Mall/SoureCode/Trunk/Test\n\n* Credentials:配置SVN用户名和密码\n\n* Ignore externals:是否忽略SVN外部引用(这个很重要，稍后会用到，关于SVN外部引用，可自行百度)\n\n* Additional Credentials:当你的SVN版本库使用外部引用关联其它版本库是这个就很重要了\n\n  Realm：填写SVN服务器的地址\n\n  ```\n   <https://127.0.0.1:9666> VisualSVN Server //(注意这个格式)\n  ```\n\n  Credentials:填写SVN用户名和密码信息\n\n其它一些选项直接按照默认值就可以，关于每一项的详细介绍可以点击后面的小？号查看。\n\n配置完成后点击保存后，构建该项目查看结果。若能够将源代码更新至Jenkins的工作空间内，则代表配置成功!\n\n### 四、通过MSBuild编译应用程序\n\n#### 1.安装插件与环境\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译.NET应用程序可通过微软提供的MSBuild工具，先安装插件:MSBuild。(注意:Jenkins服务器需安装MSBuild，建议在Jenkins上安装VS开发工具，可以在构建出问题的时候打开VS调试，省去很多不必要的麻烦)。\n\n#### 2.全局配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;插件安装完毕后，进入系统管理->全局工具配置(ConfigureTools)找到MSBuild配置选项:\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/3872697.jpg)\n\n* Name：自己起个名字\n* Path to MSBuild:MSBuild.exe程序的物理路径\n\n注意:此处MSBuild.exe必须与程序所使用freamwork版本相对应，此处我在这就遇到了一个大坑，一开始随便找个一个MSBuild工具，没想到根本编译不了C#6.0的语法。建议直接指向visual studio安装目录内的MSBuild.exe,可以避免很多问题。如VS2017在:Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\MSBuild\\15.0\\Bin路径内。\n\n#### 3.项目配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开我们之前创建的项目，找到构建选项->增加构建步骤->Build a Visual Studio project or solution using MSBuild\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/45403259.jpg)\n\n* Name:选择全局MSBuild配置的名称\n\n* MSBuild Build File:填写我们的要构建的项目.csproj文件，所相对工作的路径。如:/Test.csproj\n\n* Command Line Arguments:MSBuild的参数如：/t:Rebuild /P:Configuration=Release /p:VisualStudioVersion=14.0 /p:DeployOnBuild=True;PublishProfile=Test.pubxml\n\n  * /t:Rebuild 重新生成 \n\n  - /p:Configuration=Release Release 生成模式 \n  - /p:VisualStudioVersion=14.0 指定子工具集(VS2015为14.0，2017为15.0)，不设置会报错 \n  - /p:DeployOnBuild=True;PublishProfile=Test.pubxml 使用 Test.pubxml 发布文件来发布项目 .pubxml文件可在VS发布时配置，位于Properties文件夹内。\n\n  配置完成后，点击构建，查看控制台信息，如能构建成功，则代表我们的配置无误！\n\n#### 4.遇到的问题\n\n&nbsp;&nbsp;&nbsp;&nbsp;原以为按照度娘的一系列解决方案能够很顺利的构建，可是在连续失败了几十次之后，才明白远远没有那么简单。期间主要遇到几个问题：\n\n* MSBuild版本不对导致构建不了C#6.0的语法\n* Jenkins 是讲版本库源代码更新到自己的工作空间内，再执行后续的构建工作。我们的程序很不规范，其中引用了许多不属于自己版本库的第三方依赖包，和一些自己开发的公共库，当时这些第三方包和公共库放在我们SVN的另一个版本库里进行管理，因此在构建的时候导致很多程序集找不到引用。\n\n关于问题1:上面已经提过，只需要找到对应版本即可\n\n而问题2:一开始找了很多资料也没有找到解决方案，后来还是从源代码管理上找到了方案。\n\n方案1：\n\n&nbsp;&nbsp;&nbsp;&nbsp;借鉴Nuget的思想，使用Nuget服务器管理我们自己开发的一些公共依赖库。关于Nuget管理依赖的文章在另一篇博客里。\n\n方案2:\n\n&nbsp;&nbsp;&nbsp;&nbsp;就是上面提到的SVN 外部引用，当时也是走投无路，于是疯狂翻译Jenkins的这些英文解释，在翻译到SVN插件的Ignore externals时，找到了这种方案，就是SVN可以设置外部引用，这样在更新版本库的时候就可以把依赖的版本库也更新下来，然后Jenkins SVN插件把这个Ignore externals选项去掉，然后在Additional Credentials选项里填上所依赖版本库的SVN配置，就能够把这些依赖也更新到SVN工作空间内。\n\n&nbsp;&nbsp;&nbsp;&nbsp;以上两个问题解决后，基本没有遇到太难的问题。由此可见我们的源代码管理的科学、规范是多么的重要。\n\n几十次的构建失败，一堆乱七八糟的引用是多么痛的领悟!\n\n### 五、通过Ftp发布至应用服务器\n\n&nbsp;&nbsp;&nbsp;&nbsp;构建成功后，Test.pubxml会指定发布的包的路径(最好是放到工作空间下)，按照思路，接下来就是要想办法把发布包Copy到应用服务器的根目录下。由于我们的应用服务器都是windows系统，因此不能像linux系统一样通过ssh远程Copy过去，当时能想到的就是使用Ftp直接上传到应用服务器。\n\n#### 1.安装插件与环境\n\n&nbsp;&nbsp;&nbsp;&nbsp;Jenkins 安装插件Publish Over FTP,应用服务器上需开启Ftp。\n\n####　2.全局配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;系统管理->系统配置下找到Publish over FTP配置项\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-5/40236536.jpg)\n\n* Name:起个名字，后面项目配置里会用的到\n* HostName:Ftp主机名(端口号默认21，在高级里面可以改)\n* Username:Ftp用户名\n* Password:Ftp密码\n\n#### 3.项目配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;打开我们之前建的项目，找到构建后操作->增加构建后操作步骤->Send build artifacts over FTP\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-5/25517488.jpg)\n\n* Name:选择全局配置里的\n* Source files:选择你的发布包路径(这里是相对于工作空间的路径)\n* Remote directory：放到远程的哪个路径里(这里是相对于Ftp根目录的路径)\n\n配置完成后，点击保存，构建即可！\n\n### 六、结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上，就基本实现了我们的自动化发布的需求，这期间从早晨六点开始，差不多中午就完成了，当然也并不像上面介绍的那么简单，期间也遇到了许多问题，构建了大概一百多次，才最终成功了第一次。本文主要介绍实现自动化部署的一种基本的思路，当然还有很多方案可以实现我们的需求，甚至不仅仅局限于Jenkins。而这种方案其中也有许多细节的地方在文章中没有提到，如：如何实现自动化的Nunit单元测试，如何定时构建......，因为当时我在完成之后也给我的团队成员提供了一个非常详细的配置文档，并且培训了很多次，但事实证明，讲的越详细越会限制他们自己的主动思考与动手的能力。这也导致了后来我去做其他工作的时候，我们将近一年的时间还是停留在我这半天的研究结果的层面上，而生产环境更是迟迟没有使用。其实思路才是最重要的，有了思路我们就可以通过各种方式来解决我们的问题，还是建议大家注重解决问题的思路，多动手，自己实践，才能学得更透!关于.NET 平台下Jenkins实现持续集成与自动化部署的落地与实现的问题与讨论，可以在文章下留言。","source":"_posts/jenkins/NET实现持续集成与自动化部署1-Jenkins.md","raw":"---\ntitle: .NET实现持续集成与自动化部署1-Jenkins\ncopyright: true\ndate: 2018-11-13 11:06:33\ntags: \n- 持续集成 \n- Jenkins \n- 自动化发布 \ncategories: 持续集成&Jenkins&自动化发布\nkeywords: .NET,持续集成,Jenkins,自动化发布,自动化部署\naside: jenkins\n---\n\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;相信每一位程序员都经历过深夜加班上线的痛苦！而作为一个加班上线如家常便饭的码农，更是深感其痛。由于我们所做的系统业务复杂，系统庞大，设计到多个系统之间的合作，而核心系统更是采用分布式系统架构，由于当时对系统划分的不合理等等原因导致每次发版都会设计到多个系统的发布，小的版本三五个，大的版本十几个甚至几十个系统的同时发布！而我们也没有相应的基础设施的支撑，发版方式更是最传统的，开发人员将发布包发给运维人员，由其讲各个发布包一个一个覆盖到生产环境。因此每次上线仅仅发版就需要2-3个小时。这种方式不仅仅耗时、耗力，更是由于人工操作经常导致一些丢、落的现象。<!--more-->而我们当时的测试也是采用纯手工的测试，发版完毕后一轮回归测试就需要3-4个小时(当时主要是手工测试)。之前也一直提倡持续集成、自动化的测试和运维，但迟迟没有推进落地。终于在一个加班到凌晨四点的夜晚后，我再也受不了。回家后躺在床上迟迟睡不着，心想这个自动化的发布能有多难，他们搞不了，老子自己搞，于是6点爬起来来到公司，正式开始了我的持续集成、自动化部署的研究与推进之路。\n\n### 一、初识Jenkins\n\n&nbsp;&nbsp;&nbsp;&nbsp;由于之前亦没有相关知识的积累，因此也是对如何实现也是一头雾水。于是只能找度娘，关键字\"自动化发布\"。搜索到很多工具和方法，但都是以Java平台居多，.net平台相关资料不多。其中以Jenkins介绍较多，微软也提供一套自动化部署的方式，也有一些其他持续集成工具可以实现自动化的发布，但最终还是选择了Jenkins。主要有以下几个原因：\n\n* 代码开源、插件丰富完善、系统稳定\n* 社区活跃，成功实践和网上资源较为丰富\n* 安装配置简单\n* web形式的可视化的管理页面\n\n#### 1. Jenkins是什么\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。\n\n**  持续集成： **\n\n&nbsp;&nbsp;&nbsp;&nbsp;持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。\n\n#### 2.Jenkins能干什么\n\n&nbsp;&nbsp;&nbsp;&nbsp;众所周知，工业革命解放了人类的双手，使得人们避免了很多重复性的工作，而Jenkins能帮助开发测试运维人员解决很多重复性工作，我们可以将一些重复性的工作，写成脚本，如：代码提交，执行单元测试，程序的编译、构建、发布等封装成脚本，由Jenkins替我们定时或按需执行。事实上Jenkins的众多插件就是如此，究其根本就是执行一个或多个windows或linux命令来完成我们的需求。\n\n#### 3.Jenkins的一个工作流程\n\n&nbsp;&nbsp;&nbsp;&nbsp;通过对Jenkins的简单了解后，对完成自动化发布有了大致思路，如下图为Jenkins的一个工作流程\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/79027010.jpg)\n\n\n\n思路已经有了，接下来就是针对此流程，一步一步简单实现.NET Web应用程序基于Jenkins的自动化部署。\n\n### 二、Jenkins 安装\n\n&nbsp;&nbsp;&nbsp;&nbsp;Jenkins有windows版本也有linux版本，由于我们项目都是基于.net freamwork进行开发，而jenkins构建需要编译.net程序,为了更方便的编译，因此选择安装windows版本。\n\n#### 1.下载\n\n&nbsp;&nbsp;&nbsp;&nbsp;可从Jenkins官网https://jenkins.io/download/下载windows安装包。\n\n#### 2.安装\n\n&nbsp;&nbsp;&nbsp;&nbsp;下载完成后，可按照提示进行安装即可。(windows下傻瓜式安装，注意Jenkins是java开发，因此需先安装对应jdk版本)\n\n#### 3.配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;安装完成后会自动安装并启动一个windows服务，名为Jenkins，打开浏览器localhost:8080(Jenkins默认端口号为8080，如需修改可打开Jenkins安装目录找到Jenkins.xml修改其中端口，然后打开服务重启Jenkins服务即可)之后按照提示进行配置即可！配置完成后看到如下界面代表安装成功!\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/27633802.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;整个安装过程非常简单，基本上是傻瓜式按照提示操作即可，期间并未遇到问题，基本上10分钟左右就搞定了！接下来将介绍如何按照上述流程实现.NET下Jenkins的持续集成与自动化部署!\n\n### 三、通过SVN获取源代码\n\n#### 1.安装插件\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据我们的思路，首先要做的就是获取到我们的源代码。由于我们公司使用的源代码管理工具主要是SVN因此在这里主要介绍SVN的方式方法。根据度娘的指引，我们需要安装一个SVN的插件:Subversion Plug-in(如果：安装Jenkins时选择的安装推荐的插件，则Jenkins会直接给安装上这个插件，无需自己安装)。\n\n#### 2.项目配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;安装插件后，选择新建一个自由风格的软件项目，起个名字，进入到项目配置后，找到源代码管理选项：\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/51220937.jpg)\n\n主要有以下几个选项需要配置:\n\n* Repository URL:要获取的SVN的路径，如:https://127.0.0.1:9666/svn/HS.Mall/SoureCode/Trunk/Test\n\n* Credentials:配置SVN用户名和密码\n\n* Ignore externals:是否忽略SVN外部引用(这个很重要，稍后会用到，关于SVN外部引用，可自行百度)\n\n* Additional Credentials:当你的SVN版本库使用外部引用关联其它版本库是这个就很重要了\n\n  Realm：填写SVN服务器的地址\n\n  ```\n   <https://127.0.0.1:9666> VisualSVN Server //(注意这个格式)\n  ```\n\n  Credentials:填写SVN用户名和密码信息\n\n其它一些选项直接按照默认值就可以，关于每一项的详细介绍可以点击后面的小？号查看。\n\n配置完成后点击保存后，构建该项目查看结果。若能够将源代码更新至Jenkins的工作空间内，则代表配置成功!\n\n### 四、通过MSBuild编译应用程序\n\n#### 1.安装插件与环境\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译.NET应用程序可通过微软提供的MSBuild工具，先安装插件:MSBuild。(注意:Jenkins服务器需安装MSBuild，建议在Jenkins上安装VS开发工具，可以在构建出问题的时候打开VS调试，省去很多不必要的麻烦)。\n\n#### 2.全局配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;插件安装完毕后，进入系统管理->全局工具配置(ConfigureTools)找到MSBuild配置选项:\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/3872697.jpg)\n\n* Name：自己起个名字\n* Path to MSBuild:MSBuild.exe程序的物理路径\n\n注意:此处MSBuild.exe必须与程序所使用freamwork版本相对应，此处我在这就遇到了一个大坑，一开始随便找个一个MSBuild工具，没想到根本编译不了C#6.0的语法。建议直接指向visual studio安装目录内的MSBuild.exe,可以避免很多问题。如VS2017在:Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\MSBuild\\15.0\\Bin路径内。\n\n#### 3.项目配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开我们之前创建的项目，找到构建选项->增加构建步骤->Build a Visual Studio project or solution using MSBuild\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/45403259.jpg)\n\n* Name:选择全局MSBuild配置的名称\n\n* MSBuild Build File:填写我们的要构建的项目.csproj文件，所相对工作的路径。如:/Test.csproj\n\n* Command Line Arguments:MSBuild的参数如：/t:Rebuild /P:Configuration=Release /p:VisualStudioVersion=14.0 /p:DeployOnBuild=True;PublishProfile=Test.pubxml\n\n  * /t:Rebuild 重新生成 \n\n  - /p:Configuration=Release Release 生成模式 \n  - /p:VisualStudioVersion=14.0 指定子工具集(VS2015为14.0，2017为15.0)，不设置会报错 \n  - /p:DeployOnBuild=True;PublishProfile=Test.pubxml 使用 Test.pubxml 发布文件来发布项目 .pubxml文件可在VS发布时配置，位于Properties文件夹内。\n\n  配置完成后，点击构建，查看控制台信息，如能构建成功，则代表我们的配置无误！\n\n#### 4.遇到的问题\n\n&nbsp;&nbsp;&nbsp;&nbsp;原以为按照度娘的一系列解决方案能够很顺利的构建，可是在连续失败了几十次之后，才明白远远没有那么简单。期间主要遇到几个问题：\n\n* MSBuild版本不对导致构建不了C#6.0的语法\n* Jenkins 是讲版本库源代码更新到自己的工作空间内，再执行后续的构建工作。我们的程序很不规范，其中引用了许多不属于自己版本库的第三方依赖包，和一些自己开发的公共库，当时这些第三方包和公共库放在我们SVN的另一个版本库里进行管理，因此在构建的时候导致很多程序集找不到引用。\n\n关于问题1:上面已经提过，只需要找到对应版本即可\n\n而问题2:一开始找了很多资料也没有找到解决方案，后来还是从源代码管理上找到了方案。\n\n方案1：\n\n&nbsp;&nbsp;&nbsp;&nbsp;借鉴Nuget的思想，使用Nuget服务器管理我们自己开发的一些公共依赖库。关于Nuget管理依赖的文章在另一篇博客里。\n\n方案2:\n\n&nbsp;&nbsp;&nbsp;&nbsp;就是上面提到的SVN 外部引用，当时也是走投无路，于是疯狂翻译Jenkins的这些英文解释，在翻译到SVN插件的Ignore externals时，找到了这种方案，就是SVN可以设置外部引用，这样在更新版本库的时候就可以把依赖的版本库也更新下来，然后Jenkins SVN插件把这个Ignore externals选项去掉，然后在Additional Credentials选项里填上所依赖版本库的SVN配置，就能够把这些依赖也更新到SVN工作空间内。\n\n&nbsp;&nbsp;&nbsp;&nbsp;以上两个问题解决后，基本没有遇到太难的问题。由此可见我们的源代码管理的科学、规范是多么的重要。\n\n几十次的构建失败，一堆乱七八糟的引用是多么痛的领悟!\n\n### 五、通过Ftp发布至应用服务器\n\n&nbsp;&nbsp;&nbsp;&nbsp;构建成功后，Test.pubxml会指定发布的包的路径(最好是放到工作空间下)，按照思路，接下来就是要想办法把发布包Copy到应用服务器的根目录下。由于我们的应用服务器都是windows系统，因此不能像linux系统一样通过ssh远程Copy过去，当时能想到的就是使用Ftp直接上传到应用服务器。\n\n#### 1.安装插件与环境\n\n&nbsp;&nbsp;&nbsp;&nbsp;Jenkins 安装插件Publish Over FTP,应用服务器上需开启Ftp。\n\n####　2.全局配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;系统管理->系统配置下找到Publish over FTP配置项\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-5/40236536.jpg)\n\n* Name:起个名字，后面项目配置里会用的到\n* HostName:Ftp主机名(端口号默认21，在高级里面可以改)\n* Username:Ftp用户名\n* Password:Ftp密码\n\n#### 3.项目配置\n\n&nbsp;&nbsp;&nbsp;&nbsp;打开我们之前建的项目，找到构建后操作->增加构建后操作步骤->Send build artifacts over FTP\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-5/25517488.jpg)\n\n* Name:选择全局配置里的\n* Source files:选择你的发布包路径(这里是相对于工作空间的路径)\n* Remote directory：放到远程的哪个路径里(这里是相对于Ftp根目录的路径)\n\n配置完成后，点击保存，构建即可！\n\n### 六、结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上，就基本实现了我们的自动化发布的需求，这期间从早晨六点开始，差不多中午就完成了，当然也并不像上面介绍的那么简单，期间也遇到了许多问题，构建了大概一百多次，才最终成功了第一次。本文主要介绍实现自动化部署的一种基本的思路，当然还有很多方案可以实现我们的需求，甚至不仅仅局限于Jenkins。而这种方案其中也有许多细节的地方在文章中没有提到，如：如何实现自动化的Nunit单元测试，如何定时构建......，因为当时我在完成之后也给我的团队成员提供了一个非常详细的配置文档，并且培训了很多次，但事实证明，讲的越详细越会限制他们自己的主动思考与动手的能力。这也导致了后来我去做其他工作的时候，我们将近一年的时间还是停留在我这半天的研究结果的层面上，而生产环境更是迟迟没有使用。其实思路才是最重要的，有了思路我们就可以通过各种方式来解决我们的问题，还是建议大家注重解决问题的思路，多动手，自己实践，才能学得更透!关于.NET 平台下Jenkins实现持续集成与自动化部署的落地与实现的问题与讨论，可以在文章下留言。","slug":"jenkins/NET实现持续集成与自动化部署1-Jenkins","published":1,"updated":"2021-03-14T03:04:50.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpr3000ghyjfw21gam39","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;相信每一位程序员都经历过深夜加班上线的痛苦！而作为一个加班上线如家常便饭的码农，更是深感其痛。由于我们所做的系统业务复杂，系统庞大，设计到多个系统之间的合作，而核心系统更是采用分布式系统架构，由于当时对系统划分的不合理等等原因导致每次发版都会设计到多个系统的发布，小的版本三五个，大的版本十几个甚至几十个系统的同时发布！而我们也没有相应的基础设施的支撑，发版方式更是最传统的，开发人员将发布包发给运维人员，由其讲各个发布包一个一个覆盖到生产环境。因此每次上线仅仅发版就需要2-3个小时。这种方式不仅仅耗时、耗力，更是由于人工操作经常导致一些丢、落的现象。<a id=\"more\"></a>而我们当时的测试也是采用纯手工的测试，发版完毕后一轮回归测试就需要3-4个小时(当时主要是手工测试)。之前也一直提倡持续集成、自动化的测试和运维，但迟迟没有推进落地。终于在一个加班到凌晨四点的夜晚后，我再也受不了。回家后躺在床上迟迟睡不着，心想这个自动化的发布能有多难，他们搞不了，老子自己搞，于是6点爬起来来到公司，正式开始了我的持续集成、自动化部署的研究与推进之路。</p>\n<h3 id=\"一、初识Jenkins\"><a href=\"#一、初识Jenkins\" class=\"headerlink\" title=\"一、初识Jenkins\"></a>一、初识Jenkins</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;由于之前亦没有相关知识的积累，因此也是对如何实现也是一头雾水。于是只能找度娘，关键字”自动化发布”。搜索到很多工具和方法，但都是以Java平台居多，.net平台相关资料不多。其中以Jenkins介绍较多，微软也提供一套自动化部署的方式，也有一些其他持续集成工具可以实现自动化的发布，但最终还是选择了Jenkins。主要有以下几个原因：</p>\n<ul>\n<li>代码开源、插件丰富完善、系统稳定</li>\n<li>社区活跃，成功实践和网上资源较为丰富</li>\n<li>安装配置简单</li>\n<li>web形式的可视化的管理页面</li>\n</ul>\n<h4 id=\"1-Jenkins是什么\"><a href=\"#1-Jenkins是什么\" class=\"headerlink\" title=\"1. Jenkins是什么\"></a>1. Jenkins是什么</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>\n<p><strong>  持续集成： </strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>\n<h4 id=\"2-Jenkins能干什么\"><a href=\"#2-Jenkins能干什么\" class=\"headerlink\" title=\"2.Jenkins能干什么\"></a>2.Jenkins能干什么</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;众所周知，工业革命解放了人类的双手，使得人们避免了很多重复性的工作，而Jenkins能帮助开发测试运维人员解决很多重复性工作，我们可以将一些重复性的工作，写成脚本，如：代码提交，执行单元测试，程序的编译、构建、发布等封装成脚本，由Jenkins替我们定时或按需执行。事实上Jenkins的众多插件就是如此，究其根本就是执行一个或多个windows或linux命令来完成我们的需求。</p>\n<h4 id=\"3-Jenkins的一个工作流程\"><a href=\"#3-Jenkins的一个工作流程\" class=\"headerlink\" title=\"3.Jenkins的一个工作流程\"></a>3.Jenkins的一个工作流程</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;通过对Jenkins的简单了解后，对完成自动化发布有了大致思路，如下图为Jenkins的一个工作流程</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/79027010.jpg\" alt=\"image\"></p>\n<p>思路已经有了，接下来就是针对此流程，一步一步简单实现.NET Web应用程序基于Jenkins的自动化部署。</p>\n<h3 id=\"二、Jenkins-安装\"><a href=\"#二、Jenkins-安装\" class=\"headerlink\" title=\"二、Jenkins 安装\"></a>二、Jenkins 安装</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Jenkins有windows版本也有linux版本，由于我们项目都是基于.net freamwork进行开发，而jenkins构建需要编译.net程序,为了更方便的编译，因此选择安装windows版本。</p>\n<h4 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;可从Jenkins官网<a href=\"https://jenkins.io/download/下载windows安装包。\" target=\"_blank\" rel=\"noopener\">https://jenkins.io/download/下载windows安装包。</a></p>\n<h4 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2.安装\"></a>2.安装</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;下载完成后，可按照提示进行安装即可。(windows下傻瓜式安装，注意Jenkins是java开发，因此需先安装对应jdk版本)</p>\n<h4 id=\"3-配置\"><a href=\"#3-配置\" class=\"headerlink\" title=\"3.配置\"></a>3.配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;安装完成后会自动安装并启动一个windows服务，名为Jenkins，打开浏览器localhost:8080(Jenkins默认端口号为8080，如需修改可打开Jenkins安装目录找到Jenkins.xml修改其中端口，然后打开服务重启Jenkins服务即可)之后按照提示进行配置即可！配置完成后看到如下界面代表安装成功!</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/27633802.jpg\" alt=\"image\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;整个安装过程非常简单，基本上是傻瓜式按照提示操作即可，期间并未遇到问题，基本上10分钟左右就搞定了！接下来将介绍如何按照上述流程实现.NET下Jenkins的持续集成与自动化部署!</p>\n<h3 id=\"三、通过SVN获取源代码\"><a href=\"#三、通过SVN获取源代码\" class=\"headerlink\" title=\"三、通过SVN获取源代码\"></a>三、通过SVN获取源代码</h3><h4 id=\"1-安装插件\"><a href=\"#1-安装插件\" class=\"headerlink\" title=\"1.安装插件\"></a>1.安装插件</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据我们的思路，首先要做的就是获取到我们的源代码。由于我们公司使用的源代码管理工具主要是SVN因此在这里主要介绍SVN的方式方法。根据度娘的指引，我们需要安装一个SVN的插件:Subversion Plug-in(如果：安装Jenkins时选择的安装推荐的插件，则Jenkins会直接给安装上这个插件，无需自己安装)。</p>\n<h4 id=\"2-项目配置\"><a href=\"#2-项目配置\" class=\"headerlink\" title=\"2.项目配置\"></a>2.项目配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;安装插件后，选择新建一个自由风格的软件项目，起个名字，进入到项目配置后，找到源代码管理选项：</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/51220937.jpg\" alt=\"image\"></p>\n<p>主要有以下几个选项需要配置:</p>\n<ul>\n<li><p>Repository URL:要获取的SVN的路径，如:<a href=\"https://127.0.0.1:9666/svn/HS.Mall/SoureCode/Trunk/Test\" target=\"_blank\" rel=\"noopener\">https://127.0.0.1:9666/svn/HS.Mall/SoureCode/Trunk/Test</a></p>\n</li>\n<li><p>Credentials:配置SVN用户名和密码</p>\n</li>\n<li><p>Ignore externals:是否忽略SVN外部引用(这个很重要，稍后会用到，关于SVN外部引用，可自行百度)</p>\n</li>\n<li><p>Additional Credentials:当你的SVN版本库使用外部引用关联其它版本库是这个就很重要了</p>\n<p>Realm：填写SVN服务器的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;https://127.0.0.1:9666&gt; VisualSVN Server //(注意这个格式)</span><br></pre></td></tr></table></figure>\n<p>Credentials:填写SVN用户名和密码信息</p>\n</li>\n</ul>\n<p>其它一些选项直接按照默认值就可以，关于每一项的详细介绍可以点击后面的小？号查看。</p>\n<p>配置完成后点击保存后，构建该项目查看结果。若能够将源代码更新至Jenkins的工作空间内，则代表配置成功!</p>\n<h3 id=\"四、通过MSBuild编译应用程序\"><a href=\"#四、通过MSBuild编译应用程序\" class=\"headerlink\" title=\"四、通过MSBuild编译应用程序\"></a>四、通过MSBuild编译应用程序</h3><h4 id=\"1-安装插件与环境\"><a href=\"#1-安装插件与环境\" class=\"headerlink\" title=\"1.安装插件与环境\"></a>1.安装插件与环境</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译.NET应用程序可通过微软提供的MSBuild工具，先安装插件:MSBuild。(注意:Jenkins服务器需安装MSBuild，建议在Jenkins上安装VS开发工具，可以在构建出问题的时候打开VS调试，省去很多不必要的麻烦)。</p>\n<h4 id=\"2-全局配置\"><a href=\"#2-全局配置\" class=\"headerlink\" title=\"2.全局配置\"></a>2.全局配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;插件安装完毕后，进入系统管理-&gt;全局工具配置(ConfigureTools)找到MSBuild配置选项:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/3872697.jpg\" alt=\"image\"></p>\n<ul>\n<li>Name：自己起个名字</li>\n<li>Path to MSBuild:MSBuild.exe程序的物理路径</li>\n</ul>\n<p>注意:此处MSBuild.exe必须与程序所使用freamwork版本相对应，此处我在这就遇到了一个大坑，一开始随便找个一个MSBuild工具，没想到根本编译不了C#6.0的语法。建议直接指向visual studio安装目录内的MSBuild.exe,可以避免很多问题。如VS2017在:Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\MSBuild\\15.0\\Bin路径内。</p>\n<h4 id=\"3-项目配置\"><a href=\"#3-项目配置\" class=\"headerlink\" title=\"3.项目配置\"></a>3.项目配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开我们之前创建的项目，找到构建选项-&gt;增加构建步骤-&gt;Build a Visual Studio project or solution using MSBuild</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/45403259.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>Name:选择全局MSBuild配置的名称</p>\n</li>\n<li><p>MSBuild Build File:填写我们的要构建的项目.csproj文件，所相对工作的路径。如:/Test.csproj</p>\n</li>\n<li><p>Command Line Arguments:MSBuild的参数如：/t:Rebuild /P:Configuration=Release /p:VisualStudioVersion=14.0 /p:DeployOnBuild=True;PublishProfile=Test.pubxml</p>\n<ul>\n<li>/t:Rebuild 重新生成 </li>\n</ul>\n<ul>\n<li>/p:Configuration=Release Release 生成模式 </li>\n<li>/p:VisualStudioVersion=14.0 指定子工具集(VS2015为14.0，2017为15.0)，不设置会报错 </li>\n<li>/p:DeployOnBuild=True;PublishProfile=Test.pubxml 使用 Test.pubxml 发布文件来发布项目 .pubxml文件可在VS发布时配置，位于Properties文件夹内。</li>\n</ul>\n<p>配置完成后，点击构建，查看控制台信息，如能构建成功，则代表我们的配置无误！</p>\n</li>\n</ul>\n<h4 id=\"4-遇到的问题\"><a href=\"#4-遇到的问题\" class=\"headerlink\" title=\"4.遇到的问题\"></a>4.遇到的问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;原以为按照度娘的一系列解决方案能够很顺利的构建，可是在连续失败了几十次之后，才明白远远没有那么简单。期间主要遇到几个问题：</p>\n<ul>\n<li>MSBuild版本不对导致构建不了C#6.0的语法</li>\n<li>Jenkins 是讲版本库源代码更新到自己的工作空间内，再执行后续的构建工作。我们的程序很不规范，其中引用了许多不属于自己版本库的第三方依赖包，和一些自己开发的公共库，当时这些第三方包和公共库放在我们SVN的另一个版本库里进行管理，因此在构建的时候导致很多程序集找不到引用。</li>\n</ul>\n<p>关于问题1:上面已经提过，只需要找到对应版本即可</p>\n<p>而问题2:一开始找了很多资料也没有找到解决方案，后来还是从源代码管理上找到了方案。</p>\n<p>方案1：</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;借鉴Nuget的思想，使用Nuget服务器管理我们自己开发的一些公共依赖库。关于Nuget管理依赖的文章在另一篇博客里。</p>\n<p>方案2:</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;就是上面提到的SVN 外部引用，当时也是走投无路，于是疯狂翻译Jenkins的这些英文解释，在翻译到SVN插件的Ignore externals时，找到了这种方案，就是SVN可以设置外部引用，这样在更新版本库的时候就可以把依赖的版本库也更新下来，然后Jenkins SVN插件把这个Ignore externals选项去掉，然后在Additional Credentials选项里填上所依赖版本库的SVN配置，就能够把这些依赖也更新到SVN工作空间内。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;以上两个问题解决后，基本没有遇到太难的问题。由此可见我们的源代码管理的科学、规范是多么的重要。</p>\n<p>几十次的构建失败，一堆乱七八糟的引用是多么痛的领悟!</p>\n<h3 id=\"五、通过Ftp发布至应用服务器\"><a href=\"#五、通过Ftp发布至应用服务器\" class=\"headerlink\" title=\"五、通过Ftp发布至应用服务器\"></a>五、通过Ftp发布至应用服务器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;构建成功后，Test.pubxml会指定发布的包的路径(最好是放到工作空间下)，按照思路，接下来就是要想办法把发布包Copy到应用服务器的根目录下。由于我们的应用服务器都是windows系统，因此不能像linux系统一样通过ssh远程Copy过去，当时能想到的就是使用Ftp直接上传到应用服务器。</p>\n<h4 id=\"1-安装插件与环境-1\"><a href=\"#1-安装插件与环境-1\" class=\"headerlink\" title=\"1.安装插件与环境\"></a>1.安装插件与环境</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Jenkins 安装插件Publish Over FTP,应用服务器上需开启Ftp。</p>\n<h4 id=\"2-全局配置-1\"><a href=\"#2-全局配置-1\" class=\"headerlink\" title=\"　2.全局配置\"></a>　2.全局配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;系统管理-&gt;系统配置下找到Publish over FTP配置项</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-5/40236536.jpg\" alt=\"image\"></p>\n<ul>\n<li>Name:起个名字，后面项目配置里会用的到</li>\n<li>HostName:Ftp主机名(端口号默认21，在高级里面可以改)</li>\n<li>Username:Ftp用户名</li>\n<li>Password:Ftp密码</li>\n</ul>\n<h4 id=\"3-项目配置-1\"><a href=\"#3-项目配置-1\" class=\"headerlink\" title=\"3.项目配置\"></a>3.项目配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;打开我们之前建的项目，找到构建后操作-&gt;增加构建后操作步骤-&gt;Send build artifacts over FTP</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-5/25517488.jpg\" alt=\"image\"></p>\n<ul>\n<li>Name:选择全局配置里的</li>\n<li>Source files:选择你的发布包路径(这里是相对于工作空间的路径)</li>\n<li>Remote directory：放到远程的哪个路径里(这里是相对于Ftp根目录的路径)</li>\n</ul>\n<p>配置完成后，点击保存，构建即可！</p>\n<h3 id=\"六、结束语\"><a href=\"#六、结束语\" class=\"headerlink\" title=\"六、结束语\"></a>六、结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如上，就基本实现了我们的自动化发布的需求，这期间从早晨六点开始，差不多中午就完成了，当然也并不像上面介绍的那么简单，期间也遇到了许多问题，构建了大概一百多次，才最终成功了第一次。本文主要介绍实现自动化部署的一种基本的思路，当然还有很多方案可以实现我们的需求，甚至不仅仅局限于Jenkins。而这种方案其中也有许多细节的地方在文章中没有提到，如：如何实现自动化的Nunit单元测试，如何定时构建……，因为当时我在完成之后也给我的团队成员提供了一个非常详细的配置文档，并且培训了很多次，但事实证明，讲的越详细越会限制他们自己的主动思考与动手的能力。这也导致了后来我去做其他工作的时候，我们将近一年的时间还是停留在我这半天的研究结果的层面上，而生产环境更是迟迟没有使用。其实思路才是最重要的，有了思路我们就可以通过各种方式来解决我们的问题，还是建议大家注重解决问题的思路，多动手，自己实践，才能学得更透!关于.NET 平台下Jenkins实现持续集成与自动化部署的落地与实现的问题与讨论，可以在文章下留言。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;相信每一位程序员都经历过深夜加班上线的痛苦！而作为一个加班上线如家常便饭的码农，更是深感其痛。由于我们所做的系统业务复杂，系统庞大，设计到多个系统之间的合作，而核心系统更是采用分布式系统架构，由于当时对系统划分的不合理等等原因导致每次发版都会设计到多个系统的发布，小的版本三五个，大的版本十几个甚至几十个系统的同时发布！而我们也没有相应的基础设施的支撑，发版方式更是最传统的，开发人员将发布包发给运维人员，由其讲各个发布包一个一个覆盖到生产环境。因此每次上线仅仅发版就需要2-3个小时。这种方式不仅仅耗时、耗力，更是由于人工操作经常导致一些丢、落的现象。","more":"而我们当时的测试也是采用纯手工的测试，发版完毕后一轮回归测试就需要3-4个小时(当时主要是手工测试)。之前也一直提倡持续集成、自动化的测试和运维，但迟迟没有推进落地。终于在一个加班到凌晨四点的夜晚后，我再也受不了。回家后躺在床上迟迟睡不着，心想这个自动化的发布能有多难，他们搞不了，老子自己搞，于是6点爬起来来到公司，正式开始了我的持续集成、自动化部署的研究与推进之路。</p>\n<h3 id=\"一、初识Jenkins\"><a href=\"#一、初识Jenkins\" class=\"headerlink\" title=\"一、初识Jenkins\"></a>一、初识Jenkins</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;由于之前亦没有相关知识的积累，因此也是对如何实现也是一头雾水。于是只能找度娘，关键字”自动化发布”。搜索到很多工具和方法，但都是以Java平台居多，.net平台相关资料不多。其中以Jenkins介绍较多，微软也提供一套自动化部署的方式，也有一些其他持续集成工具可以实现自动化的发布，但最终还是选择了Jenkins。主要有以下几个原因：</p>\n<ul>\n<li>代码开源、插件丰富完善、系统稳定</li>\n<li>社区活跃，成功实践和网上资源较为丰富</li>\n<li>安装配置简单</li>\n<li>web形式的可视化的管理页面</li>\n</ul>\n<h4 id=\"1-Jenkins是什么\"><a href=\"#1-Jenkins是什么\" class=\"headerlink\" title=\"1. Jenkins是什么\"></a>1. Jenkins是什么</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>\n<p><strong>  持续集成： </strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>\n<h4 id=\"2-Jenkins能干什么\"><a href=\"#2-Jenkins能干什么\" class=\"headerlink\" title=\"2.Jenkins能干什么\"></a>2.Jenkins能干什么</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;众所周知，工业革命解放了人类的双手，使得人们避免了很多重复性的工作，而Jenkins能帮助开发测试运维人员解决很多重复性工作，我们可以将一些重复性的工作，写成脚本，如：代码提交，执行单元测试，程序的编译、构建、发布等封装成脚本，由Jenkins替我们定时或按需执行。事实上Jenkins的众多插件就是如此，究其根本就是执行一个或多个windows或linux命令来完成我们的需求。</p>\n<h4 id=\"3-Jenkins的一个工作流程\"><a href=\"#3-Jenkins的一个工作流程\" class=\"headerlink\" title=\"3.Jenkins的一个工作流程\"></a>3.Jenkins的一个工作流程</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;通过对Jenkins的简单了解后，对完成自动化发布有了大致思路，如下图为Jenkins的一个工作流程</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/79027010.jpg\" alt=\"image\"></p>\n<p>思路已经有了，接下来就是针对此流程，一步一步简单实现.NET Web应用程序基于Jenkins的自动化部署。</p>\n<h3 id=\"二、Jenkins-安装\"><a href=\"#二、Jenkins-安装\" class=\"headerlink\" title=\"二、Jenkins 安装\"></a>二、Jenkins 安装</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Jenkins有windows版本也有linux版本，由于我们项目都是基于.net freamwork进行开发，而jenkins构建需要编译.net程序,为了更方便的编译，因此选择安装windows版本。</p>\n<h4 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;可从Jenkins官网<a href=\"https://jenkins.io/download/下载windows安装包。\" target=\"_blank\" rel=\"noopener\">https://jenkins.io/download/下载windows安装包。</a></p>\n<h4 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2.安装\"></a>2.安装</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;下载完成后，可按照提示进行安装即可。(windows下傻瓜式安装，注意Jenkins是java开发，因此需先安装对应jdk版本)</p>\n<h4 id=\"3-配置\"><a href=\"#3-配置\" class=\"headerlink\" title=\"3.配置\"></a>3.配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;安装完成后会自动安装并启动一个windows服务，名为Jenkins，打开浏览器localhost:8080(Jenkins默认端口号为8080，如需修改可打开Jenkins安装目录找到Jenkins.xml修改其中端口，然后打开服务重启Jenkins服务即可)之后按照提示进行配置即可！配置完成后看到如下界面代表安装成功!</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/27633802.jpg\" alt=\"image\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;整个安装过程非常简单，基本上是傻瓜式按照提示操作即可，期间并未遇到问题，基本上10分钟左右就搞定了！接下来将介绍如何按照上述流程实现.NET下Jenkins的持续集成与自动化部署!</p>\n<h3 id=\"三、通过SVN获取源代码\"><a href=\"#三、通过SVN获取源代码\" class=\"headerlink\" title=\"三、通过SVN获取源代码\"></a>三、通过SVN获取源代码</h3><h4 id=\"1-安装插件\"><a href=\"#1-安装插件\" class=\"headerlink\" title=\"1.安装插件\"></a>1.安装插件</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据我们的思路，首先要做的就是获取到我们的源代码。由于我们公司使用的源代码管理工具主要是SVN因此在这里主要介绍SVN的方式方法。根据度娘的指引，我们需要安装一个SVN的插件:Subversion Plug-in(如果：安装Jenkins时选择的安装推荐的插件，则Jenkins会直接给安装上这个插件，无需自己安装)。</p>\n<h4 id=\"2-项目配置\"><a href=\"#2-项目配置\" class=\"headerlink\" title=\"2.项目配置\"></a>2.项目配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;安装插件后，选择新建一个自由风格的软件项目，起个名字，进入到项目配置后，找到源代码管理选项：</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/51220937.jpg\" alt=\"image\"></p>\n<p>主要有以下几个选项需要配置:</p>\n<ul>\n<li><p>Repository URL:要获取的SVN的路径，如:<a href=\"https://127.0.0.1:9666/svn/HS.Mall/SoureCode/Trunk/Test\" target=\"_blank\" rel=\"noopener\">https://127.0.0.1:9666/svn/HS.Mall/SoureCode/Trunk/Test</a></p>\n</li>\n<li><p>Credentials:配置SVN用户名和密码</p>\n</li>\n<li><p>Ignore externals:是否忽略SVN外部引用(这个很重要，稍后会用到，关于SVN外部引用，可自行百度)</p>\n</li>\n<li><p>Additional Credentials:当你的SVN版本库使用外部引用关联其它版本库是这个就很重要了</p>\n<p>Realm：填写SVN服务器的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;https://127.0.0.1:9666&gt; VisualSVN Server //(注意这个格式)</span><br></pre></td></tr></table></figure>\n<p>Credentials:填写SVN用户名和密码信息</p>\n</li>\n</ul>\n<p>其它一些选项直接按照默认值就可以，关于每一项的详细介绍可以点击后面的小？号查看。</p>\n<p>配置完成后点击保存后，构建该项目查看结果。若能够将源代码更新至Jenkins的工作空间内，则代表配置成功!</p>\n<h3 id=\"四、通过MSBuild编译应用程序\"><a href=\"#四、通过MSBuild编译应用程序\" class=\"headerlink\" title=\"四、通过MSBuild编译应用程序\"></a>四、通过MSBuild编译应用程序</h3><h4 id=\"1-安装插件与环境\"><a href=\"#1-安装插件与环境\" class=\"headerlink\" title=\"1.安装插件与环境\"></a>1.安装插件与环境</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编译.NET应用程序可通过微软提供的MSBuild工具，先安装插件:MSBuild。(注意:Jenkins服务器需安装MSBuild，建议在Jenkins上安装VS开发工具，可以在构建出问题的时候打开VS调试，省去很多不必要的麻烦)。</p>\n<h4 id=\"2-全局配置\"><a href=\"#2-全局配置\" class=\"headerlink\" title=\"2.全局配置\"></a>2.全局配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;插件安装完毕后，进入系统管理-&gt;全局工具配置(ConfigureTools)找到MSBuild配置选项:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/3872697.jpg\" alt=\"image\"></p>\n<ul>\n<li>Name：自己起个名字</li>\n<li>Path to MSBuild:MSBuild.exe程序的物理路径</li>\n</ul>\n<p>注意:此处MSBuild.exe必须与程序所使用freamwork版本相对应，此处我在这就遇到了一个大坑，一开始随便找个一个MSBuild工具，没想到根本编译不了C#6.0的语法。建议直接指向visual studio安装目录内的MSBuild.exe,可以避免很多问题。如VS2017在:Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\MSBuild\\15.0\\Bin路径内。</p>\n<h4 id=\"3-项目配置\"><a href=\"#3-项目配置\" class=\"headerlink\" title=\"3.项目配置\"></a>3.项目配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开我们之前创建的项目，找到构建选项-&gt;增加构建步骤-&gt;Build a Visual Studio project or solution using MSBuild</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-4/45403259.jpg\" alt=\"image\"></p>\n<ul>\n<li><p>Name:选择全局MSBuild配置的名称</p>\n</li>\n<li><p>MSBuild Build File:填写我们的要构建的项目.csproj文件，所相对工作的路径。如:/Test.csproj</p>\n</li>\n<li><p>Command Line Arguments:MSBuild的参数如：/t:Rebuild /P:Configuration=Release /p:VisualStudioVersion=14.0 /p:DeployOnBuild=True;PublishProfile=Test.pubxml</p>\n<ul>\n<li>/t:Rebuild 重新生成 </li>\n</ul>\n<ul>\n<li>/p:Configuration=Release Release 生成模式 </li>\n<li>/p:VisualStudioVersion=14.0 指定子工具集(VS2015为14.0，2017为15.0)，不设置会报错 </li>\n<li>/p:DeployOnBuild=True;PublishProfile=Test.pubxml 使用 Test.pubxml 发布文件来发布项目 .pubxml文件可在VS发布时配置，位于Properties文件夹内。</li>\n</ul>\n<p>配置完成后，点击构建，查看控制台信息，如能构建成功，则代表我们的配置无误！</p>\n</li>\n</ul>\n<h4 id=\"4-遇到的问题\"><a href=\"#4-遇到的问题\" class=\"headerlink\" title=\"4.遇到的问题\"></a>4.遇到的问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;原以为按照度娘的一系列解决方案能够很顺利的构建，可是在连续失败了几十次之后，才明白远远没有那么简单。期间主要遇到几个问题：</p>\n<ul>\n<li>MSBuild版本不对导致构建不了C#6.0的语法</li>\n<li>Jenkins 是讲版本库源代码更新到自己的工作空间内，再执行后续的构建工作。我们的程序很不规范，其中引用了许多不属于自己版本库的第三方依赖包，和一些自己开发的公共库，当时这些第三方包和公共库放在我们SVN的另一个版本库里进行管理，因此在构建的时候导致很多程序集找不到引用。</li>\n</ul>\n<p>关于问题1:上面已经提过，只需要找到对应版本即可</p>\n<p>而问题2:一开始找了很多资料也没有找到解决方案，后来还是从源代码管理上找到了方案。</p>\n<p>方案1：</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;借鉴Nuget的思想，使用Nuget服务器管理我们自己开发的一些公共依赖库。关于Nuget管理依赖的文章在另一篇博客里。</p>\n<p>方案2:</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;就是上面提到的SVN 外部引用，当时也是走投无路，于是疯狂翻译Jenkins的这些英文解释，在翻译到SVN插件的Ignore externals时，找到了这种方案，就是SVN可以设置外部引用，这样在更新版本库的时候就可以把依赖的版本库也更新下来，然后Jenkins SVN插件把这个Ignore externals选项去掉，然后在Additional Credentials选项里填上所依赖版本库的SVN配置，就能够把这些依赖也更新到SVN工作空间内。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;以上两个问题解决后，基本没有遇到太难的问题。由此可见我们的源代码管理的科学、规范是多么的重要。</p>\n<p>几十次的构建失败，一堆乱七八糟的引用是多么痛的领悟!</p>\n<h3 id=\"五、通过Ftp发布至应用服务器\"><a href=\"#五、通过Ftp发布至应用服务器\" class=\"headerlink\" title=\"五、通过Ftp发布至应用服务器\"></a>五、通过Ftp发布至应用服务器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;构建成功后，Test.pubxml会指定发布的包的路径(最好是放到工作空间下)，按照思路，接下来就是要想办法把发布包Copy到应用服务器的根目录下。由于我们的应用服务器都是windows系统，因此不能像linux系统一样通过ssh远程Copy过去，当时能想到的就是使用Ftp直接上传到应用服务器。</p>\n<h4 id=\"1-安装插件与环境-1\"><a href=\"#1-安装插件与环境-1\" class=\"headerlink\" title=\"1.安装插件与环境\"></a>1.安装插件与环境</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Jenkins 安装插件Publish Over FTP,应用服务器上需开启Ftp。</p>\n<h4 id=\"2-全局配置-1\"><a href=\"#2-全局配置-1\" class=\"headerlink\" title=\"　2.全局配置\"></a>　2.全局配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;系统管理-&gt;系统配置下找到Publish over FTP配置项</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-5/40236536.jpg\" alt=\"image\"></p>\n<ul>\n<li>Name:起个名字，后面项目配置里会用的到</li>\n<li>HostName:Ftp主机名(端口号默认21，在高级里面可以改)</li>\n<li>Username:Ftp用户名</li>\n<li>Password:Ftp密码</li>\n</ul>\n<h4 id=\"3-项目配置-1\"><a href=\"#3-项目配置-1\" class=\"headerlink\" title=\"3.项目配置\"></a>3.项目配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;打开我们之前建的项目，找到构建后操作-&gt;增加构建后操作步骤-&gt;Send build artifacts over FTP</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-5/25517488.jpg\" alt=\"image\"></p>\n<ul>\n<li>Name:选择全局配置里的</li>\n<li>Source files:选择你的发布包路径(这里是相对于工作空间的路径)</li>\n<li>Remote directory：放到远程的哪个路径里(这里是相对于Ftp根目录的路径)</li>\n</ul>\n<p>配置完成后，点击保存，构建即可！</p>\n<h3 id=\"六、结束语\"><a href=\"#六、结束语\" class=\"headerlink\" title=\"六、结束语\"></a>六、结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如上，就基本实现了我们的自动化发布的需求，这期间从早晨六点开始，差不多中午就完成了，当然也并不像上面介绍的那么简单，期间也遇到了许多问题，构建了大概一百多次，才最终成功了第一次。本文主要介绍实现自动化部署的一种基本的思路，当然还有很多方案可以实现我们的需求，甚至不仅仅局限于Jenkins。而这种方案其中也有许多细节的地方在文章中没有提到，如：如何实现自动化的Nunit单元测试，如何定时构建……，因为当时我在完成之后也给我的团队成员提供了一个非常详细的配置文档，并且培训了很多次，但事实证明，讲的越详细越会限制他们自己的主动思考与动手的能力。这也导致了后来我去做其他工作的时候，我们将近一年的时间还是停留在我这半天的研究结果的层面上，而生产环境更是迟迟没有使用。其实思路才是最重要的，有了思路我们就可以通过各种方式来解决我们的问题，还是建议大家注重解决问题的思路，多动手，自己实践，才能学得更透!关于.NET 平台下Jenkins实现持续集成与自动化部署的落地与实现的问题与讨论，可以在文章下留言。</p>"},{"title":".NET实现持续集成与自动化部署3-测试环境到生产环境策略","copyright":true,"date":"2018-11-13T03:13:23.000Z","keywords":"持续集成,Jenkins,自动化发布,自动化部署,.NET","aside":"jenkins","_content":"\n### 一、前言\n&nbsp;&nbsp;&nbsp;&nbsp;前面我们已经初步实现了开发集成环境、测试环境的持续集成(自动化构建、自动化测试、自动化部署)。但生产环境自动化部署迟迟没有推进。其原因主要在以下几个方面:\n* 尚未实现部署之前的自动化备份\n* 尚未实现部署出现问题后的自动化回滚\n* 由于之前采用FTP上传部署需要生产环境开放FTP端口存在安全性问题且FTP会因为各种的网速问题，导致站点瞬间挂掉\n\n只要解决以上三个问题，我们就可以初步实现生产环境的自动化部署。\n\n<!--more-->\n\n### 二、实现思路\n1. 利用Jenkins分布式的特性，其中Jenkins服务器作为Master服务器，将生产环境(可以一台也可以多台服务器)作为Jenkins集群中的一台Slave服务器。\n2. 测试环境应该模拟和生产环境的配置和编译版本保持是Release状态，且功能已经满足预期发布需求。\n3. 通过文件复制插件，复制测试环境上的部署文件到生产环境上的jenkins工作空间。\n4. 通过批处理处理不需要覆盖的文件或者临时要修改的配置等。\n5. 利用rar备份生成环境上即将要覆盖的文件，注意命名上遵循一定规律：项目-文件夹-{BuildID}.bak.rar或日期-项目-文件夹-{BuildID}.bak.rar。\n6. 利用批处理进行从jenkins工作空间上把文件复制到站点上，常用命令：xcopy。\n7. 若生产环境程序出现问题，由项目经理和运维人员决定是紧急修复bug还是启用回滚，回滚则采用批处理命令将备份的文件压缩回生产环境站点下的目录内。\n\n通过以上策略可以实现测试环境到生产环境的一键部署，实现了部署前的自动化备份，出现问题的自动化回滚，利用Jenkins Master-Slave特性解决了需要开放FTP端口的的问题，并且将先在测试站点测试好的文件，复制到正式站点上的一个缓冲区，进行预热配置，之后在本机进行文件替换，速度是相当的快，解决了FTP上传过程中网络问题导致站点挂掉的问题。\n\n缺陷与问题:\n1. 生产环境需作为Jenkins 集群中的一台服务器并承担一部分构建任务，但通过配置此问题可忽略不计\n2. 生产环境需安装JDK并开启一个Java服务\n3. 待发现\n\n### 三、生产环境拓扑图\n![image](http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-uJiAAWNJAAGzH04VEaI361.png)\n\n### 四、所需Jenkins插件\n1. Copy data to workspace plugin 插件\n2. Copy Artifact Plugin\n3. Node and Label parameter plugin 插件\n\n### 五、实现步骤\n\n1. 搭建slave\n\n1.1 Jenkins系统管理-->管理节点-->新建节点\n!![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-oHuAV0cyAAGa8kLPPek104.png)\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-oPSAWrxrAAA084f8-fE141.png)\n\n1.2 输入节点名称，next，配置如下图\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-o8iAUs6GAAFSPdUxR4A459.png)\n\n其中，有如下几点需要注意：\n\n* 【# of executors】根据CPU的个数来填写数量\n\n* 【远程工作目录】这个就是用来存放master到slave时，存放的临时目录，如slave的服务软件也会放在此，并且会以每个job名称来区分开\n\n* 【用法】只需要选择【只允许运行绑定到这台机器的Job】这种模式下，Jenkins只会构建哪些分配到这台机器的Job。这允许一个节点专门保留给某种类型的Job。例如，在Jenkins上连续的执行测试，你可以设置执行者数量为1，那么同一时间就只会有一个构建，一个实行者不会阻止其它构建，其它构建会在另外的节点运行。通过这个配置生产环境就可以仅做自己的构建。\n\n* 【启动方式】只需要选择【Launch agent via Java Web Start】，以服务的方式启动，应用最广且最好配置，其余的都太复杂，不建议使用。注意：2.x版本的默认没有这个选项，需要单独开启。其余的基本按照上面默认选择即可。\n\nLaunch agent via Java Web Start开启方式:\n\nJenkins-->系统管理-->Configure Global Security-->Agents-->修改为随机选取\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-ol2AGhRPAAIRpLCLKyU487.png)\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-otCAPdcXAAK5mBHFsQ4907.png)\n\n\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-pOiAODw6AADdSdWn-5Y467.png)\n\n1.3 点击保存后，master上已经配置好节点，那么接下来就是到节点的服务器上安装slave的服务：\n点击右侧列表的节点服务器，此时节点并未连通。\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-pOiAODw6AADdSdWn-5Y467.png)\n进入详情页面，会提示你如何安装服务：\n![image](http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-pqyAYBBMAAD-3AmzeqA038.png)\n\n**注意:由于Slave服务为Java服务，因此Slave服务器上需安装JDK**\n\n当Slave服务器上出现以下服务时代表安装并连接成功\n![image](http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-qQ2AIlCVAABvoYcszKc472.png)\n此时回到Jenkins 服务器上查看状态已经连接上\n![image](http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-qYGAMXQUAABmxXOUQsw465.png)\n\n说明:这里只介绍基于现有需求的一种策略，关于Jenkins Master-Slave连接机制与原理不多做介绍，网上关于这方面的介绍也很多，大家可以自行搜索。\n\n2. 创建生产环境自动化部署任务\n    2.1 参数化配置选择Slave构建\n    Jenkins 新建自由风格的软件项目\n    ![image](http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-q_mAW2c7AAG4v5WRAgo962.png)\n    参数化构建-->添加参数-->选择node\n    ![image](http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-q_yAD07rAADt18hYFRc490.png)\n    若没有此参数安装Node and Label parameter plugin 插件\n    参数化配置可按下图进行，也可根据需要自行配置\n    ![image](http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-rACAWacKAADN3fY9JCs868.png)\n\n2.2 文本复制\n文本复制可选择两个插件\n\nCopy data to workspace plugin 插件 <br>\n可以复制Jenkins Master服务器的文件到Slave工作空间内\n缺点:不支持参数化\nCopy Artifact Plugin 插件 <br>\n可以实现Jenkins Slave-Slave Master-Slave之间的复制，可以将一个Job构建后的生成物复制到当前工作空间内\n缺点:需再要复制的Job内内配置Archive the artifact\n\n可以根据所需自行选择插件，这里为了能够参数化我们选择Copy Artifact Plugin插件\n![image](http://img.heshang365.com/group1/M00/05/F1/wKgR6Vr-rquAaNfPAACQylX60q0644.png)\n配置说明：\n* Project name:要Copy的项目名称，这里可以使用参数化\n* Which build:选择那一次构建后的产物，一般可以选择Latest successful build\n* Stable build only:是否选择稳定的构建\n* Artifacts to copy:要Copy的文件，可以进行规则匹配，如Test/**/*,即Test文件夹下所有文件\n* Artifacts not to copy：根据规则排除某些文件\n* Target directory：本地工作空间的那个文件夹内\n* Parameter filters：这里没用到，用到的话，可以自己看说明\n\n注意:这里需要前置Job配置<br>\n在要复制的Job内增加构建后操作如下图:\n![image](http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-tu2AOR3ZAABUEIVOPVg241.png)\n\n2.3 自动化备份\n填写备份的批处理，这里可以使用WindowsRAR的压缩命令，所以如果要用RAR的时候，确保机器上已经安装WindowsRAR。注意名称必须要有规则且每次构建不能重复，因此可以使用项目名称+BuildID或者日期+项目名称+BuildID\n![image](http://img.heshang365.com/group1/M00/05/F1/wKgR6Vr-sHOAaY2wAABFNf6cB0U792.png)\n```\n//自动备份批处理命令\nstart c:\\\"Program Files\"\\winrar\\rar.exe a -k -r -s -m1\n-ag{HS.Shop.My-%BUILD_ID%.bak}  {要备份到的文件夹} {要备份的文件夹}\n```\n\n2.4 覆盖站点目录下的文件\n备份完成后将Jenkins工作空间下的文件复制到站点目录下，此时必须保证发布包已经排除掉了不需要覆盖的文件，并且是稳定可用的版本。批处理命令可采用xcopy命令。关于xcopy命令的使用可以自行百度\n![image](http://img.heshang365.com/group1/M00/05/F2/wKgR6Vr-sYSAfE-kAABAnVmx6ng732.png)\n```\nxcopy  {slave工作空间上的项目文件夹} {要复制到替换的文件夹}  /Y/E\n```\n到了这一步就完成了生产环境的自动化部署的任务配置。点击构建即可完成测试环境到生产环境的一键部署。此时若程序出现问题可以采用紧急修复或者自动化回滚。\n\n3. 创建生产环境自动化回滚任务\n\n3.1 同样新建一个自由风格的软件项目\n这里可以配置两个构建参数<br>\n1.回滚哪一个项目的哪一次构建<br>\n2.回滚哪一台服务器的构建(可以多台)<br>\n参数化配置可见下图\n![image](http://img.heshang365.com/group1/M00/05/F2/wKgR6Vr-s1-ACsgMAAEgMDxv_aI903.png)\n\n3.2 自动化回滚批处理\n![image](http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-s-KALO4lAAC2T8Sgrxk323.png)\n```\nSetlocal enabledelayedexpansion\nset \"projectKey=ChioceBuild\"\nset \"bakUrl=D:\\HS.Shop.Bak\\HS.Shop.My\\\"  //备份文件的路径\nset url=\"%ChioceBuild%\"                  //参数\nset \"rollbackUrl=D:\\\"\nset \"projectName=\"\nset \"buildID=\"\nset url=%url::=/%\nset url=%url:///=/%\nset url=%url://=/%\n\nfor /f \"tokens=1,2,3,4,5,6,7,8* delims=/\" %%a in (%url%) do (\n set \"projectName=%%g\"\n set \"buildID=%%h\"\n)\nset projectName=!projectName:%projectKey%=!\nset \"fileName=\"\n\nfor %%a in (%bakUrl%%projectName%-%buildID%.bak.rar) do (\n set \"fileName=%%a\"\n)\nc:\\\"Program Files\"\\winrar\\rar.exe x -ep2 -o+- %fileName% %rollbackUrl%\n\n```\n点击保存即可完成自动化回滚任务的建立，点击构建选择参数即可进行回滚。\n\n### 六、结束语\n&nbsp;&nbsp;&nbsp;&nbsp;Jenkins是一个持续集成工具，其功能非常强大，可以帮助我们做自动构建、自动测试、自动发布等等，它根据不同的需求实现各种各样的功能，它可以最大幅度的减少我们日常工作中重复性的工作。以上仅仅是我根据当下所需研究的一种使用策略，可能有漏洞，也可能存在问题，但如果不愿意尝试着去改进现有流程，去接受新的东西，那么我们永远不会进步。而我对其使用的了解也不过是九牛一毛，大家可以根据需求研究制定自己的使用策略。<br>\n&nbsp;&nbsp;&nbsp;&nbsp;最后希望大家:即使搬砖，也要搬出艺术感!做一个有追求的搬砖者!\n</font>","source":"_posts/jenkins/NET实现持续集成与自动化部署3-测试环境到生产环境策略.md","raw":"---\ntitle: .NET实现持续集成与自动化部署3-测试环境到生产环境策略\ncopyright: true\ndate: 2018-11-13 11:13:23\ntags: \n- 持续集成 \n- Jenkins \n- 自动化发布 \ncategories: 持续集成&Jenkins&自动化发布\nkeywords: 持续集成,Jenkins,自动化发布,自动化部署,.NET\naside: jenkins\n---\n\n### 一、前言\n&nbsp;&nbsp;&nbsp;&nbsp;前面我们已经初步实现了开发集成环境、测试环境的持续集成(自动化构建、自动化测试、自动化部署)。但生产环境自动化部署迟迟没有推进。其原因主要在以下几个方面:\n* 尚未实现部署之前的自动化备份\n* 尚未实现部署出现问题后的自动化回滚\n* 由于之前采用FTP上传部署需要生产环境开放FTP端口存在安全性问题且FTP会因为各种的网速问题，导致站点瞬间挂掉\n\n只要解决以上三个问题，我们就可以初步实现生产环境的自动化部署。\n\n<!--more-->\n\n### 二、实现思路\n1. 利用Jenkins分布式的特性，其中Jenkins服务器作为Master服务器，将生产环境(可以一台也可以多台服务器)作为Jenkins集群中的一台Slave服务器。\n2. 测试环境应该模拟和生产环境的配置和编译版本保持是Release状态，且功能已经满足预期发布需求。\n3. 通过文件复制插件，复制测试环境上的部署文件到生产环境上的jenkins工作空间。\n4. 通过批处理处理不需要覆盖的文件或者临时要修改的配置等。\n5. 利用rar备份生成环境上即将要覆盖的文件，注意命名上遵循一定规律：项目-文件夹-{BuildID}.bak.rar或日期-项目-文件夹-{BuildID}.bak.rar。\n6. 利用批处理进行从jenkins工作空间上把文件复制到站点上，常用命令：xcopy。\n7. 若生产环境程序出现问题，由项目经理和运维人员决定是紧急修复bug还是启用回滚，回滚则采用批处理命令将备份的文件压缩回生产环境站点下的目录内。\n\n通过以上策略可以实现测试环境到生产环境的一键部署，实现了部署前的自动化备份，出现问题的自动化回滚，利用Jenkins Master-Slave特性解决了需要开放FTP端口的的问题，并且将先在测试站点测试好的文件，复制到正式站点上的一个缓冲区，进行预热配置，之后在本机进行文件替换，速度是相当的快，解决了FTP上传过程中网络问题导致站点挂掉的问题。\n\n缺陷与问题:\n1. 生产环境需作为Jenkins 集群中的一台服务器并承担一部分构建任务，但通过配置此问题可忽略不计\n2. 生产环境需安装JDK并开启一个Java服务\n3. 待发现\n\n### 三、生产环境拓扑图\n![image](http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-uJiAAWNJAAGzH04VEaI361.png)\n\n### 四、所需Jenkins插件\n1. Copy data to workspace plugin 插件\n2. Copy Artifact Plugin\n3. Node and Label parameter plugin 插件\n\n### 五、实现步骤\n\n1. 搭建slave\n\n1.1 Jenkins系统管理-->管理节点-->新建节点\n!![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-oHuAV0cyAAGa8kLPPek104.png)\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-oPSAWrxrAAA084f8-fE141.png)\n\n1.2 输入节点名称，next，配置如下图\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-o8iAUs6GAAFSPdUxR4A459.png)\n\n其中，有如下几点需要注意：\n\n* 【# of executors】根据CPU的个数来填写数量\n\n* 【远程工作目录】这个就是用来存放master到slave时，存放的临时目录，如slave的服务软件也会放在此，并且会以每个job名称来区分开\n\n* 【用法】只需要选择【只允许运行绑定到这台机器的Job】这种模式下，Jenkins只会构建哪些分配到这台机器的Job。这允许一个节点专门保留给某种类型的Job。例如，在Jenkins上连续的执行测试，你可以设置执行者数量为1，那么同一时间就只会有一个构建，一个实行者不会阻止其它构建，其它构建会在另外的节点运行。通过这个配置生产环境就可以仅做自己的构建。\n\n* 【启动方式】只需要选择【Launch agent via Java Web Start】，以服务的方式启动，应用最广且最好配置，其余的都太复杂，不建议使用。注意：2.x版本的默认没有这个选项，需要单独开启。其余的基本按照上面默认选择即可。\n\nLaunch agent via Java Web Start开启方式:\n\nJenkins-->系统管理-->Configure Global Security-->Agents-->修改为随机选取\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-ol2AGhRPAAIRpLCLKyU487.png)\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-otCAPdcXAAK5mBHFsQ4907.png)\n\n\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-pOiAODw6AADdSdWn-5Y467.png)\n\n1.3 点击保存后，master上已经配置好节点，那么接下来就是到节点的服务器上安装slave的服务：\n点击右侧列表的节点服务器，此时节点并未连通。\n![image](http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-pOiAODw6AADdSdWn-5Y467.png)\n进入详情页面，会提示你如何安装服务：\n![image](http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-pqyAYBBMAAD-3AmzeqA038.png)\n\n**注意:由于Slave服务为Java服务，因此Slave服务器上需安装JDK**\n\n当Slave服务器上出现以下服务时代表安装并连接成功\n![image](http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-qQ2AIlCVAABvoYcszKc472.png)\n此时回到Jenkins 服务器上查看状态已经连接上\n![image](http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-qYGAMXQUAABmxXOUQsw465.png)\n\n说明:这里只介绍基于现有需求的一种策略，关于Jenkins Master-Slave连接机制与原理不多做介绍，网上关于这方面的介绍也很多，大家可以自行搜索。\n\n2. 创建生产环境自动化部署任务\n    2.1 参数化配置选择Slave构建\n    Jenkins 新建自由风格的软件项目\n    ![image](http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-q_mAW2c7AAG4v5WRAgo962.png)\n    参数化构建-->添加参数-->选择node\n    ![image](http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-q_yAD07rAADt18hYFRc490.png)\n    若没有此参数安装Node and Label parameter plugin 插件\n    参数化配置可按下图进行，也可根据需要自行配置\n    ![image](http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-rACAWacKAADN3fY9JCs868.png)\n\n2.2 文本复制\n文本复制可选择两个插件\n\nCopy data to workspace plugin 插件 <br>\n可以复制Jenkins Master服务器的文件到Slave工作空间内\n缺点:不支持参数化\nCopy Artifact Plugin 插件 <br>\n可以实现Jenkins Slave-Slave Master-Slave之间的复制，可以将一个Job构建后的生成物复制到当前工作空间内\n缺点:需再要复制的Job内内配置Archive the artifact\n\n可以根据所需自行选择插件，这里为了能够参数化我们选择Copy Artifact Plugin插件\n![image](http://img.heshang365.com/group1/M00/05/F1/wKgR6Vr-rquAaNfPAACQylX60q0644.png)\n配置说明：\n* Project name:要Copy的项目名称，这里可以使用参数化\n* Which build:选择那一次构建后的产物，一般可以选择Latest successful build\n* Stable build only:是否选择稳定的构建\n* Artifacts to copy:要Copy的文件，可以进行规则匹配，如Test/**/*,即Test文件夹下所有文件\n* Artifacts not to copy：根据规则排除某些文件\n* Target directory：本地工作空间的那个文件夹内\n* Parameter filters：这里没用到，用到的话，可以自己看说明\n\n注意:这里需要前置Job配置<br>\n在要复制的Job内增加构建后操作如下图:\n![image](http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-tu2AOR3ZAABUEIVOPVg241.png)\n\n2.3 自动化备份\n填写备份的批处理，这里可以使用WindowsRAR的压缩命令，所以如果要用RAR的时候，确保机器上已经安装WindowsRAR。注意名称必须要有规则且每次构建不能重复，因此可以使用项目名称+BuildID或者日期+项目名称+BuildID\n![image](http://img.heshang365.com/group1/M00/05/F1/wKgR6Vr-sHOAaY2wAABFNf6cB0U792.png)\n```\n//自动备份批处理命令\nstart c:\\\"Program Files\"\\winrar\\rar.exe a -k -r -s -m1\n-ag{HS.Shop.My-%BUILD_ID%.bak}  {要备份到的文件夹} {要备份的文件夹}\n```\n\n2.4 覆盖站点目录下的文件\n备份完成后将Jenkins工作空间下的文件复制到站点目录下，此时必须保证发布包已经排除掉了不需要覆盖的文件，并且是稳定可用的版本。批处理命令可采用xcopy命令。关于xcopy命令的使用可以自行百度\n![image](http://img.heshang365.com/group1/M00/05/F2/wKgR6Vr-sYSAfE-kAABAnVmx6ng732.png)\n```\nxcopy  {slave工作空间上的项目文件夹} {要复制到替换的文件夹}  /Y/E\n```\n到了这一步就完成了生产环境的自动化部署的任务配置。点击构建即可完成测试环境到生产环境的一键部署。此时若程序出现问题可以采用紧急修复或者自动化回滚。\n\n3. 创建生产环境自动化回滚任务\n\n3.1 同样新建一个自由风格的软件项目\n这里可以配置两个构建参数<br>\n1.回滚哪一个项目的哪一次构建<br>\n2.回滚哪一台服务器的构建(可以多台)<br>\n参数化配置可见下图\n![image](http://img.heshang365.com/group1/M00/05/F2/wKgR6Vr-s1-ACsgMAAEgMDxv_aI903.png)\n\n3.2 自动化回滚批处理\n![image](http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-s-KALO4lAAC2T8Sgrxk323.png)\n```\nSetlocal enabledelayedexpansion\nset \"projectKey=ChioceBuild\"\nset \"bakUrl=D:\\HS.Shop.Bak\\HS.Shop.My\\\"  //备份文件的路径\nset url=\"%ChioceBuild%\"                  //参数\nset \"rollbackUrl=D:\\\"\nset \"projectName=\"\nset \"buildID=\"\nset url=%url::=/%\nset url=%url:///=/%\nset url=%url://=/%\n\nfor /f \"tokens=1,2,3,4,5,6,7,8* delims=/\" %%a in (%url%) do (\n set \"projectName=%%g\"\n set \"buildID=%%h\"\n)\nset projectName=!projectName:%projectKey%=!\nset \"fileName=\"\n\nfor %%a in (%bakUrl%%projectName%-%buildID%.bak.rar) do (\n set \"fileName=%%a\"\n)\nc:\\\"Program Files\"\\winrar\\rar.exe x -ep2 -o+- %fileName% %rollbackUrl%\n\n```\n点击保存即可完成自动化回滚任务的建立，点击构建选择参数即可进行回滚。\n\n### 六、结束语\n&nbsp;&nbsp;&nbsp;&nbsp;Jenkins是一个持续集成工具，其功能非常强大，可以帮助我们做自动构建、自动测试、自动发布等等，它根据不同的需求实现各种各样的功能，它可以最大幅度的减少我们日常工作中重复性的工作。以上仅仅是我根据当下所需研究的一种使用策略，可能有漏洞，也可能存在问题，但如果不愿意尝试着去改进现有流程，去接受新的东西，那么我们永远不会进步。而我对其使用的了解也不过是九牛一毛，大家可以根据需求研究制定自己的使用策略。<br>\n&nbsp;&nbsp;&nbsp;&nbsp;最后希望大家:即使搬砖，也要搬出艺术感!做一个有追求的搬砖者!\n</font>","slug":"jenkins/NET实现持续集成与自动化部署3-测试环境到生产环境策略","published":1,"updated":"2021-03-14T03:04:50.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpr5000hhyjf0sufl94y","content":"<h3 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;前面我们已经初步实现了开发集成环境、测试环境的持续集成(自动化构建、自动化测试、自动化部署)。但生产环境自动化部署迟迟没有推进。其原因主要在以下几个方面:</p>\n<ul>\n<li>尚未实现部署之前的自动化备份</li>\n<li>尚未实现部署出现问题后的自动化回滚</li>\n<li>由于之前采用FTP上传部署需要生产环境开放FTP端口存在安全性问题且FTP会因为各种的网速问题，导致站点瞬间挂掉</li>\n</ul>\n<p>只要解决以上三个问题，我们就可以初步实现生产环境的自动化部署。</p>\n<a id=\"more\"></a>\n<h3 id=\"二、实现思路\"><a href=\"#二、实现思路\" class=\"headerlink\" title=\"二、实现思路\"></a>二、实现思路</h3><ol>\n<li>利用Jenkins分布式的特性，其中Jenkins服务器作为Master服务器，将生产环境(可以一台也可以多台服务器)作为Jenkins集群中的一台Slave服务器。</li>\n<li>测试环境应该模拟和生产环境的配置和编译版本保持是Release状态，且功能已经满足预期发布需求。</li>\n<li>通过文件复制插件，复制测试环境上的部署文件到生产环境上的jenkins工作空间。</li>\n<li>通过批处理处理不需要覆盖的文件或者临时要修改的配置等。</li>\n<li>利用rar备份生成环境上即将要覆盖的文件，注意命名上遵循一定规律：项目-文件夹-{BuildID}.bak.rar或日期-项目-文件夹-{BuildID}.bak.rar。</li>\n<li>利用批处理进行从jenkins工作空间上把文件复制到站点上，常用命令：xcopy。</li>\n<li>若生产环境程序出现问题，由项目经理和运维人员决定是紧急修复bug还是启用回滚，回滚则采用批处理命令将备份的文件压缩回生产环境站点下的目录内。</li>\n</ol>\n<p>通过以上策略可以实现测试环境到生产环境的一键部署，实现了部署前的自动化备份，出现问题的自动化回滚，利用Jenkins Master-Slave特性解决了需要开放FTP端口的的问题，并且将先在测试站点测试好的文件，复制到正式站点上的一个缓冲区，进行预热配置，之后在本机进行文件替换，速度是相当的快，解决了FTP上传过程中网络问题导致站点挂掉的问题。</p>\n<p>缺陷与问题:</p>\n<ol>\n<li>生产环境需作为Jenkins 集群中的一台服务器并承担一部分构建任务，但通过配置此问题可忽略不计</li>\n<li>生产环境需安装JDK并开启一个Java服务</li>\n<li>待发现</li>\n</ol>\n<h3 id=\"三、生产环境拓扑图\"><a href=\"#三、生产环境拓扑图\" class=\"headerlink\" title=\"三、生产环境拓扑图\"></a>三、生产环境拓扑图</h3><p><img src=\"http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-uJiAAWNJAAGzH04VEaI361.png\" alt=\"image\"></p>\n<h3 id=\"四、所需Jenkins插件\"><a href=\"#四、所需Jenkins插件\" class=\"headerlink\" title=\"四、所需Jenkins插件\"></a>四、所需Jenkins插件</h3><ol>\n<li>Copy data to workspace plugin 插件</li>\n<li>Copy Artifact Plugin</li>\n<li>Node and Label parameter plugin 插件</li>\n</ol>\n<h3 id=\"五、实现步骤\"><a href=\"#五、实现步骤\" class=\"headerlink\" title=\"五、实现步骤\"></a>五、实现步骤</h3><ol>\n<li>搭建slave</li>\n</ol>\n<p>1.1 Jenkins系统管理—&gt;管理节点—&gt;新建节点<br>!<img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-oHuAV0cyAAGa8kLPPek104.png\" alt=\"image\"><br><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-oPSAWrxrAAA084f8-fE141.png\" alt=\"image\"></p>\n<p>1.2 输入节点名称，next，配置如下图<br><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-o8iAUs6GAAFSPdUxR4A459.png\" alt=\"image\"></p>\n<p>其中，有如下几点需要注意：</p>\n<ul>\n<li><p>【# of executors】根据CPU的个数来填写数量</p>\n</li>\n<li><p>【远程工作目录】这个就是用来存放master到slave时，存放的临时目录，如slave的服务软件也会放在此，并且会以每个job名称来区分开</p>\n</li>\n<li><p>【用法】只需要选择【只允许运行绑定到这台机器的Job】这种模式下，Jenkins只会构建哪些分配到这台机器的Job。这允许一个节点专门保留给某种类型的Job。例如，在Jenkins上连续的执行测试，你可以设置执行者数量为1，那么同一时间就只会有一个构建，一个实行者不会阻止其它构建，其它构建会在另外的节点运行。通过这个配置生产环境就可以仅做自己的构建。</p>\n</li>\n<li><p>【启动方式】只需要选择【Launch agent via Java Web Start】，以服务的方式启动，应用最广且最好配置，其余的都太复杂，不建议使用。注意：2.x版本的默认没有这个选项，需要单独开启。其余的基本按照上面默认选择即可。</p>\n</li>\n</ul>\n<p>Launch agent via Java Web Start开启方式:</p>\n<p>Jenkins—&gt;系统管理—&gt;Configure Global Security—&gt;Agents—&gt;修改为随机选取<br><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-ol2AGhRPAAIRpLCLKyU487.png\" alt=\"image\"><br><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-otCAPdcXAAK5mBHFsQ4907.png\" alt=\"image\"></p>\n<p><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-pOiAODw6AADdSdWn-5Y467.png\" alt=\"image\"></p>\n<p>1.3 点击保存后，master上已经配置好节点，那么接下来就是到节点的服务器上安装slave的服务：<br>点击右侧列表的节点服务器，此时节点并未连通。<br><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-pOiAODw6AADdSdWn-5Y467.png\" alt=\"image\"><br>进入详情页面，会提示你如何安装服务：<br><img src=\"http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-pqyAYBBMAAD-3AmzeqA038.png\" alt=\"image\"></p>\n<p><strong>注意:由于Slave服务为Java服务，因此Slave服务器上需安装JDK</strong></p>\n<p>当Slave服务器上出现以下服务时代表安装并连接成功<br><img src=\"http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-qQ2AIlCVAABvoYcszKc472.png\" alt=\"image\"><br>此时回到Jenkins 服务器上查看状态已经连接上<br><img src=\"http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-qYGAMXQUAABmxXOUQsw465.png\" alt=\"image\"></p>\n<p>说明:这里只介绍基于现有需求的一种策略，关于Jenkins Master-Slave连接机制与原理不多做介绍，网上关于这方面的介绍也很多，大家可以自行搜索。</p>\n<ol>\n<li>创建生产环境自动化部署任务<br> 2.1 参数化配置选择Slave构建<br> Jenkins 新建自由风格的软件项目<br> <img src=\"http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-q_mAW2c7AAG4v5WRAgo962.png\" alt=\"image\"><br> 参数化构建—&gt;添加参数—&gt;选择node<br> <img src=\"http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-q_yAD07rAADt18hYFRc490.png\" alt=\"image\"><br> 若没有此参数安装Node and Label parameter plugin 插件<br> 参数化配置可按下图进行，也可根据需要自行配置<br> <img src=\"http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-rACAWacKAADN3fY9JCs868.png\" alt=\"image\"></li>\n</ol>\n<p>2.2 文本复制<br>文本复制可选择两个插件</p>\n<p>Copy data to workspace plugin 插件 <br><br>可以复制Jenkins Master服务器的文件到Slave工作空间内<br>缺点:不支持参数化<br>Copy Artifact Plugin 插件 <br><br>可以实现Jenkins Slave-Slave Master-Slave之间的复制，可以将一个Job构建后的生成物复制到当前工作空间内<br>缺点:需再要复制的Job内内配置Archive the artifact</p>\n<p>可以根据所需自行选择插件，这里为了能够参数化我们选择Copy Artifact Plugin插件<br><img src=\"http://img.heshang365.com/group1/M00/05/F1/wKgR6Vr-rquAaNfPAACQylX60q0644.png\" alt=\"image\"><br>配置说明：</p>\n<ul>\n<li>Project name:要Copy的项目名称，这里可以使用参数化</li>\n<li>Which build:选择那一次构建后的产物，一般可以选择Latest successful build</li>\n<li>Stable build only:是否选择稳定的构建</li>\n<li>Artifacts to copy:要Copy的文件，可以进行规则匹配，如Test/<em>*/</em>,即Test文件夹下所有文件</li>\n<li>Artifacts not to copy：根据规则排除某些文件</li>\n<li>Target directory：本地工作空间的那个文件夹内</li>\n<li>Parameter filters：这里没用到，用到的话，可以自己看说明</li>\n</ul>\n<p>注意:这里需要前置Job配置<br><br>在要复制的Job内增加构建后操作如下图:<br><img src=\"http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-tu2AOR3ZAABUEIVOPVg241.png\" alt=\"image\"></p>\n<p>2.3 自动化备份<br>填写备份的批处理，这里可以使用WindowsRAR的压缩命令，所以如果要用RAR的时候，确保机器上已经安装WindowsRAR。注意名称必须要有规则且每次构建不能重复，因此可以使用项目名称+BuildID或者日期+项目名称+BuildID<br><img src=\"http://img.heshang365.com/group1/M00/05/F1/wKgR6Vr-sHOAaY2wAABFNf6cB0U792.png\" alt=\"image\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//自动备份批处理命令</span><br><span class=\"line\">start c:\\&quot;Program Files&quot;\\winrar\\rar.exe a -k -r -s -m1</span><br><span class=\"line\">-ag&#123;HS.Shop.My-%BUILD_ID%.bak&#125;  &#123;要备份到的文件夹&#125; &#123;要备份的文件夹&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.4 覆盖站点目录下的文件<br>备份完成后将Jenkins工作空间下的文件复制到站点目录下，此时必须保证发布包已经排除掉了不需要覆盖的文件，并且是稳定可用的版本。批处理命令可采用xcopy命令。关于xcopy命令的使用可以自行百度<br><img src=\"http://img.heshang365.com/group1/M00/05/F2/wKgR6Vr-sYSAfE-kAABAnVmx6ng732.png\" alt=\"image\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcopy  &#123;slave工作空间上的项目文件夹&#125; &#123;要复制到替换的文件夹&#125;  /Y/E</span><br></pre></td></tr></table></figure></p>\n<p>到了这一步就完成了生产环境的自动化部署的任务配置。点击构建即可完成测试环境到生产环境的一键部署。此时若程序出现问题可以采用紧急修复或者自动化回滚。</p>\n<ol>\n<li>创建生产环境自动化回滚任务</li>\n</ol>\n<p>3.1 同样新建一个自由风格的软件项目<br>这里可以配置两个构建参数<br><br>1.回滚哪一个项目的哪一次构建<br><br>2.回滚哪一台服务器的构建(可以多台)<br><br>参数化配置可见下图<br><img src=\"http://img.heshang365.com/group1/M00/05/F2/wKgR6Vr-s1-ACsgMAAEgMDxv_aI903.png\" alt=\"image\"></p>\n<p>3.2 自动化回滚批处理<br><img src=\"http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-s-KALO4lAAC2T8Sgrxk323.png\" alt=\"image\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Setlocal enabledelayedexpansion</span><br><span class=\"line\">set &quot;projectKey=ChioceBuild&quot;</span><br><span class=\"line\">set &quot;bakUrl=D:\\HS.Shop.Bak\\HS.Shop.My\\&quot;  //备份文件的路径</span><br><span class=\"line\">set url=&quot;%ChioceBuild%&quot;                  //参数</span><br><span class=\"line\">set &quot;rollbackUrl=D:\\&quot;</span><br><span class=\"line\">set &quot;projectName=&quot;</span><br><span class=\"line\">set &quot;buildID=&quot;</span><br><span class=\"line\">set url=%url::=/%</span><br><span class=\"line\">set url=%url:///=/%</span><br><span class=\"line\">set url=%url://=/%</span><br><span class=\"line\"></span><br><span class=\"line\">for /f &quot;tokens=1,2,3,4,5,6,7,8* delims=/&quot; %%a in (%url%) do (</span><br><span class=\"line\"> set &quot;projectName=%%g&quot;</span><br><span class=\"line\"> set &quot;buildID=%%h&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\">set projectName=!projectName:%projectKey%=!</span><br><span class=\"line\">set &quot;fileName=&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for %%a in (%bakUrl%%projectName%-%buildID%.bak.rar) do (</span><br><span class=\"line\"> set &quot;fileName=%%a&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\">c:\\&quot;Program Files&quot;\\winrar\\rar.exe x -ep2 -o+- %fileName% %rollbackUrl%</span><br></pre></td></tr></table></figure></p>\n<p>点击保存即可完成自动化回滚任务的建立，点击构建选择参数即可进行回滚。</p>\n<h3 id=\"六、结束语\"><a href=\"#六、结束语\" class=\"headerlink\" title=\"六、结束语\"></a>六、结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Jenkins是一个持续集成工具，其功能非常强大，可以帮助我们做自动构建、自动测试、自动发布等等，它根据不同的需求实现各种各样的功能，它可以最大幅度的减少我们日常工作中重复性的工作。以上仅仅是我根据当下所需研究的一种使用策略，可能有漏洞，也可能存在问题，但如果不愿意尝试着去改进现有流程，去接受新的东西，那么我们永远不会进步。而我对其使用的了解也不过是九牛一毛，大家可以根据需求研究制定自己的使用策略。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;最后希望大家:即使搬砖，也要搬出艺术感!做一个有追求的搬砖者!<br>&lt;/font&gt;</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;前面我们已经初步实现了开发集成环境、测试环境的持续集成(自动化构建、自动化测试、自动化部署)。但生产环境自动化部署迟迟没有推进。其原因主要在以下几个方面:</p>\n<ul>\n<li>尚未实现部署之前的自动化备份</li>\n<li>尚未实现部署出现问题后的自动化回滚</li>\n<li>由于之前采用FTP上传部署需要生产环境开放FTP端口存在安全性问题且FTP会因为各种的网速问题，导致站点瞬间挂掉</li>\n</ul>\n<p>只要解决以上三个问题，我们就可以初步实现生产环境的自动化部署。</p>","more":"<h3 id=\"二、实现思路\"><a href=\"#二、实现思路\" class=\"headerlink\" title=\"二、实现思路\"></a>二、实现思路</h3><ol>\n<li>利用Jenkins分布式的特性，其中Jenkins服务器作为Master服务器，将生产环境(可以一台也可以多台服务器)作为Jenkins集群中的一台Slave服务器。</li>\n<li>测试环境应该模拟和生产环境的配置和编译版本保持是Release状态，且功能已经满足预期发布需求。</li>\n<li>通过文件复制插件，复制测试环境上的部署文件到生产环境上的jenkins工作空间。</li>\n<li>通过批处理处理不需要覆盖的文件或者临时要修改的配置等。</li>\n<li>利用rar备份生成环境上即将要覆盖的文件，注意命名上遵循一定规律：项目-文件夹-{BuildID}.bak.rar或日期-项目-文件夹-{BuildID}.bak.rar。</li>\n<li>利用批处理进行从jenkins工作空间上把文件复制到站点上，常用命令：xcopy。</li>\n<li>若生产环境程序出现问题，由项目经理和运维人员决定是紧急修复bug还是启用回滚，回滚则采用批处理命令将备份的文件压缩回生产环境站点下的目录内。</li>\n</ol>\n<p>通过以上策略可以实现测试环境到生产环境的一键部署，实现了部署前的自动化备份，出现问题的自动化回滚，利用Jenkins Master-Slave特性解决了需要开放FTP端口的的问题，并且将先在测试站点测试好的文件，复制到正式站点上的一个缓冲区，进行预热配置，之后在本机进行文件替换，速度是相当的快，解决了FTP上传过程中网络问题导致站点挂掉的问题。</p>\n<p>缺陷与问题:</p>\n<ol>\n<li>生产环境需作为Jenkins 集群中的一台服务器并承担一部分构建任务，但通过配置此问题可忽略不计</li>\n<li>生产环境需安装JDK并开启一个Java服务</li>\n<li>待发现</li>\n</ol>\n<h3 id=\"三、生产环境拓扑图\"><a href=\"#三、生产环境拓扑图\" class=\"headerlink\" title=\"三、生产环境拓扑图\"></a>三、生产环境拓扑图</h3><p><img src=\"http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-uJiAAWNJAAGzH04VEaI361.png\" alt=\"image\"></p>\n<h3 id=\"四、所需Jenkins插件\"><a href=\"#四、所需Jenkins插件\" class=\"headerlink\" title=\"四、所需Jenkins插件\"></a>四、所需Jenkins插件</h3><ol>\n<li>Copy data to workspace plugin 插件</li>\n<li>Copy Artifact Plugin</li>\n<li>Node and Label parameter plugin 插件</li>\n</ol>\n<h3 id=\"五、实现步骤\"><a href=\"#五、实现步骤\" class=\"headerlink\" title=\"五、实现步骤\"></a>五、实现步骤</h3><ol>\n<li>搭建slave</li>\n</ol>\n<p>1.1 Jenkins系统管理—&gt;管理节点—&gt;新建节点<br>!<img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-oHuAV0cyAAGa8kLPPek104.png\" alt=\"image\"><br><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-oPSAWrxrAAA084f8-fE141.png\" alt=\"image\"></p>\n<p>1.2 输入节点名称，next，配置如下图<br><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-o8iAUs6GAAFSPdUxR4A459.png\" alt=\"image\"></p>\n<p>其中，有如下几点需要注意：</p>\n<ul>\n<li><p>【# of executors】根据CPU的个数来填写数量</p>\n</li>\n<li><p>【远程工作目录】这个就是用来存放master到slave时，存放的临时目录，如slave的服务软件也会放在此，并且会以每个job名称来区分开</p>\n</li>\n<li><p>【用法】只需要选择【只允许运行绑定到这台机器的Job】这种模式下，Jenkins只会构建哪些分配到这台机器的Job。这允许一个节点专门保留给某种类型的Job。例如，在Jenkins上连续的执行测试，你可以设置执行者数量为1，那么同一时间就只会有一个构建，一个实行者不会阻止其它构建，其它构建会在另外的节点运行。通过这个配置生产环境就可以仅做自己的构建。</p>\n</li>\n<li><p>【启动方式】只需要选择【Launch agent via Java Web Start】，以服务的方式启动，应用最广且最好配置，其余的都太复杂，不建议使用。注意：2.x版本的默认没有这个选项，需要单独开启。其余的基本按照上面默认选择即可。</p>\n</li>\n</ul>\n<p>Launch agent via Java Web Start开启方式:</p>\n<p>Jenkins—&gt;系统管理—&gt;Configure Global Security—&gt;Agents—&gt;修改为随机选取<br><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-ol2AGhRPAAIRpLCLKyU487.png\" alt=\"image\"><br><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-otCAPdcXAAK5mBHFsQ4907.png\" alt=\"image\"></p>\n<p><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-pOiAODw6AADdSdWn-5Y467.png\" alt=\"image\"></p>\n<p>1.3 点击保存后，master上已经配置好节点，那么接下来就是到节点的服务器上安装slave的服务：<br>点击右侧列表的节点服务器，此时节点并未连通。<br><img src=\"http://img.heshang365.com/group1/M00/05/EE/wKgR6Vr-pOiAODw6AADdSdWn-5Y467.png\" alt=\"image\"><br>进入详情页面，会提示你如何安装服务：<br><img src=\"http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-pqyAYBBMAAD-3AmzeqA038.png\" alt=\"image\"></p>\n<p><strong>注意:由于Slave服务为Java服务，因此Slave服务器上需安装JDK</strong></p>\n<p>当Slave服务器上出现以下服务时代表安装并连接成功<br><img src=\"http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-qQ2AIlCVAABvoYcszKc472.png\" alt=\"image\"><br>此时回到Jenkins 服务器上查看状态已经连接上<br><img src=\"http://img.heshang365.com/group1/M00/05/EF/wKgR6Vr-qYGAMXQUAABmxXOUQsw465.png\" alt=\"image\"></p>\n<p>说明:这里只介绍基于现有需求的一种策略，关于Jenkins Master-Slave连接机制与原理不多做介绍，网上关于这方面的介绍也很多，大家可以自行搜索。</p>\n<ol>\n<li>创建生产环境自动化部署任务<br> 2.1 参数化配置选择Slave构建<br> Jenkins 新建自由风格的软件项目<br> <img src=\"http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-q_mAW2c7AAG4v5WRAgo962.png\" alt=\"image\"><br> 参数化构建—&gt;添加参数—&gt;选择node<br> <img src=\"http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-q_yAD07rAADt18hYFRc490.png\" alt=\"image\"><br> 若没有此参数安装Node and Label parameter plugin 插件<br> 参数化配置可按下图进行，也可根据需要自行配置<br> <img src=\"http://img.heshang365.com/group1/M00/05/F0/wKgR6Vr-rACAWacKAADN3fY9JCs868.png\" alt=\"image\"></li>\n</ol>\n<p>2.2 文本复制<br>文本复制可选择两个插件</p>\n<p>Copy data to workspace plugin 插件 <br><br>可以复制Jenkins Master服务器的文件到Slave工作空间内<br>缺点:不支持参数化<br>Copy Artifact Plugin 插件 <br><br>可以实现Jenkins Slave-Slave Master-Slave之间的复制，可以将一个Job构建后的生成物复制到当前工作空间内<br>缺点:需再要复制的Job内内配置Archive the artifact</p>\n<p>可以根据所需自行选择插件，这里为了能够参数化我们选择Copy Artifact Plugin插件<br><img src=\"http://img.heshang365.com/group1/M00/05/F1/wKgR6Vr-rquAaNfPAACQylX60q0644.png\" alt=\"image\"><br>配置说明：</p>\n<ul>\n<li>Project name:要Copy的项目名称，这里可以使用参数化</li>\n<li>Which build:选择那一次构建后的产物，一般可以选择Latest successful build</li>\n<li>Stable build only:是否选择稳定的构建</li>\n<li>Artifacts to copy:要Copy的文件，可以进行规则匹配，如Test/<em>*/</em>,即Test文件夹下所有文件</li>\n<li>Artifacts not to copy：根据规则排除某些文件</li>\n<li>Target directory：本地工作空间的那个文件夹内</li>\n<li>Parameter filters：这里没用到，用到的话，可以自己看说明</li>\n</ul>\n<p>注意:这里需要前置Job配置<br><br>在要复制的Job内增加构建后操作如下图:<br><img src=\"http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-tu2AOR3ZAABUEIVOPVg241.png\" alt=\"image\"></p>\n<p>2.3 自动化备份<br>填写备份的批处理，这里可以使用WindowsRAR的压缩命令，所以如果要用RAR的时候，确保机器上已经安装WindowsRAR。注意名称必须要有规则且每次构建不能重复，因此可以使用项目名称+BuildID或者日期+项目名称+BuildID<br><img src=\"http://img.heshang365.com/group1/M00/05/F1/wKgR6Vr-sHOAaY2wAABFNf6cB0U792.png\" alt=\"image\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//自动备份批处理命令</span><br><span class=\"line\">start c:\\&quot;Program Files&quot;\\winrar\\rar.exe a -k -r -s -m1</span><br><span class=\"line\">-ag&#123;HS.Shop.My-%BUILD_ID%.bak&#125;  &#123;要备份到的文件夹&#125; &#123;要备份的文件夹&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.4 覆盖站点目录下的文件<br>备份完成后将Jenkins工作空间下的文件复制到站点目录下，此时必须保证发布包已经排除掉了不需要覆盖的文件，并且是稳定可用的版本。批处理命令可采用xcopy命令。关于xcopy命令的使用可以自行百度<br><img src=\"http://img.heshang365.com/group1/M00/05/F2/wKgR6Vr-sYSAfE-kAABAnVmx6ng732.png\" alt=\"image\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcopy  &#123;slave工作空间上的项目文件夹&#125; &#123;要复制到替换的文件夹&#125;  /Y/E</span><br></pre></td></tr></table></figure></p>\n<p>到了这一步就完成了生产环境的自动化部署的任务配置。点击构建即可完成测试环境到生产环境的一键部署。此时若程序出现问题可以采用紧急修复或者自动化回滚。</p>\n<ol>\n<li>创建生产环境自动化回滚任务</li>\n</ol>\n<p>3.1 同样新建一个自由风格的软件项目<br>这里可以配置两个构建参数<br><br>1.回滚哪一个项目的哪一次构建<br><br>2.回滚哪一台服务器的构建(可以多台)<br><br>参数化配置可见下图<br><img src=\"http://img.heshang365.com/group1/M00/05/F2/wKgR6Vr-s1-ACsgMAAEgMDxv_aI903.png\" alt=\"image\"></p>\n<p>3.2 自动化回滚批处理<br><img src=\"http://img.heshang365.com/group1/M00/05/F3/wKgR6Vr-s-KALO4lAAC2T8Sgrxk323.png\" alt=\"image\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Setlocal enabledelayedexpansion</span><br><span class=\"line\">set &quot;projectKey=ChioceBuild&quot;</span><br><span class=\"line\">set &quot;bakUrl=D:\\HS.Shop.Bak\\HS.Shop.My\\&quot;  //备份文件的路径</span><br><span class=\"line\">set url=&quot;%ChioceBuild%&quot;                  //参数</span><br><span class=\"line\">set &quot;rollbackUrl=D:\\&quot;</span><br><span class=\"line\">set &quot;projectName=&quot;</span><br><span class=\"line\">set &quot;buildID=&quot;</span><br><span class=\"line\">set url=%url::=/%</span><br><span class=\"line\">set url=%url:///=/%</span><br><span class=\"line\">set url=%url://=/%</span><br><span class=\"line\"></span><br><span class=\"line\">for /f &quot;tokens=1,2,3,4,5,6,7,8* delims=/&quot; %%a in (%url%) do (</span><br><span class=\"line\"> set &quot;projectName=%%g&quot;</span><br><span class=\"line\"> set &quot;buildID=%%h&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\">set projectName=!projectName:%projectKey%=!</span><br><span class=\"line\">set &quot;fileName=&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for %%a in (%bakUrl%%projectName%-%buildID%.bak.rar) do (</span><br><span class=\"line\"> set &quot;fileName=%%a&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\">c:\\&quot;Program Files&quot;\\winrar\\rar.exe x -ep2 -o+- %fileName% %rollbackUrl%</span><br></pre></td></tr></table></figure></p>\n<p>点击保存即可完成自动化回滚任务的建立，点击构建选择参数即可进行回滚。</p>\n<h3 id=\"六、结束语\"><a href=\"#六、结束语\" class=\"headerlink\" title=\"六、结束语\"></a>六、结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Jenkins是一个持续集成工具，其功能非常强大，可以帮助我们做自动构建、自动测试、自动发布等等，它根据不同的需求实现各种各样的功能，它可以最大幅度的减少我们日常工作中重复性的工作。以上仅仅是我根据当下所需研究的一种使用策略，可能有漏洞，也可能存在问题，但如果不愿意尝试着去改进现有流程，去接受新的东西，那么我们永远不会进步。而我对其使用的了解也不过是九牛一毛，大家可以根据需求研究制定自己的使用策略。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;最后希望大家:即使搬砖，也要搬出艺术感!做一个有追求的搬砖者!<br>&lt;/font&gt;</p>"},{"title":".NET下日志系统的搭建—log4net+kafka+elk","copyright":true,"date":"2018-11-13T02:37:30.000Z","aside":"log","_content":"\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们公司的程序日志之前都是采用log4net记录文件日志的方式(有关log4net的简单使用可以看我另一篇博客)，但是随着后来我们团队越来越大，项目也越来越大，我们的用户量也越来越多。慢慢系统就暴露了很多问题，这个时候我们的日志系统已经不能满足我们的要求。其主要有下面几个问题:\n\n* 随着我们访问量的增加，我们的日志文件急剧增加\n* 多且乱的文件日志，难以让我们对程序进行排错\n* 文件日志的记录耗用我们应用服务器的资源，导致我们的应用服务器的处理用户请求的能力下降\n* 我们的日志分布在多台应用服务器上，当程序遇到问题时，我们的程序员都需要找运维人员要日志，随着团队越来越大，问题越来越多，于是导致了程序员们排队找运维要日志，解决问题的速度急剧下降！\n\n<!--more-->\n\n起初，用户量不大的时候，上面的问题还能容忍。但任何一种小问题都会在用户量访问量变大的时候急剧的放大。终于在几波推广活动的时候，很悲剧的我们又不得不每天深夜加班来为我们之前对这些问题的不重视来买单。于是，在推广活动结束之后，在我们的程序员得到一丝喘息的机会时，我决定来搭建一个我们自己的日志系统，改善我们的日志记录方式。根据以上问题分析我们的日志系统需要有以下几点要求：\n\n* 日志的写入效率要高不能对应用服务器造成太大的影响\n* 要将日志集中在一台服务器上(或一组)\n* 提供一个方便检索分析的可视化页面(这个最重要，再也受不了每天找运维要日志，拿到一堆文件来分析的日子了！)\n\n一开始想要借助log4net AdoAppender把我们的日志写到数据库里，然后我们开发一个相应的功能，来对我们的日志来进行查询和分析。但考虑到写入关系数据库的性能问题，就放弃了，但有一个替代方案，就是写入到Mongo中，这样就解决了提高了一定的性能。但也需要我们开发一个功能来查询分析。这个时候从网上找了许多方案:\n\n```\n//方案1:这是我们现有的方案，优点:简单 缺点:效率低，不易查询分析，难以排错...\nservice-->log4net-->文件              \n//方案2:优点:简单、效率高、有一定的查询分析功能 缺点:增加mongodb，增加一定复杂性，查询分析功能弱，需要投入开发精力和时间\nservice-->log4net-->Mongo-->开发一个功能查询分析             \n//方案3:优点:性能很高，查询分析及其方便,不需要开发投入 缺点：提高了系统复杂度，需要进行大量的测试以保证其稳定性，运维需要对这些组件进行维护监控...\nservice-->log4net-->kafka-->logstash-->elasticsearch-->kibana搜索展示               \n\n//其它方案\nservice-->log4net-->文件-->filebeat-->logstash-->elstaicsearch-->kibana\n\nservice-->log4net-->文件-->filebeat-->elstaicsearch-->kibana\n\nservice-->log4net-->文件-->logstash-->elstaicsearch-->kibana\n```\n\n最终和团队交流后决定采用方案2和方案3的结合，我增加了一个log4net for mongo的appender(这个appender,nuget上也有)，另外我们的团队开发一个能支持简单查询搜索的功能。我同步来搭建方案3。关于方案2就不多介绍了，很简单。主要提一提方案3。\n\n### 一. ELKB简介\n\n* Elastic Search: 从名称可以看出，Elastic Search 是用来进行搜索的，提供数据以及相应的配置信息（什么字段是什么数据类型，哪些字段可以检索等），然后你就可以自由地使用API搜索你的数据。\n* Logstash：。日志文件基本上都是每行一条，每一条里面有各种信息，这个软件的功能是将每条日志解析为各个字段。\n* Kibana：提供一套Web界面用来和 Elastic Search 进行交互，这样我们不用使用API来检索数据了，可以直接在 Kibana 中输入关键字，Kibana 会将返回的数据呈现给我们，当然，有很多漂亮的数据可视化图表可供选择。\n* Beats：安装在每台需要收集日志的服务器上，将日志发送给Logstash进行处理，所以Beats是一个“搬运工”，将你的日志搬运到日志收集服务器上。Beats分为很多种，每一种收集特定的信息。常用的是Filebeat，监听文件变化，传送文件内容。一般日志系统使用Filebeat就够了。\n\n### 二. kafka简介\n#### 2.1 简介\n\nkafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。\n\n#### 2.2 适用场景\n\n* Messaging\n    对于一些常规的消息系统,kafka是个不错的选择;partitons/replication和容错,可以使kafka具有良好的扩展性和性能优势.不过到目前为止,我们应该很清楚认识到,kafka并没有提供JMS中的\"事务性\"\"消息传输担保(消息确认机制)\"\"消息分组\"等企业级特性;kafka只能使用作为\"常规\"的消息系统,在一定程度上,尚未确保消息的发送与接收绝对可靠(比如,消息重发,消息发送丢失等)\n\n* Websit activity tracking\n    kafka可以作为\"网站活性跟踪\"的最佳工具;可以将网页/用户操作等信息发送到kafka中.并实时监控,或者离线统计分析等\n\n\n* Log Aggregation\n    kafka的特性决定它非常适合作为\"日志收集中心\";application可以将操作日志\"批量\"\"异步\"的发送到kafka集群中,而不是保存在本地或者DB中;kafka可以批量提交消息/压缩消息等,这对producer端而言,几乎感觉不到性能的开支.此时consumer端可以使hadoop等其他系统化的存储和分析系统.\n\n### 三、log4net+ELK+Kafka日志系统\n\n#### 3.1.简介\n\n&nbsp;&nbsp;&nbsp;&nbsp;从上我们可以了解到，我们可以增加一个log4net kafkaappender 日志生产者通过这个appender将日志写入kafka，由于kafka批量提交、压缩的特性，因此对我们的应用服务器性能的开支很小。日志消费者端使用logstash订阅kafka中的消息，传送到elasticsearch中，通过kibana展示给我们。同时我们也可以通过kibana对我们的日志进行统计分析等。刚好可以解决我们上面的一些问题。整个流程大致如下图:\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-8/33635135.jpg)\n\n关于log4net for kafka appender，我自己写了一个，nuget上也有现成的包，大家需要可以去nuget上找一找。\n\n#### 3.2.搭建\n\n&nbsp;&nbsp;&nbsp;&nbsp;简单介绍一下搭建，搭建过程中采用Docker。\n\n#### 3.2.1 docker 安装kafka\n\n```\n//下载\n//下载zookeeper\ndocker pull wurstmeister/zookeeper\n\n//下载kafka\ndocker pull wurstmeister/kafka:2.11-0.11.0.3\n```\n```\n//启动\n//启动zookeeper\ndocker run -d --name zookeeper --publish 2181:2181 --volume /etc/localtime:/etc/localtime wurstmeister/zookeeper\n\n//启动kafka\ndocker run -d --name kafka --publish 9092:9092 \\\n--link zookeeper \\\n--env KAFKA_ZOOKEEPER_CONNECT=192.168.121.205:2181 \\\n--env KAFKA_ADVERTISED_HOST_NAME=192.168.121.205 \\\n--env KAFKA_ADVERTISED_PORT=9092  \\\n--volume /etc/localtime:/etc/localtime \\\nwurstmeister/kafka:2.11-0.11.0.3\n```\n\n```\n//测试\n//创建topic\nbin/kafka-topics.sh --create --zookeeper 192.168.121.205:2181 --replication-factor 1 --partitions 1 --topic mykafka\n\n//查看topic\nbin/kafka-topics.sh --list --zookeeper 192.168.121.205:2181\n\n//创建生产者\nbin/kafka-console-producer.sh --broker-list 192.168.121.205:9092 --topic mykafka \n\n//创建消费者\nbin/kafka-console-consumer.sh --zookeeper 192.168.121.205:2181 --topic mykafka --from-beginning\n```\n\n#### 3.2.2 Docker安装ELK\n\n```\n//1.下载elk\ndocker pull sebp/elk\n```\n```\n//2.启动elk\n//Elasticsearch至少需要单独2G的内存\n//增加了一个volume绑定，以免重启container以后ES的数据丢失\ndocker run -d -p 5044:5044 -p 127.0.0.1:5601:5601 -p 127.0.0.1:9200:9200 -p 127.0.0.1:9300:9300 -v /var/data/elk:/var/lib/elasticsearch --name=elk sebp/elk\n\n```\n```\n//若启动过程出错一般是因为elasticsearch用户拥有的内存权限太小，至少需要262144\n切换到root用户\n\n执行命令：\n\nsysctl -w vm.max_map_count=262144\n\n查看结果：\n\nsysctl -a|grep vm.max_map_count\n\n显示：\n\nvm.max_map_count = 262144\n```\n```\n上述方法修改之后，如果重启虚拟机将失效，所以：\n\n解决办法：\n\n在   /etc/sysctl.conf文件最后添加一行\n\nvm.max_map_count=262144\n\n即可永久修改\n```\n启动成功之后访问：http://<your-host>:5601 看到kibana页面则说明安装成功\n\n配置使用\n\n```\n//进入容器\ndocker exec -it <container-name> /bin/bash\n```\n\n```\n//执行命令\n/opt/logstash/bin/logstash -e 'input { stdin { } } output { elasticsearch { hosts => [\"localhost\"] } }'\n/*\n 注意：如果看到这样的报错信息 Logstash could not be started because there is already another instance using the configured data directory.  If you wish to run multiple instances, you must change the \"path.data\" setting. 请执行命令：service logstash stop 然后在执行就可以了。\n*/\n```\n\n测试\n\n当命令成功被执行后，看到：Successfully started Logstash API endpoint {:port=>9600} 信息后，输入：this is a dummy entry 然后回车，模拟一条日志进行测试。\n打开浏览器，输入：http://<your-host>:9200/_search?pretty 如图，就会看到我们刚刚输入的日志内容。\n\n#### 3.2.3 logstash-kafka配置实例\n\n这是我测试用的一个配置文件。\n\n```\ninput {\n        kafka{\n                //此处注意:logstash5.x版本以前kafka插件配置的是zookeeper地址，5.x以后配置的是kafka实例地址\n                bootstrap_servers =>[\"192.168.121.205:9092\"]\n                client_id => \"test\" group_id => \"test\"\n                consumer_threads => 5\n                decorate_events => true\n                topics => \"logstash\"\n        }\n}\nfilter{\n        json{\n                source => \"message\"\n        }\n}\n\noutput {\n        elasticsearch {\n                hosts => [\"192.168.121.205\"]\n                index=> \"hslog_2\"\n                codec => \"json\"\n        }\n}\n\n```\n\n配置文件启动logstash方式\n\n```\n/opt/logstash/bin/logstash -f \"配置文件地址\"\n```\n\n### 结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上，我们的日志系统基本搭建完毕，当然还有很多关于kafka,logstash,elstaicsearch,kibana的使用，以及我们使用的一些问题，大家自己尝试着搭建一下。当然，没有最好的方案，建议大家结合自己公司和系统的现实情况，寻找和选择解决方案。能用简单的方案解决问题，就不要使用复杂的方案。因为复杂的方案在解决问题的同时，也会给我们带来其他的问题。就像我们这个方案，虽然解决了我们当时的问题，但是也增加了我们系统的复杂度，例如:这其中的每一个组件出了问题，都将导致我们的日志系统不可用......,此外，工欲善其事必先利其器，我们虽然解决了器的问题，但是要想\"善我们的事\"还有很长的路要走，因为究其根本，日志记不记录，在什么地方记录，记录什么等级的日志，还是由我们选择去记录。日志记录无规范、乱记、瞎记，如何规范日志的记录才是是我们接下来要解决的大问题！欢迎大家留言，探讨这些问题！","source":"_posts/log/NET下日志系统的搭建—log4net-kafka-elk.md","raw":"---\ntitle: .NET下日志系统的搭建—log4net+kafka+elk\ncopyright: true\ndate: 2018-11-13 10:37:30\ntags: \n- 日志\n- kafka\n- elk\n- log4net\ncategories: 日志\naside: log\n---\n\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们公司的程序日志之前都是采用log4net记录文件日志的方式(有关log4net的简单使用可以看我另一篇博客)，但是随着后来我们团队越来越大，项目也越来越大，我们的用户量也越来越多。慢慢系统就暴露了很多问题，这个时候我们的日志系统已经不能满足我们的要求。其主要有下面几个问题:\n\n* 随着我们访问量的增加，我们的日志文件急剧增加\n* 多且乱的文件日志，难以让我们对程序进行排错\n* 文件日志的记录耗用我们应用服务器的资源，导致我们的应用服务器的处理用户请求的能力下降\n* 我们的日志分布在多台应用服务器上，当程序遇到问题时，我们的程序员都需要找运维人员要日志，随着团队越来越大，问题越来越多，于是导致了程序员们排队找运维要日志，解决问题的速度急剧下降！\n\n<!--more-->\n\n起初，用户量不大的时候，上面的问题还能容忍。但任何一种小问题都会在用户量访问量变大的时候急剧的放大。终于在几波推广活动的时候，很悲剧的我们又不得不每天深夜加班来为我们之前对这些问题的不重视来买单。于是，在推广活动结束之后，在我们的程序员得到一丝喘息的机会时，我决定来搭建一个我们自己的日志系统，改善我们的日志记录方式。根据以上问题分析我们的日志系统需要有以下几点要求：\n\n* 日志的写入效率要高不能对应用服务器造成太大的影响\n* 要将日志集中在一台服务器上(或一组)\n* 提供一个方便检索分析的可视化页面(这个最重要，再也受不了每天找运维要日志，拿到一堆文件来分析的日子了！)\n\n一开始想要借助log4net AdoAppender把我们的日志写到数据库里，然后我们开发一个相应的功能，来对我们的日志来进行查询和分析。但考虑到写入关系数据库的性能问题，就放弃了，但有一个替代方案，就是写入到Mongo中，这样就解决了提高了一定的性能。但也需要我们开发一个功能来查询分析。这个时候从网上找了许多方案:\n\n```\n//方案1:这是我们现有的方案，优点:简单 缺点:效率低，不易查询分析，难以排错...\nservice-->log4net-->文件              \n//方案2:优点:简单、效率高、有一定的查询分析功能 缺点:增加mongodb，增加一定复杂性，查询分析功能弱，需要投入开发精力和时间\nservice-->log4net-->Mongo-->开发一个功能查询分析             \n//方案3:优点:性能很高，查询分析及其方便,不需要开发投入 缺点：提高了系统复杂度，需要进行大量的测试以保证其稳定性，运维需要对这些组件进行维护监控...\nservice-->log4net-->kafka-->logstash-->elasticsearch-->kibana搜索展示               \n\n//其它方案\nservice-->log4net-->文件-->filebeat-->logstash-->elstaicsearch-->kibana\n\nservice-->log4net-->文件-->filebeat-->elstaicsearch-->kibana\n\nservice-->log4net-->文件-->logstash-->elstaicsearch-->kibana\n```\n\n最终和团队交流后决定采用方案2和方案3的结合，我增加了一个log4net for mongo的appender(这个appender,nuget上也有)，另外我们的团队开发一个能支持简单查询搜索的功能。我同步来搭建方案3。关于方案2就不多介绍了，很简单。主要提一提方案3。\n\n### 一. ELKB简介\n\n* Elastic Search: 从名称可以看出，Elastic Search 是用来进行搜索的，提供数据以及相应的配置信息（什么字段是什么数据类型，哪些字段可以检索等），然后你就可以自由地使用API搜索你的数据。\n* Logstash：。日志文件基本上都是每行一条，每一条里面有各种信息，这个软件的功能是将每条日志解析为各个字段。\n* Kibana：提供一套Web界面用来和 Elastic Search 进行交互，这样我们不用使用API来检索数据了，可以直接在 Kibana 中输入关键字，Kibana 会将返回的数据呈现给我们，当然，有很多漂亮的数据可视化图表可供选择。\n* Beats：安装在每台需要收集日志的服务器上，将日志发送给Logstash进行处理，所以Beats是一个“搬运工”，将你的日志搬运到日志收集服务器上。Beats分为很多种，每一种收集特定的信息。常用的是Filebeat，监听文件变化，传送文件内容。一般日志系统使用Filebeat就够了。\n\n### 二. kafka简介\n#### 2.1 简介\n\nkafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。\n\n#### 2.2 适用场景\n\n* Messaging\n    对于一些常规的消息系统,kafka是个不错的选择;partitons/replication和容错,可以使kafka具有良好的扩展性和性能优势.不过到目前为止,我们应该很清楚认识到,kafka并没有提供JMS中的\"事务性\"\"消息传输担保(消息确认机制)\"\"消息分组\"等企业级特性;kafka只能使用作为\"常规\"的消息系统,在一定程度上,尚未确保消息的发送与接收绝对可靠(比如,消息重发,消息发送丢失等)\n\n* Websit activity tracking\n    kafka可以作为\"网站活性跟踪\"的最佳工具;可以将网页/用户操作等信息发送到kafka中.并实时监控,或者离线统计分析等\n\n\n* Log Aggregation\n    kafka的特性决定它非常适合作为\"日志收集中心\";application可以将操作日志\"批量\"\"异步\"的发送到kafka集群中,而不是保存在本地或者DB中;kafka可以批量提交消息/压缩消息等,这对producer端而言,几乎感觉不到性能的开支.此时consumer端可以使hadoop等其他系统化的存储和分析系统.\n\n### 三、log4net+ELK+Kafka日志系统\n\n#### 3.1.简介\n\n&nbsp;&nbsp;&nbsp;&nbsp;从上我们可以了解到，我们可以增加一个log4net kafkaappender 日志生产者通过这个appender将日志写入kafka，由于kafka批量提交、压缩的特性，因此对我们的应用服务器性能的开支很小。日志消费者端使用logstash订阅kafka中的消息，传送到elasticsearch中，通过kibana展示给我们。同时我们也可以通过kibana对我们的日志进行统计分析等。刚好可以解决我们上面的一些问题。整个流程大致如下图:\n\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-8/33635135.jpg)\n\n关于log4net for kafka appender，我自己写了一个，nuget上也有现成的包，大家需要可以去nuget上找一找。\n\n#### 3.2.搭建\n\n&nbsp;&nbsp;&nbsp;&nbsp;简单介绍一下搭建，搭建过程中采用Docker。\n\n#### 3.2.1 docker 安装kafka\n\n```\n//下载\n//下载zookeeper\ndocker pull wurstmeister/zookeeper\n\n//下载kafka\ndocker pull wurstmeister/kafka:2.11-0.11.0.3\n```\n```\n//启动\n//启动zookeeper\ndocker run -d --name zookeeper --publish 2181:2181 --volume /etc/localtime:/etc/localtime wurstmeister/zookeeper\n\n//启动kafka\ndocker run -d --name kafka --publish 9092:9092 \\\n--link zookeeper \\\n--env KAFKA_ZOOKEEPER_CONNECT=192.168.121.205:2181 \\\n--env KAFKA_ADVERTISED_HOST_NAME=192.168.121.205 \\\n--env KAFKA_ADVERTISED_PORT=9092  \\\n--volume /etc/localtime:/etc/localtime \\\nwurstmeister/kafka:2.11-0.11.0.3\n```\n\n```\n//测试\n//创建topic\nbin/kafka-topics.sh --create --zookeeper 192.168.121.205:2181 --replication-factor 1 --partitions 1 --topic mykafka\n\n//查看topic\nbin/kafka-topics.sh --list --zookeeper 192.168.121.205:2181\n\n//创建生产者\nbin/kafka-console-producer.sh --broker-list 192.168.121.205:9092 --topic mykafka \n\n//创建消费者\nbin/kafka-console-consumer.sh --zookeeper 192.168.121.205:2181 --topic mykafka --from-beginning\n```\n\n#### 3.2.2 Docker安装ELK\n\n```\n//1.下载elk\ndocker pull sebp/elk\n```\n```\n//2.启动elk\n//Elasticsearch至少需要单独2G的内存\n//增加了一个volume绑定，以免重启container以后ES的数据丢失\ndocker run -d -p 5044:5044 -p 127.0.0.1:5601:5601 -p 127.0.0.1:9200:9200 -p 127.0.0.1:9300:9300 -v /var/data/elk:/var/lib/elasticsearch --name=elk sebp/elk\n\n```\n```\n//若启动过程出错一般是因为elasticsearch用户拥有的内存权限太小，至少需要262144\n切换到root用户\n\n执行命令：\n\nsysctl -w vm.max_map_count=262144\n\n查看结果：\n\nsysctl -a|grep vm.max_map_count\n\n显示：\n\nvm.max_map_count = 262144\n```\n```\n上述方法修改之后，如果重启虚拟机将失效，所以：\n\n解决办法：\n\n在   /etc/sysctl.conf文件最后添加一行\n\nvm.max_map_count=262144\n\n即可永久修改\n```\n启动成功之后访问：http://<your-host>:5601 看到kibana页面则说明安装成功\n\n配置使用\n\n```\n//进入容器\ndocker exec -it <container-name> /bin/bash\n```\n\n```\n//执行命令\n/opt/logstash/bin/logstash -e 'input { stdin { } } output { elasticsearch { hosts => [\"localhost\"] } }'\n/*\n 注意：如果看到这样的报错信息 Logstash could not be started because there is already another instance using the configured data directory.  If you wish to run multiple instances, you must change the \"path.data\" setting. 请执行命令：service logstash stop 然后在执行就可以了。\n*/\n```\n\n测试\n\n当命令成功被执行后，看到：Successfully started Logstash API endpoint {:port=>9600} 信息后，输入：this is a dummy entry 然后回车，模拟一条日志进行测试。\n打开浏览器，输入：http://<your-host>:9200/_search?pretty 如图，就会看到我们刚刚输入的日志内容。\n\n#### 3.2.3 logstash-kafka配置实例\n\n这是我测试用的一个配置文件。\n\n```\ninput {\n        kafka{\n                //此处注意:logstash5.x版本以前kafka插件配置的是zookeeper地址，5.x以后配置的是kafka实例地址\n                bootstrap_servers =>[\"192.168.121.205:9092\"]\n                client_id => \"test\" group_id => \"test\"\n                consumer_threads => 5\n                decorate_events => true\n                topics => \"logstash\"\n        }\n}\nfilter{\n        json{\n                source => \"message\"\n        }\n}\n\noutput {\n        elasticsearch {\n                hosts => [\"192.168.121.205\"]\n                index=> \"hslog_2\"\n                codec => \"json\"\n        }\n}\n\n```\n\n配置文件启动logstash方式\n\n```\n/opt/logstash/bin/logstash -f \"配置文件地址\"\n```\n\n### 结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上，我们的日志系统基本搭建完毕，当然还有很多关于kafka,logstash,elstaicsearch,kibana的使用，以及我们使用的一些问题，大家自己尝试着搭建一下。当然，没有最好的方案，建议大家结合自己公司和系统的现实情况，寻找和选择解决方案。能用简单的方案解决问题，就不要使用复杂的方案。因为复杂的方案在解决问题的同时，也会给我们带来其他的问题。就像我们这个方案，虽然解决了我们当时的问题，但是也增加了我们系统的复杂度，例如:这其中的每一个组件出了问题，都将导致我们的日志系统不可用......,此外，工欲善其事必先利其器，我们虽然解决了器的问题，但是要想\"善我们的事\"还有很长的路要走，因为究其根本，日志记不记录，在什么地方记录，记录什么等级的日志，还是由我们选择去记录。日志记录无规范、乱记、瞎记，如何规范日志的记录才是是我们接下来要解决的大问题！欢迎大家留言，探讨这些问题！","slug":"log/NET下日志系统的搭建—log4net-kafka-elk","published":1,"updated":"2021-03-14T03:04:50.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpso000qhyjfh7iyye5w","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;我们公司的程序日志之前都是采用log4net记录文件日志的方式(有关log4net的简单使用可以看我另一篇博客)，但是随着后来我们团队越来越大，项目也越来越大，我们的用户量也越来越多。慢慢系统就暴露了很多问题，这个时候我们的日志系统已经不能满足我们的要求。其主要有下面几个问题:</p>\n<ul>\n<li>随着我们访问量的增加，我们的日志文件急剧增加</li>\n<li>多且乱的文件日志，难以让我们对程序进行排错</li>\n<li>文件日志的记录耗用我们应用服务器的资源，导致我们的应用服务器的处理用户请求的能力下降</li>\n<li>我们的日志分布在多台应用服务器上，当程序遇到问题时，我们的程序员都需要找运维人员要日志，随着团队越来越大，问题越来越多，于是导致了程序员们排队找运维要日志，解决问题的速度急剧下降！</li>\n</ul>\n<a id=\"more\"></a>\n<p>起初，用户量不大的时候，上面的问题还能容忍。但任何一种小问题都会在用户量访问量变大的时候急剧的放大。终于在几波推广活动的时候，很悲剧的我们又不得不每天深夜加班来为我们之前对这些问题的不重视来买单。于是，在推广活动结束之后，在我们的程序员得到一丝喘息的机会时，我决定来搭建一个我们自己的日志系统，改善我们的日志记录方式。根据以上问题分析我们的日志系统需要有以下几点要求：</p>\n<ul>\n<li>日志的写入效率要高不能对应用服务器造成太大的影响</li>\n<li>要将日志集中在一台服务器上(或一组)</li>\n<li>提供一个方便检索分析的可视化页面(这个最重要，再也受不了每天找运维要日志，拿到一堆文件来分析的日子了！)</li>\n</ul>\n<p>一开始想要借助log4net AdoAppender把我们的日志写到数据库里，然后我们开发一个相应的功能，来对我们的日志来进行查询和分析。但考虑到写入关系数据库的性能问题，就放弃了，但有一个替代方案，就是写入到Mongo中，这样就解决了提高了一定的性能。但也需要我们开发一个功能来查询分析。这个时候从网上找了许多方案:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方案1:这是我们现有的方案，优点:简单 缺点:效率低，不易查询分析，难以排错...</span><br><span class=\"line\">service--&gt;log4net--&gt;文件              </span><br><span class=\"line\">//方案2:优点:简单、效率高、有一定的查询分析功能 缺点:增加mongodb，增加一定复杂性，查询分析功能弱，需要投入开发精力和时间</span><br><span class=\"line\">service--&gt;log4net--&gt;Mongo--&gt;开发一个功能查询分析             </span><br><span class=\"line\">//方案3:优点:性能很高，查询分析及其方便,不需要开发投入 缺点：提高了系统复杂度，需要进行大量的测试以保证其稳定性，运维需要对这些组件进行维护监控...</span><br><span class=\"line\">service--&gt;log4net--&gt;kafka--&gt;logstash--&gt;elasticsearch--&gt;kibana搜索展示               </span><br><span class=\"line\"></span><br><span class=\"line\">//其它方案</span><br><span class=\"line\">service--&gt;log4net--&gt;文件--&gt;filebeat--&gt;logstash--&gt;elstaicsearch--&gt;kibana</span><br><span class=\"line\"></span><br><span class=\"line\">service--&gt;log4net--&gt;文件--&gt;filebeat--&gt;elstaicsearch--&gt;kibana</span><br><span class=\"line\"></span><br><span class=\"line\">service--&gt;log4net--&gt;文件--&gt;logstash--&gt;elstaicsearch--&gt;kibana</span><br></pre></td></tr></table></figure>\n<p>最终和团队交流后决定采用方案2和方案3的结合，我增加了一个log4net for mongo的appender(这个appender,nuget上也有)，另外我们的团队开发一个能支持简单查询搜索的功能。我同步来搭建方案3。关于方案2就不多介绍了，很简单。主要提一提方案3。</p>\n<h3 id=\"一-ELKB简介\"><a href=\"#一-ELKB简介\" class=\"headerlink\" title=\"一. ELKB简介\"></a>一. ELKB简介</h3><ul>\n<li>Elastic Search: 从名称可以看出，Elastic Search 是用来进行搜索的，提供数据以及相应的配置信息（什么字段是什么数据类型，哪些字段可以检索等），然后你就可以自由地使用API搜索你的数据。</li>\n<li>Logstash：。日志文件基本上都是每行一条，每一条里面有各种信息，这个软件的功能是将每条日志解析为各个字段。</li>\n<li>Kibana：提供一套Web界面用来和 Elastic Search 进行交互，这样我们不用使用API来检索数据了，可以直接在 Kibana 中输入关键字，Kibana 会将返回的数据呈现给我们，当然，有很多漂亮的数据可视化图表可供选择。</li>\n<li>Beats：安装在每台需要收集日志的服务器上，将日志发送给Logstash进行处理，所以Beats是一个“搬运工”，将你的日志搬运到日志收集服务器上。Beats分为很多种，每一种收集特定的信息。常用的是Filebeat，监听文件变化，传送文件内容。一般日志系统使用Filebeat就够了。</li>\n</ul>\n<h3 id=\"二-kafka简介\"><a href=\"#二-kafka简介\" class=\"headerlink\" title=\"二. kafka简介\"></a>二. kafka简介</h3><h4 id=\"2-1-简介\"><a href=\"#2-1-简介\" class=\"headerlink\" title=\"2.1 简介\"></a>2.1 简介</h4><p>kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。</p>\n<h4 id=\"2-2-适用场景\"><a href=\"#2-2-适用场景\" class=\"headerlink\" title=\"2.2 适用场景\"></a>2.2 适用场景</h4><ul>\n<li><p>Messaging<br>  对于一些常规的消息系统,kafka是个不错的选择;partitons/replication和容错,可以使kafka具有良好的扩展性和性能优势.不过到目前为止,我们应该很清楚认识到,kafka并没有提供JMS中的”事务性””消息传输担保(消息确认机制)””消息分组”等企业级特性;kafka只能使用作为”常规”的消息系统,在一定程度上,尚未确保消息的发送与接收绝对可靠(比如,消息重发,消息发送丢失等)</p>\n</li>\n<li><p>Websit activity tracking<br>  kafka可以作为”网站活性跟踪”的最佳工具;可以将网页/用户操作等信息发送到kafka中.并实时监控,或者离线统计分析等</p>\n</li>\n</ul>\n<ul>\n<li>Log Aggregation<br>  kafka的特性决定它非常适合作为”日志收集中心”;application可以将操作日志”批量””异步”的发送到kafka集群中,而不是保存在本地或者DB中;kafka可以批量提交消息/压缩消息等,这对producer端而言,几乎感觉不到性能的开支.此时consumer端可以使hadoop等其他系统化的存储和分析系统.</li>\n</ul>\n<h3 id=\"三、log4net-ELK-Kafka日志系统\"><a href=\"#三、log4net-ELK-Kafka日志系统\" class=\"headerlink\" title=\"三、log4net+ELK+Kafka日志系统\"></a>三、log4net+ELK+Kafka日志系统</h3><h4 id=\"3-1-简介\"><a href=\"#3-1-简介\" class=\"headerlink\" title=\"3.1.简介\"></a>3.1.简介</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;从上我们可以了解到，我们可以增加一个log4net kafkaappender 日志生产者通过这个appender将日志写入kafka，由于kafka批量提交、压缩的特性，因此对我们的应用服务器性能的开支很小。日志消费者端使用logstash订阅kafka中的消息，传送到elasticsearch中，通过kibana展示给我们。同时我们也可以通过kibana对我们的日志进行统计分析等。刚好可以解决我们上面的一些问题。整个流程大致如下图:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-8/33635135.jpg\" alt=\"image\"></p>\n<p>关于log4net for kafka appender，我自己写了一个，nuget上也有现成的包，大家需要可以去nuget上找一找。</p>\n<h4 id=\"3-2-搭建\"><a href=\"#3-2-搭建\" class=\"headerlink\" title=\"3.2.搭建\"></a>3.2.搭建</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;简单介绍一下搭建，搭建过程中采用Docker。</p>\n<h4 id=\"3-2-1-docker-安装kafka\"><a href=\"#3-2-1-docker-安装kafka\" class=\"headerlink\" title=\"3.2.1 docker 安装kafka\"></a>3.2.1 docker 安装kafka</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下载</span><br><span class=\"line\">//下载zookeeper</span><br><span class=\"line\">docker pull wurstmeister/zookeeper</span><br><span class=\"line\"></span><br><span class=\"line\">//下载kafka</span><br><span class=\"line\">docker pull wurstmeister/kafka:2.11-0.11.0.3</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//启动</span><br><span class=\"line\">//启动zookeeper</span><br><span class=\"line\">docker run -d --name zookeeper --publish 2181:2181 --volume /etc/localtime:/etc/localtime wurstmeister/zookeeper</span><br><span class=\"line\"></span><br><span class=\"line\">//启动kafka</span><br><span class=\"line\">docker run -d --name kafka --publish 9092:9092 \\</span><br><span class=\"line\">--link zookeeper \\</span><br><span class=\"line\">--env KAFKA_ZOOKEEPER_CONNECT=192.168.121.205:2181 \\</span><br><span class=\"line\">--env KAFKA_ADVERTISED_HOST_NAME=192.168.121.205 \\</span><br><span class=\"line\">--env KAFKA_ADVERTISED_PORT=9092  \\</span><br><span class=\"line\">--volume /etc/localtime:/etc/localtime \\</span><br><span class=\"line\">wurstmeister/kafka:2.11-0.11.0.3</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//测试</span><br><span class=\"line\">//创建topic</span><br><span class=\"line\">bin/kafka-topics.sh --create --zookeeper 192.168.121.205:2181 --replication-factor 1 --partitions 1 --topic mykafka</span><br><span class=\"line\"></span><br><span class=\"line\">//查看topic</span><br><span class=\"line\">bin/kafka-topics.sh --list --zookeeper 192.168.121.205:2181</span><br><span class=\"line\"></span><br><span class=\"line\">//创建生产者</span><br><span class=\"line\">bin/kafka-console-producer.sh --broker-list 192.168.121.205:9092 --topic mykafka </span><br><span class=\"line\"></span><br><span class=\"line\">//创建消费者</span><br><span class=\"line\">bin/kafka-console-consumer.sh --zookeeper 192.168.121.205:2181 --topic mykafka --from-beginning</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-2-Docker安装ELK\"><a href=\"#3-2-2-Docker安装ELK\" class=\"headerlink\" title=\"3.2.2 Docker安装ELK\"></a>3.2.2 Docker安装ELK</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.下载elk</span><br><span class=\"line\">docker pull sebp/elk</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//2.启动elk</span><br><span class=\"line\">//Elasticsearch至少需要单独2G的内存</span><br><span class=\"line\">//增加了一个volume绑定，以免重启container以后ES的数据丢失</span><br><span class=\"line\">docker run -d -p 5044:5044 -p 127.0.0.1:5601:5601 -p 127.0.0.1:9200:9200 -p 127.0.0.1:9300:9300 -v /var/data/elk:/var/lib/elasticsearch --name=elk sebp/elk</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//若启动过程出错一般是因为elasticsearch用户拥有的内存权限太小，至少需要262144</span><br><span class=\"line\">切换到root用户</span><br><span class=\"line\"></span><br><span class=\"line\">执行命令：</span><br><span class=\"line\"></span><br><span class=\"line\">sysctl -w vm.max_map_count=262144</span><br><span class=\"line\"></span><br><span class=\"line\">查看结果：</span><br><span class=\"line\"></span><br><span class=\"line\">sysctl -a|grep vm.max_map_count</span><br><span class=\"line\"></span><br><span class=\"line\">显示：</span><br><span class=\"line\"></span><br><span class=\"line\">vm.max_map_count = 262144</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上述方法修改之后，如果重启虚拟机将失效，所以：</span><br><span class=\"line\"></span><br><span class=\"line\">解决办法：</span><br><span class=\"line\"></span><br><span class=\"line\">在   /etc/sysctl.conf文件最后添加一行</span><br><span class=\"line\"></span><br><span class=\"line\">vm.max_map_count=262144</span><br><span class=\"line\"></span><br><span class=\"line\">即可永久修改</span><br></pre></td></tr></table></figure>\n<p>启动成功之后访问：http://<your-host>:5601 看到kibana页面则说明安装成功</your-host></p>\n<p>配置使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//进入容器</span><br><span class=\"line\">docker exec -it &lt;container-name&gt; /bin/bash</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//执行命令</span><br><span class=\"line\">/opt/logstash/bin/logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; elasticsearch &#123; hosts =&gt; [&quot;localhost&quot;] &#125; &#125;&apos;</span><br><span class=\"line\">/*</span><br><span class=\"line\"> 注意：如果看到这样的报错信息 Logstash could not be started because there is already another instance using the configured data directory.  If you wish to run multiple instances, you must change the &quot;path.data&quot; setting. 请执行命令：service logstash stop 然后在执行就可以了。</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p>测试</p>\n<p>当命令成功被执行后，看到：Successfully started Logstash API endpoint {:port=&gt;9600} 信息后，输入：this is a dummy entry 然后回车，模拟一条日志进行测试。<br>打开浏览器，输入：http://<your-host>:9200/_search?pretty 如图，就会看到我们刚刚输入的日志内容。</your-host></p>\n<h4 id=\"3-2-3-logstash-kafka配置实例\"><a href=\"#3-2-3-logstash-kafka配置实例\" class=\"headerlink\" title=\"3.2.3 logstash-kafka配置实例\"></a>3.2.3 logstash-kafka配置实例</h4><p>这是我测试用的一个配置文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input &#123;</span><br><span class=\"line\">        kafka&#123;</span><br><span class=\"line\">                //此处注意:logstash5.x版本以前kafka插件配置的是zookeeper地址，5.x以后配置的是kafka实例地址</span><br><span class=\"line\">                bootstrap_servers =&gt;[&quot;192.168.121.205:9092&quot;]</span><br><span class=\"line\">                client_id =&gt; &quot;test&quot; group_id =&gt; &quot;test&quot;</span><br><span class=\"line\">                consumer_threads =&gt; 5</span><br><span class=\"line\">                decorate_events =&gt; true</span><br><span class=\"line\">                topics =&gt; &quot;logstash&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">filter&#123;</span><br><span class=\"line\">        json&#123;</span><br><span class=\"line\">                source =&gt; &quot;message&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output &#123;</span><br><span class=\"line\">        elasticsearch &#123;</span><br><span class=\"line\">                hosts =&gt; [&quot;192.168.121.205&quot;]</span><br><span class=\"line\">                index=&gt; &quot;hslog_2&quot;</span><br><span class=\"line\">                codec =&gt; &quot;json&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置文件启动logstash方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/opt/logstash/bin/logstash -f &quot;配置文件地址&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如上，我们的日志系统基本搭建完毕，当然还有很多关于kafka,logstash,elstaicsearch,kibana的使用，以及我们使用的一些问题，大家自己尝试着搭建一下。当然，没有最好的方案，建议大家结合自己公司和系统的现实情况，寻找和选择解决方案。能用简单的方案解决问题，就不要使用复杂的方案。因为复杂的方案在解决问题的同时，也会给我们带来其他的问题。就像我们这个方案，虽然解决了我们当时的问题，但是也增加了我们系统的复杂度，例如:这其中的每一个组件出了问题，都将导致我们的日志系统不可用……,此外，工欲善其事必先利其器，我们虽然解决了器的问题，但是要想”善我们的事”还有很长的路要走，因为究其根本，日志记不记录，在什么地方记录，记录什么等级的日志，还是由我们选择去记录。日志记录无规范、乱记、瞎记，如何规范日志的记录才是是我们接下来要解决的大问题！欢迎大家留言，探讨这些问题！</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;我们公司的程序日志之前都是采用log4net记录文件日志的方式(有关log4net的简单使用可以看我另一篇博客)，但是随着后来我们团队越来越大，项目也越来越大，我们的用户量也越来越多。慢慢系统就暴露了很多问题，这个时候我们的日志系统已经不能满足我们的要求。其主要有下面几个问题:</p>\n<ul>\n<li>随着我们访问量的增加，我们的日志文件急剧增加</li>\n<li>多且乱的文件日志，难以让我们对程序进行排错</li>\n<li>文件日志的记录耗用我们应用服务器的资源，导致我们的应用服务器的处理用户请求的能力下降</li>\n<li>我们的日志分布在多台应用服务器上，当程序遇到问题时，我们的程序员都需要找运维人员要日志，随着团队越来越大，问题越来越多，于是导致了程序员们排队找运维要日志，解决问题的速度急剧下降！</li>\n</ul>","more":"<p>起初，用户量不大的时候，上面的问题还能容忍。但任何一种小问题都会在用户量访问量变大的时候急剧的放大。终于在几波推广活动的时候，很悲剧的我们又不得不每天深夜加班来为我们之前对这些问题的不重视来买单。于是，在推广活动结束之后，在我们的程序员得到一丝喘息的机会时，我决定来搭建一个我们自己的日志系统，改善我们的日志记录方式。根据以上问题分析我们的日志系统需要有以下几点要求：</p>\n<ul>\n<li>日志的写入效率要高不能对应用服务器造成太大的影响</li>\n<li>要将日志集中在一台服务器上(或一组)</li>\n<li>提供一个方便检索分析的可视化页面(这个最重要，再也受不了每天找运维要日志，拿到一堆文件来分析的日子了！)</li>\n</ul>\n<p>一开始想要借助log4net AdoAppender把我们的日志写到数据库里，然后我们开发一个相应的功能，来对我们的日志来进行查询和分析。但考虑到写入关系数据库的性能问题，就放弃了，但有一个替代方案，就是写入到Mongo中，这样就解决了提高了一定的性能。但也需要我们开发一个功能来查询分析。这个时候从网上找了许多方案:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方案1:这是我们现有的方案，优点:简单 缺点:效率低，不易查询分析，难以排错...</span><br><span class=\"line\">service--&gt;log4net--&gt;文件              </span><br><span class=\"line\">//方案2:优点:简单、效率高、有一定的查询分析功能 缺点:增加mongodb，增加一定复杂性，查询分析功能弱，需要投入开发精力和时间</span><br><span class=\"line\">service--&gt;log4net--&gt;Mongo--&gt;开发一个功能查询分析             </span><br><span class=\"line\">//方案3:优点:性能很高，查询分析及其方便,不需要开发投入 缺点：提高了系统复杂度，需要进行大量的测试以保证其稳定性，运维需要对这些组件进行维护监控...</span><br><span class=\"line\">service--&gt;log4net--&gt;kafka--&gt;logstash--&gt;elasticsearch--&gt;kibana搜索展示               </span><br><span class=\"line\"></span><br><span class=\"line\">//其它方案</span><br><span class=\"line\">service--&gt;log4net--&gt;文件--&gt;filebeat--&gt;logstash--&gt;elstaicsearch--&gt;kibana</span><br><span class=\"line\"></span><br><span class=\"line\">service--&gt;log4net--&gt;文件--&gt;filebeat--&gt;elstaicsearch--&gt;kibana</span><br><span class=\"line\"></span><br><span class=\"line\">service--&gt;log4net--&gt;文件--&gt;logstash--&gt;elstaicsearch--&gt;kibana</span><br></pre></td></tr></table></figure>\n<p>最终和团队交流后决定采用方案2和方案3的结合，我增加了一个log4net for mongo的appender(这个appender,nuget上也有)，另外我们的团队开发一个能支持简单查询搜索的功能。我同步来搭建方案3。关于方案2就不多介绍了，很简单。主要提一提方案3。</p>\n<h3 id=\"一-ELKB简介\"><a href=\"#一-ELKB简介\" class=\"headerlink\" title=\"一. ELKB简介\"></a>一. ELKB简介</h3><ul>\n<li>Elastic Search: 从名称可以看出，Elastic Search 是用来进行搜索的，提供数据以及相应的配置信息（什么字段是什么数据类型，哪些字段可以检索等），然后你就可以自由地使用API搜索你的数据。</li>\n<li>Logstash：。日志文件基本上都是每行一条，每一条里面有各种信息，这个软件的功能是将每条日志解析为各个字段。</li>\n<li>Kibana：提供一套Web界面用来和 Elastic Search 进行交互，这样我们不用使用API来检索数据了，可以直接在 Kibana 中输入关键字，Kibana 会将返回的数据呈现给我们，当然，有很多漂亮的数据可视化图表可供选择。</li>\n<li>Beats：安装在每台需要收集日志的服务器上，将日志发送给Logstash进行处理，所以Beats是一个“搬运工”，将你的日志搬运到日志收集服务器上。Beats分为很多种，每一种收集特定的信息。常用的是Filebeat，监听文件变化，传送文件内容。一般日志系统使用Filebeat就够了。</li>\n</ul>\n<h3 id=\"二-kafka简介\"><a href=\"#二-kafka简介\" class=\"headerlink\" title=\"二. kafka简介\"></a>二. kafka简介</h3><h4 id=\"2-1-简介\"><a href=\"#2-1-简介\" class=\"headerlink\" title=\"2.1 简介\"></a>2.1 简介</h4><p>kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。</p>\n<h4 id=\"2-2-适用场景\"><a href=\"#2-2-适用场景\" class=\"headerlink\" title=\"2.2 适用场景\"></a>2.2 适用场景</h4><ul>\n<li><p>Messaging<br>  对于一些常规的消息系统,kafka是个不错的选择;partitons/replication和容错,可以使kafka具有良好的扩展性和性能优势.不过到目前为止,我们应该很清楚认识到,kafka并没有提供JMS中的”事务性””消息传输担保(消息确认机制)””消息分组”等企业级特性;kafka只能使用作为”常规”的消息系统,在一定程度上,尚未确保消息的发送与接收绝对可靠(比如,消息重发,消息发送丢失等)</p>\n</li>\n<li><p>Websit activity tracking<br>  kafka可以作为”网站活性跟踪”的最佳工具;可以将网页/用户操作等信息发送到kafka中.并实时监控,或者离线统计分析等</p>\n</li>\n</ul>\n<ul>\n<li>Log Aggregation<br>  kafka的特性决定它非常适合作为”日志收集中心”;application可以将操作日志”批量””异步”的发送到kafka集群中,而不是保存在本地或者DB中;kafka可以批量提交消息/压缩消息等,这对producer端而言,几乎感觉不到性能的开支.此时consumer端可以使hadoop等其他系统化的存储和分析系统.</li>\n</ul>\n<h3 id=\"三、log4net-ELK-Kafka日志系统\"><a href=\"#三、log4net-ELK-Kafka日志系统\" class=\"headerlink\" title=\"三、log4net+ELK+Kafka日志系统\"></a>三、log4net+ELK+Kafka日志系统</h3><h4 id=\"3-1-简介\"><a href=\"#3-1-简介\" class=\"headerlink\" title=\"3.1.简介\"></a>3.1.简介</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;从上我们可以了解到，我们可以增加一个log4net kafkaappender 日志生产者通过这个appender将日志写入kafka，由于kafka批量提交、压缩的特性，因此对我们的应用服务器性能的开支很小。日志消费者端使用logstash订阅kafka中的消息，传送到elasticsearch中，通过kibana展示给我们。同时我们也可以通过kibana对我们的日志进行统计分析等。刚好可以解决我们上面的一些问题。整个流程大致如下图:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-8/33635135.jpg\" alt=\"image\"></p>\n<p>关于log4net for kafka appender，我自己写了一个，nuget上也有现成的包，大家需要可以去nuget上找一找。</p>\n<h4 id=\"3-2-搭建\"><a href=\"#3-2-搭建\" class=\"headerlink\" title=\"3.2.搭建\"></a>3.2.搭建</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;简单介绍一下搭建，搭建过程中采用Docker。</p>\n<h4 id=\"3-2-1-docker-安装kafka\"><a href=\"#3-2-1-docker-安装kafka\" class=\"headerlink\" title=\"3.2.1 docker 安装kafka\"></a>3.2.1 docker 安装kafka</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下载</span><br><span class=\"line\">//下载zookeeper</span><br><span class=\"line\">docker pull wurstmeister/zookeeper</span><br><span class=\"line\"></span><br><span class=\"line\">//下载kafka</span><br><span class=\"line\">docker pull wurstmeister/kafka:2.11-0.11.0.3</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//启动</span><br><span class=\"line\">//启动zookeeper</span><br><span class=\"line\">docker run -d --name zookeeper --publish 2181:2181 --volume /etc/localtime:/etc/localtime wurstmeister/zookeeper</span><br><span class=\"line\"></span><br><span class=\"line\">//启动kafka</span><br><span class=\"line\">docker run -d --name kafka --publish 9092:9092 \\</span><br><span class=\"line\">--link zookeeper \\</span><br><span class=\"line\">--env KAFKA_ZOOKEEPER_CONNECT=192.168.121.205:2181 \\</span><br><span class=\"line\">--env KAFKA_ADVERTISED_HOST_NAME=192.168.121.205 \\</span><br><span class=\"line\">--env KAFKA_ADVERTISED_PORT=9092  \\</span><br><span class=\"line\">--volume /etc/localtime:/etc/localtime \\</span><br><span class=\"line\">wurstmeister/kafka:2.11-0.11.0.3</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//测试</span><br><span class=\"line\">//创建topic</span><br><span class=\"line\">bin/kafka-topics.sh --create --zookeeper 192.168.121.205:2181 --replication-factor 1 --partitions 1 --topic mykafka</span><br><span class=\"line\"></span><br><span class=\"line\">//查看topic</span><br><span class=\"line\">bin/kafka-topics.sh --list --zookeeper 192.168.121.205:2181</span><br><span class=\"line\"></span><br><span class=\"line\">//创建生产者</span><br><span class=\"line\">bin/kafka-console-producer.sh --broker-list 192.168.121.205:9092 --topic mykafka </span><br><span class=\"line\"></span><br><span class=\"line\">//创建消费者</span><br><span class=\"line\">bin/kafka-console-consumer.sh --zookeeper 192.168.121.205:2181 --topic mykafka --from-beginning</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-2-Docker安装ELK\"><a href=\"#3-2-2-Docker安装ELK\" class=\"headerlink\" title=\"3.2.2 Docker安装ELK\"></a>3.2.2 Docker安装ELK</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1.下载elk</span><br><span class=\"line\">docker pull sebp/elk</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//2.启动elk</span><br><span class=\"line\">//Elasticsearch至少需要单独2G的内存</span><br><span class=\"line\">//增加了一个volume绑定，以免重启container以后ES的数据丢失</span><br><span class=\"line\">docker run -d -p 5044:5044 -p 127.0.0.1:5601:5601 -p 127.0.0.1:9200:9200 -p 127.0.0.1:9300:9300 -v /var/data/elk:/var/lib/elasticsearch --name=elk sebp/elk</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//若启动过程出错一般是因为elasticsearch用户拥有的内存权限太小，至少需要262144</span><br><span class=\"line\">切换到root用户</span><br><span class=\"line\"></span><br><span class=\"line\">执行命令：</span><br><span class=\"line\"></span><br><span class=\"line\">sysctl -w vm.max_map_count=262144</span><br><span class=\"line\"></span><br><span class=\"line\">查看结果：</span><br><span class=\"line\"></span><br><span class=\"line\">sysctl -a|grep vm.max_map_count</span><br><span class=\"line\"></span><br><span class=\"line\">显示：</span><br><span class=\"line\"></span><br><span class=\"line\">vm.max_map_count = 262144</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上述方法修改之后，如果重启虚拟机将失效，所以：</span><br><span class=\"line\"></span><br><span class=\"line\">解决办法：</span><br><span class=\"line\"></span><br><span class=\"line\">在   /etc/sysctl.conf文件最后添加一行</span><br><span class=\"line\"></span><br><span class=\"line\">vm.max_map_count=262144</span><br><span class=\"line\"></span><br><span class=\"line\">即可永久修改</span><br></pre></td></tr></table></figure>\n<p>启动成功之后访问：http://<your-host>:5601 看到kibana页面则说明安装成功</your-host></p>\n<p>配置使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//进入容器</span><br><span class=\"line\">docker exec -it &lt;container-name&gt; /bin/bash</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//执行命令</span><br><span class=\"line\">/opt/logstash/bin/logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; elasticsearch &#123; hosts =&gt; [&quot;localhost&quot;] &#125; &#125;&apos;</span><br><span class=\"line\">/*</span><br><span class=\"line\"> 注意：如果看到这样的报错信息 Logstash could not be started because there is already another instance using the configured data directory.  If you wish to run multiple instances, you must change the &quot;path.data&quot; setting. 请执行命令：service logstash stop 然后在执行就可以了。</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p>测试</p>\n<p>当命令成功被执行后，看到：Successfully started Logstash API endpoint {:port=&gt;9600} 信息后，输入：this is a dummy entry 然后回车，模拟一条日志进行测试。<br>打开浏览器，输入：http://<your-host>:9200/_search?pretty 如图，就会看到我们刚刚输入的日志内容。</your-host></p>\n<h4 id=\"3-2-3-logstash-kafka配置实例\"><a href=\"#3-2-3-logstash-kafka配置实例\" class=\"headerlink\" title=\"3.2.3 logstash-kafka配置实例\"></a>3.2.3 logstash-kafka配置实例</h4><p>这是我测试用的一个配置文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input &#123;</span><br><span class=\"line\">        kafka&#123;</span><br><span class=\"line\">                //此处注意:logstash5.x版本以前kafka插件配置的是zookeeper地址，5.x以后配置的是kafka实例地址</span><br><span class=\"line\">                bootstrap_servers =&gt;[&quot;192.168.121.205:9092&quot;]</span><br><span class=\"line\">                client_id =&gt; &quot;test&quot; group_id =&gt; &quot;test&quot;</span><br><span class=\"line\">                consumer_threads =&gt; 5</span><br><span class=\"line\">                decorate_events =&gt; true</span><br><span class=\"line\">                topics =&gt; &quot;logstash&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">filter&#123;</span><br><span class=\"line\">        json&#123;</span><br><span class=\"line\">                source =&gt; &quot;message&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output &#123;</span><br><span class=\"line\">        elasticsearch &#123;</span><br><span class=\"line\">                hosts =&gt; [&quot;192.168.121.205&quot;]</span><br><span class=\"line\">                index=&gt; &quot;hslog_2&quot;</span><br><span class=\"line\">                codec =&gt; &quot;json&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置文件启动logstash方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/opt/logstash/bin/logstash -f &quot;配置文件地址&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如上，我们的日志系统基本搭建完毕，当然还有很多关于kafka,logstash,elstaicsearch,kibana的使用，以及我们使用的一些问题，大家自己尝试着搭建一下。当然，没有最好的方案，建议大家结合自己公司和系统的现实情况，寻找和选择解决方案。能用简单的方案解决问题，就不要使用复杂的方案。因为复杂的方案在解决问题的同时，也会给我们带来其他的问题。就像我们这个方案，虽然解决了我们当时的问题，但是也增加了我们系统的复杂度，例如:这其中的每一个组件出了问题，都将导致我们的日志系统不可用……,此外，工欲善其事必先利其器，我们虽然解决了器的问题，但是要想”善我们的事”还有很长的路要走，因为究其根本，日志记不记录，在什么地方记录，记录什么等级的日志，还是由我们选择去记录。日志记录无规范、乱记、瞎记，如何规范日志的记录才是是我们接下来要解决的大问题！欢迎大家留言，探讨这些问题！</p>"},{"title":".NET日志记录-log4net","copyright":true,"date":"2018-11-13T02:33:18.000Z","keywords":"日志记录,log4net","aside":"log","_content":"\n### 1.概述\nlog4net是.Net下一个非常优秀的开源日志记录组件。log4net记录日志的功能非常强大。它可以将日志分不同的等级，以不同的格式，输出到不同的媒介。\n\n<!--more-->\n\n### 2.Log4net的主要组成部分\n#### 2.1 **Appenders**\nAppenders用来定义日志的输出方式，即日志要写到那种介质上去。较常用的Log4net已经实现好了，直接在配置文件中调用即可，可参见上面配置文件例子；当然也可以自己写一个，需要从log4net.Appender.AppenderSkeleton类继承。它还可以通过配置Filters和Layout来实现日志的过滤和输出格式。\n\n已经实现的输出方式有：\n```\nAdoNetAppender 将日志记录到数据库中。可以采用SQL和存储过程两种方式。\n\nAnsiColorTerminalAppender 将日志高亮输出到ANSI终端。\n\nAspNetTraceAppender  能用asp.net中Trace的方式查看记录的日志。\n\nBufferingForwardingAppender 在输出到子Appenders之前先缓存日志事件。\n\nConsoleAppender 将日志输出到应用程序控制台。\n\nEventLogAppender 将日志写到Windows Event Log。\n\nFileAppender 将日志输出到文件。\n\nForwardingAppender 发送日志事件到子Appenders。\n\nLocalSyslogAppender 将日志写到local syslog service (仅用于UNIX环境下)。\n\nMemoryAppender 将日志存到内存缓冲区。\n\nNetSendAppender 将日志输出到Windows Messenger service.这些日志信息将在用户终端的对话框中显示。\n\nOutputDebugStringAppender 将日志输出到Debuger，如果程序没有Debuger，就输出到系统Debuger。如果系统Debuger也不可用，将忽略消息。\n\nRemoteSyslogAppender 通过UDP网络协议将日志写到Remote syslog service。\n\nRemotingAppender 通过.NET Remoting将日志写到远程接收端。\n\nRollingFileAppender 将日志以回滚文件的形式写到文件中。\n\nSmtpAppender 将日志写到邮件中。\n\nSmtpPickupDirAppender 将消息以文件的方式放入一个目录中，像IIS SMTP agent这样的SMTP代理就可以阅读或发送它们。\n\nTelnetAppender 客户端通过Telnet来接受日志事件。\n\nTraceAppender 将日志写到.NET trace 系统。\n\nUdpAppender 将日志以无连接UDP数据报的形式送到远程宿主或用UdpClient的形式广播。\n\n```\n\n#### **2.2 Filters**\n\n使用过滤器可以过滤掉Appender输出的内容。过滤器通常有以下几种：\n```\nDenyAllFilter 阻止所有的日志事件被记录\n\nLevelMatchFilter 只有指定等级的日志事件才被记录\n\nLevelRangeFilter 日志等级在指定范围内的事件才被记录\n\nLoggerMatchFilter 与Logger名称匹配，才记录\n\nPropertyFilter 消息匹配指定的属性值时才被记录\n\nStringMathFilter 消息匹配指定的字符串才被记录\n```\n\n#### **2.3 Layouts**\n\nLayout用于控制Appender的输出格式，可以是线性的也可以是XML。\n\n一个Appender只能有一个Layout。\n\n最常用的Layout应该是经典格式的PatternLayout，其次是SimpleLayout，RawTimeStampLayout和ExceptionLayout。然后还有IRawLayout，XMLLayout等几个，使用较少。Layout可以自己实现，需要从log4net.Layout.LayoutSkeleton类继承，来输出一些特殊需要的格式，在后面扩展时就重新实现了一个Layout。\n```\nSimpleLayout 简单输出格式，只输出日志级别与消息内容。\n\nRawTimeStampLayout 用来格式化时间，在向数据库输出时会用到。样式如“yyyy-MM-dd HH:mm:ss“\n\nExceptionLayout 需要给Logger的方法传入Exception对象作为参数才起作用，否则就什么也不输出。输出的时候会包含Message和Trace。\n\nPatternLayout 使用最多的一个Layout，能输出的信息很多，使用方式可参见上面例子中的配置文件。PatterLayout的格式化字符串见文后附注8.1。\n```\n\n#### **2.4 Loggers**\n\nLogger是直接和应用程序交互的组件。Logger只是产生日志，然后由它引用的Appender记录到指定的媒介，并由Layout控制输出格式。\n\nLogger提供了多种方式来记录一个日志消息，也可以有多个Logger同时存在。每个实例化的Logger对象对被log4net作为命名实体（Named Entity）来维护。log4net使用继承体系，也就是说假如存在两个Logger，名字分别为a.b.c和a.b。那么a.b就是a.b.c的祖先。每个Logger都继承了它祖先的属性。所有的Logger都从Root继承,Root本身也是一个Logger。\n\n日志的等级，它们由高到底分别为：\n```\nOFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG  &gt; ALL \n```\n\n高于等级设定值方法（如何设置参见“配置文件详解”）都能写入日志， Off所有的写入方法都不写到日志里，ALL则相反。例如当我们设成Info时，logger.Debug就会被忽略而不写入文件，但是FATAL,ERROR,WARN,INFO会被写入，因为他们等级高于INFO。\n\n在具体写日志时，一般可以这样理解日志等级：\n```\nFATAL（致命错误）：记录系统中出现的能使用系统完全失去功能，服务停止，系统崩溃等使系统无法继续运行下去的错误。例如，数据库无法连接，系统出现死循环。\n\nERROR（一般错误）：记录系统中出现的导致系统不稳定，部分功能出现混乱或部分功能失效一类的错误。例如，数据字段为空，数据操作不可完成，操作出现异常等。\n\nWARN（警告）：记录系统中不影响系统继续运行，但不符合系统运行正常条件，有可能引起系统错误的信息。例如，记录内容为空，数据内容不正确等。\n\nINFO（一般信息）：记录系统运行中应该让用户知道的基本信息。例如，服务开始运行，功能已经开户等。\n\nDEBUG （调试信息）：记录系统用于调试的一切信息，内容或者是一些关键数据内容的输出。\n```\nLogger实现的ILog接口，ILog定义了5个方法（Debug,Inof,Warn,Error,Fatal）分别对不同的日志等级记录日志。这5个方法还有5个重载。以Debug为例说明一下，其它的和它差不多。\n\nILog中对Debug方法的定义如下：\n```\nvoid Debug(object message);\n\nvoid Debug(object message, Exception ex);\n```\n还有一个布尔属性：\n```\nbool IsDebugEnabled { get; }\n```\n如果使用Debug(object message, Exception ex)，则无论Layout中是否定义了%exception，默认配置下日志都会输出Exception。包括Exception的Message和Trace。如果使用Debug(object message)，则日志是不会输出Exception。\n\n最后还要说一个LogManager类，它用来管理所有的Logger。它的GetLogger静态方法，可以获得配置文件中相应的Logger：\n```\nlog4net.ILog log = log4net.LogManager.GetLogger(\"logger-name\");\n```\n\n#### **2.5 Object Renders**\n\n它将告诉logger如何把一个对象转化为一个字符串记录到日志里。（ILog中定义的接口接收的参数是Object，而不是String。）\n\n例如你想把Orange对象记录到日志中，但此时logger只会调用Orange默认的ToString方法而已。所以要定义一个OrangeRender类实现log4net.ObjectRender.IObjectRender接口，然后注册它（我们在本文中的扩展不使用这种方法，而是直接实现一个自定义的Layout）。这时logger就会知道如何把Orange记录到日志中了。\n\n#### **2.6 Repository**\n\nRepository主要用于日志对象组织结构的维护。\n\n### 3.配置文件详解\n\n#### **3.1 配置文件构成**\n\n主要有两大部分，一是申明一个名为“log4net“的自定义配置节，如下所示：\n```\n&lt;configSections&gt;\n    &lt;section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\" /&gt;\n&lt;/configSections&gt;\n&lt;log4net&gt;\n    ...\n    ...\n    ...\n&lt;/log4net&gt;\n```\n二是&lt;log4net&gt;节的具体配置，这是下面要重点说明的。\n#### 3.1.1 &lt;log4net&gt;\n\n所有的配置都要在&lt;log4net&gt;元素里定义。\n\n支持的属性：\n\n| 属性      | 详解                                                         |\n| --------- | ------------------------------------------------------------ |\n| debug     | 可选，取值是true或false，默认是false。设置为true，开启log4net的内部调试。 |\n| update    | 可选，取值是Merge(合并)或Overwrite(覆盖)，默认值是Merge。设置为Overwrite，在提交配置的时候会重置已经配置过的库。 |\n| threshold | 可选，取值是repository（库）中注册的level，默认值是ALL。     |\n\n支持的子元素：\n\n| 属性     |   详解   |\n| -------- | :------: |\n| appender | 0或多个  |\n| logger   | 0或多个  |\n| renderer | 0或多个  |\n| root     | 最多一个 |\n| param    | 0或多个  |\n\n#### 3.1.2 &lt;root&gt;\n\n实际上就是一个根logger，所有其它logger都默认继承它，如果配置文件里没有显式定义，则框架使用根日志中定义的属性。root元素没有属性。\n\n支持的子元素：\n\n| 属性         |                       详解                        |\n| ------------ | :-----------------------------------------------: |\n| appender-ref |        0个或多个，要引用的appender的名字。        |\n| level        | 最多一个。 只有在这个级别或之上的事件才会被记录。 |\n| param        |            0个或多个， 设置一些参数。             |\n\n#### 3.1.3 &lt;logger&gt;\n支持的属性：\n\n| 属性       |                             详解                             |\n| ---------- | :----------------------------------------------------------: |\n| name       |                     必须的，logger的名称                     |\n| additivity | 可选，取值是true或false，默认值是true。设置为false时将阻止父logger中的appender。 |\n\n支持的子元素：\n\n| 属性         |                       详解                        |\n| ------------ | :-----------------------------------------------: |\n| appender-ref |        0个或多个，要引用的appender的名字。        |\n| level        | 最多一个。 只有在这个级别或之上的事件才会被记录。 |\n| param        |            0个或多个， 设置一些参数。             |\n\n#### 3.1.4 &lt;appender&gt;\n定义日志的输出方式，只能作为 log4net 的子元素。name属性必须唯一，type属性必须指定。\n\n支持的属性：\n\n| 属性 |              详解              |\n| ---- | :----------------------------: |\n| name |   必须的，Appender对象的名称   |\n| type | 必须的，Appender对象的输出类型 |\n\n支持的子元素：\n\n| 属性         |                             详解                             |\n| ------------ | :----------------------------------------------------------: |\n| appender-ref | 0个或多个，允许此appender引用其他appender，并不是所以appender类型都支持。 |\n| filter       |              0个或多个，定义此app使用的过滤器。              |\n| layout       |            最多一个。定义appender使用的输出格式。            |\n| param        |         0个或多个， 设置Appender类中对应的属性的值。         |\n\n实际上&lt;appender&gt;所能包含的子元素远不止上面4个。\n\n#### 3.1.5 &lt;layout&gt;\n\n布局，只能作为&lt;appender&gt;的子元素。\n\n支持的属性：\n\n| 属性 |         详解         |\n| ---- | :------------------: |\n| type | 必须的，Layout的类型 |\n\n支持的子元素：\n\n| 属性  |            详解            |\n| ----- | :------------------------: |\n| param | 0个或多个， 设置一些参数。 |\n\n#### 3.1.6 &lt;filter&gt;\n过滤器，只能作为&lt;appender&gt;的子元素。\n\n支持的属性：\n\n| 属性 |         详解         |\n| ---- | :------------------: |\n| type | 必须的，Filter的类型 |\n\n支持的子元素：\n\n| 属性  |            详解            |\n| ----- | :------------------------: |\n| param | 0个或多个， 设置一些参数。 |\n\n#### 3.1.7 &lt;param&gt;\n\n&lt;param&gt;元素可以是任何元素的子元素。\n\n支持的属性：\n\n| 属性  |                             详解                             |\n| ----- | :----------------------------------------------------------: |\n| name  |                必须的，取值是父对象的参数名。                |\n| value | 可选的，value和type中，必须有一个属性被指定。value是一个能被转化为参数值的字符串。 |\n| type  | 可选的，value和type中，必须有一个属性被指定。type是一个类型名，如果type不是在log4net程序集中定义的，就需要使用全名。 |\n\n支持的子元素：\n\n| 属性  |            详解            |\n| ----- | :------------------------: |\n| param | 0个或多个， 设置一些参数。 |\n\n### 4. 关联配置文件\n\nlog4net默认关联的是应用程序的配置文件App.config(BS程序是Web.config)，可以使用程序集自定义属性来进行设置。下面来介绍一下这个自定义属性：\n\nlog4net.Config.XmlConifguratorAttribute\n\nXmlConfiguratorAttribute有3个属性：\n\nConfigFile： 配置文件的名字，文件路径相对于应用程序目录\n\n(AppDomain.CurrentDomain.BaseDirectory)。ConfigFile属性不能和ConfigFileExtension属性一起使用。\n\nConfigFileExtension： 配置文件的扩展名，文件路径相对于应用程序的目录。ConfigFileExtension属性不能和ConfigFile属性一起使用。\n\nWatch： 如果将Watch属性设置为true，就会监视配置文件。当配置文件发生变化的时候，就会重新加载。\n\n如果ConfigFile和ConfigFileExtension都没有设置，则使用应用程序的配置文件App.config（Web.config）。\n\n可以在项目的AssemblyInfo.cs文件里添加以下的语句：\n\n```\n\n//监视默认的配置文件，App.config \n[assembly: log4net.Config.XmlConfigurator(Watch = true)]\n\n//使用配置文件log4net.config，不监视改变。注意log4net.config文件的目录，BS程序在站点目录//下，CS则在应用程序启动目录下，如调试时在/bin/Debug下，一般将文件属性的文件输出目录调为//始终复制即可\n\n[assembly: log4net.Config.XmlConfigurator(ConfigFile = \"log4net.config\")]\n\n\n//使用配置文件log4net.config，不监视改变\n\n[assembly: log4net.Config.XmlConfigurator()]\n```\n\n\n也可以在Global.asax的Application_Start里或者是Program.cs中的Main方法中添加，注意这里一定是绝对路径，如下所示：\n```\n//这是在BS程序下，使用自定义的配置文件log4net.config，使用Server.MapPath(\"~\") + //@\"/log4net.config”来取得路径。/log4net.config为相对于站点的路径\n\n// ConfigureAndWatch()相当于Configure(Watch = true)\n\nlog4net.Config.XmlConfigurator.ConfigureAndWatch(new System.IO.FileInfo(Server.MapPath(\"~\") + @\"/log4net.config\"));\n```\n```\n//这是在CS程序下，可以用以下方法获得：\n\nstring assemblyFilePath = Assembly.GetExecutingAssembly().Location;\n\nstring assemblyDirPath = Path.GetDirectoryName(assemblyFilePath);\n\nstring configFilePath = assemblyDirPath + \" //log4net.config\";\n\nlog4net.Config.XmlConfigurator.ConfigureAndWatch(new FileInfo(configFilePath));\n```\n或直接使用绝对路径：\n```\n//使用自定义的配置文件，直接绝对路径为：c:/log4net.config\n\nlog4net.Config.XmlConfigurator.Configure(new System.IO.FileInfo(@\"c:/log4net.config\"));\n```\n\n&lt;/font&gt;","source":"_posts/log/NET日志记录-log4net.md","raw":"---\ntitle: .NET日志记录-log4net\ncopyright: true\ndate: 2018-11-13 10:33:18\ntags: \n- 日志\n- log4net \ncategories: 日志\nkeywords: 日志记录,log4net\naside: log\n---\n\n### 1.概述\nlog4net是.Net下一个非常优秀的开源日志记录组件。log4net记录日志的功能非常强大。它可以将日志分不同的等级，以不同的格式，输出到不同的媒介。\n\n<!--more-->\n\n### 2.Log4net的主要组成部分\n#### 2.1 **Appenders**\nAppenders用来定义日志的输出方式，即日志要写到那种介质上去。较常用的Log4net已经实现好了，直接在配置文件中调用即可，可参见上面配置文件例子；当然也可以自己写一个，需要从log4net.Appender.AppenderSkeleton类继承。它还可以通过配置Filters和Layout来实现日志的过滤和输出格式。\n\n已经实现的输出方式有：\n```\nAdoNetAppender 将日志记录到数据库中。可以采用SQL和存储过程两种方式。\n\nAnsiColorTerminalAppender 将日志高亮输出到ANSI终端。\n\nAspNetTraceAppender  能用asp.net中Trace的方式查看记录的日志。\n\nBufferingForwardingAppender 在输出到子Appenders之前先缓存日志事件。\n\nConsoleAppender 将日志输出到应用程序控制台。\n\nEventLogAppender 将日志写到Windows Event Log。\n\nFileAppender 将日志输出到文件。\n\nForwardingAppender 发送日志事件到子Appenders。\n\nLocalSyslogAppender 将日志写到local syslog service (仅用于UNIX环境下)。\n\nMemoryAppender 将日志存到内存缓冲区。\n\nNetSendAppender 将日志输出到Windows Messenger service.这些日志信息将在用户终端的对话框中显示。\n\nOutputDebugStringAppender 将日志输出到Debuger，如果程序没有Debuger，就输出到系统Debuger。如果系统Debuger也不可用，将忽略消息。\n\nRemoteSyslogAppender 通过UDP网络协议将日志写到Remote syslog service。\n\nRemotingAppender 通过.NET Remoting将日志写到远程接收端。\n\nRollingFileAppender 将日志以回滚文件的形式写到文件中。\n\nSmtpAppender 将日志写到邮件中。\n\nSmtpPickupDirAppender 将消息以文件的方式放入一个目录中，像IIS SMTP agent这样的SMTP代理就可以阅读或发送它们。\n\nTelnetAppender 客户端通过Telnet来接受日志事件。\n\nTraceAppender 将日志写到.NET trace 系统。\n\nUdpAppender 将日志以无连接UDP数据报的形式送到远程宿主或用UdpClient的形式广播。\n\n```\n\n#### **2.2 Filters**\n\n使用过滤器可以过滤掉Appender输出的内容。过滤器通常有以下几种：\n```\nDenyAllFilter 阻止所有的日志事件被记录\n\nLevelMatchFilter 只有指定等级的日志事件才被记录\n\nLevelRangeFilter 日志等级在指定范围内的事件才被记录\n\nLoggerMatchFilter 与Logger名称匹配，才记录\n\nPropertyFilter 消息匹配指定的属性值时才被记录\n\nStringMathFilter 消息匹配指定的字符串才被记录\n```\n\n#### **2.3 Layouts**\n\nLayout用于控制Appender的输出格式，可以是线性的也可以是XML。\n\n一个Appender只能有一个Layout。\n\n最常用的Layout应该是经典格式的PatternLayout，其次是SimpleLayout，RawTimeStampLayout和ExceptionLayout。然后还有IRawLayout，XMLLayout等几个，使用较少。Layout可以自己实现，需要从log4net.Layout.LayoutSkeleton类继承，来输出一些特殊需要的格式，在后面扩展时就重新实现了一个Layout。\n```\nSimpleLayout 简单输出格式，只输出日志级别与消息内容。\n\nRawTimeStampLayout 用来格式化时间，在向数据库输出时会用到。样式如“yyyy-MM-dd HH:mm:ss“\n\nExceptionLayout 需要给Logger的方法传入Exception对象作为参数才起作用，否则就什么也不输出。输出的时候会包含Message和Trace。\n\nPatternLayout 使用最多的一个Layout，能输出的信息很多，使用方式可参见上面例子中的配置文件。PatterLayout的格式化字符串见文后附注8.1。\n```\n\n#### **2.4 Loggers**\n\nLogger是直接和应用程序交互的组件。Logger只是产生日志，然后由它引用的Appender记录到指定的媒介，并由Layout控制输出格式。\n\nLogger提供了多种方式来记录一个日志消息，也可以有多个Logger同时存在。每个实例化的Logger对象对被log4net作为命名实体（Named Entity）来维护。log4net使用继承体系，也就是说假如存在两个Logger，名字分别为a.b.c和a.b。那么a.b就是a.b.c的祖先。每个Logger都继承了它祖先的属性。所有的Logger都从Root继承,Root本身也是一个Logger。\n\n日志的等级，它们由高到底分别为：\n```\nOFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG  &gt; ALL \n```\n\n高于等级设定值方法（如何设置参见“配置文件详解”）都能写入日志， Off所有的写入方法都不写到日志里，ALL则相反。例如当我们设成Info时，logger.Debug就会被忽略而不写入文件，但是FATAL,ERROR,WARN,INFO会被写入，因为他们等级高于INFO。\n\n在具体写日志时，一般可以这样理解日志等级：\n```\nFATAL（致命错误）：记录系统中出现的能使用系统完全失去功能，服务停止，系统崩溃等使系统无法继续运行下去的错误。例如，数据库无法连接，系统出现死循环。\n\nERROR（一般错误）：记录系统中出现的导致系统不稳定，部分功能出现混乱或部分功能失效一类的错误。例如，数据字段为空，数据操作不可完成，操作出现异常等。\n\nWARN（警告）：记录系统中不影响系统继续运行，但不符合系统运行正常条件，有可能引起系统错误的信息。例如，记录内容为空，数据内容不正确等。\n\nINFO（一般信息）：记录系统运行中应该让用户知道的基本信息。例如，服务开始运行，功能已经开户等。\n\nDEBUG （调试信息）：记录系统用于调试的一切信息，内容或者是一些关键数据内容的输出。\n```\nLogger实现的ILog接口，ILog定义了5个方法（Debug,Inof,Warn,Error,Fatal）分别对不同的日志等级记录日志。这5个方法还有5个重载。以Debug为例说明一下，其它的和它差不多。\n\nILog中对Debug方法的定义如下：\n```\nvoid Debug(object message);\n\nvoid Debug(object message, Exception ex);\n```\n还有一个布尔属性：\n```\nbool IsDebugEnabled { get; }\n```\n如果使用Debug(object message, Exception ex)，则无论Layout中是否定义了%exception，默认配置下日志都会输出Exception。包括Exception的Message和Trace。如果使用Debug(object message)，则日志是不会输出Exception。\n\n最后还要说一个LogManager类，它用来管理所有的Logger。它的GetLogger静态方法，可以获得配置文件中相应的Logger：\n```\nlog4net.ILog log = log4net.LogManager.GetLogger(\"logger-name\");\n```\n\n#### **2.5 Object Renders**\n\n它将告诉logger如何把一个对象转化为一个字符串记录到日志里。（ILog中定义的接口接收的参数是Object，而不是String。）\n\n例如你想把Orange对象记录到日志中，但此时logger只会调用Orange默认的ToString方法而已。所以要定义一个OrangeRender类实现log4net.ObjectRender.IObjectRender接口，然后注册它（我们在本文中的扩展不使用这种方法，而是直接实现一个自定义的Layout）。这时logger就会知道如何把Orange记录到日志中了。\n\n#### **2.6 Repository**\n\nRepository主要用于日志对象组织结构的维护。\n\n### 3.配置文件详解\n\n#### **3.1 配置文件构成**\n\n主要有两大部分，一是申明一个名为“log4net“的自定义配置节，如下所示：\n```\n&lt;configSections&gt;\n    &lt;section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\" /&gt;\n&lt;/configSections&gt;\n&lt;log4net&gt;\n    ...\n    ...\n    ...\n&lt;/log4net&gt;\n```\n二是&lt;log4net&gt;节的具体配置，这是下面要重点说明的。\n#### 3.1.1 &lt;log4net&gt;\n\n所有的配置都要在&lt;log4net&gt;元素里定义。\n\n支持的属性：\n\n| 属性      | 详解                                                         |\n| --------- | ------------------------------------------------------------ |\n| debug     | 可选，取值是true或false，默认是false。设置为true，开启log4net的内部调试。 |\n| update    | 可选，取值是Merge(合并)或Overwrite(覆盖)，默认值是Merge。设置为Overwrite，在提交配置的时候会重置已经配置过的库。 |\n| threshold | 可选，取值是repository（库）中注册的level，默认值是ALL。     |\n\n支持的子元素：\n\n| 属性     |   详解   |\n| -------- | :------: |\n| appender | 0或多个  |\n| logger   | 0或多个  |\n| renderer | 0或多个  |\n| root     | 最多一个 |\n| param    | 0或多个  |\n\n#### 3.1.2 &lt;root&gt;\n\n实际上就是一个根logger，所有其它logger都默认继承它，如果配置文件里没有显式定义，则框架使用根日志中定义的属性。root元素没有属性。\n\n支持的子元素：\n\n| 属性         |                       详解                        |\n| ------------ | :-----------------------------------------------: |\n| appender-ref |        0个或多个，要引用的appender的名字。        |\n| level        | 最多一个。 只有在这个级别或之上的事件才会被记录。 |\n| param        |            0个或多个， 设置一些参数。             |\n\n#### 3.1.3 &lt;logger&gt;\n支持的属性：\n\n| 属性       |                             详解                             |\n| ---------- | :----------------------------------------------------------: |\n| name       |                     必须的，logger的名称                     |\n| additivity | 可选，取值是true或false，默认值是true。设置为false时将阻止父logger中的appender。 |\n\n支持的子元素：\n\n| 属性         |                       详解                        |\n| ------------ | :-----------------------------------------------: |\n| appender-ref |        0个或多个，要引用的appender的名字。        |\n| level        | 最多一个。 只有在这个级别或之上的事件才会被记录。 |\n| param        |            0个或多个， 设置一些参数。             |\n\n#### 3.1.4 &lt;appender&gt;\n定义日志的输出方式，只能作为 log4net 的子元素。name属性必须唯一，type属性必须指定。\n\n支持的属性：\n\n| 属性 |              详解              |\n| ---- | :----------------------------: |\n| name |   必须的，Appender对象的名称   |\n| type | 必须的，Appender对象的输出类型 |\n\n支持的子元素：\n\n| 属性         |                             详解                             |\n| ------------ | :----------------------------------------------------------: |\n| appender-ref | 0个或多个，允许此appender引用其他appender，并不是所以appender类型都支持。 |\n| filter       |              0个或多个，定义此app使用的过滤器。              |\n| layout       |            最多一个。定义appender使用的输出格式。            |\n| param        |         0个或多个， 设置Appender类中对应的属性的值。         |\n\n实际上&lt;appender&gt;所能包含的子元素远不止上面4个。\n\n#### 3.1.5 &lt;layout&gt;\n\n布局，只能作为&lt;appender&gt;的子元素。\n\n支持的属性：\n\n| 属性 |         详解         |\n| ---- | :------------------: |\n| type | 必须的，Layout的类型 |\n\n支持的子元素：\n\n| 属性  |            详解            |\n| ----- | :------------------------: |\n| param | 0个或多个， 设置一些参数。 |\n\n#### 3.1.6 &lt;filter&gt;\n过滤器，只能作为&lt;appender&gt;的子元素。\n\n支持的属性：\n\n| 属性 |         详解         |\n| ---- | :------------------: |\n| type | 必须的，Filter的类型 |\n\n支持的子元素：\n\n| 属性  |            详解            |\n| ----- | :------------------------: |\n| param | 0个或多个， 设置一些参数。 |\n\n#### 3.1.7 &lt;param&gt;\n\n&lt;param&gt;元素可以是任何元素的子元素。\n\n支持的属性：\n\n| 属性  |                             详解                             |\n| ----- | :----------------------------------------------------------: |\n| name  |                必须的，取值是父对象的参数名。                |\n| value | 可选的，value和type中，必须有一个属性被指定。value是一个能被转化为参数值的字符串。 |\n| type  | 可选的，value和type中，必须有一个属性被指定。type是一个类型名，如果type不是在log4net程序集中定义的，就需要使用全名。 |\n\n支持的子元素：\n\n| 属性  |            详解            |\n| ----- | :------------------------: |\n| param | 0个或多个， 设置一些参数。 |\n\n### 4. 关联配置文件\n\nlog4net默认关联的是应用程序的配置文件App.config(BS程序是Web.config)，可以使用程序集自定义属性来进行设置。下面来介绍一下这个自定义属性：\n\nlog4net.Config.XmlConifguratorAttribute\n\nXmlConfiguratorAttribute有3个属性：\n\nConfigFile： 配置文件的名字，文件路径相对于应用程序目录\n\n(AppDomain.CurrentDomain.BaseDirectory)。ConfigFile属性不能和ConfigFileExtension属性一起使用。\n\nConfigFileExtension： 配置文件的扩展名，文件路径相对于应用程序的目录。ConfigFileExtension属性不能和ConfigFile属性一起使用。\n\nWatch： 如果将Watch属性设置为true，就会监视配置文件。当配置文件发生变化的时候，就会重新加载。\n\n如果ConfigFile和ConfigFileExtension都没有设置，则使用应用程序的配置文件App.config（Web.config）。\n\n可以在项目的AssemblyInfo.cs文件里添加以下的语句：\n\n```\n\n//监视默认的配置文件，App.config \n[assembly: log4net.Config.XmlConfigurator(Watch = true)]\n\n//使用配置文件log4net.config，不监视改变。注意log4net.config文件的目录，BS程序在站点目录//下，CS则在应用程序启动目录下，如调试时在/bin/Debug下，一般将文件属性的文件输出目录调为//始终复制即可\n\n[assembly: log4net.Config.XmlConfigurator(ConfigFile = \"log4net.config\")]\n\n\n//使用配置文件log4net.config，不监视改变\n\n[assembly: log4net.Config.XmlConfigurator()]\n```\n\n\n也可以在Global.asax的Application_Start里或者是Program.cs中的Main方法中添加，注意这里一定是绝对路径，如下所示：\n```\n//这是在BS程序下，使用自定义的配置文件log4net.config，使用Server.MapPath(\"~\") + //@\"/log4net.config”来取得路径。/log4net.config为相对于站点的路径\n\n// ConfigureAndWatch()相当于Configure(Watch = true)\n\nlog4net.Config.XmlConfigurator.ConfigureAndWatch(new System.IO.FileInfo(Server.MapPath(\"~\") + @\"/log4net.config\"));\n```\n```\n//这是在CS程序下，可以用以下方法获得：\n\nstring assemblyFilePath = Assembly.GetExecutingAssembly().Location;\n\nstring assemblyDirPath = Path.GetDirectoryName(assemblyFilePath);\n\nstring configFilePath = assemblyDirPath + \" //log4net.config\";\n\nlog4net.Config.XmlConfigurator.ConfigureAndWatch(new FileInfo(configFilePath));\n```\n或直接使用绝对路径：\n```\n//使用自定义的配置文件，直接绝对路径为：c:/log4net.config\n\nlog4net.Config.XmlConfigurator.Configure(new System.IO.FileInfo(@\"c:/log4net.config\"));\n```\n\n&lt;/font&gt;","slug":"log/NET日志记录-log4net","published":1,"updated":"2021-03-14T03:04:50.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpsp000rhyjfi5hbo0mi","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h3><p>log4net是.Net下一个非常优秀的开源日志记录组件。log4net记录日志的功能非常强大。它可以将日志分不同的等级，以不同的格式，输出到不同的媒介。</p>\n<a id=\"more\"></a>\n<h3 id=\"2-Log4net的主要组成部分\"><a href=\"#2-Log4net的主要组成部分\" class=\"headerlink\" title=\"2.Log4net的主要组成部分\"></a>2.Log4net的主要组成部分</h3><h4 id=\"2-1-Appenders\"><a href=\"#2-1-Appenders\" class=\"headerlink\" title=\"2.1 Appenders\"></a>2.1 <strong>Appenders</strong></h4><p>Appenders用来定义日志的输出方式，即日志要写到那种介质上去。较常用的Log4net已经实现好了，直接在配置文件中调用即可，可参见上面配置文件例子；当然也可以自己写一个，需要从log4net.Appender.AppenderSkeleton类继承。它还可以通过配置Filters和Layout来实现日志的过滤和输出格式。</p>\n<p>已经实现的输出方式有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AdoNetAppender 将日志记录到数据库中。可以采用SQL和存储过程两种方式。</span><br><span class=\"line\"></span><br><span class=\"line\">AnsiColorTerminalAppender 将日志高亮输出到ANSI终端。</span><br><span class=\"line\"></span><br><span class=\"line\">AspNetTraceAppender  能用asp.net中Trace的方式查看记录的日志。</span><br><span class=\"line\"></span><br><span class=\"line\">BufferingForwardingAppender 在输出到子Appenders之前先缓存日志事件。</span><br><span class=\"line\"></span><br><span class=\"line\">ConsoleAppender 将日志输出到应用程序控制台。</span><br><span class=\"line\"></span><br><span class=\"line\">EventLogAppender 将日志写到Windows Event Log。</span><br><span class=\"line\"></span><br><span class=\"line\">FileAppender 将日志输出到文件。</span><br><span class=\"line\"></span><br><span class=\"line\">ForwardingAppender 发送日志事件到子Appenders。</span><br><span class=\"line\"></span><br><span class=\"line\">LocalSyslogAppender 将日志写到local syslog service (仅用于UNIX环境下)。</span><br><span class=\"line\"></span><br><span class=\"line\">MemoryAppender 将日志存到内存缓冲区。</span><br><span class=\"line\"></span><br><span class=\"line\">NetSendAppender 将日志输出到Windows Messenger service.这些日志信息将在用户终端的对话框中显示。</span><br><span class=\"line\"></span><br><span class=\"line\">OutputDebugStringAppender 将日志输出到Debuger，如果程序没有Debuger，就输出到系统Debuger。如果系统Debuger也不可用，将忽略消息。</span><br><span class=\"line\"></span><br><span class=\"line\">RemoteSyslogAppender 通过UDP网络协议将日志写到Remote syslog service。</span><br><span class=\"line\"></span><br><span class=\"line\">RemotingAppender 通过.NET Remoting将日志写到远程接收端。</span><br><span class=\"line\"></span><br><span class=\"line\">RollingFileAppender 将日志以回滚文件的形式写到文件中。</span><br><span class=\"line\"></span><br><span class=\"line\">SmtpAppender 将日志写到邮件中。</span><br><span class=\"line\"></span><br><span class=\"line\">SmtpPickupDirAppender 将消息以文件的方式放入一个目录中，像IIS SMTP agent这样的SMTP代理就可以阅读或发送它们。</span><br><span class=\"line\"></span><br><span class=\"line\">TelnetAppender 客户端通过Telnet来接受日志事件。</span><br><span class=\"line\"></span><br><span class=\"line\">TraceAppender 将日志写到.NET trace 系统。</span><br><span class=\"line\"></span><br><span class=\"line\">UdpAppender 将日志以无连接UDP数据报的形式送到远程宿主或用UdpClient的形式广播。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-2-Filters\"><a href=\"#2-2-Filters\" class=\"headerlink\" title=\"2.2 Filters\"></a><strong>2.2 Filters</strong></h4><p>使用过滤器可以过滤掉Appender输出的内容。过滤器通常有以下几种：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DenyAllFilter 阻止所有的日志事件被记录</span><br><span class=\"line\"></span><br><span class=\"line\">LevelMatchFilter 只有指定等级的日志事件才被记录</span><br><span class=\"line\"></span><br><span class=\"line\">LevelRangeFilter 日志等级在指定范围内的事件才被记录</span><br><span class=\"line\"></span><br><span class=\"line\">LoggerMatchFilter 与Logger名称匹配，才记录</span><br><span class=\"line\"></span><br><span class=\"line\">PropertyFilter 消息匹配指定的属性值时才被记录</span><br><span class=\"line\"></span><br><span class=\"line\">StringMathFilter 消息匹配指定的字符串才被记录</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-3-Layouts\"><a href=\"#2-3-Layouts\" class=\"headerlink\" title=\"2.3 Layouts\"></a><strong>2.3 Layouts</strong></h4><p>Layout用于控制Appender的输出格式，可以是线性的也可以是XML。</p>\n<p>一个Appender只能有一个Layout。</p>\n<p>最常用的Layout应该是经典格式的PatternLayout，其次是SimpleLayout，RawTimeStampLayout和ExceptionLayout。然后还有IRawLayout，XMLLayout等几个，使用较少。Layout可以自己实现，需要从log4net.Layout.LayoutSkeleton类继承，来输出一些特殊需要的格式，在后面扩展时就重新实现了一个Layout。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SimpleLayout 简单输出格式，只输出日志级别与消息内容。</span><br><span class=\"line\"></span><br><span class=\"line\">RawTimeStampLayout 用来格式化时间，在向数据库输出时会用到。样式如“yyyy-MM-dd HH:mm:ss“</span><br><span class=\"line\"></span><br><span class=\"line\">ExceptionLayout 需要给Logger的方法传入Exception对象作为参数才起作用，否则就什么也不输出。输出的时候会包含Message和Trace。</span><br><span class=\"line\"></span><br><span class=\"line\">PatternLayout 使用最多的一个Layout，能输出的信息很多，使用方式可参见上面例子中的配置文件。PatterLayout的格式化字符串见文后附注8.1。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-4-Loggers\"><a href=\"#2-4-Loggers\" class=\"headerlink\" title=\"2.4 Loggers\"></a><strong>2.4 Loggers</strong></h4><p>Logger是直接和应用程序交互的组件。Logger只是产生日志，然后由它引用的Appender记录到指定的媒介，并由Layout控制输出格式。</p>\n<p>Logger提供了多种方式来记录一个日志消息，也可以有多个Logger同时存在。每个实例化的Logger对象对被log4net作为命名实体（Named Entity）来维护。log4net使用继承体系，也就是说假如存在两个Logger，名字分别为a.b.c和a.b。那么a.b就是a.b.c的祖先。每个Logger都继承了它祖先的属性。所有的Logger都从Root继承,Root本身也是一个Logger。</p>\n<p>日志的等级，它们由高到底分别为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OFF &amp;gt; FATAL &amp;gt; ERROR &amp;gt; WARN &amp;gt; INFO &amp;gt; DEBUG  &amp;gt; ALL</span><br></pre></td></tr></table></figure></p>\n<p>高于等级设定值方法（如何设置参见“配置文件详解”）都能写入日志， Off所有的写入方法都不写到日志里，ALL则相反。例如当我们设成Info时，logger.Debug就会被忽略而不写入文件，但是FATAL,ERROR,WARN,INFO会被写入，因为他们等级高于INFO。</p>\n<p>在具体写日志时，一般可以这样理解日志等级：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FATAL（致命错误）：记录系统中出现的能使用系统完全失去功能，服务停止，系统崩溃等使系统无法继续运行下去的错误。例如，数据库无法连接，系统出现死循环。</span><br><span class=\"line\"></span><br><span class=\"line\">ERROR（一般错误）：记录系统中出现的导致系统不稳定，部分功能出现混乱或部分功能失效一类的错误。例如，数据字段为空，数据操作不可完成，操作出现异常等。</span><br><span class=\"line\"></span><br><span class=\"line\">WARN（警告）：记录系统中不影响系统继续运行，但不符合系统运行正常条件，有可能引起系统错误的信息。例如，记录内容为空，数据内容不正确等。</span><br><span class=\"line\"></span><br><span class=\"line\">INFO（一般信息）：记录系统运行中应该让用户知道的基本信息。例如，服务开始运行，功能已经开户等。</span><br><span class=\"line\"></span><br><span class=\"line\">DEBUG （调试信息）：记录系统用于调试的一切信息，内容或者是一些关键数据内容的输出。</span><br></pre></td></tr></table></figure></p>\n<p>Logger实现的ILog接口，ILog定义了5个方法（Debug,Inof,Warn,Error,Fatal）分别对不同的日志等级记录日志。这5个方法还有5个重载。以Debug为例说明一下，其它的和它差不多。</p>\n<p>ILog中对Debug方法的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Debug(object message);</span><br><span class=\"line\"></span><br><span class=\"line\">void Debug(object message, Exception ex);</span><br></pre></td></tr></table></figure></p>\n<p>还有一个布尔属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool IsDebugEnabled &#123; get; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果使用Debug(object message, Exception ex)，则无论Layout中是否定义了%exception，默认配置下日志都会输出Exception。包括Exception的Message和Trace。如果使用Debug(object message)，则日志是不会输出Exception。</p>\n<p>最后还要说一个LogManager类，它用来管理所有的Logger。它的GetLogger静态方法，可以获得配置文件中相应的Logger：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log4net.ILog log = log4net.LogManager.GetLogger(&quot;logger-name&quot;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-5-Object-Renders\"><a href=\"#2-5-Object-Renders\" class=\"headerlink\" title=\"2.5 Object Renders\"></a><strong>2.5 Object Renders</strong></h4><p>它将告诉logger如何把一个对象转化为一个字符串记录到日志里。（ILog中定义的接口接收的参数是Object，而不是String。）</p>\n<p>例如你想把Orange对象记录到日志中，但此时logger只会调用Orange默认的ToString方法而已。所以要定义一个OrangeRender类实现log4net.ObjectRender.IObjectRender接口，然后注册它（我们在本文中的扩展不使用这种方法，而是直接实现一个自定义的Layout）。这时logger就会知道如何把Orange记录到日志中了。</p>\n<h4 id=\"2-6-Repository\"><a href=\"#2-6-Repository\" class=\"headerlink\" title=\"2.6 Repository\"></a><strong>2.6 Repository</strong></h4><p>Repository主要用于日志对象组织结构的维护。</p>\n<h3 id=\"3-配置文件详解\"><a href=\"#3-配置文件详解\" class=\"headerlink\" title=\"3.配置文件详解\"></a>3.配置文件详解</h3><h4 id=\"3-1-配置文件构成\"><a href=\"#3-1-配置文件构成\" class=\"headerlink\" title=\"3.1 配置文件构成\"></a><strong>3.1 配置文件构成</strong></h4><p>主要有两大部分，一是申明一个名为“log4net“的自定义配置节，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;configSections&amp;gt;</span><br><span class=\"line\">    &amp;lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler, log4net&quot; /&amp;gt;</span><br><span class=\"line\">&amp;lt;/configSections&amp;gt;</span><br><span class=\"line\">&amp;lt;log4net&amp;gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&amp;lt;/log4net&amp;gt;</span><br></pre></td></tr></table></figure></p>\n<p>二是&lt;log4net&gt;节的具体配置，这是下面要重点说明的。</p>\n<h4 id=\"3-1-1-lt-log4net-gt\"><a href=\"#3-1-1-lt-log4net-gt\" class=\"headerlink\" title=\"3.1.1 &lt;log4net&gt;\"></a>3.1.1 &lt;log4net&gt;</h4><p>所有的配置都要在&lt;log4net&gt;元素里定义。</p>\n<p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>debug</td>\n<td>可选，取值是true或false，默认是false。设置为true，开启log4net的内部调试。</td>\n</tr>\n<tr>\n<td>update</td>\n<td>可选，取值是Merge(合并)或Overwrite(覆盖)，默认值是Merge。设置为Overwrite，在提交配置的时候会重置已经配置过的库。</td>\n</tr>\n<tr>\n<td>threshold</td>\n<td>可选，取值是repository（库）中注册的level，默认值是ALL。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>appender</td>\n<td style=\"text-align:center\">0或多个</td>\n</tr>\n<tr>\n<td>logger</td>\n<td style=\"text-align:center\">0或多个</td>\n</tr>\n<tr>\n<td>renderer</td>\n<td style=\"text-align:center\">0或多个</td>\n</tr>\n<tr>\n<td>root</td>\n<td style=\"text-align:center\">最多一个</td>\n</tr>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0或多个</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"3-1-2-lt-root-gt\"><a href=\"#3-1-2-lt-root-gt\" class=\"headerlink\" title=\"3.1.2 &lt;root&gt;\"></a>3.1.2 &lt;root&gt;</h4><p>实际上就是一个根logger，所有其它logger都默认继承它，如果配置文件里没有显式定义，则框架使用根日志中定义的属性。root元素没有属性。</p>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>appender-ref</td>\n<td style=\"text-align:center\">0个或多个，要引用的appender的名字。</td>\n</tr>\n<tr>\n<td>level</td>\n<td style=\"text-align:center\">最多一个。 只有在这个级别或之上的事件才会被记录。</td>\n</tr>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置一些参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"3-1-3-lt-logger-gt\"><a href=\"#3-1-3-lt-logger-gt\" class=\"headerlink\" title=\"3.1.3 &lt;logger&gt;\"></a>3.1.3 &lt;logger&gt;</h4><p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td style=\"text-align:center\">必须的，logger的名称</td>\n</tr>\n<tr>\n<td>additivity</td>\n<td style=\"text-align:center\">可选，取值是true或false，默认值是true。设置为false时将阻止父logger中的appender。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>appender-ref</td>\n<td style=\"text-align:center\">0个或多个，要引用的appender的名字。</td>\n</tr>\n<tr>\n<td>level</td>\n<td style=\"text-align:center\">最多一个。 只有在这个级别或之上的事件才会被记录。</td>\n</tr>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置一些参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"3-1-4-lt-appender-gt\"><a href=\"#3-1-4-lt-appender-gt\" class=\"headerlink\" title=\"3.1.4 &lt;appender&gt;\"></a>3.1.4 &lt;appender&gt;</h4><p>定义日志的输出方式，只能作为 log4net 的子元素。name属性必须唯一，type属性必须指定。</p>\n<p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td style=\"text-align:center\">必须的，Appender对象的名称</td>\n</tr>\n<tr>\n<td>type</td>\n<td style=\"text-align:center\">必须的，Appender对象的输出类型</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>appender-ref</td>\n<td style=\"text-align:center\">0个或多个，允许此appender引用其他appender，并不是所以appender类型都支持。</td>\n</tr>\n<tr>\n<td>filter</td>\n<td style=\"text-align:center\">0个或多个，定义此app使用的过滤器。</td>\n</tr>\n<tr>\n<td>layout</td>\n<td style=\"text-align:center\">最多一个。定义appender使用的输出格式。</td>\n</tr>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置Appender类中对应的属性的值。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>实际上&lt;appender&gt;所能包含的子元素远不止上面4个。</p>\n<h4 id=\"3-1-5-lt-layout-gt\"><a href=\"#3-1-5-lt-layout-gt\" class=\"headerlink\" title=\"3.1.5 &lt;layout&gt;\"></a>3.1.5 &lt;layout&gt;</h4><p>布局，只能作为&lt;appender&gt;的子元素。</p>\n<p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>type</td>\n<td style=\"text-align:center\">必须的，Layout的类型</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置一些参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"3-1-6-lt-filter-gt\"><a href=\"#3-1-6-lt-filter-gt\" class=\"headerlink\" title=\"3.1.6 &lt;filter&gt;\"></a>3.1.6 &lt;filter&gt;</h4><p>过滤器，只能作为&lt;appender&gt;的子元素。</p>\n<p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>type</td>\n<td style=\"text-align:center\">必须的，Filter的类型</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置一些参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"3-1-7-lt-param-gt\"><a href=\"#3-1-7-lt-param-gt\" class=\"headerlink\" title=\"3.1.7 &lt;param&gt;\"></a>3.1.7 &lt;param&gt;</h4><p>&lt;param&gt;元素可以是任何元素的子元素。</p>\n<p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td style=\"text-align:center\">必须的，取值是父对象的参数名。</td>\n</tr>\n<tr>\n<td>value</td>\n<td style=\"text-align:center\">可选的，value和type中，必须有一个属性被指定。value是一个能被转化为参数值的字符串。</td>\n</tr>\n<tr>\n<td>type</td>\n<td style=\"text-align:center\">可选的，value和type中，必须有一个属性被指定。type是一个类型名，如果type不是在log4net程序集中定义的，就需要使用全名。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置一些参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"4-关联配置文件\"><a href=\"#4-关联配置文件\" class=\"headerlink\" title=\"4. 关联配置文件\"></a>4. 关联配置文件</h3><p>log4net默认关联的是应用程序的配置文件App.config(BS程序是Web.config)，可以使用程序集自定义属性来进行设置。下面来介绍一下这个自定义属性：</p>\n<p>log4net.Config.XmlConifguratorAttribute</p>\n<p>XmlConfiguratorAttribute有3个属性：</p>\n<p>ConfigFile： 配置文件的名字，文件路径相对于应用程序目录</p>\n<p>(AppDomain.CurrentDomain.BaseDirectory)。ConfigFile属性不能和ConfigFileExtension属性一起使用。</p>\n<p>ConfigFileExtension： 配置文件的扩展名，文件路径相对于应用程序的目录。ConfigFileExtension属性不能和ConfigFile属性一起使用。</p>\n<p>Watch： 如果将Watch属性设置为true，就会监视配置文件。当配置文件发生变化的时候，就会重新加载。</p>\n<p>如果ConfigFile和ConfigFileExtension都没有设置，则使用应用程序的配置文件App.config（Web.config）。</p>\n<p>可以在项目的AssemblyInfo.cs文件里添加以下的语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">//监视默认的配置文件，App.config </span><br><span class=\"line\">[assembly: log4net.Config.XmlConfigurator(Watch = true)]</span><br><span class=\"line\"></span><br><span class=\"line\">//使用配置文件log4net.config，不监视改变。注意log4net.config文件的目录，BS程序在站点目录//下，CS则在应用程序启动目录下，如调试时在/bin/Debug下，一般将文件属性的文件输出目录调为//始终复制即可</span><br><span class=\"line\"></span><br><span class=\"line\">[assembly: log4net.Config.XmlConfigurator(ConfigFile = &quot;log4net.config&quot;)]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//使用配置文件log4net.config，不监视改变</span><br><span class=\"line\"></span><br><span class=\"line\">[assembly: log4net.Config.XmlConfigurator()]</span><br></pre></td></tr></table></figure>\n<p>也可以在Global.asax的Application_Start里或者是Program.cs中的Main方法中添加，注意这里一定是绝对路径，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这是在BS程序下，使用自定义的配置文件log4net.config，使用Server.MapPath(&quot;~&quot;) + //@&quot;/log4net.config”来取得路径。/log4net.config为相对于站点的路径</span><br><span class=\"line\"></span><br><span class=\"line\">// ConfigureAndWatch()相当于Configure(Watch = true)</span><br><span class=\"line\"></span><br><span class=\"line\">log4net.Config.XmlConfigurator.ConfigureAndWatch(new System.IO.FileInfo(Server.MapPath(&quot;~&quot;) + @&quot;/log4net.config&quot;));</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这是在CS程序下，可以用以下方法获得：</span><br><span class=\"line\"></span><br><span class=\"line\">string assemblyFilePath = Assembly.GetExecutingAssembly().Location;</span><br><span class=\"line\"></span><br><span class=\"line\">string assemblyDirPath = Path.GetDirectoryName(assemblyFilePath);</span><br><span class=\"line\"></span><br><span class=\"line\">string configFilePath = assemblyDirPath + &quot; //log4net.config&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">log4net.Config.XmlConfigurator.ConfigureAndWatch(new FileInfo(configFilePath));</span><br></pre></td></tr></table></figure>\n<p>或直接使用绝对路径：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用自定义的配置文件，直接绝对路径为：c:/log4net.config</span><br><span class=\"line\"></span><br><span class=\"line\">log4net.Config.XmlConfigurator.Configure(new System.IO.FileInfo(@&quot;c:/log4net.config&quot;));</span><br></pre></td></tr></table></figure></p>\n<p>&lt;/font&gt;</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h3><p>log4net是.Net下一个非常优秀的开源日志记录组件。log4net记录日志的功能非常强大。它可以将日志分不同的等级，以不同的格式，输出到不同的媒介。</p>","more":"<h3 id=\"2-Log4net的主要组成部分\"><a href=\"#2-Log4net的主要组成部分\" class=\"headerlink\" title=\"2.Log4net的主要组成部分\"></a>2.Log4net的主要组成部分</h3><h4 id=\"2-1-Appenders\"><a href=\"#2-1-Appenders\" class=\"headerlink\" title=\"2.1 Appenders\"></a>2.1 <strong>Appenders</strong></h4><p>Appenders用来定义日志的输出方式，即日志要写到那种介质上去。较常用的Log4net已经实现好了，直接在配置文件中调用即可，可参见上面配置文件例子；当然也可以自己写一个，需要从log4net.Appender.AppenderSkeleton类继承。它还可以通过配置Filters和Layout来实现日志的过滤和输出格式。</p>\n<p>已经实现的输出方式有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AdoNetAppender 将日志记录到数据库中。可以采用SQL和存储过程两种方式。</span><br><span class=\"line\"></span><br><span class=\"line\">AnsiColorTerminalAppender 将日志高亮输出到ANSI终端。</span><br><span class=\"line\"></span><br><span class=\"line\">AspNetTraceAppender  能用asp.net中Trace的方式查看记录的日志。</span><br><span class=\"line\"></span><br><span class=\"line\">BufferingForwardingAppender 在输出到子Appenders之前先缓存日志事件。</span><br><span class=\"line\"></span><br><span class=\"line\">ConsoleAppender 将日志输出到应用程序控制台。</span><br><span class=\"line\"></span><br><span class=\"line\">EventLogAppender 将日志写到Windows Event Log。</span><br><span class=\"line\"></span><br><span class=\"line\">FileAppender 将日志输出到文件。</span><br><span class=\"line\"></span><br><span class=\"line\">ForwardingAppender 发送日志事件到子Appenders。</span><br><span class=\"line\"></span><br><span class=\"line\">LocalSyslogAppender 将日志写到local syslog service (仅用于UNIX环境下)。</span><br><span class=\"line\"></span><br><span class=\"line\">MemoryAppender 将日志存到内存缓冲区。</span><br><span class=\"line\"></span><br><span class=\"line\">NetSendAppender 将日志输出到Windows Messenger service.这些日志信息将在用户终端的对话框中显示。</span><br><span class=\"line\"></span><br><span class=\"line\">OutputDebugStringAppender 将日志输出到Debuger，如果程序没有Debuger，就输出到系统Debuger。如果系统Debuger也不可用，将忽略消息。</span><br><span class=\"line\"></span><br><span class=\"line\">RemoteSyslogAppender 通过UDP网络协议将日志写到Remote syslog service。</span><br><span class=\"line\"></span><br><span class=\"line\">RemotingAppender 通过.NET Remoting将日志写到远程接收端。</span><br><span class=\"line\"></span><br><span class=\"line\">RollingFileAppender 将日志以回滚文件的形式写到文件中。</span><br><span class=\"line\"></span><br><span class=\"line\">SmtpAppender 将日志写到邮件中。</span><br><span class=\"line\"></span><br><span class=\"line\">SmtpPickupDirAppender 将消息以文件的方式放入一个目录中，像IIS SMTP agent这样的SMTP代理就可以阅读或发送它们。</span><br><span class=\"line\"></span><br><span class=\"line\">TelnetAppender 客户端通过Telnet来接受日志事件。</span><br><span class=\"line\"></span><br><span class=\"line\">TraceAppender 将日志写到.NET trace 系统。</span><br><span class=\"line\"></span><br><span class=\"line\">UdpAppender 将日志以无连接UDP数据报的形式送到远程宿主或用UdpClient的形式广播。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-2-Filters\"><a href=\"#2-2-Filters\" class=\"headerlink\" title=\"2.2 Filters\"></a><strong>2.2 Filters</strong></h4><p>使用过滤器可以过滤掉Appender输出的内容。过滤器通常有以下几种：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DenyAllFilter 阻止所有的日志事件被记录</span><br><span class=\"line\"></span><br><span class=\"line\">LevelMatchFilter 只有指定等级的日志事件才被记录</span><br><span class=\"line\"></span><br><span class=\"line\">LevelRangeFilter 日志等级在指定范围内的事件才被记录</span><br><span class=\"line\"></span><br><span class=\"line\">LoggerMatchFilter 与Logger名称匹配，才记录</span><br><span class=\"line\"></span><br><span class=\"line\">PropertyFilter 消息匹配指定的属性值时才被记录</span><br><span class=\"line\"></span><br><span class=\"line\">StringMathFilter 消息匹配指定的字符串才被记录</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-3-Layouts\"><a href=\"#2-3-Layouts\" class=\"headerlink\" title=\"2.3 Layouts\"></a><strong>2.3 Layouts</strong></h4><p>Layout用于控制Appender的输出格式，可以是线性的也可以是XML。</p>\n<p>一个Appender只能有一个Layout。</p>\n<p>最常用的Layout应该是经典格式的PatternLayout，其次是SimpleLayout，RawTimeStampLayout和ExceptionLayout。然后还有IRawLayout，XMLLayout等几个，使用较少。Layout可以自己实现，需要从log4net.Layout.LayoutSkeleton类继承，来输出一些特殊需要的格式，在后面扩展时就重新实现了一个Layout。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SimpleLayout 简单输出格式，只输出日志级别与消息内容。</span><br><span class=\"line\"></span><br><span class=\"line\">RawTimeStampLayout 用来格式化时间，在向数据库输出时会用到。样式如“yyyy-MM-dd HH:mm:ss“</span><br><span class=\"line\"></span><br><span class=\"line\">ExceptionLayout 需要给Logger的方法传入Exception对象作为参数才起作用，否则就什么也不输出。输出的时候会包含Message和Trace。</span><br><span class=\"line\"></span><br><span class=\"line\">PatternLayout 使用最多的一个Layout，能输出的信息很多，使用方式可参见上面例子中的配置文件。PatterLayout的格式化字符串见文后附注8.1。</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-4-Loggers\"><a href=\"#2-4-Loggers\" class=\"headerlink\" title=\"2.4 Loggers\"></a><strong>2.4 Loggers</strong></h4><p>Logger是直接和应用程序交互的组件。Logger只是产生日志，然后由它引用的Appender记录到指定的媒介，并由Layout控制输出格式。</p>\n<p>Logger提供了多种方式来记录一个日志消息，也可以有多个Logger同时存在。每个实例化的Logger对象对被log4net作为命名实体（Named Entity）来维护。log4net使用继承体系，也就是说假如存在两个Logger，名字分别为a.b.c和a.b。那么a.b就是a.b.c的祖先。每个Logger都继承了它祖先的属性。所有的Logger都从Root继承,Root本身也是一个Logger。</p>\n<p>日志的等级，它们由高到底分别为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OFF &amp;gt; FATAL &amp;gt; ERROR &amp;gt; WARN &amp;gt; INFO &amp;gt; DEBUG  &amp;gt; ALL</span><br></pre></td></tr></table></figure></p>\n<p>高于等级设定值方法（如何设置参见“配置文件详解”）都能写入日志， Off所有的写入方法都不写到日志里，ALL则相反。例如当我们设成Info时，logger.Debug就会被忽略而不写入文件，但是FATAL,ERROR,WARN,INFO会被写入，因为他们等级高于INFO。</p>\n<p>在具体写日志时，一般可以这样理解日志等级：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FATAL（致命错误）：记录系统中出现的能使用系统完全失去功能，服务停止，系统崩溃等使系统无法继续运行下去的错误。例如，数据库无法连接，系统出现死循环。</span><br><span class=\"line\"></span><br><span class=\"line\">ERROR（一般错误）：记录系统中出现的导致系统不稳定，部分功能出现混乱或部分功能失效一类的错误。例如，数据字段为空，数据操作不可完成，操作出现异常等。</span><br><span class=\"line\"></span><br><span class=\"line\">WARN（警告）：记录系统中不影响系统继续运行，但不符合系统运行正常条件，有可能引起系统错误的信息。例如，记录内容为空，数据内容不正确等。</span><br><span class=\"line\"></span><br><span class=\"line\">INFO（一般信息）：记录系统运行中应该让用户知道的基本信息。例如，服务开始运行，功能已经开户等。</span><br><span class=\"line\"></span><br><span class=\"line\">DEBUG （调试信息）：记录系统用于调试的一切信息，内容或者是一些关键数据内容的输出。</span><br></pre></td></tr></table></figure></p>\n<p>Logger实现的ILog接口，ILog定义了5个方法（Debug,Inof,Warn,Error,Fatal）分别对不同的日志等级记录日志。这5个方法还有5个重载。以Debug为例说明一下，其它的和它差不多。</p>\n<p>ILog中对Debug方法的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Debug(object message);</span><br><span class=\"line\"></span><br><span class=\"line\">void Debug(object message, Exception ex);</span><br></pre></td></tr></table></figure></p>\n<p>还有一个布尔属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool IsDebugEnabled &#123; get; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果使用Debug(object message, Exception ex)，则无论Layout中是否定义了%exception，默认配置下日志都会输出Exception。包括Exception的Message和Trace。如果使用Debug(object message)，则日志是不会输出Exception。</p>\n<p>最后还要说一个LogManager类，它用来管理所有的Logger。它的GetLogger静态方法，可以获得配置文件中相应的Logger：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log4net.ILog log = log4net.LogManager.GetLogger(&quot;logger-name&quot;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-5-Object-Renders\"><a href=\"#2-5-Object-Renders\" class=\"headerlink\" title=\"2.5 Object Renders\"></a><strong>2.5 Object Renders</strong></h4><p>它将告诉logger如何把一个对象转化为一个字符串记录到日志里。（ILog中定义的接口接收的参数是Object，而不是String。）</p>\n<p>例如你想把Orange对象记录到日志中，但此时logger只会调用Orange默认的ToString方法而已。所以要定义一个OrangeRender类实现log4net.ObjectRender.IObjectRender接口，然后注册它（我们在本文中的扩展不使用这种方法，而是直接实现一个自定义的Layout）。这时logger就会知道如何把Orange记录到日志中了。</p>\n<h4 id=\"2-6-Repository\"><a href=\"#2-6-Repository\" class=\"headerlink\" title=\"2.6 Repository\"></a><strong>2.6 Repository</strong></h4><p>Repository主要用于日志对象组织结构的维护。</p>\n<h3 id=\"3-配置文件详解\"><a href=\"#3-配置文件详解\" class=\"headerlink\" title=\"3.配置文件详解\"></a>3.配置文件详解</h3><h4 id=\"3-1-配置文件构成\"><a href=\"#3-1-配置文件构成\" class=\"headerlink\" title=\"3.1 配置文件构成\"></a><strong>3.1 配置文件构成</strong></h4><p>主要有两大部分，一是申明一个名为“log4net“的自定义配置节，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;lt;configSections&amp;gt;</span><br><span class=\"line\">    &amp;lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler, log4net&quot; /&amp;gt;</span><br><span class=\"line\">&amp;lt;/configSections&amp;gt;</span><br><span class=\"line\">&amp;lt;log4net&amp;gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&amp;lt;/log4net&amp;gt;</span><br></pre></td></tr></table></figure></p>\n<p>二是&lt;log4net&gt;节的具体配置，这是下面要重点说明的。</p>\n<h4 id=\"3-1-1-lt-log4net-gt\"><a href=\"#3-1-1-lt-log4net-gt\" class=\"headerlink\" title=\"3.1.1 &lt;log4net&gt;\"></a>3.1.1 &lt;log4net&gt;</h4><p>所有的配置都要在&lt;log4net&gt;元素里定义。</p>\n<p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>debug</td>\n<td>可选，取值是true或false，默认是false。设置为true，开启log4net的内部调试。</td>\n</tr>\n<tr>\n<td>update</td>\n<td>可选，取值是Merge(合并)或Overwrite(覆盖)，默认值是Merge。设置为Overwrite，在提交配置的时候会重置已经配置过的库。</td>\n</tr>\n<tr>\n<td>threshold</td>\n<td>可选，取值是repository（库）中注册的level，默认值是ALL。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>appender</td>\n<td style=\"text-align:center\">0或多个</td>\n</tr>\n<tr>\n<td>logger</td>\n<td style=\"text-align:center\">0或多个</td>\n</tr>\n<tr>\n<td>renderer</td>\n<td style=\"text-align:center\">0或多个</td>\n</tr>\n<tr>\n<td>root</td>\n<td style=\"text-align:center\">最多一个</td>\n</tr>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0或多个</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"3-1-2-lt-root-gt\"><a href=\"#3-1-2-lt-root-gt\" class=\"headerlink\" title=\"3.1.2 &lt;root&gt;\"></a>3.1.2 &lt;root&gt;</h4><p>实际上就是一个根logger，所有其它logger都默认继承它，如果配置文件里没有显式定义，则框架使用根日志中定义的属性。root元素没有属性。</p>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>appender-ref</td>\n<td style=\"text-align:center\">0个或多个，要引用的appender的名字。</td>\n</tr>\n<tr>\n<td>level</td>\n<td style=\"text-align:center\">最多一个。 只有在这个级别或之上的事件才会被记录。</td>\n</tr>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置一些参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"3-1-3-lt-logger-gt\"><a href=\"#3-1-3-lt-logger-gt\" class=\"headerlink\" title=\"3.1.3 &lt;logger&gt;\"></a>3.1.3 &lt;logger&gt;</h4><p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td style=\"text-align:center\">必须的，logger的名称</td>\n</tr>\n<tr>\n<td>additivity</td>\n<td style=\"text-align:center\">可选，取值是true或false，默认值是true。设置为false时将阻止父logger中的appender。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>appender-ref</td>\n<td style=\"text-align:center\">0个或多个，要引用的appender的名字。</td>\n</tr>\n<tr>\n<td>level</td>\n<td style=\"text-align:center\">最多一个。 只有在这个级别或之上的事件才会被记录。</td>\n</tr>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置一些参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"3-1-4-lt-appender-gt\"><a href=\"#3-1-4-lt-appender-gt\" class=\"headerlink\" title=\"3.1.4 &lt;appender&gt;\"></a>3.1.4 &lt;appender&gt;</h4><p>定义日志的输出方式，只能作为 log4net 的子元素。name属性必须唯一，type属性必须指定。</p>\n<p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td style=\"text-align:center\">必须的，Appender对象的名称</td>\n</tr>\n<tr>\n<td>type</td>\n<td style=\"text-align:center\">必须的，Appender对象的输出类型</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>appender-ref</td>\n<td style=\"text-align:center\">0个或多个，允许此appender引用其他appender，并不是所以appender类型都支持。</td>\n</tr>\n<tr>\n<td>filter</td>\n<td style=\"text-align:center\">0个或多个，定义此app使用的过滤器。</td>\n</tr>\n<tr>\n<td>layout</td>\n<td style=\"text-align:center\">最多一个。定义appender使用的输出格式。</td>\n</tr>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置Appender类中对应的属性的值。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>实际上&lt;appender&gt;所能包含的子元素远不止上面4个。</p>\n<h4 id=\"3-1-5-lt-layout-gt\"><a href=\"#3-1-5-lt-layout-gt\" class=\"headerlink\" title=\"3.1.5 &lt;layout&gt;\"></a>3.1.5 &lt;layout&gt;</h4><p>布局，只能作为&lt;appender&gt;的子元素。</p>\n<p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>type</td>\n<td style=\"text-align:center\">必须的，Layout的类型</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置一些参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"3-1-6-lt-filter-gt\"><a href=\"#3-1-6-lt-filter-gt\" class=\"headerlink\" title=\"3.1.6 &lt;filter&gt;\"></a>3.1.6 &lt;filter&gt;</h4><p>过滤器，只能作为&lt;appender&gt;的子元素。</p>\n<p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>type</td>\n<td style=\"text-align:center\">必须的，Filter的类型</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置一些参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"3-1-7-lt-param-gt\"><a href=\"#3-1-7-lt-param-gt\" class=\"headerlink\" title=\"3.1.7 &lt;param&gt;\"></a>3.1.7 &lt;param&gt;</h4><p>&lt;param&gt;元素可以是任何元素的子元素。</p>\n<p>支持的属性：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td style=\"text-align:center\">必须的，取值是父对象的参数名。</td>\n</tr>\n<tr>\n<td>value</td>\n<td style=\"text-align:center\">可选的，value和type中，必须有一个属性被指定。value是一个能被转化为参数值的字符串。</td>\n</tr>\n<tr>\n<td>type</td>\n<td style=\"text-align:center\">可选的，value和type中，必须有一个属性被指定。type是一个类型名，如果type不是在log4net程序集中定义的，就需要使用全名。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>支持的子元素：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:center\">详解</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>param</td>\n<td style=\"text-align:center\">0个或多个， 设置一些参数。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"4-关联配置文件\"><a href=\"#4-关联配置文件\" class=\"headerlink\" title=\"4. 关联配置文件\"></a>4. 关联配置文件</h3><p>log4net默认关联的是应用程序的配置文件App.config(BS程序是Web.config)，可以使用程序集自定义属性来进行设置。下面来介绍一下这个自定义属性：</p>\n<p>log4net.Config.XmlConifguratorAttribute</p>\n<p>XmlConfiguratorAttribute有3个属性：</p>\n<p>ConfigFile： 配置文件的名字，文件路径相对于应用程序目录</p>\n<p>(AppDomain.CurrentDomain.BaseDirectory)。ConfigFile属性不能和ConfigFileExtension属性一起使用。</p>\n<p>ConfigFileExtension： 配置文件的扩展名，文件路径相对于应用程序的目录。ConfigFileExtension属性不能和ConfigFile属性一起使用。</p>\n<p>Watch： 如果将Watch属性设置为true，就会监视配置文件。当配置文件发生变化的时候，就会重新加载。</p>\n<p>如果ConfigFile和ConfigFileExtension都没有设置，则使用应用程序的配置文件App.config（Web.config）。</p>\n<p>可以在项目的AssemblyInfo.cs文件里添加以下的语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">//监视默认的配置文件，App.config </span><br><span class=\"line\">[assembly: log4net.Config.XmlConfigurator(Watch = true)]</span><br><span class=\"line\"></span><br><span class=\"line\">//使用配置文件log4net.config，不监视改变。注意log4net.config文件的目录，BS程序在站点目录//下，CS则在应用程序启动目录下，如调试时在/bin/Debug下，一般将文件属性的文件输出目录调为//始终复制即可</span><br><span class=\"line\"></span><br><span class=\"line\">[assembly: log4net.Config.XmlConfigurator(ConfigFile = &quot;log4net.config&quot;)]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//使用配置文件log4net.config，不监视改变</span><br><span class=\"line\"></span><br><span class=\"line\">[assembly: log4net.Config.XmlConfigurator()]</span><br></pre></td></tr></table></figure>\n<p>也可以在Global.asax的Application_Start里或者是Program.cs中的Main方法中添加，注意这里一定是绝对路径，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这是在BS程序下，使用自定义的配置文件log4net.config，使用Server.MapPath(&quot;~&quot;) + //@&quot;/log4net.config”来取得路径。/log4net.config为相对于站点的路径</span><br><span class=\"line\"></span><br><span class=\"line\">// ConfigureAndWatch()相当于Configure(Watch = true)</span><br><span class=\"line\"></span><br><span class=\"line\">log4net.Config.XmlConfigurator.ConfigureAndWatch(new System.IO.FileInfo(Server.MapPath(&quot;~&quot;) + @&quot;/log4net.config&quot;));</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这是在CS程序下，可以用以下方法获得：</span><br><span class=\"line\"></span><br><span class=\"line\">string assemblyFilePath = Assembly.GetExecutingAssembly().Location;</span><br><span class=\"line\"></span><br><span class=\"line\">string assemblyDirPath = Path.GetDirectoryName(assemblyFilePath);</span><br><span class=\"line\"></span><br><span class=\"line\">string configFilePath = assemblyDirPath + &quot; //log4net.config&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">log4net.Config.XmlConfigurator.ConfigureAndWatch(new FileInfo(configFilePath));</span><br></pre></td></tr></table></figure>\n<p>或直接使用绝对路径：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用自定义的配置文件，直接绝对路径为：c:/log4net.config</span><br><span class=\"line\"></span><br><span class=\"line\">log4net.Config.XmlConfigurator.Configure(new System.IO.FileInfo(@&quot;c:/log4net.config&quot;));</span><br></pre></td></tr></table></figure></p>\n<p>&lt;/font&gt;</p>"},{"title":"BITCOUNT(bitcount)","copyright":true,"date":"2020-03-19T12:03:19.000Z","keywords":"Redis命令,bitcount","aside":"bitmap","_content":"## BITCOUNT key [start end] \n>起始版本：2.6.0<br/>时间复杂度：O(N)  \n\n\n#### 说明:\n* 统计字符串被设置为1的bit数.\n* 一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。\n\n#### 返回值\n\n**Integer reply**:被设置为 1 的位的数量。\n\n\n#### 示例\n\n```\nredis> SET mykey \"foobar\"\nOK\nredis> BITCOUNT mykey\n(integer) 26\nredis> BITCOUNT mykey 0 0\n(integer) 4\nredis> BITCOUNT mykey 1 1\n(integer) 6\nredis>\n```","source":"_posts/redis_command/bitmap/bitcount.md","raw":"---\n\ntitle: BITCOUNT(bitcount)\ncopyright: true\ndate: 2020-03-19 20:03:19\ncategories: \n- Redis命令大全\n- Bitmap\nkeywords: Redis命令,bitcount\naside: bitmap\n---\n## BITCOUNT key [start end] \n>起始版本：2.6.0<br/>时间复杂度：O(N)  \n\n\n#### 说明:\n* 统计字符串被设置为1的bit数.\n* 一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。\n\n#### 返回值\n\n**Integer reply**:被设置为 1 的位的数量。\n\n\n#### 示例\n\n```\nredis> SET mykey \"foobar\"\nOK\nredis> BITCOUNT mykey\n(integer) 26\nredis> BITCOUNT mykey 0 0\n(integer) 4\nredis> BITCOUNT mykey 1 1\n(integer) 6\nredis>\n```","slug":"redis_command/bitmap/bitcount","published":1,"updated":"2021-03-14T03:04:50.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfptr0018hyjfylcx0emg","content":"<h2 id=\"BITCOUNT-key-start-end\"><a href=\"#BITCOUNT-key-start-end\" class=\"headerlink\" title=\"BITCOUNT key [start end]\"></a>BITCOUNT key [start end]</h2><blockquote>\n<p>起始版本：2.6.0<br>时间复杂度：O(N)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>统计字符串被设置为1的bit数.</li>\n<li>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply</strong>:被设置为 1 的位的数量。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey &quot;foobar&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; BITCOUNT mykey</span><br><span class=\"line\">(integer) 26</span><br><span class=\"line\">redis&gt; BITCOUNT mykey 0 0</span><br><span class=\"line\">(integer) 4</span><br><span class=\"line\">redis&gt; BITCOUNT mykey 1 1</span><br><span class=\"line\">(integer) 6</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"BITCOUNT-key-start-end\"><a href=\"#BITCOUNT-key-start-end\" class=\"headerlink\" title=\"BITCOUNT key [start end]\"></a>BITCOUNT key [start end]</h2><blockquote>\n<p>起始版本：2.6.0<br>时间复杂度：O(N)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>统计字符串被设置为1的bit数.</li>\n<li>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply</strong>:被设置为 1 的位的数量。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey &quot;foobar&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; BITCOUNT mykey</span><br><span class=\"line\">(integer) 26</span><br><span class=\"line\">redis&gt; BITCOUNT mykey 0 0</span><br><span class=\"line\">(integer) 4</span><br><span class=\"line\">redis&gt; BITCOUNT mykey 1 1</span><br><span class=\"line\">(integer) 6</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"BITOP(bitop)","copyright":true,"date":"2020-03-19T12:01:19.000Z","keywords":"Redis命令,bitop","aside":"bitmap","_content":"## BITOP operation destkey key [key ...] \n>起始版本：2.6.0<br/>时间复杂度：O(N)  \n\n\n#### 说明:\n对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。\n\n`BITOP` 命令支持 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种参数：\n\n- `BITOP AND destkey srckey1 srckey2 srckey3 ... srckeyN` ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。\n- `BITOP OR destkey srckey1 srckey2 srckey3 ... srckeyN`，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。\n- `BITOP XOR destkey srckey1 srckey2 srckey3 ... srckeyN`，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。\n- `BITOP NOT destkey srckey`，对给定 key 求逻辑非，并将结果保存到 destkey 。\n\n除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。\n\n执行结果将始终保持到`destkey`里面。\n\n#### 处理不同长度的字符串\n\n当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。\n\n空的 key 也被看作是包含 0 的字符串序列。\n\n#### 返回值\n\n**Integer reply:**保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。\n\n\n#### 示例\n\n```\nredis> SET key1 \"foobar\"\nOK\nredis> SET key2 \"abcdef\"\nOK\nredis> BITOP AND dest key1 key2\n(integer) 6\nredis> GET dest\n\"`bc`ab\"\nredis>\n```\n\nBITOP可能是一个缓慢的命令，它的时间复杂度是O(N)。 在处理长字符串时应注意一下效率问题。\n对于实时的指标和统计，涉及大输入一个很好的方法是 使用bit-wise操作以避免阻塞主实例。","source":"_posts/redis_command/bitmap/bitop.md","raw":"---\ntitle: BITOP(bitop)\ncopyright: true\ndate: 2020-03-19 20:01:19\ncategories: \n- Redis命令大全\n- Bitmap\nkeywords: Redis命令,bitop\naside: bitmap\n---\n## BITOP operation destkey key [key ...] \n>起始版本：2.6.0<br/>时间复杂度：O(N)  \n\n\n#### 说明:\n对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。\n\n`BITOP` 命令支持 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种参数：\n\n- `BITOP AND destkey srckey1 srckey2 srckey3 ... srckeyN` ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。\n- `BITOP OR destkey srckey1 srckey2 srckey3 ... srckeyN`，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。\n- `BITOP XOR destkey srckey1 srckey2 srckey3 ... srckeyN`，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。\n- `BITOP NOT destkey srckey`，对给定 key 求逻辑非，并将结果保存到 destkey 。\n\n除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。\n\n执行结果将始终保持到`destkey`里面。\n\n#### 处理不同长度的字符串\n\n当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。\n\n空的 key 也被看作是包含 0 的字符串序列。\n\n#### 返回值\n\n**Integer reply:**保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。\n\n\n#### 示例\n\n```\nredis> SET key1 \"foobar\"\nOK\nredis> SET key2 \"abcdef\"\nOK\nredis> BITOP AND dest key1 key2\n(integer) 6\nredis> GET dest\n\"`bc`ab\"\nredis>\n```\n\nBITOP可能是一个缓慢的命令，它的时间复杂度是O(N)。 在处理长字符串时应注意一下效率问题。\n对于实时的指标和统计，涉及大输入一个很好的方法是 使用bit-wise操作以避免阻塞主实例。","slug":"redis_command/bitmap/bitop","published":1,"updated":"2021-03-14T03:04:50.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpts0019hyjfid377nk4","content":"<h2 id=\"BITOP-operation-destkey-key-key-…\"><a href=\"#BITOP-operation-destkey-key-key-…\" class=\"headerlink\" title=\"BITOP operation destkey key [key …]\"></a>BITOP operation destkey key [key …]</h2><blockquote>\n<p>起始版本：2.6.0<br>时间复杂度：O(N)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><p>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p>\n<p><code>BITOP</code> 命令支持 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种参数：</p>\n<ul>\n<li><code>BITOP AND destkey srckey1 srckey2 srckey3 ... srckeyN</code> ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。</li>\n<li><code>BITOP OR destkey srckey1 srckey2 srckey3 ... srckeyN</code>，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。</li>\n<li><code>BITOP XOR destkey srckey1 srckey2 srckey3 ... srckeyN</code>，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。</li>\n<li><code>BITOP NOT destkey srckey</code>，对给定 key 求逻辑非，并将结果保存到 destkey 。</li>\n</ul>\n<p>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</p>\n<p>执行结果将始终保持到<code>destkey</code>里面。</p>\n<h4 id=\"处理不同长度的字符串\"><a href=\"#处理不同长度的字符串\" class=\"headerlink\" title=\"处理不同长度的字符串\"></a>处理不同长度的字符串</h4><p>当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。</p>\n<p>空的 key 也被看作是包含 0 的字符串序列。</p>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply:</strong>保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET key1 &quot;foobar&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; SET key2 &quot;abcdef&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; BITOP AND dest key1 key2</span><br><span class=\"line\">(integer) 6</span><br><span class=\"line\">redis&gt; GET dest</span><br><span class=\"line\">&quot;`bc`ab&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n<p>BITOP可能是一个缓慢的命令，它的时间复杂度是O(N)。 在处理长字符串时应注意一下效率问题。<br>对于实时的指标和统计，涉及大输入一个很好的方法是 使用bit-wise操作以避免阻塞主实例。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"BITOP-operation-destkey-key-key-…\"><a href=\"#BITOP-operation-destkey-key-key-…\" class=\"headerlink\" title=\"BITOP operation destkey key [key …]\"></a>BITOP operation destkey key [key …]</h2><blockquote>\n<p>起始版本：2.6.0<br>时间复杂度：O(N)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><p>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p>\n<p><code>BITOP</code> 命令支持 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种参数：</p>\n<ul>\n<li><code>BITOP AND destkey srckey1 srckey2 srckey3 ... srckeyN</code> ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。</li>\n<li><code>BITOP OR destkey srckey1 srckey2 srckey3 ... srckeyN</code>，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。</li>\n<li><code>BITOP XOR destkey srckey1 srckey2 srckey3 ... srckeyN</code>，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。</li>\n<li><code>BITOP NOT destkey srckey</code>，对给定 key 求逻辑非，并将结果保存到 destkey 。</li>\n</ul>\n<p>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</p>\n<p>执行结果将始终保持到<code>destkey</code>里面。</p>\n<h4 id=\"处理不同长度的字符串\"><a href=\"#处理不同长度的字符串\" class=\"headerlink\" title=\"处理不同长度的字符串\"></a>处理不同长度的字符串</h4><p>当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。</p>\n<p>空的 key 也被看作是包含 0 的字符串序列。</p>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply:</strong>保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET key1 &quot;foobar&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; SET key2 &quot;abcdef&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; BITOP AND dest key1 key2</span><br><span class=\"line\">(integer) 6</span><br><span class=\"line\">redis&gt; GET dest</span><br><span class=\"line\">&quot;`bc`ab&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n<p>BITOP可能是一个缓慢的命令，它的时间复杂度是O(N)。 在处理长字符串时应注意一下效率问题。<br>对于实时的指标和统计，涉及大输入一个很好的方法是 使用bit-wise操作以避免阻塞主实例。</p>\n"},{"title":"SETBIT(setbit)","copyright":true,"date":"2020-03-19T11:45:19.000Z","keywords":"Redis命令,setbit","aside":"bitmap","_content":"## SETBIT key offset value \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 设置或者清空key的value(字符串)在offset处的bit值。\n\n  那个位置的bit要么被设置，要么被清空，这个由value（只能是0或者1）来决定。当key不存在的时候，就创建一个新的字符串value。要确保这个字符串大到在offset处有bit值。参数offset需要大于等于0，并且小于232(限制bitmap大小为512)。当key对应的字符串增大的时候，新增的部分bit值都是设置为0。\n\n  警告：当set最后一个bit(offset等于232-1)并且key还没有一个字符串value或者其value是个比较小的字符串时，Redis需要立即分配所有内存，这有可能会导致服务阻塞一会。在一台2010MacBook Pro上，offset为232-1（分配512MB）需要～300ms，offset为230-1(分配128MB)需要～80ms，offset为228-1（分配32MB）需要～30ms，offset为226-1（分配8MB）需要8ms。注意，一旦第一次内存分配完，后面对同一个key调用[SETBIT](http://www.redis.cn/commands/setbit.html)就不会预先得到内存分配。\n\n#### 返回值\n\n\n**integer-reply：**在offset处原来的bit值\n\n\n#### 示例\n\n```\nredis> SETBIT mykey 7 1\n(integer) 0\nredis> SETBIT mykey 7 0\n(integer) 1\nredis> GET mykey\n\"\\x00\"\nredis> \n```","source":"_posts/redis_command/bitmap/setbit.md","raw":"---\ntitle: SETBIT(setbit)\ncopyright: true\ndate: 2020-03-19 19:45:19\ncategories: \n- Redis命令大全\n- Bitmap\nkeywords: Redis命令,setbit\naside: bitmap\n---\n## SETBIT key offset value \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 设置或者清空key的value(字符串)在offset处的bit值。\n\n  那个位置的bit要么被设置，要么被清空，这个由value（只能是0或者1）来决定。当key不存在的时候，就创建一个新的字符串value。要确保这个字符串大到在offset处有bit值。参数offset需要大于等于0，并且小于232(限制bitmap大小为512)。当key对应的字符串增大的时候，新增的部分bit值都是设置为0。\n\n  警告：当set最后一个bit(offset等于232-1)并且key还没有一个字符串value或者其value是个比较小的字符串时，Redis需要立即分配所有内存，这有可能会导致服务阻塞一会。在一台2010MacBook Pro上，offset为232-1（分配512MB）需要～300ms，offset为230-1(分配128MB)需要～80ms，offset为228-1（分配32MB）需要～30ms，offset为226-1（分配8MB）需要8ms。注意，一旦第一次内存分配完，后面对同一个key调用[SETBIT](http://www.redis.cn/commands/setbit.html)就不会预先得到内存分配。\n\n#### 返回值\n\n\n**integer-reply：**在offset处原来的bit值\n\n\n#### 示例\n\n```\nredis> SETBIT mykey 7 1\n(integer) 0\nredis> SETBIT mykey 7 0\n(integer) 1\nredis> GET mykey\n\"\\x00\"\nredis> \n```","slug":"redis_command/bitmap/setbit","published":1,"updated":"2021-03-14T03:04:50.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfptu001bhyjfxrmzo810","content":"<h2 id=\"SETBIT-key-offset-value\"><a href=\"#SETBIT-key-offset-value\" class=\"headerlink\" title=\"SETBIT key offset value\"></a>SETBIT key offset value</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>设置或者清空key的value(字符串)在offset处的bit值。</p>\n<p>那个位置的bit要么被设置，要么被清空，这个由value（只能是0或者1）来决定。当key不存在的时候，就创建一个新的字符串value。要确保这个字符串大到在offset处有bit值。参数offset需要大于等于0，并且小于232(限制bitmap大小为512)。当key对应的字符串增大的时候，新增的部分bit值都是设置为0。</p>\n<p>警告：当set最后一个bit(offset等于232-1)并且key还没有一个字符串value或者其value是个比较小的字符串时，Redis需要立即分配所有内存，这有可能会导致服务阻塞一会。在一台2010MacBook Pro上，offset为232-1（分配512MB）需要～300ms，offset为230-1(分配128MB)需要～80ms，offset为228-1（分配32MB）需要～30ms，offset为226-1（分配8MB）需要8ms。注意，一旦第一次内存分配完，后面对同一个key调用<a href=\"http://www.redis.cn/commands/setbit.html\" target=\"_blank\" rel=\"noopener\">SETBIT</a>就不会预先得到内存分配。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply：</strong>在offset处原来的bit值</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SETBIT mykey 7 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt; SETBIT mykey 7 0</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\">&quot;\\x00&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SETBIT-key-offset-value\"><a href=\"#SETBIT-key-offset-value\" class=\"headerlink\" title=\"SETBIT key offset value\"></a>SETBIT key offset value</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>设置或者清空key的value(字符串)在offset处的bit值。</p>\n<p>那个位置的bit要么被设置，要么被清空，这个由value（只能是0或者1）来决定。当key不存在的时候，就创建一个新的字符串value。要确保这个字符串大到在offset处有bit值。参数offset需要大于等于0，并且小于232(限制bitmap大小为512)。当key对应的字符串增大的时候，新增的部分bit值都是设置为0。</p>\n<p>警告：当set最后一个bit(offset等于232-1)并且key还没有一个字符串value或者其value是个比较小的字符串时，Redis需要立即分配所有内存，这有可能会导致服务阻塞一会。在一台2010MacBook Pro上，offset为232-1（分配512MB）需要～300ms，offset为230-1(分配128MB)需要～80ms，offset为228-1（分配32MB）需要～30ms，offset为226-1（分配8MB）需要8ms。注意，一旦第一次内存分配完，后面对同一个key调用<a href=\"http://www.redis.cn/commands/setbit.html\" target=\"_blank\" rel=\"noopener\">SETBIT</a>就不会预先得到内存分配。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply：</strong>在offset处原来的bit值</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SETBIT mykey 7 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt; SETBIT mykey 7 0</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\">&quot;\\x00&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"GETBIT(getbit)","copyright":true,"date":"2020-03-19T11:56:19.000Z","keywords":"Redis命令,getbit","aside":"bitmap","_content":"## GETBIT key offset \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回key对应的string在offset处的bit值 当offset超出了字符串长度的时候，这个字符串就被假定为由0比特填充的连续空间。当key不存在的时候，它就认为是一个空字符串，所以offset总是超出范围，然后value也被认为是由0比特填充的连续空间。到内存分配。\n\n#### 返回值\n\n\n**integer-reply：**在offset处的bit值\n\n\n#### 示例\n\n```\nredis> SETBIT mykey 7 1\n(integer) 0\nredis> GETBIT mykey 0\n(integer) 0\nredis> GETBIT mykey 7\n(integer) 1\nredis> GETBIT mykey 100\n(integer) 0\nredis> \n```","source":"_posts/redis_command/bitmap/getbit.md","raw":"---\ntitle: GETBIT(getbit)\ncopyright: true\ndate: 2020-03-19 19:56:19\ncategories: \n- Redis命令大全\n- Bitmap\nkeywords: Redis命令,getbit\naside: bitmap\n---\n## GETBIT key offset \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回key对应的string在offset处的bit值 当offset超出了字符串长度的时候，这个字符串就被假定为由0比特填充的连续空间。当key不存在的时候，它就认为是一个空字符串，所以offset总是超出范围，然后value也被认为是由0比特填充的连续空间。到内存分配。\n\n#### 返回值\n\n\n**integer-reply：**在offset处的bit值\n\n\n#### 示例\n\n```\nredis> SETBIT mykey 7 1\n(integer) 0\nredis> GETBIT mykey 0\n(integer) 0\nredis> GETBIT mykey 7\n(integer) 1\nredis> GETBIT mykey 100\n(integer) 0\nredis> \n```","slug":"redis_command/bitmap/getbit","published":1,"updated":"2021-03-14T03:04:50.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfptv001chyjff3p1tvar","content":"<h2 id=\"GETBIT-key-offset\"><a href=\"#GETBIT-key-offset\" class=\"headerlink\" title=\"GETBIT key offset\"></a>GETBIT key offset</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回key对应的string在offset处的bit值 当offset超出了字符串长度的时候，这个字符串就被假定为由0比特填充的连续空间。当key不存在的时候，它就认为是一个空字符串，所以offset总是超出范围，然后value也被认为是由0比特填充的连续空间。到内存分配。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply：</strong>在offset处的bit值</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SETBIT mykey 7 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt; GETBIT mykey 0</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt; GETBIT mykey 7</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; GETBIT mykey 100</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"GETBIT-key-offset\"><a href=\"#GETBIT-key-offset\" class=\"headerlink\" title=\"GETBIT key offset\"></a>GETBIT key offset</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回key对应的string在offset处的bit值 当offset超出了字符串长度的时候，这个字符串就被假定为由0比特填充的连续空间。当key不存在的时候，它就认为是一个空字符串，所以offset总是超出范围，然后value也被认为是由0比特填充的连续空间。到内存分配。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply：</strong>在offset处的bit值</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SETBIT mykey 7 1</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt; GETBIT mykey 0</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt; GETBIT mykey 7</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; GETBIT mykey 100</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"BITFIELD(bitfield)","copyright":true,"date":"2020-03-19T12:02:19.000Z","keywords":"Redis命令,bitfield","aside":"bitmap","_content":"## BITFIELD key \n**BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL] **\n\n>起始版本：3.2.0<br/>时间复杂度：O(1)  对于指定的每个子命令\n\n\n#### 说明:\n* 本命令会把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。在实践中，可以使用该命令对一个有符号的5位整型数的1234位设置指定值，也可以对一个31位无符号整型数的4567位进行取值。类似地，在对指定的整数进行自增和自减操作，本命令可以提供有保证的、可配置的上溢和下溢处理操作。\n* BITFIELD命令能操作多字节位域，它会执行一系列操作，并返回一个响应数组，在参数列表中每个响应数组匹配相应的操作。\n例如，下面的命令是对一个8位有符号整数偏移100位自增1，并获取4位无符号整数的值：\n```\n> BITFIELD mykey INCRBY i5 100 1 GET u4 0\n1) (integer) 1\n2) (integer) 0\n```\n**提示：**\n* 用GET指令对超出当前字符串长度的位（含key不存在的情况）进行寻址，执行操作的结果会对缺失部分的位（bits）赋值为0。\n* 用SET或INCRBY指令对超出当前字符串长度的位（含key不存在的情况）进行寻址，将会扩展字符串并对扩展部分进行补0，扩展方式包括：按需扩展、按最小长度扩展和按最大寻址能力扩展。\n\n#### 支持子命令和整型\n下面是已支持的命令列表：\n* `GET <type> <offset>` – 返回指定的位域\n* `SET <type> <offset> <value>` – 设置指定位域的值并返回它的原值\n* `INCRBY <type> <offset> <increment>` – 自增或自减（如果increment为负数）指定位域的值并返回它的新值\n还有一个命令通过设置溢出行为来改变调用INCRBY指令的后序操作：\n`OVERFLOW [WRAP|SAT|FAIL]`\n* 当需要一个整型时，有符号整型需在位数前加i，无符号在位数前加u。例如，u8是一个8位的无符号整型，i16是一个16位的有符号整型。\n* 有符号整型最大支持64位，而无符号整型最大支持63位。对无符号整型的限制，是由于当前Redis协议不能在响应消息中返回64位无符号整数。\n#### 位和位偏移\nbitfield命令有两种方式来指定位偏移。如果未定带数字的前缀，将会以字符串的第0位作为起始位。\n不过，如果偏移量带有#前缀，那么指定的偏移量需要乘以整型宽度，例如：\n`BITFIELD mystring SET i8 #0 100 i8 #1 200`\n\n将会在第1个i8整数的偏移0位和第2个整数的偏移8位进行设值。如果想得到一个给定长度的普通整型数组，则不一定要在客户端进行计算。\n\n#### 溢出控制\n\n使用`OVERFLOW`命令，用户可以通过指定下列其中一种行为来调整自增或自减操作溢出（或下溢）后的行为：\n\n- **WRAP**: 回环算法，适用于有符号和无符号整型两种类型。对于无符号整型，回环计数将对整型最大值进行取模操作（C语言的标准行为）。对于有符号整型，上溢从最负的负数开始取数，下溢则从最大的正数开始取数，例如，如果i8整型的值设为127，自加1后的值变为-128。\n- **SAT**: 饱和算法，下溢之后设为最小的整型值，上溢之后设为最大的整数值。例如，i8整型的值从120开始加10后，结果是127，继续增加，结果还是保持为127。下溢也是同理，但量结果值将会保持在最负的负数值。\n- **FAIL**: 失败算法，这种模式下，在检测到上溢或下溢时，不做任何操作。相应的返回值会设为NULL，并返回给调用者。\n\n注意每种溢出（`OVERFLOW`）控制方法，仅影响紧跟在`INCRBY`命令后的子命令，直到重新指定溢出（`OVERFLOW`）控制方法。\n\n如果没有指定溢出控制方法，默认情况下，将使用**WRAP**算法。\n```\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\n1) (integer) 1\n2) (integer) 1\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\n1) (integer) 2\n2) (integer) 2\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\n1) (integer) 3\n2) (integer) 3\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\n1) (integer) 0\n2) (integer) 3\n```\n#### 返回值\n本命令返回一个针对子命令给定位置的处理结果组成的数组。OVERFLOW子命令在响应消息中，不会统计结果的条数。\n下面是OVERFLOW FAIL返回NULL的样例：\n```\n> BITFIELD mykey OVERFLOW FAIL incrby u2 102 1\n1) (nil)\n```\n\n#### 动机（Motivations）\n本命令的动机是为了能够在单个大位图（large bitmap）中高效地存储多个小整数（或对键分成多个key，避免出现超大键），同时开放Redis提供的新使用案例，尤其是在实时分析领域。这种使用案例可以通过指定的溢出控制方法来支持。\n\n#### 性能考虑（Performance considerations）\n通常，BITFIELD是一个非常快的命令，但是注意，对短字符串的远地址（fat bits）寻址，将会比在存在的位执行命令更加耗时。\n\n#### 字节序（Orders of bits）\nBITFIELD命令使用的位图表现形式，可看作是从0位开始的，例如：把一个5位的无符号整数23，对一个所有位事先置0的位图，从第7位开始赋值，其结果如下所示：\n```\n+--------+--------+\n|00000001|01110000|\n+--------+--------+\n```\n当偏移量和整型大小是字节边界对齐时，此时与大端模式（big endian）相同，但是，当字节边界未对齐时，那么理解字节序将变得非常重要。\n\n","source":"_posts/redis_command/bitmap/bitfield.md","raw":"---\n\ntitle: BITFIELD(bitfield)\ncopyright: true\ndate: 2020-03-19 20:02:19\ncategories: \n- Redis命令大全\n- Bitmap\nkeywords: Redis命令,bitfield\naside: bitmap\n---\n## BITFIELD key \n**BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL] **\n\n>起始版本：3.2.0<br/>时间复杂度：O(1)  对于指定的每个子命令\n\n\n#### 说明:\n* 本命令会把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。在实践中，可以使用该命令对一个有符号的5位整型数的1234位设置指定值，也可以对一个31位无符号整型数的4567位进行取值。类似地，在对指定的整数进行自增和自减操作，本命令可以提供有保证的、可配置的上溢和下溢处理操作。\n* BITFIELD命令能操作多字节位域，它会执行一系列操作，并返回一个响应数组，在参数列表中每个响应数组匹配相应的操作。\n例如，下面的命令是对一个8位有符号整数偏移100位自增1，并获取4位无符号整数的值：\n```\n> BITFIELD mykey INCRBY i5 100 1 GET u4 0\n1) (integer) 1\n2) (integer) 0\n```\n**提示：**\n* 用GET指令对超出当前字符串长度的位（含key不存在的情况）进行寻址，执行操作的结果会对缺失部分的位（bits）赋值为0。\n* 用SET或INCRBY指令对超出当前字符串长度的位（含key不存在的情况）进行寻址，将会扩展字符串并对扩展部分进行补0，扩展方式包括：按需扩展、按最小长度扩展和按最大寻址能力扩展。\n\n#### 支持子命令和整型\n下面是已支持的命令列表：\n* `GET <type> <offset>` – 返回指定的位域\n* `SET <type> <offset> <value>` – 设置指定位域的值并返回它的原值\n* `INCRBY <type> <offset> <increment>` – 自增或自减（如果increment为负数）指定位域的值并返回它的新值\n还有一个命令通过设置溢出行为来改变调用INCRBY指令的后序操作：\n`OVERFLOW [WRAP|SAT|FAIL]`\n* 当需要一个整型时，有符号整型需在位数前加i，无符号在位数前加u。例如，u8是一个8位的无符号整型，i16是一个16位的有符号整型。\n* 有符号整型最大支持64位，而无符号整型最大支持63位。对无符号整型的限制，是由于当前Redis协议不能在响应消息中返回64位无符号整数。\n#### 位和位偏移\nbitfield命令有两种方式来指定位偏移。如果未定带数字的前缀，将会以字符串的第0位作为起始位。\n不过，如果偏移量带有#前缀，那么指定的偏移量需要乘以整型宽度，例如：\n`BITFIELD mystring SET i8 #0 100 i8 #1 200`\n\n将会在第1个i8整数的偏移0位和第2个整数的偏移8位进行设值。如果想得到一个给定长度的普通整型数组，则不一定要在客户端进行计算。\n\n#### 溢出控制\n\n使用`OVERFLOW`命令，用户可以通过指定下列其中一种行为来调整自增或自减操作溢出（或下溢）后的行为：\n\n- **WRAP**: 回环算法，适用于有符号和无符号整型两种类型。对于无符号整型，回环计数将对整型最大值进行取模操作（C语言的标准行为）。对于有符号整型，上溢从最负的负数开始取数，下溢则从最大的正数开始取数，例如，如果i8整型的值设为127，自加1后的值变为-128。\n- **SAT**: 饱和算法，下溢之后设为最小的整型值，上溢之后设为最大的整数值。例如，i8整型的值从120开始加10后，结果是127，继续增加，结果还是保持为127。下溢也是同理，但量结果值将会保持在最负的负数值。\n- **FAIL**: 失败算法，这种模式下，在检测到上溢或下溢时，不做任何操作。相应的返回值会设为NULL，并返回给调用者。\n\n注意每种溢出（`OVERFLOW`）控制方法，仅影响紧跟在`INCRBY`命令后的子命令，直到重新指定溢出（`OVERFLOW`）控制方法。\n\n如果没有指定溢出控制方法，默认情况下，将使用**WRAP**算法。\n```\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\n1) (integer) 1\n2) (integer) 1\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\n1) (integer) 2\n2) (integer) 2\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\n1) (integer) 3\n2) (integer) 3\n> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1\n1) (integer) 0\n2) (integer) 3\n```\n#### 返回值\n本命令返回一个针对子命令给定位置的处理结果组成的数组。OVERFLOW子命令在响应消息中，不会统计结果的条数。\n下面是OVERFLOW FAIL返回NULL的样例：\n```\n> BITFIELD mykey OVERFLOW FAIL incrby u2 102 1\n1) (nil)\n```\n\n#### 动机（Motivations）\n本命令的动机是为了能够在单个大位图（large bitmap）中高效地存储多个小整数（或对键分成多个key，避免出现超大键），同时开放Redis提供的新使用案例，尤其是在实时分析领域。这种使用案例可以通过指定的溢出控制方法来支持。\n\n#### 性能考虑（Performance considerations）\n通常，BITFIELD是一个非常快的命令，但是注意，对短字符串的远地址（fat bits）寻址，将会比在存在的位执行命令更加耗时。\n\n#### 字节序（Orders of bits）\nBITFIELD命令使用的位图表现形式，可看作是从0位开始的，例如：把一个5位的无符号整数23，对一个所有位事先置0的位图，从第7位开始赋值，其结果如下所示：\n```\n+--------+--------+\n|00000001|01110000|\n+--------+--------+\n```\n当偏移量和整型大小是字节边界对齐时，此时与大端模式（big endian）相同，但是，当字节边界未对齐时，那么理解字节序将变得非常重要。\n\n","slug":"redis_command/bitmap/bitfield","published":1,"updated":"2021-03-14T03:04:50.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfptw001dhyjfm1j1ae68","content":"<h2 id=\"BITFIELD-key\"><a href=\"#BITFIELD-key\" class=\"headerlink\" title=\"BITFIELD key\"></a>BITFIELD key</h2><p><strong>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL] </strong></p>\n<blockquote>\n<p>起始版本：3.2.0<br>时间复杂度：O(1)  对于指定的每个子命令</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>本命令会把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。在实践中，可以使用该命令对一个有符号的5位整型数的1234位设置指定值，也可以对一个31位无符号整型数的4567位进行取值。类似地，在对指定的整数进行自增和自减操作，本命令可以提供有保证的、可配置的上溢和下溢处理操作。</li>\n<li>BITFIELD命令能操作多字节位域，它会执行一系列操作，并返回一个响应数组，在参数列表中每个响应数组匹配相应的操作。<br>例如，下面的命令是对一个8位有符号整数偏移100位自增1，并获取4位无符号整数的值：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; BITFIELD mykey INCRBY i5 100 1 GET u4 0</span><br><span class=\"line\">1) (integer) 1</span><br><span class=\"line\">2) (integer) 0</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>提示：</strong></p>\n<ul>\n<li>用GET指令对超出当前字符串长度的位（含key不存在的情况）进行寻址，执行操作的结果会对缺失部分的位（bits）赋值为0。</li>\n<li>用SET或INCRBY指令对超出当前字符串长度的位（含key不存在的情况）进行寻址，将会扩展字符串并对扩展部分进行补0，扩展方式包括：按需扩展、按最小长度扩展和按最大寻址能力扩展。</li>\n</ul>\n<h4 id=\"支持子命令和整型\"><a href=\"#支持子命令和整型\" class=\"headerlink\" title=\"支持子命令和整型\"></a>支持子命令和整型</h4><p>下面是已支持的命令列表：</p>\n<ul>\n<li><code>GET &lt;type&gt; &lt;offset&gt;</code> – 返回指定的位域</li>\n<li><code>SET &lt;type&gt; &lt;offset&gt; &lt;value&gt;</code> – 设置指定位域的值并返回它的原值</li>\n<li><code>INCRBY &lt;type&gt; &lt;offset&gt; &lt;increment&gt;</code> – 自增或自减（如果increment为负数）指定位域的值并返回它的新值<br>还有一个命令通过设置溢出行为来改变调用INCRBY指令的后序操作：<br><code>OVERFLOW [WRAP|SAT|FAIL]</code></li>\n<li>当需要一个整型时，有符号整型需在位数前加i，无符号在位数前加u。例如，u8是一个8位的无符号整型，i16是一个16位的有符号整型。</li>\n<li>有符号整型最大支持64位，而无符号整型最大支持63位。对无符号整型的限制，是由于当前Redis协议不能在响应消息中返回64位无符号整数。<h4 id=\"位和位偏移\"><a href=\"#位和位偏移\" class=\"headerlink\" title=\"位和位偏移\"></a>位和位偏移</h4>bitfield命令有两种方式来指定位偏移。如果未定带数字的前缀，将会以字符串的第0位作为起始位。<br>不过，如果偏移量带有#前缀，那么指定的偏移量需要乘以整型宽度，例如：<br><code>BITFIELD mystring SET i8 #0 100 i8 #1 200</code></li>\n</ul>\n<p>将会在第1个i8整数的偏移0位和第2个整数的偏移8位进行设值。如果想得到一个给定长度的普通整型数组，则不一定要在客户端进行计算。</p>\n<h4 id=\"溢出控制\"><a href=\"#溢出控制\" class=\"headerlink\" title=\"溢出控制\"></a>溢出控制</h4><p>使用<code>OVERFLOW</code>命令，用户可以通过指定下列其中一种行为来调整自增或自减操作溢出（或下溢）后的行为：</p>\n<ul>\n<li><strong>WRAP</strong>: 回环算法，适用于有符号和无符号整型两种类型。对于无符号整型，回环计数将对整型最大值进行取模操作（C语言的标准行为）。对于有符号整型，上溢从最负的负数开始取数，下溢则从最大的正数开始取数，例如，如果i8整型的值设为127，自加1后的值变为-128。</li>\n<li><strong>SAT</strong>: 饱和算法，下溢之后设为最小的整型值，上溢之后设为最大的整数值。例如，i8整型的值从120开始加10后，结果是127，继续增加，结果还是保持为127。下溢也是同理，但量结果值将会保持在最负的负数值。</li>\n<li><strong>FAIL</strong>: 失败算法，这种模式下，在检测到上溢或下溢时，不做任何操作。相应的返回值会设为NULL，并返回给调用者。</li>\n</ul>\n<p>注意每种溢出（<code>OVERFLOW</code>）控制方法，仅影响紧跟在<code>INCRBY</code>命令后的子命令，直到重新指定溢出（<code>OVERFLOW</code>）控制方法。</p>\n<p>如果没有指定溢出控制方法，默认情况下，将使用<strong>WRAP</strong>算法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class=\"line\">1) (integer) 1</span><br><span class=\"line\">2) (integer) 1</span><br><span class=\"line\">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class=\"line\">1) (integer) 2</span><br><span class=\"line\">2) (integer) 2</span><br><span class=\"line\">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class=\"line\">1) (integer) 3</span><br><span class=\"line\">2) (integer) 3</span><br><span class=\"line\">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class=\"line\">1) (integer) 0</span><br><span class=\"line\">2) (integer) 3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>本命令返回一个针对子命令给定位置的处理结果组成的数组。OVERFLOW子命令在响应消息中，不会统计结果的条数。<br>下面是OVERFLOW FAIL返回NULL的样例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; BITFIELD mykey OVERFLOW FAIL incrby u2 102 1</span><br><span class=\"line\">1) (nil)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"动机（Motivations）\"><a href=\"#动机（Motivations）\" class=\"headerlink\" title=\"动机（Motivations）\"></a>动机（Motivations）</h4><p>本命令的动机是为了能够在单个大位图（large bitmap）中高效地存储多个小整数（或对键分成多个key，避免出现超大键），同时开放Redis提供的新使用案例，尤其是在实时分析领域。这种使用案例可以通过指定的溢出控制方法来支持。</p>\n<h4 id=\"性能考虑（Performance-considerations）\"><a href=\"#性能考虑（Performance-considerations）\" class=\"headerlink\" title=\"性能考虑（Performance considerations）\"></a>性能考虑（Performance considerations）</h4><p>通常，BITFIELD是一个非常快的命令，但是注意，对短字符串的远地址（fat bits）寻址，将会比在存在的位执行命令更加耗时。</p>\n<h4 id=\"字节序（Orders-of-bits）\"><a href=\"#字节序（Orders-of-bits）\" class=\"headerlink\" title=\"字节序（Orders of bits）\"></a>字节序（Orders of bits）</h4><p>BITFIELD命令使用的位图表现形式，可看作是从0位开始的，例如：把一个5位的无符号整数23，对一个所有位事先置0的位图，从第7位开始赋值，其结果如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--------+--------+</span><br><span class=\"line\">|00000001|01110000|</span><br><span class=\"line\">+--------+--------+</span><br></pre></td></tr></table></figure></p>\n<p>当偏移量和整型大小是字节边界对齐时，此时与大端模式（big endian）相同，但是，当字节边界未对齐时，那么理解字节序将变得非常重要。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"BITFIELD-key\"><a href=\"#BITFIELD-key\" class=\"headerlink\" title=\"BITFIELD key\"></a>BITFIELD key</h2><p><strong>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL] </strong></p>\n<blockquote>\n<p>起始版本：3.2.0<br>时间复杂度：O(1)  对于指定的每个子命令</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>本命令会把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。在实践中，可以使用该命令对一个有符号的5位整型数的1234位设置指定值，也可以对一个31位无符号整型数的4567位进行取值。类似地，在对指定的整数进行自增和自减操作，本命令可以提供有保证的、可配置的上溢和下溢处理操作。</li>\n<li>BITFIELD命令能操作多字节位域，它会执行一系列操作，并返回一个响应数组，在参数列表中每个响应数组匹配相应的操作。<br>例如，下面的命令是对一个8位有符号整数偏移100位自增1，并获取4位无符号整数的值：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; BITFIELD mykey INCRBY i5 100 1 GET u4 0</span><br><span class=\"line\">1) (integer) 1</span><br><span class=\"line\">2) (integer) 0</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>提示：</strong></p>\n<ul>\n<li>用GET指令对超出当前字符串长度的位（含key不存在的情况）进行寻址，执行操作的结果会对缺失部分的位（bits）赋值为0。</li>\n<li>用SET或INCRBY指令对超出当前字符串长度的位（含key不存在的情况）进行寻址，将会扩展字符串并对扩展部分进行补0，扩展方式包括：按需扩展、按最小长度扩展和按最大寻址能力扩展。</li>\n</ul>\n<h4 id=\"支持子命令和整型\"><a href=\"#支持子命令和整型\" class=\"headerlink\" title=\"支持子命令和整型\"></a>支持子命令和整型</h4><p>下面是已支持的命令列表：</p>\n<ul>\n<li><code>GET &lt;type&gt; &lt;offset&gt;</code> – 返回指定的位域</li>\n<li><code>SET &lt;type&gt; &lt;offset&gt; &lt;value&gt;</code> – 设置指定位域的值并返回它的原值</li>\n<li><code>INCRBY &lt;type&gt; &lt;offset&gt; &lt;increment&gt;</code> – 自增或自减（如果increment为负数）指定位域的值并返回它的新值<br>还有一个命令通过设置溢出行为来改变调用INCRBY指令的后序操作：<br><code>OVERFLOW [WRAP|SAT|FAIL]</code></li>\n<li>当需要一个整型时，有符号整型需在位数前加i，无符号在位数前加u。例如，u8是一个8位的无符号整型，i16是一个16位的有符号整型。</li>\n<li>有符号整型最大支持64位，而无符号整型最大支持63位。对无符号整型的限制，是由于当前Redis协议不能在响应消息中返回64位无符号整数。<h4 id=\"位和位偏移\"><a href=\"#位和位偏移\" class=\"headerlink\" title=\"位和位偏移\"></a>位和位偏移</h4>bitfield命令有两种方式来指定位偏移。如果未定带数字的前缀，将会以字符串的第0位作为起始位。<br>不过，如果偏移量带有#前缀，那么指定的偏移量需要乘以整型宽度，例如：<br><code>BITFIELD mystring SET i8 #0 100 i8 #1 200</code></li>\n</ul>\n<p>将会在第1个i8整数的偏移0位和第2个整数的偏移8位进行设值。如果想得到一个给定长度的普通整型数组，则不一定要在客户端进行计算。</p>\n<h4 id=\"溢出控制\"><a href=\"#溢出控制\" class=\"headerlink\" title=\"溢出控制\"></a>溢出控制</h4><p>使用<code>OVERFLOW</code>命令，用户可以通过指定下列其中一种行为来调整自增或自减操作溢出（或下溢）后的行为：</p>\n<ul>\n<li><strong>WRAP</strong>: 回环算法，适用于有符号和无符号整型两种类型。对于无符号整型，回环计数将对整型最大值进行取模操作（C语言的标准行为）。对于有符号整型，上溢从最负的负数开始取数，下溢则从最大的正数开始取数，例如，如果i8整型的值设为127，自加1后的值变为-128。</li>\n<li><strong>SAT</strong>: 饱和算法，下溢之后设为最小的整型值，上溢之后设为最大的整数值。例如，i8整型的值从120开始加10后，结果是127，继续增加，结果还是保持为127。下溢也是同理，但量结果值将会保持在最负的负数值。</li>\n<li><strong>FAIL</strong>: 失败算法，这种模式下，在检测到上溢或下溢时，不做任何操作。相应的返回值会设为NULL，并返回给调用者。</li>\n</ul>\n<p>注意每种溢出（<code>OVERFLOW</code>）控制方法，仅影响紧跟在<code>INCRBY</code>命令后的子命令，直到重新指定溢出（<code>OVERFLOW</code>）控制方法。</p>\n<p>如果没有指定溢出控制方法，默认情况下，将使用<strong>WRAP</strong>算法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class=\"line\">1) (integer) 1</span><br><span class=\"line\">2) (integer) 1</span><br><span class=\"line\">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class=\"line\">1) (integer) 2</span><br><span class=\"line\">2) (integer) 2</span><br><span class=\"line\">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class=\"line\">1) (integer) 3</span><br><span class=\"line\">2) (integer) 3</span><br><span class=\"line\">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class=\"line\">1) (integer) 0</span><br><span class=\"line\">2) (integer) 3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>本命令返回一个针对子命令给定位置的处理结果组成的数组。OVERFLOW子命令在响应消息中，不会统计结果的条数。<br>下面是OVERFLOW FAIL返回NULL的样例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; BITFIELD mykey OVERFLOW FAIL incrby u2 102 1</span><br><span class=\"line\">1) (nil)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"动机（Motivations）\"><a href=\"#动机（Motivations）\" class=\"headerlink\" title=\"动机（Motivations）\"></a>动机（Motivations）</h4><p>本命令的动机是为了能够在单个大位图（large bitmap）中高效地存储多个小整数（或对键分成多个key，避免出现超大键），同时开放Redis提供的新使用案例，尤其是在实时分析领域。这种使用案例可以通过指定的溢出控制方法来支持。</p>\n<h4 id=\"性能考虑（Performance-considerations）\"><a href=\"#性能考虑（Performance-considerations）\" class=\"headerlink\" title=\"性能考虑（Performance considerations）\"></a>性能考虑（Performance considerations）</h4><p>通常，BITFIELD是一个非常快的命令，但是注意，对短字符串的远地址（fat bits）寻址，将会比在存在的位执行命令更加耗时。</p>\n<h4 id=\"字节序（Orders-of-bits）\"><a href=\"#字节序（Orders-of-bits）\" class=\"headerlink\" title=\"字节序（Orders of bits）\"></a>字节序（Orders of bits）</h4><p>BITFIELD命令使用的位图表现形式，可看作是从0位开始的，例如：把一个5位的无符号整数23，对一个所有位事先置0的位图，从第7位开始赋值，其结果如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--------+--------+</span><br><span class=\"line\">|00000001|01110000|</span><br><span class=\"line\">+--------+--------+</span><br></pre></td></tr></table></figure></p>\n<p>当偏移量和整型大小是字节边界对齐时，此时与大端模式（big endian）相同，但是，当字节边界未对齐时，那么理解字节序将变得非常重要。</p>\n"},{"title":"SDIFFSTORE(sdiffstore)","copyright":true,"date":"2020-03-30T06:43:30.000Z","keywords":"Redis命令,sdiffstore","aside":"set","_content":"## SDIFFSTORE destination key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是所有给定集合中元素的总数\n\n\n#### 说明:\n* 该命令类似于 SDIFF, 不同之处在于该命令不返回结果集，而是将结果存放在destination集合中.\n* 如果destination已经存在, 则将其覆盖重写.\n\n#### 返回值\n\n**integer-reply**: 结果集元素的个数.\n\n\n#### 示例\n\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SDIFFSTORE key key1 key2\n(integer) 2\nredis> SMEMBERS key\n1) \"b\"\n2) \"a\"\nredis> \n```","source":"_posts/redis_command/set/sdiffstore.md","raw":"---\n\ntitle: SDIFFSTORE(sdiffstore)\ncopyright: true\ndate: 2020-03-30 14:43:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,sdiffstore\naside: set\n\n---\n## SDIFFSTORE destination key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是所有给定集合中元素的总数\n\n\n#### 说明:\n* 该命令类似于 SDIFF, 不同之处在于该命令不返回结果集，而是将结果存放在destination集合中.\n* 如果destination已经存在, 则将其覆盖重写.\n\n#### 返回值\n\n**integer-reply**: 结果集元素的个数.\n\n\n#### 示例\n\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SDIFFSTORE key key1 key2\n(integer) 2\nredis> SMEMBERS key\n1) \"b\"\n2) \"a\"\nredis> \n```","slug":"redis_command/set/sdiffstore","published":1,"updated":"2021-03-14T03:04:50.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfptx001fhyjfcsh83q9u","content":"<h2 id=\"SDIFFSTORE-destination-key-key-…\"><a href=\"#SDIFFSTORE-destination-key-key-…\" class=\"headerlink\" title=\"SDIFFSTORE destination key [key …]\"></a>SDIFFSTORE destination key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是所有给定集合中元素的总数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>该命令类似于 SDIFF, 不同之处在于该命令不返回结果集，而是将结果存放在destination集合中.</li>\n<li>如果destination已经存在, 则将其覆盖重写.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 结果集元素的个数.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SDIFFSTORE key key1 key2</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; SMEMBERS key</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SDIFFSTORE-destination-key-key-…\"><a href=\"#SDIFFSTORE-destination-key-key-…\" class=\"headerlink\" title=\"SDIFFSTORE destination key [key …]\"></a>SDIFFSTORE destination key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是所有给定集合中元素的总数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>该命令类似于 SDIFF, 不同之处在于该命令不返回结果集，而是将结果存放在destination集合中.</li>\n<li>如果destination已经存在, 则将其覆盖重写.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 结果集元素的个数.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SDIFFSTORE key key1 key2</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; SMEMBERS key</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SCARD(scard)","copyright":true,"date":"2020-03-30T06:45:30.000Z","keywords":"Redis命令,scard","aside":"set","_content":"## SCARD key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回集合存储的key的基数 (集合元素的数量).\n\n#### 返回值\n\n\n**integer-reply**: 集合的基数(元素的数量),如果key不存在,则返回 0.\n#### 示例\n```c\nredis> SADD myset \"Hello\"\n(integer) 1\nredis> SADD myset \"World\"\n(integer) 1\nredis> SCARD myset\n(integer) 2\nredis> \n```\n","source":"_posts/redis_command/set/scard.md","raw":"---\n\ntitle: SCARD(scard)\ncopyright: true\ndate: 2020-03-30 14:45:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,scard\naside: set\n\n---\n## SCARD key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回集合存储的key的基数 (集合元素的数量).\n\n#### 返回值\n\n\n**integer-reply**: 集合的基数(元素的数量),如果key不存在,则返回 0.\n#### 示例\n```c\nredis> SADD myset \"Hello\"\n(integer) 1\nredis> SADD myset \"World\"\n(integer) 1\nredis> SCARD myset\n(integer) 2\nredis> \n```\n","slug":"redis_command/set/scard","published":1,"updated":"2021-03-14T03:04:50.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfptz001ghyjffytdecw8","content":"<h2 id=\"SCARD-key\"><a href=\"#SCARD-key\" class=\"headerlink\" title=\"SCARD key\"></a>SCARD key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回集合存储的key的基数 (集合元素的数量).</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 集合的基数(元素的数量),如果key不存在,则返回 0.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SCARD myset</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SCARD-key\"><a href=\"#SCARD-key\" class=\"headerlink\" title=\"SCARD key\"></a>SCARD key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回集合存储的key的基数 (集合元素的数量).</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 集合的基数(元素的数量),如果key不存在,则返回 0.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SCARD myset</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"SADD(sadd)","copyright":true,"date":"2020-03-30T06:46:30.000Z","keywords":"Redis命令,sadd","aside":"set","_content":"## SADD key member [member ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是要添加的成员数  \n\n\n#### 说明:\n* 添加一个或多个指定的member元素到集合的 key中.指定的一个或者多个元素member 如果已经在集合key中存在则忽略.如果集合key 不存在，则新建集合key,并添加member元素到集合key中.\n* 如果key 的类型不是集合则返回错误.\n\n#### 返回值\n\n**integer-reply**:返回新成功添加到集合里元素的数量，不包括已经存在于集合中的元素.\n\n#### 历史\n\n\n\\>= 2.4: 接受多个member 参数. Redis 2.4 以前的版本每次只能添加一个member元素.\n\n\n#### 示例\n\n```c\nredis> SADD myset \"Hello\"\n(integer) 1\nredis> SADD myset \"World\"\n(integer) 1\nredis> SADD myset \"World\"\n(integer) 0\nredis> SMEMBERS myset\n1) \"World\"\n2) \"Hello\"\nredis> \n```","source":"_posts/redis_command/set/sadd.md","raw":"---\n\ntitle: SADD(sadd)\ncopyright: true\ndate: 2020-03-30 14:46:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,sadd\naside: set\n\n---\n## SADD key member [member ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是要添加的成员数  \n\n\n#### 说明:\n* 添加一个或多个指定的member元素到集合的 key中.指定的一个或者多个元素member 如果已经在集合key中存在则忽略.如果集合key 不存在，则新建集合key,并添加member元素到集合key中.\n* 如果key 的类型不是集合则返回错误.\n\n#### 返回值\n\n**integer-reply**:返回新成功添加到集合里元素的数量，不包括已经存在于集合中的元素.\n\n#### 历史\n\n\n\\>= 2.4: 接受多个member 参数. Redis 2.4 以前的版本每次只能添加一个member元素.\n\n\n#### 示例\n\n```c\nredis> SADD myset \"Hello\"\n(integer) 1\nredis> SADD myset \"World\"\n(integer) 1\nredis> SADD myset \"World\"\n(integer) 0\nredis> SMEMBERS myset\n1) \"World\"\n2) \"Hello\"\nredis> \n```","slug":"redis_command/set/sadd","published":1,"updated":"2021-03-14T03:04:50.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu0001ihyjfewky7e83","content":"<h2 id=\"SADD-key-member-member-…\"><a href=\"#SADD-key-member-member-…\" class=\"headerlink\" title=\"SADD key member [member …]\"></a>SADD key member [member …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是要添加的成员数  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>添加一个或多个指定的member元素到集合的 key中.指定的一个或者多个元素member 如果已经在集合key中存在则忽略.如果集合key 不存在，则新建集合key,并添加member元素到集合key中.</li>\n<li>如果key 的类型不是集合则返回错误.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:返回新成功添加到集合里元素的数量，不包括已经存在于集合中的元素.</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>>= 2.4: 接受多个member 参数. Redis 2.4 以前的版本每次只能添加一个member元素.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; SMEMBERS myset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SADD-key-member-member-…\"><a href=\"#SADD-key-member-member-…\" class=\"headerlink\" title=\"SADD key member [member …]\"></a>SADD key member [member …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是要添加的成员数  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>添加一个或多个指定的member元素到集合的 key中.指定的一个或者多个元素member 如果已经在集合key中存在则忽略.如果集合key 不存在，则新建集合key,并添加member元素到集合key中.</li>\n<li>如果key 的类型不是集合则返回错误.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:返回新成功添加到集合里元素的数量，不包括已经存在于集合中的元素.</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>>= 2.4: 接受多个member 参数. Redis 2.4 以前的版本每次只能添加一个member元素.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; SMEMBERS myset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SDIFF(sdiff)","copyright":true,"date":"2020-03-30T06:44:30.000Z","keywords":"Redis命令,sdiff","aside":"set","_content":"## SDIFF key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是所有给定集合中元素的总数。\n\n\n#### 说明:\n* 返回一个集合与给定集合的差集的元素.\n\n#### 返回值\n\n**array-reply**:结果集的元素.\n\n#### 示例\n\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SDIFF key1 key2\n1) \"a\"\n2) \"b\"\nredis> \n```","source":"_posts/redis_command/set/sdiff.md","raw":"---\n\ntitle: SDIFF(sdiff)\ncopyright: true\ndate: 2020-03-30 14:44:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,sdiff\naside: set\n---\n## SDIFF key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是所有给定集合中元素的总数。\n\n\n#### 说明:\n* 返回一个集合与给定集合的差集的元素.\n\n#### 返回值\n\n**array-reply**:结果集的元素.\n\n#### 示例\n\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SDIFF key1 key2\n1) \"a\"\n2) \"b\"\nredis> \n```","slug":"redis_command/set/sdiff","published":1,"updated":"2021-03-14T03:04:50.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu0001jhyjfjhx9l67y","content":"<h2 id=\"SDIFF-key-key-…\"><a href=\"#SDIFF-key-key-…\" class=\"headerlink\" title=\"SDIFF key [key …]\"></a>SDIFF key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是所有给定集合中元素的总数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回一个集合与给定集合的差集的元素.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>:结果集的元素.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SDIFF key1 key2</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SDIFF-key-key-…\"><a href=\"#SDIFF-key-key-…\" class=\"headerlink\" title=\"SDIFF key [key …]\"></a>SDIFF key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是所有给定集合中元素的总数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回一个集合与给定集合的差集的元素.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>:结果集的元素.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SDIFF key1 key2</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SINTERSTORE(sinterstore)","copyright":true,"date":"2020-03-30T06:41:30.000Z","keywords":"Redis命令,sinterstore","aside":"set","_content":"## SINTERSTORE destination key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N*M) 最坏情况下，N是最小集合的基数,M是集合的个数 \n\n\n#### 说明:\n* 这个命令与SINTER命令类似, 但是它并不是直接返回结果集,而是将结果保存在 destination集合中.\n* 如果destination 集合存在, 则会被重写.\n\n#### 返回值\n\n**integer-reply**: 结果集中成员的个数.\n\n\n#### 示例\n\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SINTERSTORE key key1 key2\n(integer) 1\nredis> SMEMBERS key\n1) \"c\"\nredis> \n```","source":"_posts/redis_command/set/sinterstore.md","raw":"---\n\ntitle: SINTERSTORE(sinterstore)\ncopyright: true\ndate: 2020-03-30 14:41:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,sinterstore\naside: set\n\n---\n## SINTERSTORE destination key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N*M) 最坏情况下，N是最小集合的基数,M是集合的个数 \n\n\n#### 说明:\n* 这个命令与SINTER命令类似, 但是它并不是直接返回结果集,而是将结果保存在 destination集合中.\n* 如果destination 集合存在, 则会被重写.\n\n#### 返回值\n\n**integer-reply**: 结果集中成员的个数.\n\n\n#### 示例\n\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SINTERSTORE key key1 key2\n(integer) 1\nredis> SMEMBERS key\n1) \"c\"\nredis> \n```","slug":"redis_command/set/sinterstore","published":1,"updated":"2021-03-14T03:04:50.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu1001lhyjfwib6dwi2","content":"<h2 id=\"SINTERSTORE-destination-key-key-…\"><a href=\"#SINTERSTORE-destination-key-key-…\" class=\"headerlink\" title=\"SINTERSTORE destination key [key …]\"></a>SINTERSTORE destination key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N*M) 最坏情况下，N是最小集合的基数,M是集合的个数 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>这个命令与SINTER命令类似, 但是它并不是直接返回结果集,而是将结果保存在 destination集合中.</li>\n<li>如果destination 集合存在, 则会被重写.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 结果集中成员的个数.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SINTERSTORE key key1 key2</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SMEMBERS key</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SINTERSTORE-destination-key-key-…\"><a href=\"#SINTERSTORE-destination-key-key-…\" class=\"headerlink\" title=\"SINTERSTORE destination key [key …]\"></a>SINTERSTORE destination key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N*M) 最坏情况下，N是最小集合的基数,M是集合的个数 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>这个命令与SINTER命令类似, 但是它并不是直接返回结果集,而是将结果保存在 destination集合中.</li>\n<li>如果destination 集合存在, 则会被重写.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 结果集中成员的个数.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SINTERSTORE key key1 key2</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SMEMBERS key</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"BITPOS(bitpos)","copyright":true,"date":"2020-03-19T12:00:19.000Z","keywords":"Redis命令,bitpos","aside":"bitmap","_content":"## BITPOS key bit [start] [end] \n>起始版本：2.8.7<br/>时间复杂度：O(N)  \n\n\n#### 说明:\n* 返回字符串里面第一个被设置为1或者0的bit位。\n\n* 返回一个位置，把字符串当做一个从左到右的字节数组，第一个符合条件的在位置0，其次在位置8，等等。\n\n* 和`GETBIT` 相似的也是操作字节位的命令。\n\n* 默认情况下整个字符串都会被检索一次，只有在指定start和end参数(指定start和end位是可行的)，该范围被解释为一个字节的范围，而不是一系列的位。所以`start=0` 并且 `end=2`是指前三个字节范围内查找。\n  注意，返回的位的位置始终是从0开始的，即使使用了start来指定了一个开始字节也是这样。\n\n* 和GETRANGE命令一样，start和end也可以包含负值，负值将从字符串的末尾开始计算，-1是字符串的最后一个字节，-2是倒数第二个，等等。\n\n* 不存在的key将会被当做空字符串来处理。\n\n#### 返回值\n\n\n**Integer reply:**\n命令返回字符串里面第一个被设置为1或者0的bit位。\n如果我们在空字符串或者0字节的字符串里面查找bit为1的内容，那么结果将返回-1。\n如果我们在字符串里面查找bit为0而且字符串只包含1的值时，将返回字符串最右边的第一个空位。如果有一个字符串是三个字节的值为0xff的字符串，那么命令BITPOS key 0将会返回24，因为0-23位都是1。\n基本上，我们可以把字符串看成右边有无数个0。\n如果你用指定start和end范围进行查找指定值时，如果该范围内没有对应值，结果将返回-1。\n\n\n#### 示例\n\n```\nredis> SET mykey \"\\xff\\xf0\\x00\"\nOK\n//# 查找字符串里面bit值为0的位置\nredis> BITPOS mykey 0 \n(integer) 12\nredis> SET mykey \"\\x00\\xff\\xf0\"\nOK\n//查找字符串里面bit值为1从第0个字节开始的位置\nredis> BITPOS mykey 1 0 \n(integer) 8\n//查找字符串里面bit值为1从第2个字节(12)开始的位置\nredis> BITPOS mykey 1 2 \n(integer) 16\nredis> set mykey \"\\x00\\x00\\x00\"\nOK\n//查找字符串里面bit值为1的位置\nredis> BITPOS mykey 1 \n(integer) -1\nredis>\n```","source":"_posts/redis_command/bitmap/bitpos.md","raw":"---\ntitle: BITPOS(bitpos)\ncopyright: true\ndate: 2020-03-19 20:00:19\ncategories: \n- Redis命令大全\n- Bitmap\nkeywords: Redis命令,bitpos\naside: bitmap\n---\n## BITPOS key bit [start] [end] \n>起始版本：2.8.7<br/>时间复杂度：O(N)  \n\n\n#### 说明:\n* 返回字符串里面第一个被设置为1或者0的bit位。\n\n* 返回一个位置，把字符串当做一个从左到右的字节数组，第一个符合条件的在位置0，其次在位置8，等等。\n\n* 和`GETBIT` 相似的也是操作字节位的命令。\n\n* 默认情况下整个字符串都会被检索一次，只有在指定start和end参数(指定start和end位是可行的)，该范围被解释为一个字节的范围，而不是一系列的位。所以`start=0` 并且 `end=2`是指前三个字节范围内查找。\n  注意，返回的位的位置始终是从0开始的，即使使用了start来指定了一个开始字节也是这样。\n\n* 和GETRANGE命令一样，start和end也可以包含负值，负值将从字符串的末尾开始计算，-1是字符串的最后一个字节，-2是倒数第二个，等等。\n\n* 不存在的key将会被当做空字符串来处理。\n\n#### 返回值\n\n\n**Integer reply:**\n命令返回字符串里面第一个被设置为1或者0的bit位。\n如果我们在空字符串或者0字节的字符串里面查找bit为1的内容，那么结果将返回-1。\n如果我们在字符串里面查找bit为0而且字符串只包含1的值时，将返回字符串最右边的第一个空位。如果有一个字符串是三个字节的值为0xff的字符串，那么命令BITPOS key 0将会返回24，因为0-23位都是1。\n基本上，我们可以把字符串看成右边有无数个0。\n如果你用指定start和end范围进行查找指定值时，如果该范围内没有对应值，结果将返回-1。\n\n\n#### 示例\n\n```\nredis> SET mykey \"\\xff\\xf0\\x00\"\nOK\n//# 查找字符串里面bit值为0的位置\nredis> BITPOS mykey 0 \n(integer) 12\nredis> SET mykey \"\\x00\\xff\\xf0\"\nOK\n//查找字符串里面bit值为1从第0个字节开始的位置\nredis> BITPOS mykey 1 0 \n(integer) 8\n//查找字符串里面bit值为1从第2个字节(12)开始的位置\nredis> BITPOS mykey 1 2 \n(integer) 16\nredis> set mykey \"\\x00\\x00\\x00\"\nOK\n//查找字符串里面bit值为1的位置\nredis> BITPOS mykey 1 \n(integer) -1\nredis>\n```","slug":"redis_command/bitmap/bitpos","published":1,"updated":"2021-03-14T03:04:50.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu2001mhyjfinz50wdp","content":"<h2 id=\"BITPOS-key-bit-start-end\"><a href=\"#BITPOS-key-bit-start-end\" class=\"headerlink\" title=\"BITPOS key bit [start] [end]\"></a>BITPOS key bit [start] [end]</h2><blockquote>\n<p>起始版本：2.8.7<br>时间复杂度：O(N)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>返回字符串里面第一个被设置为1或者0的bit位。</p>\n</li>\n<li><p>返回一个位置，把字符串当做一个从左到右的字节数组，第一个符合条件的在位置0，其次在位置8，等等。</p>\n</li>\n<li><p>和<code>GETBIT</code> 相似的也是操作字节位的命令。</p>\n</li>\n<li><p>默认情况下整个字符串都会被检索一次，只有在指定start和end参数(指定start和end位是可行的)，该范围被解释为一个字节的范围，而不是一系列的位。所以<code>start=0</code> 并且 <code>end=2</code>是指前三个字节范围内查找。<br>注意，返回的位的位置始终是从0开始的，即使使用了start来指定了一个开始字节也是这样。</p>\n</li>\n<li><p>和GETRANGE命令一样，start和end也可以包含负值，负值将从字符串的末尾开始计算，-1是字符串的最后一个字节，-2是倒数第二个，等等。</p>\n</li>\n<li><p>不存在的key将会被当做空字符串来处理。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply:</strong><br>命令返回字符串里面第一个被设置为1或者0的bit位。<br>如果我们在空字符串或者0字节的字符串里面查找bit为1的内容，那么结果将返回-1。<br>如果我们在字符串里面查找bit为0而且字符串只包含1的值时，将返回字符串最右边的第一个空位。如果有一个字符串是三个字节的值为0xff的字符串，那么命令BITPOS key 0将会返回24，因为0-23位都是1。<br>基本上，我们可以把字符串看成右边有无数个0。<br>如果你用指定start和end范围进行查找指定值时，如果该范围内没有对应值，结果将返回-1。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey &quot;\\xff\\xf0\\x00&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">//# 查找字符串里面bit值为0的位置</span><br><span class=\"line\">redis&gt; BITPOS mykey 0 </span><br><span class=\"line\">(integer) 12</span><br><span class=\"line\">redis&gt; SET mykey &quot;\\x00\\xff\\xf0&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">//查找字符串里面bit值为1从第0个字节开始的位置</span><br><span class=\"line\">redis&gt; BITPOS mykey 1 0 </span><br><span class=\"line\">(integer) 8</span><br><span class=\"line\">//查找字符串里面bit值为1从第2个字节(12)开始的位置</span><br><span class=\"line\">redis&gt; BITPOS mykey 1 2 </span><br><span class=\"line\">(integer) 16</span><br><span class=\"line\">redis&gt; set mykey &quot;\\x00\\x00\\x00&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">//查找字符串里面bit值为1的位置</span><br><span class=\"line\">redis&gt; BITPOS mykey 1 </span><br><span class=\"line\">(integer) -1</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"BITPOS-key-bit-start-end\"><a href=\"#BITPOS-key-bit-start-end\" class=\"headerlink\" title=\"BITPOS key bit [start] [end]\"></a>BITPOS key bit [start] [end]</h2><blockquote>\n<p>起始版本：2.8.7<br>时间复杂度：O(N)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>返回字符串里面第一个被设置为1或者0的bit位。</p>\n</li>\n<li><p>返回一个位置，把字符串当做一个从左到右的字节数组，第一个符合条件的在位置0，其次在位置8，等等。</p>\n</li>\n<li><p>和<code>GETBIT</code> 相似的也是操作字节位的命令。</p>\n</li>\n<li><p>默认情况下整个字符串都会被检索一次，只有在指定start和end参数(指定start和end位是可行的)，该范围被解释为一个字节的范围，而不是一系列的位。所以<code>start=0</code> 并且 <code>end=2</code>是指前三个字节范围内查找。<br>注意，返回的位的位置始终是从0开始的，即使使用了start来指定了一个开始字节也是这样。</p>\n</li>\n<li><p>和GETRANGE命令一样，start和end也可以包含负值，负值将从字符串的末尾开始计算，-1是字符串的最后一个字节，-2是倒数第二个，等等。</p>\n</li>\n<li><p>不存在的key将会被当做空字符串来处理。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply:</strong><br>命令返回字符串里面第一个被设置为1或者0的bit位。<br>如果我们在空字符串或者0字节的字符串里面查找bit为1的内容，那么结果将返回-1。<br>如果我们在字符串里面查找bit为0而且字符串只包含1的值时，将返回字符串最右边的第一个空位。如果有一个字符串是三个字节的值为0xff的字符串，那么命令BITPOS key 0将会返回24，因为0-23位都是1。<br>基本上，我们可以把字符串看成右边有无数个0。<br>如果你用指定start和end范围进行查找指定值时，如果该范围内没有对应值，结果将返回-1。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey &quot;\\xff\\xf0\\x00&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">//# 查找字符串里面bit值为0的位置</span><br><span class=\"line\">redis&gt; BITPOS mykey 0 </span><br><span class=\"line\">(integer) 12</span><br><span class=\"line\">redis&gt; SET mykey &quot;\\x00\\xff\\xf0&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">//查找字符串里面bit值为1从第0个字节开始的位置</span><br><span class=\"line\">redis&gt; BITPOS mykey 1 0 </span><br><span class=\"line\">(integer) 8</span><br><span class=\"line\">//查找字符串里面bit值为1从第2个字节(12)开始的位置</span><br><span class=\"line\">redis&gt; BITPOS mykey 1 2 </span><br><span class=\"line\">(integer) 16</span><br><span class=\"line\">redis&gt; set mykey &quot;\\x00\\x00\\x00&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">//查找字符串里面bit值为1的位置</span><br><span class=\"line\">redis&gt; BITPOS mykey 1 </span><br><span class=\"line\">(integer) -1</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SISMEMBER(sismember)","copyright":true,"date":"2020-03-30T06:40:30.000Z","keywords":"Redis命令,sismember","aside":"set","_content":"## SISMEMBER key member \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回成员 member 是否是存储的集合 key的成员.\n\n#### 返回值\n\n**integer-reply**:\n\n* 如果member元素是集合key的成员，则返回1\n\n* 如果member元素不是key的成员，或者集合key不存在，则返回0\n\n\n#### 示例\n```c\n  redis> SADD myset \"one\"\n  (integer) 1\n  redis> SISMEMBER myset \"one\"\n  (integer) 1\n  redis> SISMEMBER myset \"two\"\n  (integer) 0\n  redis> \n```","source":"_posts/redis_command/set/sismember.md","raw":"---\n\ntitle: SISMEMBER(sismember)\ncopyright: true\ndate: 2020-03-30 14:40:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,sismember\naside: set\n---\n## SISMEMBER key member \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回成员 member 是否是存储的集合 key的成员.\n\n#### 返回值\n\n**integer-reply**:\n\n* 如果member元素是集合key的成员，则返回1\n\n* 如果member元素不是key的成员，或者集合key不存在，则返回0\n\n\n#### 示例\n```c\n  redis> SADD myset \"one\"\n  (integer) 1\n  redis> SISMEMBER myset \"one\"\n  (integer) 1\n  redis> SISMEMBER myset \"two\"\n  (integer) 0\n  redis> \n```","slug":"redis_command/set/sismember","published":1,"updated":"2021-03-14T03:04:50.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu3001ohyjfudawn3m2","content":"<h2 id=\"SISMEMBER-key-member\"><a href=\"#SISMEMBER-key-member\" class=\"headerlink\" title=\"SISMEMBER key member\"></a>SISMEMBER key member</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回成员 member 是否是存储的集合 key的成员.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:</p>\n<ul>\n<li><p>如果member元素是集合key的成员，则返回1</p>\n</li>\n<li><p>如果member元素不是key的成员，或者集合key不存在，则返回0</p>\n</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SISMEMBER myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SISMEMBER myset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SISMEMBER-key-member\"><a href=\"#SISMEMBER-key-member\" class=\"headerlink\" title=\"SISMEMBER key member\"></a>SISMEMBER key member</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回成员 member 是否是存储的集合 key的成员.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:</p>\n<ul>\n<li><p>如果member元素是集合key的成员，则返回1</p>\n</li>\n<li><p>如果member元素不是key的成员，或者集合key不存在，则返回0</p>\n</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SISMEMBER myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SISMEMBER myset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SPOP(spop)","copyright":true,"date":"2020-03-30T06:37:30.000Z","keywords":"Redis命令,spop","aside":"set","_content":"## SPOP key [count] \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 从存储在key的集合中移除并返回一个或多个随机元素。\n* 此操作与SRANDMEMBER类似，它从一个集合中返回一个或多个随机元素，但不删除元素。\n* 如果count大于集合内部的元素数量，此命令将会返回整个集合，不会有额外的元素。\n\n#### 历史\n\n\\>=3.2版本 `count`参数可用。\n\n#### 返回值\n\n**bulk-string-reply**：被删除的元素，或者当key不存在时返回nil。\n\n\n#### 示例\n\n```c\nSADD myset \"one\"\nSADD myset \"two\"\nSADD myset \"three\"\nSPOP myset\nSMEMBERS myset\nSADD myset \"four\"\nSADD myset \"five\"\nSPOP myset 3\nSMEMBERS myset\n```","source":"_posts/redis_command/set/spop.md","raw":"---\n\ntitle: SPOP(spop)\ncopyright: true\ndate: 2020-03-30 14:37:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,spop\naside: set\n\n---\n## SPOP key [count] \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 从存储在key的集合中移除并返回一个或多个随机元素。\n* 此操作与SRANDMEMBER类似，它从一个集合中返回一个或多个随机元素，但不删除元素。\n* 如果count大于集合内部的元素数量，此命令将会返回整个集合，不会有额外的元素。\n\n#### 历史\n\n\\>=3.2版本 `count`参数可用。\n\n#### 返回值\n\n**bulk-string-reply**：被删除的元素，或者当key不存在时返回nil。\n\n\n#### 示例\n\n```c\nSADD myset \"one\"\nSADD myset \"two\"\nSADD myset \"three\"\nSPOP myset\nSMEMBERS myset\nSADD myset \"four\"\nSADD myset \"five\"\nSPOP myset 3\nSMEMBERS myset\n```","slug":"redis_command/set/spop","published":1,"updated":"2021-03-14T03:04:50.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu4001phyjfxp1yd2w7","content":"<h2 id=\"SPOP-key-count\"><a href=\"#SPOP-key-count\" class=\"headerlink\" title=\"SPOP key [count]\"></a>SPOP key [count]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>从存储在key的集合中移除并返回一个或多个随机元素。</li>\n<li>此操作与SRANDMEMBER类似，它从一个集合中返回一个或多个随机元素，但不删除元素。</li>\n<li>如果count大于集合内部的元素数量，此命令将会返回整个集合，不会有额外的元素。</li>\n</ul>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>>=3.2版本 <code>count</code>参数可用。</p>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>：被删除的元素，或者当key不存在时返回nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SADD myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">SADD myset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">SADD myset <span class=\"string\">\"three\"</span></span><br><span class=\"line\">SPOP myset</span><br><span class=\"line\">SMEMBERS myset</span><br><span class=\"line\">SADD myset <span class=\"string\">\"four\"</span></span><br><span class=\"line\">SADD myset <span class=\"string\">\"five\"</span></span><br><span class=\"line\">SPOP myset <span class=\"number\">3</span></span><br><span class=\"line\">SMEMBERS myset</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SPOP-key-count\"><a href=\"#SPOP-key-count\" class=\"headerlink\" title=\"SPOP key [count]\"></a>SPOP key [count]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>从存储在key的集合中移除并返回一个或多个随机元素。</li>\n<li>此操作与SRANDMEMBER类似，它从一个集合中返回一个或多个随机元素，但不删除元素。</li>\n<li>如果count大于集合内部的元素数量，此命令将会返回整个集合，不会有额外的元素。</li>\n</ul>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>>=3.2版本 <code>count</code>参数可用。</p>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>：被删除的元素，或者当key不存在时返回nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SADD myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">SADD myset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">SADD myset <span class=\"string\">\"three\"</span></span><br><span class=\"line\">SPOP myset</span><br><span class=\"line\">SMEMBERS myset</span><br><span class=\"line\">SADD myset <span class=\"string\">\"four\"</span></span><br><span class=\"line\">SADD myset <span class=\"string\">\"five\"</span></span><br><span class=\"line\">SPOP myset <span class=\"number\">3</span></span><br><span class=\"line\">SMEMBERS myset</span><br></pre></td></tr></table></figure>"},{"title":"SINTER(sinter)","copyright":true,"date":"2020-03-30T06:42:30.000Z","keywords":"Redis命令,sinter","aside":"set","_content":"## SINTER key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N*M) 最坏情况下，N是最小集合的基数,M是集合的个数 \n\n\n#### 说明:\n* 返回指定所有的集合的成员的交集.\n\n* 例如:\n\n  ```\n  key1 = {a,b,c,d}\n  key2 = {c}\n  key3 = {a,c,e}\n  SINTER key1 key2 key3 = {c}\n  ```\n\n#### 返回值\n\n**array-reply**: 结果集成员的列表.\n\n\n#### 示例\n\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SINTER key1 key2\n1) \"c\"\nredis> \n```","source":"_posts/redis_command/set/sinter.md","raw":"---\n\ntitle: SINTER(sinter)\ncopyright: true\ndate: 2020-03-30 14:42:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,sinter\naside: set\n---\n## SINTER key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N*M) 最坏情况下，N是最小集合的基数,M是集合的个数 \n\n\n#### 说明:\n* 返回指定所有的集合的成员的交集.\n\n* 例如:\n\n  ```\n  key1 = {a,b,c,d}\n  key2 = {c}\n  key3 = {a,c,e}\n  SINTER key1 key2 key3 = {c}\n  ```\n\n#### 返回值\n\n**array-reply**: 结果集成员的列表.\n\n\n#### 示例\n\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SINTER key1 key2\n1) \"c\"\nredis> \n```","slug":"redis_command/set/sinter","published":1,"updated":"2021-03-14T03:04:50.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu4001shyjf7axk2fq7","content":"<h2 id=\"SINTER-key-key-…\"><a href=\"#SINTER-key-key-…\" class=\"headerlink\" title=\"SINTER key [key …]\"></a>SINTER key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N*M) 最坏情况下，N是最小集合的基数,M是集合的个数 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>返回指定所有的集合的成员的交集.</p>\n</li>\n<li><p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key1 = &#123;a,b,c,d&#125;</span><br><span class=\"line\">key2 = &#123;c&#125;</span><br><span class=\"line\">key3 = &#123;a,c,e&#125;</span><br><span class=\"line\">SINTER key1 key2 key3 = &#123;c&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 结果集成员的列表.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SINTER key1 key2</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SINTER-key-key-…\"><a href=\"#SINTER-key-key-…\" class=\"headerlink\" title=\"SINTER key [key …]\"></a>SINTER key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N*M) 最坏情况下，N是最小集合的基数,M是集合的个数 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>返回指定所有的集合的成员的交集.</p>\n</li>\n<li><p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key1 = &#123;a,b,c,d&#125;</span><br><span class=\"line\">key2 = &#123;c&#125;</span><br><span class=\"line\">key3 = &#123;a,c,e&#125;</span><br><span class=\"line\">SINTER key1 key2 key3 = &#123;c&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 结果集成员的列表.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SINTER key1 key2</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SMOVE(smove)","copyright":true,"date":"2020-03-30T06:38:30.000Z","keywords":"Redis命令,smove","aside":"set","_content":"## SMOVE source destination member \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将member从source集合移动到destination集合中. 对于其他的客户端,在特定的时间元素将会作为source或者destination集合的成员出现.\n* 如果source 集合不存在或者不包含指定的元素,这smove命令不执行任何操作并且返回0.否则对象将会从source集合中移除，并添加到destination集合中去，如果destination集合已经存在该元素，则smove命令仅将该元素充source集合中移除. 如果source 和destination不是集合类型,则返回错误.\n\n#### 返回值\n\n**integer-reply:**\n\n* 如果该元素成功移除,返回1\n\n* 如果该元素不是 source集合成员,无任何操作,则返回0.\n\n```c\nredis> SADD myset \"one\"\n  (integer) 1\n  redis> SADD myset \"two\"\n  (integer) 1\n  redis> SADD myotherset \"three\"\n  (integer) 1\n  redis> SMOVE myset myotherset \"two\"\n  (integer) 1\n  redis> SMEMBERS myset\n  1) \"one\"\n  redis> SMEMBERS myotherset\n  1) \"three\"\n  2) \"two\"\n  redis> \n```","source":"_posts/redis_command/set/smove.md","raw":"---\n\ntitle: SMOVE(smove)\ncopyright: true\ndate: 2020-03-30 14:38:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,smove\naside: set\n\n---\n## SMOVE source destination member \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将member从source集合移动到destination集合中. 对于其他的客户端,在特定的时间元素将会作为source或者destination集合的成员出现.\n* 如果source 集合不存在或者不包含指定的元素,这smove命令不执行任何操作并且返回0.否则对象将会从source集合中移除，并添加到destination集合中去，如果destination集合已经存在该元素，则smove命令仅将该元素充source集合中移除. 如果source 和destination不是集合类型,则返回错误.\n\n#### 返回值\n\n**integer-reply:**\n\n* 如果该元素成功移除,返回1\n\n* 如果该元素不是 source集合成员,无任何操作,则返回0.\n\n```c\nredis> SADD myset \"one\"\n  (integer) 1\n  redis> SADD myset \"two\"\n  (integer) 1\n  redis> SADD myotherset \"three\"\n  (integer) 1\n  redis> SMOVE myset myotherset \"two\"\n  (integer) 1\n  redis> SMEMBERS myset\n  1) \"one\"\n  redis> SMEMBERS myotherset\n  1) \"three\"\n  2) \"two\"\n  redis> \n```","slug":"redis_command/set/smove","published":1,"updated":"2021-03-14T03:04:50.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu5001uhyjfifzu1xm7","content":"<h2 id=\"SMOVE-source-destination-member\"><a href=\"#SMOVE-source-destination-member\" class=\"headerlink\" title=\"SMOVE source destination member\"></a>SMOVE source destination member</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将member从source集合移动到destination集合中. 对于其他的客户端,在特定的时间元素将会作为source或者destination集合的成员出现.</li>\n<li>如果source 集合不存在或者不包含指定的元素,这smove命令不执行任何操作并且返回0.否则对象将会从source集合中移除，并添加到destination集合中去，如果destination集合已经存在该元素，则smove命令仅将该元素充source集合中移除. 如果source 和destination不是集合类型,则返回错误.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply:</strong></p>\n<ul>\n<li><p>如果该元素成功移除,返回1</p>\n</li>\n<li><p>如果该元素不是 source集合成员,无任何操作,则返回0.</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">  (integer) <span class=\"number\">1</span></span><br><span class=\"line\">  redis&gt; SADD myset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">  (integer) <span class=\"number\">1</span></span><br><span class=\"line\">  redis&gt; SADD myotherset <span class=\"string\">\"three\"</span></span><br><span class=\"line\">  (integer) <span class=\"number\">1</span></span><br><span class=\"line\">  redis&gt; SMOVE myset myotherset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">  (integer) <span class=\"number\">1</span></span><br><span class=\"line\">  redis&gt; SMEMBERS myset</span><br><span class=\"line\">  <span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">  redis&gt; SMEMBERS myotherset</span><br><span class=\"line\">  <span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">  <span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">  redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SMOVE-source-destination-member\"><a href=\"#SMOVE-source-destination-member\" class=\"headerlink\" title=\"SMOVE source destination member\"></a>SMOVE source destination member</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将member从source集合移动到destination集合中. 对于其他的客户端,在特定的时间元素将会作为source或者destination集合的成员出现.</li>\n<li>如果source 集合不存在或者不包含指定的元素,这smove命令不执行任何操作并且返回0.否则对象将会从source集合中移除，并添加到destination集合中去，如果destination集合已经存在该元素，则smove命令仅将该元素充source集合中移除. 如果source 和destination不是集合类型,则返回错误.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply:</strong></p>\n<ul>\n<li><p>如果该元素成功移除,返回1</p>\n</li>\n<li><p>如果该元素不是 source集合成员,无任何操作,则返回0.</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">  (integer) <span class=\"number\">1</span></span><br><span class=\"line\">  redis&gt; SADD myset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">  (integer) <span class=\"number\">1</span></span><br><span class=\"line\">  redis&gt; SADD myotherset <span class=\"string\">\"three\"</span></span><br><span class=\"line\">  (integer) <span class=\"number\">1</span></span><br><span class=\"line\">  redis&gt; SMOVE myset myotherset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">  (integer) <span class=\"number\">1</span></span><br><span class=\"line\">  redis&gt; SMEMBERS myset</span><br><span class=\"line\">  <span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">  redis&gt; SMEMBERS myotherset</span><br><span class=\"line\">  <span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">  <span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">  redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SMEMBERS(smembers)","copyright":true,"date":"2020-03-30T06:39:30.000Z","keywords":"Redis命令,smembers","aside":"set","_content":"## SMEMBERS key \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是集合的基数。  \n\n\n#### 说明:\n* 返回key集合所有的元素.\n* 该命令的作用与使用一个参数的SINTER 命令作用相同.\n\n#### 返回值\n\n**array-reply**:集合中的所有元素.\n\n### 示例\n\n```c\nredis> SADD myset \"Hello\"\n(integer) 1\nredis> SADD myset \"World\"\n(integer) 1\nredis> SMEMBERS myset\n1) \"World\"\n2) \"Hello\"\nredis> \n```","source":"_posts/redis_command/set/smembers.md","raw":"---\n\ntitle: SMEMBERS(smembers)\ncopyright: true\ndate: 2020-03-30 14:39:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,smembers\naside: set\n\n---\n## SMEMBERS key \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是集合的基数。  \n\n\n#### 说明:\n* 返回key集合所有的元素.\n* 该命令的作用与使用一个参数的SINTER 命令作用相同.\n\n#### 返回值\n\n**array-reply**:集合中的所有元素.\n\n### 示例\n\n```c\nredis> SADD myset \"Hello\"\n(integer) 1\nredis> SADD myset \"World\"\n(integer) 1\nredis> SMEMBERS myset\n1) \"World\"\n2) \"Hello\"\nredis> \n```","slug":"redis_command/set/smembers","published":1,"updated":"2021-03-14T03:04:50.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu6001xhyjfjq0e894o","content":"<h2 id=\"SMEMBERS-key\"><a href=\"#SMEMBERS-key\" class=\"headerlink\" title=\"SMEMBERS key\"></a>SMEMBERS key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是集合的基数。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回key集合所有的元素.</li>\n<li>该命令的作用与使用一个参数的SINTER 命令作用相同.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>:集合中的所有元素.</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SMEMBERS myset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SMEMBERS-key\"><a href=\"#SMEMBERS-key\" class=\"headerlink\" title=\"SMEMBERS key\"></a>SMEMBERS key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是集合的基数。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回key集合所有的元素.</li>\n<li>该命令的作用与使用一个参数的SINTER 命令作用相同.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>:集合中的所有元素.</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SMEMBERS myset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SREM(srem)","copyright":true,"date":"2020-03-30T06:35:30.000Z","keywords":"Redis命令,srem","aside":"set","_content":"## SREM key member [member ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是要删除的成员数\n\n\n#### 说明:\n* 在key集合中移除指定的元素. 如果指定的元素不是key集合中的元素则忽略 如果key集合不存在则被视为一个空的集合，该命令返回0.\n* 如果key的类型不是一个集合,则返回错误.\n\n#### 返回值\n\n**integer-reply**:从集合中移除元素的个数，不包括不存在的成员.\n\n\n#### 历史\n\n\\>= 2.4: 接受多个 member 元素参数. Redis 2.4 之前的版本每次只能移除一个元素.\n\n### 示例\n\n```c\nredis> SADD myset \"one\"\n(integer) 1\nredis> SADD myset \"two\"\n(integer) 1\nredis> SADD myset \"three\"\n(integer) 1\nredis> SREM myset \"one\"\n(integer) 1\nredis> SREM myset \"four\"\n(integer) 0\nredis> SMEMBERS myset\n1) \"three\"\n2) \"two\"\nredis> \n```","source":"_posts/redis_command/set/srem.md","raw":"---\n\ntitle: SREM(srem)\ncopyright: true\ndate: 2020-03-30 14:35:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,srem\naside: set\n\n---\n## SREM key member [member ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是要删除的成员数\n\n\n#### 说明:\n* 在key集合中移除指定的元素. 如果指定的元素不是key集合中的元素则忽略 如果key集合不存在则被视为一个空的集合，该命令返回0.\n* 如果key的类型不是一个集合,则返回错误.\n\n#### 返回值\n\n**integer-reply**:从集合中移除元素的个数，不包括不存在的成员.\n\n\n#### 历史\n\n\\>= 2.4: 接受多个 member 元素参数. Redis 2.4 之前的版本每次只能移除一个元素.\n\n### 示例\n\n```c\nredis> SADD myset \"one\"\n(integer) 1\nredis> SADD myset \"two\"\n(integer) 1\nredis> SADD myset \"three\"\n(integer) 1\nredis> SREM myset \"one\"\n(integer) 1\nredis> SREM myset \"four\"\n(integer) 0\nredis> SMEMBERS myset\n1) \"three\"\n2) \"two\"\nredis> \n```","slug":"redis_command/set/srem","published":1,"updated":"2021-03-14T03:04:50.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu7001zhyjfduuw21ed","content":"<h2 id=\"SREM-key-member-member-…\"><a href=\"#SREM-key-member-member-…\" class=\"headerlink\" title=\"SREM key member [member …]\"></a>SREM key member [member …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是要删除的成员数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>在key集合中移除指定的元素. 如果指定的元素不是key集合中的元素则忽略 如果key集合不存在则被视为一个空的集合，该命令返回0.</li>\n<li>如果key的类型不是一个集合,则返回错误.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:从集合中移除元素的个数，不包括不存在的成员.</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>>= 2.4: 接受多个 member 元素参数. Redis 2.4 之前的版本每次只能移除一个元素.</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SREM myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SREM myset <span class=\"string\">\"four\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; SMEMBERS myset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SREM-key-member-member-…\"><a href=\"#SREM-key-member-member-…\" class=\"headerlink\" title=\"SREM key member [member …]\"></a>SREM key member [member …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是要删除的成员数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>在key集合中移除指定的元素. 如果指定的元素不是key集合中的元素则忽略 如果key集合不存在则被视为一个空的集合，该命令返回0.</li>\n<li>如果key的类型不是一个集合,则返回错误.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:从集合中移除元素的个数，不包括不存在的成员.</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>>= 2.4: 接受多个 member 元素参数. Redis 2.4 之前的版本每次只能移除一个元素.</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD myset <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SREM myset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SREM myset <span class=\"string\">\"four\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; SMEMBERS myset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SRANDMEMBER(srandmember)","copyright":true,"date":"2020-03-30T06:36:30.000Z","keywords":"Redis命令,srandmember","aside":"set","_content":"## SRANDMEMBER key [count] \n>起始版本：1.0.0<br/>时间复杂度：没有count参数O(1)，否则O(N)，其中N是传递的count的绝对值。 \n\n\n#### 说明:\n* 仅提供key参数，那么随机返回key集合中的一个元素.\n* Redis 2.6开始，可以接受 count 参数，如果count是整数且小于元素的个数，返回含有 count 个不同的元素的数组，如果count是个整数且大于集合中元素的个数时，仅返回整个集合的所有元素，当count是负数，则会返回一个包含count的绝对值的个数元素的数组，如果count的绝对值大于元素的个数，则返回的结果集里会出现一个元素出现多次的情况.\n\n#### 返回值\n\n**bulk-string-reply**: 不使用count 参数的情况下该命令返回随机的元素，如果key不存在则返回nil。\n**array-reply**: 使用count参数,则返回一个随机的元素数组，如果key不存在则返回一个空的数组。\n\n### 示例\n\n\n```c\nredis> SADD myset one two three\n(integer) 3\nredis> SRANDMEMBER myset\n\"one\"\nredis> SRANDMEMBER myset 2\n1) \"three\"\n2) \"one\"\nredis> SRANDMEMBER myset -5\n1) \"one\"\n2) \"one\"\n3) \"one\"\n4) \"one\"\n5) \"one\"\nredis> \n```\n#### 传递count参数时的行为规范\n* 当传递了一个值为正数的count参数，返回的元素就好像从集合中移除了每个选中的元素一样（就像在宾果游戏中提取数字一样）。但是元素不会从集合中移除。所以基本上：不会返回重复的元素。\n* 如果count参数的值大于集合内的元素数量，此命令将会仅返回整个集合，没有额外的元素。\n  相反，当count参数的值为负数时，此命令的行为将发生改变，并且提取操作就像在每次提取后，重新将取出的元素放回包里一样，因此，可能返回重复的元素，以及总是会返回我们请求的数量的元素，因为我们可以一次又一次地重复相同的元素，除了当集合为空（或者不存在key）的时候，将总是会返回一个空数组。\n\n#### 返回元素的分布\n* 当集合中的元素数量很少时，返回元素分布远不够完美，这是因为我们使用了一个近似随机元素函数，它并不能保证良好的分布。\n* 所使用的算法（在dict.c中实现）对哈希表桶进行采样以找到非空桶。一旦找到非空桶，由于我们在哈希表的实现中使用了链接法，因此会检查桶中的元素数量，并且选出一个随机元素。这意味着，如果你在整个哈希表中有两个非空桶，其中一个有三个元素，另一个只有一个元素，那么其桶中单独存在的元素将以更高的概率返回。","source":"_posts/redis_command/set/srandmember.md","raw":"---\n\ntitle: SRANDMEMBER(srandmember)\ncopyright: true\ndate: 2020-03-30 14:36:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,srandmember\naside: set\n\n---\n## SRANDMEMBER key [count] \n>起始版本：1.0.0<br/>时间复杂度：没有count参数O(1)，否则O(N)，其中N是传递的count的绝对值。 \n\n\n#### 说明:\n* 仅提供key参数，那么随机返回key集合中的一个元素.\n* Redis 2.6开始，可以接受 count 参数，如果count是整数且小于元素的个数，返回含有 count 个不同的元素的数组，如果count是个整数且大于集合中元素的个数时，仅返回整个集合的所有元素，当count是负数，则会返回一个包含count的绝对值的个数元素的数组，如果count的绝对值大于元素的个数，则返回的结果集里会出现一个元素出现多次的情况.\n\n#### 返回值\n\n**bulk-string-reply**: 不使用count 参数的情况下该命令返回随机的元素，如果key不存在则返回nil。\n**array-reply**: 使用count参数,则返回一个随机的元素数组，如果key不存在则返回一个空的数组。\n\n### 示例\n\n\n```c\nredis> SADD myset one two three\n(integer) 3\nredis> SRANDMEMBER myset\n\"one\"\nredis> SRANDMEMBER myset 2\n1) \"three\"\n2) \"one\"\nredis> SRANDMEMBER myset -5\n1) \"one\"\n2) \"one\"\n3) \"one\"\n4) \"one\"\n5) \"one\"\nredis> \n```\n#### 传递count参数时的行为规范\n* 当传递了一个值为正数的count参数，返回的元素就好像从集合中移除了每个选中的元素一样（就像在宾果游戏中提取数字一样）。但是元素不会从集合中移除。所以基本上：不会返回重复的元素。\n* 如果count参数的值大于集合内的元素数量，此命令将会仅返回整个集合，没有额外的元素。\n  相反，当count参数的值为负数时，此命令的行为将发生改变，并且提取操作就像在每次提取后，重新将取出的元素放回包里一样，因此，可能返回重复的元素，以及总是会返回我们请求的数量的元素，因为我们可以一次又一次地重复相同的元素，除了当集合为空（或者不存在key）的时候，将总是会返回一个空数组。\n\n#### 返回元素的分布\n* 当集合中的元素数量很少时，返回元素分布远不够完美，这是因为我们使用了一个近似随机元素函数，它并不能保证良好的分布。\n* 所使用的算法（在dict.c中实现）对哈希表桶进行采样以找到非空桶。一旦找到非空桶，由于我们在哈希表的实现中使用了链接法，因此会检查桶中的元素数量，并且选出一个随机元素。这意味着，如果你在整个哈希表中有两个非空桶，其中一个有三个元素，另一个只有一个元素，那么其桶中单独存在的元素将以更高的概率返回。","slug":"redis_command/set/srandmember","published":1,"updated":"2021-03-14T03:04:50.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu80022hyjfltlap4lw","content":"<h2 id=\"SRANDMEMBER-key-count\"><a href=\"#SRANDMEMBER-key-count\" class=\"headerlink\" title=\"SRANDMEMBER key [count]\"></a>SRANDMEMBER key [count]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：没有count参数O(1)，否则O(N)，其中N是传递的count的绝对值。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>仅提供key参数，那么随机返回key集合中的一个元素.</li>\n<li>Redis 2.6开始，可以接受 count 参数，如果count是整数且小于元素的个数，返回含有 count 个不同的元素的数组，如果count是个整数且大于集合中元素的个数时，仅返回整个集合的所有元素，当count是负数，则会返回一个包含count的绝对值的个数元素的数组，如果count的绝对值大于元素的个数，则返回的结果集里会出现一个元素出现多次的情况.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>: 不使用count 参数的情况下该命令返回随机的元素，如果key不存在则返回nil。<br><strong>array-reply</strong>: 使用count参数,则返回一个随机的元素数组，如果key不存在则返回一个空的数组。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset one two three</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; SRANDMEMBER myset</span><br><span class=\"line\"><span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; SRANDMEMBER myset <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; SRANDMEMBER myset <span class=\"number\">-5</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"传递count参数时的行为规范\"><a href=\"#传递count参数时的行为规范\" class=\"headerlink\" title=\"传递count参数时的行为规范\"></a>传递count参数时的行为规范</h4><ul>\n<li>当传递了一个值为正数的count参数，返回的元素就好像从集合中移除了每个选中的元素一样（就像在宾果游戏中提取数字一样）。但是元素不会从集合中移除。所以基本上：不会返回重复的元素。</li>\n<li>如果count参数的值大于集合内的元素数量，此命令将会仅返回整个集合，没有额外的元素。<br>相反，当count参数的值为负数时，此命令的行为将发生改变，并且提取操作就像在每次提取后，重新将取出的元素放回包里一样，因此，可能返回重复的元素，以及总是会返回我们请求的数量的元素，因为我们可以一次又一次地重复相同的元素，除了当集合为空（或者不存在key）的时候，将总是会返回一个空数组。</li>\n</ul>\n<h4 id=\"返回元素的分布\"><a href=\"#返回元素的分布\" class=\"headerlink\" title=\"返回元素的分布\"></a>返回元素的分布</h4><ul>\n<li>当集合中的元素数量很少时，返回元素分布远不够完美，这是因为我们使用了一个近似随机元素函数，它并不能保证良好的分布。</li>\n<li>所使用的算法（在dict.c中实现）对哈希表桶进行采样以找到非空桶。一旦找到非空桶，由于我们在哈希表的实现中使用了链接法，因此会检查桶中的元素数量，并且选出一个随机元素。这意味着，如果你在整个哈希表中有两个非空桶，其中一个有三个元素，另一个只有一个元素，那么其桶中单独存在的元素将以更高的概率返回。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SRANDMEMBER-key-count\"><a href=\"#SRANDMEMBER-key-count\" class=\"headerlink\" title=\"SRANDMEMBER key [count]\"></a>SRANDMEMBER key [count]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：没有count参数O(1)，否则O(N)，其中N是传递的count的绝对值。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>仅提供key参数，那么随机返回key集合中的一个元素.</li>\n<li>Redis 2.6开始，可以接受 count 参数，如果count是整数且小于元素的个数，返回含有 count 个不同的元素的数组，如果count是个整数且大于集合中元素的个数时，仅返回整个集合的所有元素，当count是负数，则会返回一个包含count的绝对值的个数元素的数组，如果count的绝对值大于元素的个数，则返回的结果集里会出现一个元素出现多次的情况.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>: 不使用count 参数的情况下该命令返回随机的元素，如果key不存在则返回nil。<br><strong>array-reply</strong>: 使用count参数,则返回一个随机的元素数组，如果key不存在则返回一个空的数组。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD myset one two three</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; SRANDMEMBER myset</span><br><span class=\"line\"><span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; SRANDMEMBER myset <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; SRANDMEMBER myset <span class=\"number\">-5</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"传递count参数时的行为规范\"><a href=\"#传递count参数时的行为规范\" class=\"headerlink\" title=\"传递count参数时的行为规范\"></a>传递count参数时的行为规范</h4><ul>\n<li>当传递了一个值为正数的count参数，返回的元素就好像从集合中移除了每个选中的元素一样（就像在宾果游戏中提取数字一样）。但是元素不会从集合中移除。所以基本上：不会返回重复的元素。</li>\n<li>如果count参数的值大于集合内的元素数量，此命令将会仅返回整个集合，没有额外的元素。<br>相反，当count参数的值为负数时，此命令的行为将发生改变，并且提取操作就像在每次提取后，重新将取出的元素放回包里一样，因此，可能返回重复的元素，以及总是会返回我们请求的数量的元素，因为我们可以一次又一次地重复相同的元素，除了当集合为空（或者不存在key）的时候，将总是会返回一个空数组。</li>\n</ul>\n<h4 id=\"返回元素的分布\"><a href=\"#返回元素的分布\" class=\"headerlink\" title=\"返回元素的分布\"></a>返回元素的分布</h4><ul>\n<li>当集合中的元素数量很少时，返回元素分布远不够完美，这是因为我们使用了一个近似随机元素函数，它并不能保证良好的分布。</li>\n<li>所使用的算法（在dict.c中实现）对哈希表桶进行采样以找到非空桶。一旦找到非空桶，由于我们在哈希表的实现中使用了链接法，因此会检查桶中的元素数量，并且选出一个随机元素。这意味着，如果你在整个哈希表中有两个非空桶，其中一个有三个元素，另一个只有一个元素，那么其桶中单独存在的元素将以更高的概率返回。</li>\n</ul>\n"},{"title":"SUNION(sunion)","copyright":true,"date":"2020-03-30T06:34:30.000Z","keywords":"Redis命令,sunion","aside":"set","_content":"## SUNION key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是所有给定集合中元素的总数。\n\n\n#### 说明:\n* 返回给定的多个集合的并集中的所有成员.\n\n* 例如:\n\n  ```\n  key1 = {a,b,c,d}\n  key2 = {c}\n  key3 = {a,c,e}\n  SUNION key1 key2 key3 = {a,b,c,d,e}\n  ```\n\n\n#### 返回值\n\n\n**array-reply**:并集的成员列表\n### 示例\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SUNION key1 key2\n1) \"a\"\n2) \"b\"\n3) \"c\"\n4) \"d\"\n5) \"e\"\nredis> \n```","source":"_posts/redis_command/set/sunion.md","raw":"---\n\ntitle: SUNION(sunion)\ncopyright: true\ndate: 2020-03-30 14:34:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,sunion\naside: set\n\n---\n## SUNION key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是所有给定集合中元素的总数。\n\n\n#### 说明:\n* 返回给定的多个集合的并集中的所有成员.\n\n* 例如:\n\n  ```\n  key1 = {a,b,c,d}\n  key2 = {c}\n  key3 = {a,c,e}\n  SUNION key1 key2 key3 = {a,b,c,d,e}\n  ```\n\n\n#### 返回值\n\n\n**array-reply**:并集的成员列表\n### 示例\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SUNION key1 key2\n1) \"a\"\n2) \"b\"\n3) \"c\"\n4) \"d\"\n5) \"e\"\nredis> \n```","slug":"redis_command/set/sunion","published":1,"updated":"2021-03-14T03:04:50.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpu90024hyjfgc6aun5p","content":"<h2 id=\"SUNION-key-key-…\"><a href=\"#SUNION-key-key-…\" class=\"headerlink\" title=\"SUNION key [key …]\"></a>SUNION key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是所有给定集合中元素的总数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>返回给定的多个集合的并集中的所有成员.</p>\n</li>\n<li><p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key1 = &#123;a,b,c,d&#125;</span><br><span class=\"line\">key2 = &#123;c&#125;</span><br><span class=\"line\">key3 = &#123;a,c,e&#125;</span><br><span class=\"line\">SUNION key1 key2 key3 = &#123;a,b,c,d,e&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>:并集的成员列表</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SUNION key1 key2</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"e\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SUNION-key-key-…\"><a href=\"#SUNION-key-key-…\" class=\"headerlink\" title=\"SUNION key [key …]\"></a>SUNION key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是所有给定集合中元素的总数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>返回给定的多个集合的并集中的所有成员.</p>\n</li>\n<li><p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key1 = &#123;a,b,c,d&#125;</span><br><span class=\"line\">key2 = &#123;c&#125;</span><br><span class=\"line\">key3 = &#123;a,c,e&#125;</span><br><span class=\"line\">SUNION key1 key2 key3 = &#123;a,b,c,d,e&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>:并集的成员列表</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SUNION key1 key2</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"e\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SSCAN(sscan)","copyright":true,"date":"2020-03-30T06:32:30.000Z","keywords":"Redis命令,sscan","aside":"set","_content":"## SSCAN key cursor [MATCH pattern] [COUNT count] \n>起始版本：2.8.0<br/>时间复杂度：O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..  \n\n\n#### 说明:\n* 请参考SCAN\n\n","source":"_posts/redis_command/set/sscan.md","raw":"---\n\ntitle: SSCAN(sscan)\ncopyright: true\ndate: 2020-03-30 14:32:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,sscan\naside: set\n\n---\n## SSCAN key cursor [MATCH pattern] [COUNT count] \n>起始版本：2.8.0<br/>时间复杂度：O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..  \n\n\n#### 说明:\n* 请参考SCAN\n\n","slug":"redis_command/set/sscan","published":1,"updated":"2021-03-14T03:04:50.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpua0027hyjfc84a1x66","content":"<h2 id=\"SSCAN-key-cursor-MATCH-pattern-COUNT-count\"><a href=\"#SSCAN-key-cursor-MATCH-pattern-COUNT-count\" class=\"headerlink\" title=\"SSCAN key cursor [MATCH pattern] [COUNT count]\"></a>SSCAN key cursor [MATCH pattern] [COUNT count]</h2><blockquote>\n<p>起始版本：2.8.0<br>时间复杂度：O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>请参考SCAN</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SSCAN-key-cursor-MATCH-pattern-COUNT-count\"><a href=\"#SSCAN-key-cursor-MATCH-pattern-COUNT-count\" class=\"headerlink\" title=\"SSCAN key cursor [MATCH pattern] [COUNT count]\"></a>SSCAN key cursor [MATCH pattern] [COUNT count]</h2><blockquote>\n<p>起始版本：2.8.0<br>时间复杂度：O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>请参考SCAN</li>\n</ul>\n"},{"title":"SUNIONSTORE(sunionstore)","copyright":true,"date":"2020-03-30T06:33:30.000Z","keywords":"Redis命令,sunionstore","aside":"set","_content":"## SUNIONSTORE destination key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是所有给定集合中元素的总数。\n\n\n#### 说明:\n* 该命令作用类似于SUNION命令,不同的是它并不返回结果集,而是将结果存储在destination集合中.\n* 如果destination 已经存在,则将其覆盖.\n\n#### 返回值\n\n**integer-reply**:结果集中元素的个数.\n\n#### 示例\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SUNIONSTORE key key1 key2\n(integer) 5\nredis> SMEMBERS key\n1) \"c\"\n2) \"e\"\n3) \"b\"\n4) \"a\"\n5) \"d\"\nredis>\n```","source":"_posts/redis_command/set/sunionstore.md","raw":"---\n\ntitle: SUNIONSTORE(sunionstore)\ncopyright: true\ndate: 2020-03-30 14:33:30\ncategories: \n- Redis命令大全\n- Set\nkeywords: Redis命令,sunionstore\naside: set\n\n---\n## SUNIONSTORE destination key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是所有给定集合中元素的总数。\n\n\n#### 说明:\n* 该命令作用类似于SUNION命令,不同的是它并不返回结果集,而是将结果存储在destination集合中.\n* 如果destination 已经存在,则将其覆盖.\n\n#### 返回值\n\n**integer-reply**:结果集中元素的个数.\n\n#### 示例\n```c\nredis> SADD key1 \"a\"\n(integer) 1\nredis> SADD key1 \"b\"\n(integer) 1\nredis> SADD key1 \"c\"\n(integer) 1\nredis> SADD key2 \"c\"\n(integer) 1\nredis> SADD key2 \"d\"\n(integer) 1\nredis> SADD key2 \"e\"\n(integer) 1\nredis> SUNIONSTORE key key1 key2\n(integer) 5\nredis> SMEMBERS key\n1) \"c\"\n2) \"e\"\n3) \"b\"\n4) \"a\"\n5) \"d\"\nredis>\n```","slug":"redis_command/set/sunionstore","published":1,"updated":"2021-03-14T03:04:50.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpua0029hyjfatm7j3e9","content":"<h2 id=\"SUNIONSTORE-destination-key-key-…\"><a href=\"#SUNIONSTORE-destination-key-key-…\" class=\"headerlink\" title=\"SUNIONSTORE destination key [key …]\"></a>SUNIONSTORE destination key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是所有给定集合中元素的总数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>该命令作用类似于SUNION命令,不同的是它并不返回结果集,而是将结果存储在destination集合中.</li>\n<li>如果destination 已经存在,则将其覆盖.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:结果集中元素的个数.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SUNIONSTORE key key1 key2</span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt; SMEMBERS key</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"e\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SUNIONSTORE-destination-key-key-…\"><a href=\"#SUNIONSTORE-destination-key-key-…\" class=\"headerlink\" title=\"SUNIONSTORE destination key [key …]\"></a>SUNIONSTORE destination key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是所有给定集合中元素的总数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>该命令作用类似于SUNION命令,不同的是它并不返回结果集,而是将结果存储在destination集合中.</li>\n<li>如果destination 已经存在,则将其覆盖.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:结果集中元素的个数.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"a\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"b\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key1 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"c\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"d\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SADD key2 <span class=\"string\">\"e\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SUNIONSTORE key key1 key2</span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt; SMEMBERS key</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"e\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"BRPOPLPUSH(brpoplpush)","copyright":true,"date":"2020-03-24T02:33:24.000Z","keywords":"Redis命令,brpoplpush","aside":"list","_content":"## BRPOPLPUSH source destination timeout \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本。 当 source 包含元素的时候，这个命令表现得跟 RPOPLPUSH 一模一样。 当 source 是空的时候，Redis将会阻塞这个连接，直到另一个客户端 push 元素进入或者达到 timeout 时限。 timeout 为 0 能用于无限期阻塞客户端。\n\n#### 返回值\n\n\n**批量回复(bulk-reply)**: 元素从 source 中弹出来，并压入 destination 中。 如果达到 timeout 时限，会返回一个空的多批量回复(nil-reply)。\n\n更多信息请参考RPOPLPUSH 命令文档。\n\n","source":"_posts/redis_command/list/brpoplpush.md","raw":"---\n\ntitle: BRPOPLPUSH(brpoplpush)\ncopyright: true\ndate: 2020-03-24 10:33:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,brpoplpush\naside: list\n\n---\n## BRPOPLPUSH source destination timeout \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本。 当 source 包含元素的时候，这个命令表现得跟 RPOPLPUSH 一模一样。 当 source 是空的时候，Redis将会阻塞这个连接，直到另一个客户端 push 元素进入或者达到 timeout 时限。 timeout 为 0 能用于无限期阻塞客户端。\n\n#### 返回值\n\n\n**批量回复(bulk-reply)**: 元素从 source 中弹出来，并压入 destination 中。 如果达到 timeout 时限，会返回一个空的多批量回复(nil-reply)。\n\n更多信息请参考RPOPLPUSH 命令文档。\n\n","slug":"redis_command/list/brpoplpush","published":1,"updated":"2021-03-14T03:04:50.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpub002chyjfe0idjnbj","content":"<h2 id=\"BRPOPLPUSH-source-destination-timeout\"><a href=\"#BRPOPLPUSH-source-destination-timeout\" class=\"headerlink\" title=\"BRPOPLPUSH source destination timeout\"></a>BRPOPLPUSH source destination timeout</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本。 当 source 包含元素的时候，这个命令表现得跟 RPOPLPUSH 一模一样。 当 source 是空的时候，Redis将会阻塞这个连接，直到另一个客户端 push 元素进入或者达到 timeout 时限。 timeout 为 0 能用于无限期阻塞客户端。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>批量回复(bulk-reply)</strong>: 元素从 source 中弹出来，并压入 destination 中。 如果达到 timeout 时限，会返回一个空的多批量回复(nil-reply)。</p>\n<p>更多信息请参考RPOPLPUSH 命令文档。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"BRPOPLPUSH-source-destination-timeout\"><a href=\"#BRPOPLPUSH-source-destination-timeout\" class=\"headerlink\" title=\"BRPOPLPUSH source destination timeout\"></a>BRPOPLPUSH source destination timeout</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本。 当 source 包含元素的时候，这个命令表现得跟 RPOPLPUSH 一模一样。 当 source 是空的时候，Redis将会阻塞这个连接，直到另一个客户端 push 元素进入或者达到 timeout 时限。 timeout 为 0 能用于无限期阻塞客户端。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>批量回复(bulk-reply)</strong>: 元素从 source 中弹出来，并压入 destination 中。 如果达到 timeout 时限，会返回一个空的多批量回复(nil-reply)。</p>\n<p>更多信息请参考RPOPLPUSH 命令文档。</p>\n"},{"title":"BRPOP(brpop)","copyright":true,"date":"2020-03-24T02:34:24.000Z","keywords":"Redis命令,brpop","aside":"list","_content":"## BRPOP key [key ...] timeout \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* BRPOP 是一个阻塞的列表弹出原语。 它是 RPOP 的阻塞版本，因为这个命令会在给定list无法弹出任何元素的时候阻塞连接。 该命令会按照给出的 key 顺序查看 list，并在找到的第一个非空 list 的尾部弹出一个元素。\n* 请在 BLPOP 文档 中查看该命令的准确语义，因为 BRPOP 和 BLPOP 基本是完全一样的，除了它们一个是从尾部弹出元素，而另一个是从头部弹出元素。\n\n#### 返回值\n\n**多批量回复(multi-bulk-reply)**: 具体来说:当没有元素可以被弹出时返回一个 nil 的多批量值，并且 timeout 过期。当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。\n\n\n#### 示例\n\n```c\nredis> DEL list1 list2\n(integer) 0\nredis> RPUSH list1 a b c\n(integer) 3\nredis> BRPOP list1 list2 0\n1) \"list1\"\n2) \"c\"\n```\n\n","source":"_posts/redis_command/list/brpop.md","raw":"---\n\ntitle: BRPOP(brpop)\ncopyright: true\ndate: 2020-03-24 10:34:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,brpop\naside: list\n\n---\n## BRPOP key [key ...] timeout \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* BRPOP 是一个阻塞的列表弹出原语。 它是 RPOP 的阻塞版本，因为这个命令会在给定list无法弹出任何元素的时候阻塞连接。 该命令会按照给出的 key 顺序查看 list，并在找到的第一个非空 list 的尾部弹出一个元素。\n* 请在 BLPOP 文档 中查看该命令的准确语义，因为 BRPOP 和 BLPOP 基本是完全一样的，除了它们一个是从尾部弹出元素，而另一个是从头部弹出元素。\n\n#### 返回值\n\n**多批量回复(multi-bulk-reply)**: 具体来说:当没有元素可以被弹出时返回一个 nil 的多批量值，并且 timeout 过期。当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。\n\n\n#### 示例\n\n```c\nredis> DEL list1 list2\n(integer) 0\nredis> RPUSH list1 a b c\n(integer) 3\nredis> BRPOP list1 list2 0\n1) \"list1\"\n2) \"c\"\n```\n\n","slug":"redis_command/list/brpop","published":1,"updated":"2021-03-14T03:04:50.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpuc002ehyjfxyb5b57i","content":"<h2 id=\"BRPOP-key-key-…-timeout\"><a href=\"#BRPOP-key-key-…-timeout\" class=\"headerlink\" title=\"BRPOP key [key …] timeout\"></a>BRPOP key [key …] timeout</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>BRPOP 是一个阻塞的列表弹出原语。 它是 RPOP 的阻塞版本，因为这个命令会在给定list无法弹出任何元素的时候阻塞连接。 该命令会按照给出的 key 顺序查看 list，并在找到的第一个非空 list 的尾部弹出一个元素。</li>\n<li>请在 BLPOP 文档 中查看该命令的准确语义，因为 BRPOP 和 BLPOP 基本是完全一样的，除了它们一个是从尾部弹出元素，而另一个是从头部弹出元素。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>多批量回复(multi-bulk-reply)</strong>: 具体来说:当没有元素可以被弹出时返回一个 nil 的多批量值，并且 timeout 过期。当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; DEL list1 list2</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; RPUSH list1 a b c</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; BRPOP list1 list2 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"list1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"c\"</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"BRPOP-key-key-…-timeout\"><a href=\"#BRPOP-key-key-…-timeout\" class=\"headerlink\" title=\"BRPOP key [key …] timeout\"></a>BRPOP key [key …] timeout</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>BRPOP 是一个阻塞的列表弹出原语。 它是 RPOP 的阻塞版本，因为这个命令会在给定list无法弹出任何元素的时候阻塞连接。 该命令会按照给出的 key 顺序查看 list，并在找到的第一个非空 list 的尾部弹出一个元素。</li>\n<li>请在 BLPOP 文档 中查看该命令的准确语义，因为 BRPOP 和 BLPOP 基本是完全一样的，除了它们一个是从尾部弹出元素，而另一个是从头部弹出元素。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>多批量回复(multi-bulk-reply)</strong>: 具体来说:当没有元素可以被弹出时返回一个 nil 的多批量值，并且 timeout 过期。当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; DEL list1 list2</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; RPUSH list1 a b c</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; BRPOP list1 list2 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"list1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"c\"</span></span><br></pre></td></tr></table></figure>\n"},{"title":"LINDEX(lindex)","copyright":true,"date":"2020-03-24T02:32:24.000Z","keywords":"Redis命令,lindex","aside":"list","_content":"## LINDEX key index \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是要遍历的元素数\n\n\n#### 说明:\n* 返回列表里的元素的索引 index 存储在 key 里面。 下标是从0开始索引的，所以 0 是表示第一个元素， 1 表示第二个元素，并以此类推。 负数索引用于指定从列表尾部开始索引的元素。在这种方法下，-1 表示最后一个元素，-2 表示倒数第二个元素，并以此往前推。\n* 当 key 位置的值不是一个列表的时候，会返回一个error。\n\n#### 返回值\n\n**bulk-reply**：请求的对应元素，或者当 index 超过范围的时候返回 nil。\n\n\n#### 示例\n\n```c\nredis> LPUSH mylist \"World\"\n(integer) 1\nredis> LPUSH mylist \"Hello\"\n(integer) 2\nredis> LINDEX mylist 0\n\"Hello\"\nredis> LINDEX mylist -1\n\"World\"\nredis> LINDEX mylist 3\n(nil)\nredis> \n```","source":"_posts/redis_command/list/lindex.md","raw":"---\n\ntitle: LINDEX(lindex)\ncopyright: true\ndate: 2020-03-24 10:32:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,lindex\naside: list\n---\n## LINDEX key index \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是要遍历的元素数\n\n\n#### 说明:\n* 返回列表里的元素的索引 index 存储在 key 里面。 下标是从0开始索引的，所以 0 是表示第一个元素， 1 表示第二个元素，并以此类推。 负数索引用于指定从列表尾部开始索引的元素。在这种方法下，-1 表示最后一个元素，-2 表示倒数第二个元素，并以此往前推。\n* 当 key 位置的值不是一个列表的时候，会返回一个error。\n\n#### 返回值\n\n**bulk-reply**：请求的对应元素，或者当 index 超过范围的时候返回 nil。\n\n\n#### 示例\n\n```c\nredis> LPUSH mylist \"World\"\n(integer) 1\nredis> LPUSH mylist \"Hello\"\n(integer) 2\nredis> LINDEX mylist 0\n\"Hello\"\nredis> LINDEX mylist -1\n\"World\"\nredis> LINDEX mylist 3\n(nil)\nredis> \n```","slug":"redis_command/list/lindex","published":1,"updated":"2021-03-14T03:04:50.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpue002hhyjf473d7azo","content":"<h2 id=\"LINDEX-key-index\"><a href=\"#LINDEX-key-index\" class=\"headerlink\" title=\"LINDEX key index\"></a>LINDEX key index</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是要遍历的元素数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回列表里的元素的索引 index 存储在 key 里面。 下标是从0开始索引的，所以 0 是表示第一个元素， 1 表示第二个元素，并以此类推。 负数索引用于指定从列表尾部开始索引的元素。在这种方法下，-1 表示最后一个元素，-2 表示倒数第二个元素，并以此往前推。</li>\n<li>当 key 位置的值不是一个列表的时候，会返回一个error。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-reply</strong>：请求的对应元素，或者当 index 超过范围的时候返回 nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LINDEX mylist <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt; LINDEX mylist <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"string\">\"World\"</span></span><br><span class=\"line\">redis&gt; LINDEX mylist <span class=\"number\">3</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LINDEX-key-index\"><a href=\"#LINDEX-key-index\" class=\"headerlink\" title=\"LINDEX key index\"></a>LINDEX key index</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是要遍历的元素数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回列表里的元素的索引 index 存储在 key 里面。 下标是从0开始索引的，所以 0 是表示第一个元素， 1 表示第二个元素，并以此类推。 负数索引用于指定从列表尾部开始索引的元素。在这种方法下，-1 表示最后一个元素，-2 表示倒数第二个元素，并以此往前推。</li>\n<li>当 key 位置的值不是一个列表的时候，会返回一个error。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-reply</strong>：请求的对应元素，或者当 index 超过范围的时候返回 nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LINDEX mylist <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt; LINDEX mylist <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"string\">\"World\"</span></span><br><span class=\"line\">redis&gt; LINDEX mylist <span class=\"number\">3</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"LLEN(llen)","copyright":true,"date":"2020-03-24T02:30:24.000Z","keywords":"Redis命令,llen","aside":"list","_content":"## LLEN key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回存储在 key 里的list的长度。 如果 key 不存在，那么就被看作是空list，并且返回长度为 0。 当存储在 key 里的值不是一个list的话，会返回error。\n\n#### 返回值\n\n\n**integer-reply**: key对应的list的长度。\n\n\n#### 示例\n\n```c\nredis> LPUSH mylist \"World\"\n(integer) 1\nredis> LPUSH mylist \"Hello\"\n(integer) 2\nredis> LLEN mylist\n(integer) 2\nredis> \n```","source":"_posts/redis_command/list/llen.md","raw":"---\n\ntitle: LLEN(llen)\ncopyright: true\ndate: 2020-03-24 10:30:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,llen\naside: list\n\n---\n## LLEN key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回存储在 key 里的list的长度。 如果 key 不存在，那么就被看作是空list，并且返回长度为 0。 当存储在 key 里的值不是一个list的话，会返回error。\n\n#### 返回值\n\n\n**integer-reply**: key对应的list的长度。\n\n\n#### 示例\n\n```c\nredis> LPUSH mylist \"World\"\n(integer) 1\nredis> LPUSH mylist \"Hello\"\n(integer) 2\nredis> LLEN mylist\n(integer) 2\nredis> \n```","slug":"redis_command/list/llen","published":1,"updated":"2021-03-14T03:04:50.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpui002jhyjf96h2n92h","content":"<h2 id=\"LLEN-key\"><a href=\"#LLEN-key\" class=\"headerlink\" title=\"LLEN key\"></a>LLEN key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回存储在 key 里的list的长度。 如果 key 不存在，那么就被看作是空list，并且返回长度为 0。 当存储在 key 里的值不是一个list的话，会返回error。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: key对应的list的长度。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LLEN mylist</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LLEN-key\"><a href=\"#LLEN-key\" class=\"headerlink\" title=\"LLEN key\"></a>LLEN key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回存储在 key 里的list的长度。 如果 key 不存在，那么就被看作是空list，并且返回长度为 0。 当存储在 key 里的值不是一个list的话，会返回error。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: key对应的list的长度。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LLEN mylist</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"LINSERT(linsert)","copyright":true,"date":"2020-03-24T02:31:24.000Z","keywords":"Redis命令,linsert","aside":"list","_content":"## LINSERT key BEFORE|AFTER pivot value \n>起始版本：2.2.0<br/>时间复杂度：O(N) N是要遍历的元素数  \n\n\n#### 说明:\n* 把 value 插入存于 key 的列表中在基准值 pivot 的前面或后面。\n* 当 key 不存在时，这个list会被看作是空list，任何操作都不会发生。\n* 当 key 存在，但保存的不是一个list的时候，会返回error。\n\n#### 返回值\n\n**integer-reply**: 经过插入操作后的list长度，或者当 pivot 值找不到的时候返回 -1。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"Hello\"\n(integer) 1\nredis> RPUSH mylist \"World\"\n(integer) 2\nredis> LINSERT mylist BEFORE \"World\" \"There\"\n(integer) 3\nredis> LRANGE mylist 0 -1\n1) \"Hello\"\n2) \"There\"\n3) \"World\"\nredis> \n```","source":"_posts/redis_command/list/linsert.md","raw":"---\n\ntitle: LINSERT(linsert)\ncopyright: true\ndate: 2020-03-24 10:31:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,linsert\naside: list\n\n---\n## LINSERT key BEFORE|AFTER pivot value \n>起始版本：2.2.0<br/>时间复杂度：O(N) N是要遍历的元素数  \n\n\n#### 说明:\n* 把 value 插入存于 key 的列表中在基准值 pivot 的前面或后面。\n* 当 key 不存在时，这个list会被看作是空list，任何操作都不会发生。\n* 当 key 存在，但保存的不是一个list的时候，会返回error。\n\n#### 返回值\n\n**integer-reply**: 经过插入操作后的list长度，或者当 pivot 值找不到的时候返回 -1。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"Hello\"\n(integer) 1\nredis> RPUSH mylist \"World\"\n(integer) 2\nredis> LINSERT mylist BEFORE \"World\" \"There\"\n(integer) 3\nredis> LRANGE mylist 0 -1\n1) \"Hello\"\n2) \"There\"\n3) \"World\"\nredis> \n```","slug":"redis_command/list/linsert","published":1,"updated":"2021-03-14T03:04:50.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpuj002mhyjf2ish9l52","content":"<h2 id=\"LINSERT-key-BEFORE-AFTER-pivot-value\"><a href=\"#LINSERT-key-BEFORE-AFTER-pivot-value\" class=\"headerlink\" title=\"LINSERT key BEFORE|AFTER pivot value\"></a>LINSERT key BEFORE|AFTER pivot value</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(N) N是要遍历的元素数  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>把 value 插入存于 key 的列表中在基准值 pivot 的前面或后面。</li>\n<li>当 key 不存在时，这个list会被看作是空list，任何操作都不会发生。</li>\n<li>当 key 存在，但保存的不是一个list的时候，会返回error。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 经过插入操作后的list长度，或者当 pivot 值找不到的时候返回 -1。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LINSERT mylist BEFORE <span class=\"string\">\"World\"</span> <span class=\"string\">\"There\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"There\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LINSERT-key-BEFORE-AFTER-pivot-value\"><a href=\"#LINSERT-key-BEFORE-AFTER-pivot-value\" class=\"headerlink\" title=\"LINSERT key BEFORE|AFTER pivot value\"></a>LINSERT key BEFORE|AFTER pivot value</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(N) N是要遍历的元素数  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>把 value 插入存于 key 的列表中在基准值 pivot 的前面或后面。</li>\n<li>当 key 不存在时，这个list会被看作是空list，任何操作都不会发生。</li>\n<li>当 key 存在，但保存的不是一个list的时候，会返回error。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 经过插入操作后的list长度，或者当 pivot 值找不到的时候返回 -1。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LINSERT mylist BEFORE <span class=\"string\">\"World\"</span> <span class=\"string\">\"There\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"There\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"BLPOP(blpop)","copyright":true,"date":"2020-03-24T02:35:24.000Z","keywords":"Redis命令,blpop","aside":"list","_content":"## BLPOP key [key ...] timeout \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* BLPOP——阻塞式列表命令，是命令 LPOP 的阻塞版本，这是因为当给定列表内没有任何元素可供弹出的时候， 连接将被 BLPOP 命令阻塞。 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。\n\n#### 非阻塞行为\n\n当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字 key 一起，组成结果返回给调用者。\n\n当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。 我们假设 key list1 不存在，而 list2 和 list3 都是非空列表。考虑以下的命令：\n\n```c\nBLPOP list1 list2 list3 0\n```\n\nBLPOP 保证返回一个存在于 list2 里的元素（因为它是从 list1 –> list2 –> list3 这个顺序查起的第一个非空列表）。\n\n#### 阻塞行为\n\n如果所有给定 key 都不存在或包含空列表，那么 BLPOP] 命令将阻塞连接， 直到有另一个客户端对给定的这些 key 的任意一个执行 LPUSH 命令为止。\n\n一旦有新的数据出现在其中一个列表里，那么这个命令会解除阻塞状态，并且返回 key 和弹出的元素值。\n\n当 BLPOP 命令引起客户端阻塞并且设置了一个非零的超时参数 timeout 的时候， 若经过了指定的 timeout 仍没有出现一个针对某一特定 key 的 push 操作，则客户端会解除阻塞状态并且返回一个 nil 的多组合值(multi-bulk value)。\n\n**timeout 参数表示的是一个指定阻塞的最大秒数的整型值。**当 timeout 为 0 是表示阻塞时间无限制。\n\n**注意:**\n\n- 当客户端为多个 key 尝试阻塞的时候，若至少存在一个 key 拥有元素，那么返回的键值对(key/element pair)就是从左到右数第一个拥有一个或多个元素的key。 在这种情况下客户端不会被阻塞。比如对于这个例子 BLPOP key1 key2 key3 key4 0，假设 key2 和 key4 都非空， 那么就会返回 key2 里的一个元素。\n- 当多个客户端为同一个 key 阻塞的时候，第一个被处理的客户端是等待最长时间的那个（即第一个因为该key而阻塞的客户端）。 一旦一个客户端解除阻塞那么它就不会保持任何优先级，当它因为下一个 BLPOP 命令而再次被阻塞的时候，会在处理完那些 被同个 key 阻塞的客户端后才处理它（即从第一个被阻塞的处理到最后一个被阻塞的）。\n- 当一个客户端同时被多个 key 阻塞时，若多个 key 的元素同时可用（可能是因为事务或者某个Lua脚本向多个list添加元素）， 那么客户端会解除阻塞，并使用第一个接收到 push 操作的 key（假设它拥有足够的元素为我们的客户端服务，因为有可能存在其他客户端同样是被这个key阻塞着）。 从根本上来说，在执行完每个命令之后，Redis 会把一个所有 key 都获得数据并且至少使一个客户端阻塞了的 list 运行一次。 这个 list 按照新数据的接收时间进行整理，即是从第一个接收数据的 key 到最后一个。在处理每个 key 的时候，只要这个 key 里有元素， Redis就会对所有等待这个key的客户端按照“先进先出”(FIFO)的顺序进行服务。若这个 key 是空的，或者没有客户端在等待这个 key， 那么将会去处理下一个从之前的命令或事务或脚本中获得新数据的 key，如此等等。\n\n#### 当多个元素被 push 进入一个 list 时 BLPOP 的行为\n\n有时候一个 list 会在同一概念的命令的情况下接收到多个元素：\n\n- 像 LPUSH mylist a b c 这样的可变 push 操作。\n- 在对一个向同一个 list 进行多次 push 操作的 MULTI 块执行完 EXEC 语句后。\n- 使用 Redis 2.6 或者更新的版本执行一个 Lua 脚本。\n\n当多个元素被 push 进入一个被客户端阻塞着的 list 的时候，Redis 2.4 和 Redis 2.6 或者更新的版本所采取行为是不一样的。\n\n对于 Redis 2.6 来说，所采取的行为是先执行多个 push 命令，然后在执行了这个命令之后再去服务被阻塞的客户端。看看下面命令顺序。\n\n```\nClient A:   BLPOP foo 0\nClient B:   LPUSH foo a b c\n```\n\n如果上面的情况是发生在 Redis 2.6 或更高版本的服务器上，客户端 A 会接收到 c 元素，因为在 LPUSH 命令执行后，list 包含了 c,b,a 这三个元素，所以从左边取一个元素就会返回 c。\n\n相反，Redis 2.4 是以不同的方式工作的：客户端会在 push 操作的上下文中被服务，所以当 LPUSH foo a b c 开始往 list 中 push 第一个元素，它就被传送给客户端A，也就是客户端A会接收到 a（第一个被 push 的元素）。\n\nRedis 2.4的这种行为会在复制或者持续把数据存入AOF文件的时候引发很多问题，所以为了防止这些问题，很多更一般性的、并且在语义上更简单的行为被引入到 Redis 2.6 中。\n\n需要注意的是，一个Lua脚本或者一个 MULTI / EXEC 块可能会 push 一堆元素进入一个 list 后，再 删除这个 list。 在这种情况下，被阻塞的客户端完全不会被服务，并且只要在执行某个单一命令、事务或者脚本后 list 中没有出现元素，它就会被继续阻塞下去。\n\n#### 返回值\n\n**多批量回复(multi-bulk-reply)**: 具体来说:\n\n- 当没有元素的时候会弹出一个 nil 的多批量值，并且 timeout 过期。\n- 当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。\n\n\n#### 示例\n\n```c\nredis> DEL list1 list2\n(integer) 0\nredis> RPUSH list1 a b c\n(integer) 3\nredis> BLPOP list1 list2 0\n1) \"list1\"\n2) \"a\"\n```\n\n**注意:**当 BLPOP 返回一个元素给客户端的时候，它也从 list 中把该元素移除。这意味着该元素就只存在于客户端的上下文中：如果客户端在处理这个返回元素的过程崩溃了，那么这个元素就永远丢失了。\n\n在一些我们希望是更可靠的消息传递系统中的应用上，这可能会导致一些问题。在这种时候，可以使用BRPOPLPUSH 命令，这是 BLPOP 的一个变形，它会在把返回元素传给客户端之前先把该元素加入到一个目标 list 中。\n\n#### 场景\n\n有些时候我们可以用BLPOP来阻塞一些其他操作。 比如在某些应用里，为了等待新元素进入 Redis Set ，而阻塞队列，直到有个新元素加入到 Set 中，这样就可以在不轮询的情况下获得元素。我们可以通过阻塞 list 操作来实现这个功能。\n\n消费者端伪代码:\n\n```\nwhile(true){\n\tvar result=SPOP(key)\n\tif(result.isNull()){\n\t   BRPOP helper_key\n\t}\n}\n```\n\n生产者端伪代码\n\n```\nMULTI\nSADD key element\nLPUSH helper_key x\nEXEC\n```\n\n","source":"_posts/redis_command/list/blpop.md","raw":"---\n\ntitle: BLPOP(blpop)\ncopyright: true\ndate: 2020-03-24 10:35:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,blpop\naside: list\n\n---\n## BLPOP key [key ...] timeout \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* BLPOP——阻塞式列表命令，是命令 LPOP 的阻塞版本，这是因为当给定列表内没有任何元素可供弹出的时候， 连接将被 BLPOP 命令阻塞。 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。\n\n#### 非阻塞行为\n\n当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字 key 一起，组成结果返回给调用者。\n\n当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。 我们假设 key list1 不存在，而 list2 和 list3 都是非空列表。考虑以下的命令：\n\n```c\nBLPOP list1 list2 list3 0\n```\n\nBLPOP 保证返回一个存在于 list2 里的元素（因为它是从 list1 –> list2 –> list3 这个顺序查起的第一个非空列表）。\n\n#### 阻塞行为\n\n如果所有给定 key 都不存在或包含空列表，那么 BLPOP] 命令将阻塞连接， 直到有另一个客户端对给定的这些 key 的任意一个执行 LPUSH 命令为止。\n\n一旦有新的数据出现在其中一个列表里，那么这个命令会解除阻塞状态，并且返回 key 和弹出的元素值。\n\n当 BLPOP 命令引起客户端阻塞并且设置了一个非零的超时参数 timeout 的时候， 若经过了指定的 timeout 仍没有出现一个针对某一特定 key 的 push 操作，则客户端会解除阻塞状态并且返回一个 nil 的多组合值(multi-bulk value)。\n\n**timeout 参数表示的是一个指定阻塞的最大秒数的整型值。**当 timeout 为 0 是表示阻塞时间无限制。\n\n**注意:**\n\n- 当客户端为多个 key 尝试阻塞的时候，若至少存在一个 key 拥有元素，那么返回的键值对(key/element pair)就是从左到右数第一个拥有一个或多个元素的key。 在这种情况下客户端不会被阻塞。比如对于这个例子 BLPOP key1 key2 key3 key4 0，假设 key2 和 key4 都非空， 那么就会返回 key2 里的一个元素。\n- 当多个客户端为同一个 key 阻塞的时候，第一个被处理的客户端是等待最长时间的那个（即第一个因为该key而阻塞的客户端）。 一旦一个客户端解除阻塞那么它就不会保持任何优先级，当它因为下一个 BLPOP 命令而再次被阻塞的时候，会在处理完那些 被同个 key 阻塞的客户端后才处理它（即从第一个被阻塞的处理到最后一个被阻塞的）。\n- 当一个客户端同时被多个 key 阻塞时，若多个 key 的元素同时可用（可能是因为事务或者某个Lua脚本向多个list添加元素）， 那么客户端会解除阻塞，并使用第一个接收到 push 操作的 key（假设它拥有足够的元素为我们的客户端服务，因为有可能存在其他客户端同样是被这个key阻塞着）。 从根本上来说，在执行完每个命令之后，Redis 会把一个所有 key 都获得数据并且至少使一个客户端阻塞了的 list 运行一次。 这个 list 按照新数据的接收时间进行整理，即是从第一个接收数据的 key 到最后一个。在处理每个 key 的时候，只要这个 key 里有元素， Redis就会对所有等待这个key的客户端按照“先进先出”(FIFO)的顺序进行服务。若这个 key 是空的，或者没有客户端在等待这个 key， 那么将会去处理下一个从之前的命令或事务或脚本中获得新数据的 key，如此等等。\n\n#### 当多个元素被 push 进入一个 list 时 BLPOP 的行为\n\n有时候一个 list 会在同一概念的命令的情况下接收到多个元素：\n\n- 像 LPUSH mylist a b c 这样的可变 push 操作。\n- 在对一个向同一个 list 进行多次 push 操作的 MULTI 块执行完 EXEC 语句后。\n- 使用 Redis 2.6 或者更新的版本执行一个 Lua 脚本。\n\n当多个元素被 push 进入一个被客户端阻塞着的 list 的时候，Redis 2.4 和 Redis 2.6 或者更新的版本所采取行为是不一样的。\n\n对于 Redis 2.6 来说，所采取的行为是先执行多个 push 命令，然后在执行了这个命令之后再去服务被阻塞的客户端。看看下面命令顺序。\n\n```\nClient A:   BLPOP foo 0\nClient B:   LPUSH foo a b c\n```\n\n如果上面的情况是发生在 Redis 2.6 或更高版本的服务器上，客户端 A 会接收到 c 元素，因为在 LPUSH 命令执行后，list 包含了 c,b,a 这三个元素，所以从左边取一个元素就会返回 c。\n\n相反，Redis 2.4 是以不同的方式工作的：客户端会在 push 操作的上下文中被服务，所以当 LPUSH foo a b c 开始往 list 中 push 第一个元素，它就被传送给客户端A，也就是客户端A会接收到 a（第一个被 push 的元素）。\n\nRedis 2.4的这种行为会在复制或者持续把数据存入AOF文件的时候引发很多问题，所以为了防止这些问题，很多更一般性的、并且在语义上更简单的行为被引入到 Redis 2.6 中。\n\n需要注意的是，一个Lua脚本或者一个 MULTI / EXEC 块可能会 push 一堆元素进入一个 list 后，再 删除这个 list。 在这种情况下，被阻塞的客户端完全不会被服务，并且只要在执行某个单一命令、事务或者脚本后 list 中没有出现元素，它就会被继续阻塞下去。\n\n#### 返回值\n\n**多批量回复(multi-bulk-reply)**: 具体来说:\n\n- 当没有元素的时候会弹出一个 nil 的多批量值，并且 timeout 过期。\n- 当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。\n\n\n#### 示例\n\n```c\nredis> DEL list1 list2\n(integer) 0\nredis> RPUSH list1 a b c\n(integer) 3\nredis> BLPOP list1 list2 0\n1) \"list1\"\n2) \"a\"\n```\n\n**注意:**当 BLPOP 返回一个元素给客户端的时候，它也从 list 中把该元素移除。这意味着该元素就只存在于客户端的上下文中：如果客户端在处理这个返回元素的过程崩溃了，那么这个元素就永远丢失了。\n\n在一些我们希望是更可靠的消息传递系统中的应用上，这可能会导致一些问题。在这种时候，可以使用BRPOPLPUSH 命令，这是 BLPOP 的一个变形，它会在把返回元素传给客户端之前先把该元素加入到一个目标 list 中。\n\n#### 场景\n\n有些时候我们可以用BLPOP来阻塞一些其他操作。 比如在某些应用里，为了等待新元素进入 Redis Set ，而阻塞队列，直到有个新元素加入到 Set 中，这样就可以在不轮询的情况下获得元素。我们可以通过阻塞 list 操作来实现这个功能。\n\n消费者端伪代码:\n\n```\nwhile(true){\n\tvar result=SPOP(key)\n\tif(result.isNull()){\n\t   BRPOP helper_key\n\t}\n}\n```\n\n生产者端伪代码\n\n```\nMULTI\nSADD key element\nLPUSH helper_key x\nEXEC\n```\n\n","slug":"redis_command/list/blpop","published":1,"updated":"2021-03-14T03:04:50.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpuk002ohyjfb809bntj","content":"<h2 id=\"BLPOP-key-key-…-timeout\"><a href=\"#BLPOP-key-key-…-timeout\" class=\"headerlink\" title=\"BLPOP key [key …] timeout\"></a>BLPOP key [key …] timeout</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>BLPOP——阻塞式列表命令，是命令 LPOP 的阻塞版本，这是因为当给定列表内没有任何元素可供弹出的时候， 连接将被 BLPOP 命令阻塞。 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</li>\n</ul>\n<h4 id=\"非阻塞行为\"><a href=\"#非阻塞行为\" class=\"headerlink\" title=\"非阻塞行为\"></a>非阻塞行为</h4><p>当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字 key 一起，组成结果返回给调用者。</p>\n<p>当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。 我们假设 key list1 不存在，而 list2 和 list3 都是非空列表。考虑以下的命令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BLPOP list1 list2 list3 <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>BLPOP 保证返回一个存在于 list2 里的元素（因为它是从 list1 –&gt; list2 –&gt; list3 这个顺序查起的第一个非空列表）。</p>\n<h4 id=\"阻塞行为\"><a href=\"#阻塞行为\" class=\"headerlink\" title=\"阻塞行为\"></a>阻塞行为</h4><p>如果所有给定 key 都不存在或包含空列表，那么 BLPOP] 命令将阻塞连接， 直到有另一个客户端对给定的这些 key 的任意一个执行 LPUSH 命令为止。</p>\n<p>一旦有新的数据出现在其中一个列表里，那么这个命令会解除阻塞状态，并且返回 key 和弹出的元素值。</p>\n<p>当 BLPOP 命令引起客户端阻塞并且设置了一个非零的超时参数 timeout 的时候， 若经过了指定的 timeout 仍没有出现一个针对某一特定 key 的 push 操作，则客户端会解除阻塞状态并且返回一个 nil 的多组合值(multi-bulk value)。</p>\n<p><strong>timeout 参数表示的是一个指定阻塞的最大秒数的整型值。</strong>当 timeout 为 0 是表示阻塞时间无限制。</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>当客户端为多个 key 尝试阻塞的时候，若至少存在一个 key 拥有元素，那么返回的键值对(key/element pair)就是从左到右数第一个拥有一个或多个元素的key。 在这种情况下客户端不会被阻塞。比如对于这个例子 BLPOP key1 key2 key3 key4 0，假设 key2 和 key4 都非空， 那么就会返回 key2 里的一个元素。</li>\n<li>当多个客户端为同一个 key 阻塞的时候，第一个被处理的客户端是等待最长时间的那个（即第一个因为该key而阻塞的客户端）。 一旦一个客户端解除阻塞那么它就不会保持任何优先级，当它因为下一个 BLPOP 命令而再次被阻塞的时候，会在处理完那些 被同个 key 阻塞的客户端后才处理它（即从第一个被阻塞的处理到最后一个被阻塞的）。</li>\n<li>当一个客户端同时被多个 key 阻塞时，若多个 key 的元素同时可用（可能是因为事务或者某个Lua脚本向多个list添加元素）， 那么客户端会解除阻塞，并使用第一个接收到 push 操作的 key（假设它拥有足够的元素为我们的客户端服务，因为有可能存在其他客户端同样是被这个key阻塞着）。 从根本上来说，在执行完每个命令之后，Redis 会把一个所有 key 都获得数据并且至少使一个客户端阻塞了的 list 运行一次。 这个 list 按照新数据的接收时间进行整理，即是从第一个接收数据的 key 到最后一个。在处理每个 key 的时候，只要这个 key 里有元素， Redis就会对所有等待这个key的客户端按照“先进先出”(FIFO)的顺序进行服务。若这个 key 是空的，或者没有客户端在等待这个 key， 那么将会去处理下一个从之前的命令或事务或脚本中获得新数据的 key，如此等等。</li>\n</ul>\n<h4 id=\"当多个元素被-push-进入一个-list-时-BLPOP-的行为\"><a href=\"#当多个元素被-push-进入一个-list-时-BLPOP-的行为\" class=\"headerlink\" title=\"当多个元素被 push 进入一个 list 时 BLPOP 的行为\"></a>当多个元素被 push 进入一个 list 时 BLPOP 的行为</h4><p>有时候一个 list 会在同一概念的命令的情况下接收到多个元素：</p>\n<ul>\n<li>像 LPUSH mylist a b c 这样的可变 push 操作。</li>\n<li>在对一个向同一个 list 进行多次 push 操作的 MULTI 块执行完 EXEC 语句后。</li>\n<li>使用 Redis 2.6 或者更新的版本执行一个 Lua 脚本。</li>\n</ul>\n<p>当多个元素被 push 进入一个被客户端阻塞着的 list 的时候，Redis 2.4 和 Redis 2.6 或者更新的版本所采取行为是不一样的。</p>\n<p>对于 Redis 2.6 来说，所采取的行为是先执行多个 push 命令，然后在执行了这个命令之后再去服务被阻塞的客户端。看看下面命令顺序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Client A:   BLPOP foo 0</span><br><span class=\"line\">Client B:   LPUSH foo a b c</span><br></pre></td></tr></table></figure>\n<p>如果上面的情况是发生在 Redis 2.6 或更高版本的服务器上，客户端 A 会接收到 c 元素，因为在 LPUSH 命令执行后，list 包含了 c,b,a 这三个元素，所以从左边取一个元素就会返回 c。</p>\n<p>相反，Redis 2.4 是以不同的方式工作的：客户端会在 push 操作的上下文中被服务，所以当 LPUSH foo a b c 开始往 list 中 push 第一个元素，它就被传送给客户端A，也就是客户端A会接收到 a（第一个被 push 的元素）。</p>\n<p>Redis 2.4的这种行为会在复制或者持续把数据存入AOF文件的时候引发很多问题，所以为了防止这些问题，很多更一般性的、并且在语义上更简单的行为被引入到 Redis 2.6 中。</p>\n<p>需要注意的是，一个Lua脚本或者一个 MULTI / EXEC 块可能会 push 一堆元素进入一个 list 后，再 删除这个 list。 在这种情况下，被阻塞的客户端完全不会被服务，并且只要在执行某个单一命令、事务或者脚本后 list 中没有出现元素，它就会被继续阻塞下去。</p>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>多批量回复(multi-bulk-reply)</strong>: 具体来说:</p>\n<ul>\n<li>当没有元素的时候会弹出一个 nil 的多批量值，并且 timeout 过期。</li>\n<li>当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; DEL list1 list2</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; RPUSH list1 a b c</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; BLPOP list1 list2 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"list1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"a\"</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意:</strong>当 BLPOP 返回一个元素给客户端的时候，它也从 list 中把该元素移除。这意味着该元素就只存在于客户端的上下文中：如果客户端在处理这个返回元素的过程崩溃了，那么这个元素就永远丢失了。</p>\n<p>在一些我们希望是更可靠的消息传递系统中的应用上，这可能会导致一些问题。在这种时候，可以使用BRPOPLPUSH 命令，这是 BLPOP 的一个变形，它会在把返回元素传给客户端之前先把该元素加入到一个目标 list 中。</p>\n<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>有些时候我们可以用BLPOP来阻塞一些其他操作。 比如在某些应用里，为了等待新元素进入 Redis Set ，而阻塞队列，直到有个新元素加入到 Set 中，这样就可以在不轮询的情况下获得元素。我们可以通过阻塞 list 操作来实现这个功能。</p>\n<p>消费者端伪代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(true)&#123;</span><br><span class=\"line\">\tvar result=SPOP(key)</span><br><span class=\"line\">\tif(result.isNull())&#123;</span><br><span class=\"line\">\t   BRPOP helper_key</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生产者端伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MULTI</span><br><span class=\"line\">SADD key element</span><br><span class=\"line\">LPUSH helper_key x</span><br><span class=\"line\">EXEC</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"BLPOP-key-key-…-timeout\"><a href=\"#BLPOP-key-key-…-timeout\" class=\"headerlink\" title=\"BLPOP key [key …] timeout\"></a>BLPOP key [key …] timeout</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>BLPOP——阻塞式列表命令，是命令 LPOP 的阻塞版本，这是因为当给定列表内没有任何元素可供弹出的时候， 连接将被 BLPOP 命令阻塞。 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</li>\n</ul>\n<h4 id=\"非阻塞行为\"><a href=\"#非阻塞行为\" class=\"headerlink\" title=\"非阻塞行为\"></a>非阻塞行为</h4><p>当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字 key 一起，组成结果返回给调用者。</p>\n<p>当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。 我们假设 key list1 不存在，而 list2 和 list3 都是非空列表。考虑以下的命令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BLPOP list1 list2 list3 <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>BLPOP 保证返回一个存在于 list2 里的元素（因为它是从 list1 –&gt; list2 –&gt; list3 这个顺序查起的第一个非空列表）。</p>\n<h4 id=\"阻塞行为\"><a href=\"#阻塞行为\" class=\"headerlink\" title=\"阻塞行为\"></a>阻塞行为</h4><p>如果所有给定 key 都不存在或包含空列表，那么 BLPOP] 命令将阻塞连接， 直到有另一个客户端对给定的这些 key 的任意一个执行 LPUSH 命令为止。</p>\n<p>一旦有新的数据出现在其中一个列表里，那么这个命令会解除阻塞状态，并且返回 key 和弹出的元素值。</p>\n<p>当 BLPOP 命令引起客户端阻塞并且设置了一个非零的超时参数 timeout 的时候， 若经过了指定的 timeout 仍没有出现一个针对某一特定 key 的 push 操作，则客户端会解除阻塞状态并且返回一个 nil 的多组合值(multi-bulk value)。</p>\n<p><strong>timeout 参数表示的是一个指定阻塞的最大秒数的整型值。</strong>当 timeout 为 0 是表示阻塞时间无限制。</p>\n<p><strong>注意:</strong></p>\n<ul>\n<li>当客户端为多个 key 尝试阻塞的时候，若至少存在一个 key 拥有元素，那么返回的键值对(key/element pair)就是从左到右数第一个拥有一个或多个元素的key。 在这种情况下客户端不会被阻塞。比如对于这个例子 BLPOP key1 key2 key3 key4 0，假设 key2 和 key4 都非空， 那么就会返回 key2 里的一个元素。</li>\n<li>当多个客户端为同一个 key 阻塞的时候，第一个被处理的客户端是等待最长时间的那个（即第一个因为该key而阻塞的客户端）。 一旦一个客户端解除阻塞那么它就不会保持任何优先级，当它因为下一个 BLPOP 命令而再次被阻塞的时候，会在处理完那些 被同个 key 阻塞的客户端后才处理它（即从第一个被阻塞的处理到最后一个被阻塞的）。</li>\n<li>当一个客户端同时被多个 key 阻塞时，若多个 key 的元素同时可用（可能是因为事务或者某个Lua脚本向多个list添加元素）， 那么客户端会解除阻塞，并使用第一个接收到 push 操作的 key（假设它拥有足够的元素为我们的客户端服务，因为有可能存在其他客户端同样是被这个key阻塞着）。 从根本上来说，在执行完每个命令之后，Redis 会把一个所有 key 都获得数据并且至少使一个客户端阻塞了的 list 运行一次。 这个 list 按照新数据的接收时间进行整理，即是从第一个接收数据的 key 到最后一个。在处理每个 key 的时候，只要这个 key 里有元素， Redis就会对所有等待这个key的客户端按照“先进先出”(FIFO)的顺序进行服务。若这个 key 是空的，或者没有客户端在等待这个 key， 那么将会去处理下一个从之前的命令或事务或脚本中获得新数据的 key，如此等等。</li>\n</ul>\n<h4 id=\"当多个元素被-push-进入一个-list-时-BLPOP-的行为\"><a href=\"#当多个元素被-push-进入一个-list-时-BLPOP-的行为\" class=\"headerlink\" title=\"当多个元素被 push 进入一个 list 时 BLPOP 的行为\"></a>当多个元素被 push 进入一个 list 时 BLPOP 的行为</h4><p>有时候一个 list 会在同一概念的命令的情况下接收到多个元素：</p>\n<ul>\n<li>像 LPUSH mylist a b c 这样的可变 push 操作。</li>\n<li>在对一个向同一个 list 进行多次 push 操作的 MULTI 块执行完 EXEC 语句后。</li>\n<li>使用 Redis 2.6 或者更新的版本执行一个 Lua 脚本。</li>\n</ul>\n<p>当多个元素被 push 进入一个被客户端阻塞着的 list 的时候，Redis 2.4 和 Redis 2.6 或者更新的版本所采取行为是不一样的。</p>\n<p>对于 Redis 2.6 来说，所采取的行为是先执行多个 push 命令，然后在执行了这个命令之后再去服务被阻塞的客户端。看看下面命令顺序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Client A:   BLPOP foo 0</span><br><span class=\"line\">Client B:   LPUSH foo a b c</span><br></pre></td></tr></table></figure>\n<p>如果上面的情况是发生在 Redis 2.6 或更高版本的服务器上，客户端 A 会接收到 c 元素，因为在 LPUSH 命令执行后，list 包含了 c,b,a 这三个元素，所以从左边取一个元素就会返回 c。</p>\n<p>相反，Redis 2.4 是以不同的方式工作的：客户端会在 push 操作的上下文中被服务，所以当 LPUSH foo a b c 开始往 list 中 push 第一个元素，它就被传送给客户端A，也就是客户端A会接收到 a（第一个被 push 的元素）。</p>\n<p>Redis 2.4的这种行为会在复制或者持续把数据存入AOF文件的时候引发很多问题，所以为了防止这些问题，很多更一般性的、并且在语义上更简单的行为被引入到 Redis 2.6 中。</p>\n<p>需要注意的是，一个Lua脚本或者一个 MULTI / EXEC 块可能会 push 一堆元素进入一个 list 后，再 删除这个 list。 在这种情况下，被阻塞的客户端完全不会被服务，并且只要在执行某个单一命令、事务或者脚本后 list 中没有出现元素，它就会被继续阻塞下去。</p>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>多批量回复(multi-bulk-reply)</strong>: 具体来说:</p>\n<ul>\n<li>当没有元素的时候会弹出一个 nil 的多批量值，并且 timeout 过期。</li>\n<li>当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; DEL list1 list2</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; RPUSH list1 a b c</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; BLPOP list1 list2 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"list1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"a\"</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意:</strong>当 BLPOP 返回一个元素给客户端的时候，它也从 list 中把该元素移除。这意味着该元素就只存在于客户端的上下文中：如果客户端在处理这个返回元素的过程崩溃了，那么这个元素就永远丢失了。</p>\n<p>在一些我们希望是更可靠的消息传递系统中的应用上，这可能会导致一些问题。在这种时候，可以使用BRPOPLPUSH 命令，这是 BLPOP 的一个变形，它会在把返回元素传给客户端之前先把该元素加入到一个目标 list 中。</p>\n<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>有些时候我们可以用BLPOP来阻塞一些其他操作。 比如在某些应用里，为了等待新元素进入 Redis Set ，而阻塞队列，直到有个新元素加入到 Set 中，这样就可以在不轮询的情况下获得元素。我们可以通过阻塞 list 操作来实现这个功能。</p>\n<p>消费者端伪代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(true)&#123;</span><br><span class=\"line\">\tvar result=SPOP(key)</span><br><span class=\"line\">\tif(result.isNull())&#123;</span><br><span class=\"line\">\t   BRPOP helper_key</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生产者端伪代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MULTI</span><br><span class=\"line\">SADD key element</span><br><span class=\"line\">LPUSH helper_key x</span><br><span class=\"line\">EXEC</span><br></pre></td></tr></table></figure>\n"},{"title":"LPUSH(lpush)","copyright":true,"date":"2020-03-24T01:56:24.000Z","keywords":"Redis命令,lpush","aside":"list","_content":"## LPUSH key value [value ...] \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将所有指定的值插入到存于 key 的列表的头部。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。\n* 可以使用一个命令把多个元素 push 进入列表，只需在命令末尾加上多个指定的参数。元素是从最左端的到最右端的、一个接一个被插入到 list 的头部。 所以对于这个命令\n\n#### 返回值\n\n LPUSH mylist a b c，返回的列表是 c 为第一个元素， b 为第二个元素， a 为第三个元素。\n\n\n#### 历史\n\n\n版本2.4: 接受多个 value 参数。版本老于 2.4 的 Redis 只能每条命令 push 一个值。\n\n\n#### 示例\n\n```c\nredis> LPUSH mylist \"world\"\n(integer) 1\nredis> LPUSH mylist \"hello\"\n(integer) 2\nredis> LRANGE mylist 0 -1\n1) \"hello\"\n2) \"world\"\nredis> \n```","source":"_posts/redis_command/list/lpush.md","raw":"---\n\ntitle: LPUSH(lpush)\ncopyright: true\ndate: 2020-03-24 09:56:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,lpush\naside: list\n\n---\n## LPUSH key value [value ...] \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将所有指定的值插入到存于 key 的列表的头部。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。\n* 可以使用一个命令把多个元素 push 进入列表，只需在命令末尾加上多个指定的参数。元素是从最左端的到最右端的、一个接一个被插入到 list 的头部。 所以对于这个命令\n\n#### 返回值\n\n LPUSH mylist a b c，返回的列表是 c 为第一个元素， b 为第二个元素， a 为第三个元素。\n\n\n#### 历史\n\n\n版本2.4: 接受多个 value 参数。版本老于 2.4 的 Redis 只能每条命令 push 一个值。\n\n\n#### 示例\n\n```c\nredis> LPUSH mylist \"world\"\n(integer) 1\nredis> LPUSH mylist \"hello\"\n(integer) 2\nredis> LRANGE mylist 0 -1\n1) \"hello\"\n2) \"world\"\nredis> \n```","slug":"redis_command/list/lpush","published":1,"updated":"2021-03-14T03:04:50.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpul002rhyjfzjf6ywy2","content":"<h2 id=\"LPUSH-key-value-value-…\"><a href=\"#LPUSH-key-value-value-…\" class=\"headerlink\" title=\"LPUSH key value [value …]\"></a>LPUSH key value [value …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将所有指定的值插入到存于 key 的列表的头部。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。</li>\n<li>可以使用一个命令把多个元素 push 进入列表，只需在命令末尾加上多个指定的参数。元素是从最左端的到最右端的、一个接一个被插入到 list 的头部。 所以对于这个命令</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p> LPUSH mylist a b c，返回的列表是 c 为第一个元素， b 为第二个元素， a 为第三个元素。</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>版本2.4: 接受多个 value 参数。版本老于 2.4 的 Redis 只能每条命令 push 一个值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"world\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"world\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LPUSH-key-value-value-…\"><a href=\"#LPUSH-key-value-value-…\" class=\"headerlink\" title=\"LPUSH key value [value …]\"></a>LPUSH key value [value …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将所有指定的值插入到存于 key 的列表的头部。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。</li>\n<li>可以使用一个命令把多个元素 push 进入列表，只需在命令末尾加上多个指定的参数。元素是从最左端的到最右端的、一个接一个被插入到 list 的头部。 所以对于这个命令</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p> LPUSH mylist a b c，返回的列表是 c 为第一个元素， b 为第二个元素， a 为第三个元素。</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>版本2.4: 接受多个 value 参数。版本老于 2.4 的 Redis 只能每条命令 push 一个值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"world\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"world\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"LPOP(lpop)","copyright":true,"date":"2020-03-24T01:57:24.000Z","keywords":"Redis命令,lpop","aside":"list","_content":"## LPOP key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 移除并且返回 key 对应的 list 的第一个元素。\n\n#### 返回值\n\n**bulk-string-reply**: 返回第一个元素的值，或者当 key 不存在时返回 nil。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> LPOP mylist\n\"one\"\nredis> LRANGE mylist 0 -1\n1) \"two\"\n2) \"three\"\nredis> \n```\n\n","source":"_posts/redis_command/list/lpop.md","raw":"---\n\ntitle: LPOP(lpop)\ncopyright: true\ndate: 2020-03-24 09:57:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,lpop\naside: list\n\n---\n## LPOP key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 移除并且返回 key 对应的 list 的第一个元素。\n\n#### 返回值\n\n**bulk-string-reply**: 返回第一个元素的值，或者当 key 不存在时返回 nil。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> LPOP mylist\n\"one\"\nredis> LRANGE mylist 0 -1\n1) \"two\"\n2) \"three\"\nredis> \n```\n\n","slug":"redis_command/list/lpop","published":1,"updated":"2021-03-14T03:04:50.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpum002thyjfdwdb29ma","content":"<h2 id=\"LPOP-key\"><a href=\"#LPOP-key\" class=\"headerlink\" title=\"LPOP key\"></a>LPOP key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>移除并且返回 key 对应的 list 的第一个元素。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>: 返回第一个元素的值，或者当 key 不存在时返回 nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; LPOP mylist</span><br><span class=\"line\"><span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LPOP-key\"><a href=\"#LPOP-key\" class=\"headerlink\" title=\"LPOP key\"></a>LPOP key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>移除并且返回 key 对应的 list 的第一个元素。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>: 返回第一个元素的值，或者当 key 不存在时返回 nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; LPOP mylist</span><br><span class=\"line\"><span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"LPUSHX(lpushx)","copyright":true,"date":"2020-03-24T02:27:24.000Z","keywords":"Redis命令,lpushx","aside":"list","_content":"## LPUSHX key value \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 只有当 key 已经存在并且存着一个 list 的时候，在这个 key 下面的 list 的头部插入 value。 与 LPUSH 相反，当 key 不存在的时候不会进行任何操作。\n\n#### 返回值\n\n**integer-reply**: 在 push 操作后的 list 长度。\n\n\n#### 示例\n\n```c\nredis> LPUSH mylist \"World\"\n(integer) 1\nredis> LPUSHX mylist \"Hello\"\n(integer) 2\nredis> LPUSHX myotherlist \"Hello\"\n(integer) 0\nredis> LRANGE mylist 0 -1\n1) \"Hello\"\n2) \"World\"\nredis> LRANGE myotherlist 0 -1\n(empty list or set)\nredis> \n```","source":"_posts/redis_command/list/lpushx.md","raw":"---\n\ntitle: LPUSHX(lpushx)\ncopyright: true\ndate: 2020-03-24 10:27:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,lpushx\naside: list\n\n---\n## LPUSHX key value \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 只有当 key 已经存在并且存着一个 list 的时候，在这个 key 下面的 list 的头部插入 value。 与 LPUSH 相反，当 key 不存在的时候不会进行任何操作。\n\n#### 返回值\n\n**integer-reply**: 在 push 操作后的 list 长度。\n\n\n#### 示例\n\n```c\nredis> LPUSH mylist \"World\"\n(integer) 1\nredis> LPUSHX mylist \"Hello\"\n(integer) 2\nredis> LPUSHX myotherlist \"Hello\"\n(integer) 0\nredis> LRANGE mylist 0 -1\n1) \"Hello\"\n2) \"World\"\nredis> LRANGE myotherlist 0 -1\n(empty list or set)\nredis> \n```","slug":"redis_command/list/lpushx","published":1,"updated":"2021-03-14T03:04:50.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpun002whyjflb6ts5oh","content":"<h2 id=\"LPUSHX-key-value\"><a href=\"#LPUSHX-key-value\" class=\"headerlink\" title=\"LPUSHX key value\"></a>LPUSHX key value</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>只有当 key 已经存在并且存着一个 list 的时候，在这个 key 下面的 list 的头部插入 value。 与 LPUSH 相反，当 key 不存在的时候不会进行任何操作。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 在 push 操作后的 list 长度。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; LPUSHX mylist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LPUSHX myotherlist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\">redis&gt; LRANGE myotherlist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LPUSHX-key-value\"><a href=\"#LPUSHX-key-value\" class=\"headerlink\" title=\"LPUSHX key value\"></a>LPUSHX key value</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>只有当 key 已经存在并且存着一个 list 的时候，在这个 key 下面的 list 的头部插入 value。 与 LPUSH 相反，当 key 不存在的时候不会进行任何操作。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 在 push 操作后的 list 长度。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; LPUSH mylist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; LPUSHX mylist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LPUSHX myotherlist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\">redis&gt; LRANGE myotherlist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"LRANGE(lrange)","copyright":true,"date":"2020-03-24T02:26:24.000Z","keywords":"Redis命令,lrange","aside":"list","_content":"## LRANGE key start stop \n>起始版本：1.0.0<br/>时间复杂度：O(S+N) 其中S为小链表从头开始偏移的距离，大链表从最近的头或尾开始偏移的距离;N是指定范围内元素的个数。 \n\n\n#### 说明:\n* 返回存储在 key 的列表里指定范围内的元素。 start 和 end 偏移量都是基于0的下标，即list的第一个元素下标是0（list的表头），第二个元素下标是1，以此类推。\n* 偏移量也可以是负数，表示偏移量是从list尾部开始计数。 例如， -1 表示列表的最后一个元素，-2 是倒数第二个，以此类推。\n\n#### 注意\n\n* 当下标超过list范围的时候不会产生error。 如果start比list的尾部下标大的时候，会返回一个空列表。 如果stop比list的实际尾部大的时候，Redis会当它是最后一个元素的下标。\n\n#### 返回值\n\n**array-reply**: 指定范围里的列表元素。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> LRANGE mylist 0 0\n1) \"one\"\nredis> LRANGE mylist -3 2\n1) \"one\"\n2) \"two\"\n3) \"three\"\nredis> LRANGE mylist -100 100\n1) \"one\"\n2) \"two\"\n3) \"three\"\nredis> LRANGE mylist 5 10\n(empty list or set)\nredis> \n```","source":"_posts/redis_command/list/lrange.md","raw":"---\n\ntitle: LRANGE(lrange)\ncopyright: true\ndate: 2020-03-24 10:26:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,lrange\naside: list\n\n---\n## LRANGE key start stop \n>起始版本：1.0.0<br/>时间复杂度：O(S+N) 其中S为小链表从头开始偏移的距离，大链表从最近的头或尾开始偏移的距离;N是指定范围内元素的个数。 \n\n\n#### 说明:\n* 返回存储在 key 的列表里指定范围内的元素。 start 和 end 偏移量都是基于0的下标，即list的第一个元素下标是0（list的表头），第二个元素下标是1，以此类推。\n* 偏移量也可以是负数，表示偏移量是从list尾部开始计数。 例如， -1 表示列表的最后一个元素，-2 是倒数第二个，以此类推。\n\n#### 注意\n\n* 当下标超过list范围的时候不会产生error。 如果start比list的尾部下标大的时候，会返回一个空列表。 如果stop比list的实际尾部大的时候，Redis会当它是最后一个元素的下标。\n\n#### 返回值\n\n**array-reply**: 指定范围里的列表元素。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> LRANGE mylist 0 0\n1) \"one\"\nredis> LRANGE mylist -3 2\n1) \"one\"\n2) \"two\"\n3) \"three\"\nredis> LRANGE mylist -100 100\n1) \"one\"\n2) \"two\"\n3) \"three\"\nredis> LRANGE mylist 5 10\n(empty list or set)\nredis> \n```","slug":"redis_command/list/lrange","published":1,"updated":"2021-03-14T03:04:50.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpuo002yhyjf7g8573pb","content":"<h2 id=\"LRANGE-key-start-stop\"><a href=\"#LRANGE-key-start-stop\" class=\"headerlink\" title=\"LRANGE key start stop\"></a>LRANGE key start stop</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(S+N) 其中S为小链表从头开始偏移的距离，大链表从最近的头或尾开始偏移的距离;N是指定范围内元素的个数。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回存储在 key 的列表里指定范围内的元素。 start 和 end 偏移量都是基于0的下标，即list的第一个元素下标是0（list的表头），第二个元素下标是1，以此类推。</li>\n<li>偏移量也可以是负数，表示偏移量是从list尾部开始计数。 例如， -1 表示列表的最后一个元素，-2 是倒数第二个，以此类推。</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>当下标超过list范围的时候不会产生error。 如果start比list的尾部下标大的时候，会返回一个空列表。 如果stop比list的实际尾部大的时候，Redis会当它是最后一个元素的下标。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 指定范围里的列表元素。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">-3</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">-100</span> <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">5</span> <span class=\"number\">10</span></span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LRANGE-key-start-stop\"><a href=\"#LRANGE-key-start-stop\" class=\"headerlink\" title=\"LRANGE key start stop\"></a>LRANGE key start stop</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(S+N) 其中S为小链表从头开始偏移的距离，大链表从最近的头或尾开始偏移的距离;N是指定范围内元素的个数。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回存储在 key 的列表里指定范围内的元素。 start 和 end 偏移量都是基于0的下标，即list的第一个元素下标是0（list的表头），第二个元素下标是1，以此类推。</li>\n<li>偏移量也可以是负数，表示偏移量是从list尾部开始计数。 例如， -1 表示列表的最后一个元素，-2 是倒数第二个，以此类推。</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>当下标超过list范围的时候不会产生error。 如果start比list的尾部下标大的时候，会返回一个空列表。 如果stop比list的实际尾部大的时候，Redis会当它是最后一个元素的下标。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 指定范围里的列表元素。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">-3</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">-100</span> <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">5</span> <span class=\"number\">10</span></span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"LSET(lset)","copyright":true,"date":"2020-03-24T02:24:24.000Z","keywords":"Redis命令,lset","aside":"list","_content":"## LSET key index value \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是链表的长度。设置列表的第一个或最后一个元素为O(1)。\n\n\n#### 说明:\n* 设置 index 位置的list元素的值为 value。 更多关于 index 参数的信息，详见 LINDEX。\n* 当index超出范围时会返回一个error。\n\n#### 返回值\n\n\n**simple-string-reply**\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> LSET mylist 0 \"four\"\nOK\nredis> LSET mylist -2 \"five\"\nOK\nredis> LRANGE mylist 0 -1\n1) \"four\"\n2) \"five\"\n3) \"three\"\nredis> \n```","source":"_posts/redis_command/list/lset.md","raw":"---\n\ntitle: LSET(lset)\ncopyright: true\ndate: 2020-03-24 10:24:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,lset\naside: list\n\n---\n## LSET key index value \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是链表的长度。设置列表的第一个或最后一个元素为O(1)。\n\n\n#### 说明:\n* 设置 index 位置的list元素的值为 value。 更多关于 index 参数的信息，详见 LINDEX。\n* 当index超出范围时会返回一个error。\n\n#### 返回值\n\n\n**simple-string-reply**\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> LSET mylist 0 \"four\"\nOK\nredis> LSET mylist -2 \"five\"\nOK\nredis> LRANGE mylist 0 -1\n1) \"four\"\n2) \"five\"\n3) \"three\"\nredis> \n```","slug":"redis_command/list/lset","published":1,"updated":"2021-03-14T03:04:50.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpuo0031hyjf1rodj2fm","content":"<h2 id=\"LSET-key-index-value\"><a href=\"#LSET-key-index-value\" class=\"headerlink\" title=\"LSET key index value\"></a>LSET key index value</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是链表的长度。设置列表的第一个或最后一个元素为O(1)。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>设置 index 位置的list元素的值为 value。 更多关于 index 参数的信息，详见 LINDEX。</li>\n<li>当index超出范围时会返回一个error。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong></p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; LSET mylist <span class=\"number\">0</span> <span class=\"string\">\"four\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; LSET mylist <span class=\"number\">-2</span> <span class=\"string\">\"five\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"four\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"five\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LSET-key-index-value\"><a href=\"#LSET-key-index-value\" class=\"headerlink\" title=\"LSET key index value\"></a>LSET key index value</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是链表的长度。设置列表的第一个或最后一个元素为O(1)。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>设置 index 位置的list元素的值为 value。 更多关于 index 参数的信息，详见 LINDEX。</li>\n<li>当index超出范围时会返回一个error。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong></p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; LSET mylist <span class=\"number\">0</span> <span class=\"string\">\"four\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; LSET mylist <span class=\"number\">-2</span> <span class=\"string\">\"five\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"four\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"five\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"LTRIM(ltrim)","copyright":true,"date":"2020-03-24T02:23:24.000Z","keywords":"Redis命令,ltrim","aside":"list","_content":"## LTRIM key start stop \n>起始版本：1.0.0<br/>时间复杂度：O(N) N为操作要删除的元素数。 \n\n\n#### 说明:\n* Trim一个已存在的 list(有点像substring)，这样 list 就会只包含指定范围的指定元素。start 和 stop 都是由0开始计数的， 这里的 0 是列表里的第一个元素（表头），1 是第二个元素，以此类推。\n\n  例如： `LTRIM foobar 0 2` 将会对存储在 foobar 的列表进行修剪，只保留列表里的前3个元素。\n\n  start 和 end 也可以用负数来表示与表尾的偏移量，比如 -1 表示列表里的最后一个元素， -2 表示倒数第二个，等等。\n\n  超过范围的下标并不会产生错误：如果 start 超过列表尾部，或者 start > end，结果会是列表变成空表（即该 key 会被移除）。 如果 end 超过列表尾部，Redis 会将其当作列表的最后一个元素。\n\n  `LTRIM` 的一个常见用法是和 LPUSH / RPUSH一起使用。 例如：\n\n  - LPUSH mylist someelement\n  - LTRIM mylist 0 99\n\n  这一对命令会将一个新的元素 push 进列表里，并保证该列表不会增长到超过100个元素。这个是很有用的，比如当用 Redis 来存储日志。 需要特别注意的是，当用这种方式来使用 LTRIM 的时候，操作的复杂度是 O(1) ， 因为平均情况下，每次只有一个元素会被移除。\n\n#### 返回值\n\n**simple-string-reply**\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> LTRIM mylist 1 -1\nOK\nredis> LRANGE mylist 0 -1\n1) \"two\"\n2) \"three\"\nredis> \n```","source":"_posts/redis_command/list/ltrim.md","raw":"---\n\ntitle: LTRIM(ltrim)\ncopyright: true\ndate: 2020-03-24 10:23:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,ltrim\naside: list\n\n---\n## LTRIM key start stop \n>起始版本：1.0.0<br/>时间复杂度：O(N) N为操作要删除的元素数。 \n\n\n#### 说明:\n* Trim一个已存在的 list(有点像substring)，这样 list 就会只包含指定范围的指定元素。start 和 stop 都是由0开始计数的， 这里的 0 是列表里的第一个元素（表头），1 是第二个元素，以此类推。\n\n  例如： `LTRIM foobar 0 2` 将会对存储在 foobar 的列表进行修剪，只保留列表里的前3个元素。\n\n  start 和 end 也可以用负数来表示与表尾的偏移量，比如 -1 表示列表里的最后一个元素， -2 表示倒数第二个，等等。\n\n  超过范围的下标并不会产生错误：如果 start 超过列表尾部，或者 start > end，结果会是列表变成空表（即该 key 会被移除）。 如果 end 超过列表尾部，Redis 会将其当作列表的最后一个元素。\n\n  `LTRIM` 的一个常见用法是和 LPUSH / RPUSH一起使用。 例如：\n\n  - LPUSH mylist someelement\n  - LTRIM mylist 0 99\n\n  这一对命令会将一个新的元素 push 进列表里，并保证该列表不会增长到超过100个元素。这个是很有用的，比如当用 Redis 来存储日志。 需要特别注意的是，当用这种方式来使用 LTRIM 的时候，操作的复杂度是 O(1) ， 因为平均情况下，每次只有一个元素会被移除。\n\n#### 返回值\n\n**simple-string-reply**\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> LTRIM mylist 1 -1\nOK\nredis> LRANGE mylist 0 -1\n1) \"two\"\n2) \"three\"\nredis> \n```","slug":"redis_command/list/ltrim","published":1,"updated":"2021-03-14T03:04:50.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpup0033hyjf4oq8y9el","content":"<h2 id=\"LTRIM-key-start-stop\"><a href=\"#LTRIM-key-start-stop\" class=\"headerlink\" title=\"LTRIM key start stop\"></a>LTRIM key start stop</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N为操作要删除的元素数。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>Trim一个已存在的 list(有点像substring)，这样 list 就会只包含指定范围的指定元素。start 和 stop 都是由0开始计数的， 这里的 0 是列表里的第一个元素（表头），1 是第二个元素，以此类推。</p>\n<p>例如： <code>LTRIM foobar 0 2</code> 将会对存储在 foobar 的列表进行修剪，只保留列表里的前3个元素。</p>\n<p>start 和 end 也可以用负数来表示与表尾的偏移量，比如 -1 表示列表里的最后一个元素， -2 表示倒数第二个，等等。</p>\n<p>超过范围的下标并不会产生错误：如果 start 超过列表尾部，或者 start &gt; end，结果会是列表变成空表（即该 key 会被移除）。 如果 end 超过列表尾部，Redis 会将其当作列表的最后一个元素。</p>\n<p><code>LTRIM</code> 的一个常见用法是和 LPUSH / RPUSH一起使用。 例如：</p>\n<ul>\n<li>LPUSH mylist someelement</li>\n<li>LTRIM mylist 0 99</li>\n</ul>\n<p>这一对命令会将一个新的元素 push 进列表里，并保证该列表不会增长到超过100个元素。这个是很有用的，比如当用 Redis 来存储日志。 需要特别注意的是，当用这种方式来使用 LTRIM 的时候，操作的复杂度是 O(1) ， 因为平均情况下，每次只有一个元素会被移除。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong></p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; LTRIM mylist <span class=\"number\">1</span> <span class=\"number\">-1</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LTRIM-key-start-stop\"><a href=\"#LTRIM-key-start-stop\" class=\"headerlink\" title=\"LTRIM key start stop\"></a>LTRIM key start stop</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N为操作要删除的元素数。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>Trim一个已存在的 list(有点像substring)，这样 list 就会只包含指定范围的指定元素。start 和 stop 都是由0开始计数的， 这里的 0 是列表里的第一个元素（表头），1 是第二个元素，以此类推。</p>\n<p>例如： <code>LTRIM foobar 0 2</code> 将会对存储在 foobar 的列表进行修剪，只保留列表里的前3个元素。</p>\n<p>start 和 end 也可以用负数来表示与表尾的偏移量，比如 -1 表示列表里的最后一个元素， -2 表示倒数第二个，等等。</p>\n<p>超过范围的下标并不会产生错误：如果 start 超过列表尾部，或者 start &gt; end，结果会是列表变成空表（即该 key 会被移除）。 如果 end 超过列表尾部，Redis 会将其当作列表的最后一个元素。</p>\n<p><code>LTRIM</code> 的一个常见用法是和 LPUSH / RPUSH一起使用。 例如：</p>\n<ul>\n<li>LPUSH mylist someelement</li>\n<li>LTRIM mylist 0 99</li>\n</ul>\n<p>这一对命令会将一个新的元素 push 进列表里，并保证该列表不会增长到超过100个元素。这个是很有用的，比如当用 Redis 来存储日志。 需要特别注意的是，当用这种方式来使用 LTRIM 的时候，操作的复杂度是 O(1) ， 因为平均情况下，每次只有一个元素会被移除。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong></p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; LTRIM mylist <span class=\"number\">1</span> <span class=\"number\">-1</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"LREM(lrem)","copyright":true,"date":"2020-03-24T02:25:24.000Z","keywords":"Redis命令,lrem","aside":"list","_content":"## LREM key count value \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是链表的长度 \n\n\n#### 说明:\n* 从存于 key 的列表里移除前 count 次出现的值为 value 的元素。 这个 count 参数通过下面几种方式影响这个操作：\n\n  - count > 0: 从头往尾移除值为 value 的元素。\n  - count < 0: 从尾往头移除值为 value 的元素。\n  - count = 0: 移除所有值为 value 的元素。\n\n  比如， LREM list -2 “hello” 会从存于 list 的列表里移除最后两个出现的 “hello”。\n\n  需要注意的是，如果list里没有存在key就会被当作空list处理，所以当 key 不存在的时候，这个命令会返回 0。\n\n#### 返回值\n\n\n**integer-reply**: 被移除的元素个数。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"hello\"\n(integer) 1\nredis> RPUSH mylist \"hello\"\n(integer) 2\nredis> RPUSH mylist \"foo\"\n(integer) 3\nredis> RPUSH mylist \"hello\"\n(integer) 4\nredis> LREM mylist -2 \"hello\"\n(integer) 2\nredis> LRANGE mylist 0 -1\n1) \"hello\"\n2) \"foo\"\nredis> \n```","source":"_posts/redis_command/list/lrem.md","raw":"---\n\ntitle: LREM(lrem)\ncopyright: true\ndate: 2020-03-24 10:25:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,lrem\naside: list\n\n---\n## LREM key count value \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是链表的长度 \n\n\n#### 说明:\n* 从存于 key 的列表里移除前 count 次出现的值为 value 的元素。 这个 count 参数通过下面几种方式影响这个操作：\n\n  - count > 0: 从头往尾移除值为 value 的元素。\n  - count < 0: 从尾往头移除值为 value 的元素。\n  - count = 0: 移除所有值为 value 的元素。\n\n  比如， LREM list -2 “hello” 会从存于 list 的列表里移除最后两个出现的 “hello”。\n\n  需要注意的是，如果list里没有存在key就会被当作空list处理，所以当 key 不存在的时候，这个命令会返回 0。\n\n#### 返回值\n\n\n**integer-reply**: 被移除的元素个数。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"hello\"\n(integer) 1\nredis> RPUSH mylist \"hello\"\n(integer) 2\nredis> RPUSH mylist \"foo\"\n(integer) 3\nredis> RPUSH mylist \"hello\"\n(integer) 4\nredis> LREM mylist -2 \"hello\"\n(integer) 2\nredis> LRANGE mylist 0 -1\n1) \"hello\"\n2) \"foo\"\nredis> \n```","slug":"redis_command/list/lrem","published":1,"updated":"2021-03-14T03:04:50.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpuq0036hyjfj0ajxud8","content":"<h2 id=\"LREM-key-count-value\"><a href=\"#LREM-key-count-value\" class=\"headerlink\" title=\"LREM key count value\"></a>LREM key count value</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是链表的长度 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>从存于 key 的列表里移除前 count 次出现的值为 value 的元素。 这个 count 参数通过下面几种方式影响这个操作：</p>\n<ul>\n<li>count &gt; 0: 从头往尾移除值为 value 的元素。</li>\n<li>count &lt; 0: 从尾往头移除值为 value 的元素。</li>\n<li>count = 0: 移除所有值为 value 的元素。</li>\n</ul>\n<p>比如， LREM list -2 “hello” 会从存于 list 的列表里移除最后两个出现的 “hello”。</p>\n<p>需要注意的是，如果list里没有存在key就会被当作空list处理，所以当 key 不存在的时候，这个命令会返回 0。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 被移除的元素个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"foo\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">4</span></span><br><span class=\"line\">redis&gt; LREM mylist <span class=\"number\">-2</span> <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"foo\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"LREM-key-count-value\"><a href=\"#LREM-key-count-value\" class=\"headerlink\" title=\"LREM key count value\"></a>LREM key count value</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是链表的长度 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>从存于 key 的列表里移除前 count 次出现的值为 value 的元素。 这个 count 参数通过下面几种方式影响这个操作：</p>\n<ul>\n<li>count &gt; 0: 从头往尾移除值为 value 的元素。</li>\n<li>count &lt; 0: 从尾往头移除值为 value 的元素。</li>\n<li>count = 0: 移除所有值为 value 的元素。</li>\n</ul>\n<p>比如， LREM list -2 “hello” 会从存于 list 的列表里移除最后两个出现的 “hello”。</p>\n<p>需要注意的是，如果list里没有存在key就会被当作空list处理，所以当 key 不存在的时候，这个命令会返回 0。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 被移除的元素个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"foo\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">4</span></span><br><span class=\"line\">redis&gt; LREM mylist <span class=\"number\">-2</span> <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"foo\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"RPOP(rpop)","copyright":true,"date":"2020-03-24T02:22:24.000Z","keywords":"Redis命令,rpop","aside":"list","_content":"## RPOP key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 移除并返回存于 key 的 list 的最后一个元素。\n\n#### 返回值\n\n**bulk-string-reply**: 最后一个元素的值，或者当 key 不存在的时候返回 nil。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> RPOP mylist\n\"three\"\nredis> LRANGE mylist 0 -1\n1) \"one\"\n2) \"two\"\nredis> \n```","source":"_posts/redis_command/list/rpop.md","raw":"---\n\ntitle: RPOP(rpop)\ncopyright: true\ndate: 2020-03-24 10:22:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,rpop\naside: list\n\n---\n## RPOP key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 移除并返回存于 key 的 list 的最后一个元素。\n\n#### 返回值\n\n**bulk-string-reply**: 最后一个元素的值，或者当 key 不存在的时候返回 nil。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> RPOP mylist\n\"three\"\nredis> LRANGE mylist 0 -1\n1) \"one\"\n2) \"two\"\nredis> \n```","slug":"redis_command/list/rpop","published":1,"updated":"2021-03-14T03:04:50.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpur0038hyjf1ysr67em","content":"<h2 id=\"RPOP-key\"><a href=\"#RPOP-key\" class=\"headerlink\" title=\"RPOP key\"></a>RPOP key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>移除并返回存于 key 的 list 的最后一个元素。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>: 最后一个元素的值，或者当 key 不存在的时候返回 nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; RPOP mylist</span><br><span class=\"line\"><span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"RPOP-key\"><a href=\"#RPOP-key\" class=\"headerlink\" title=\"RPOP key\"></a>RPOP key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>移除并返回存于 key 的 list 的最后一个元素。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>: 最后一个元素的值，或者当 key 不存在的时候返回 nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; RPOP mylist</span><br><span class=\"line\"><span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"RPOPLPUSH(rpoplpush)","copyright":true,"date":"2020-03-24T02:21:24.000Z","keywords":"Redis命令,rpoplpush","aside":"list","_content":"## RPOPLPUSH source destination \n>起始版本：1.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 原子性地返回并移除存储在 source 的列表的最后一个元素（列表尾部元素）， 并把该元素放入存储在 destination 的列表的第一个元素位置（列表头部）。\n\n  例如：假设 source 存储着列表 a,b,c， destination存储着列表 x,y,z。 执行 RPOPLPUSH 得到的结果是 source 保存着列表 a,b ，而 destination 保存着列表 c,x,y,z。\n\n  如果 source 不存在，那么会返回 nil 值，并且不会执行任何操作。 如果 source 和 destination 是同样的，那么这个操作等同于移除列表最后一个元素并且把该元素放在列表头部， 所以这个命令也可以当作是一个旋转列表的命令。\n\n#### 返回值\n\n**bulk-string-reply**: 被移除和放入的元素\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> RPOPLPUSH mylist myotherlist\n\"three\"\nredis> LRANGE mylist 0 -1\n1) \"one\"\n2) \"two\"\nredis> LRANGE myotherlist 0 -1\n1) \"three\"\nredis> \n```\n\n#### 使用场景\n\n1. 消息队列中的备份队列(类似于RabbitMQ中的备份交换机的功能)\n\n   Redis列表通常会被用作消息队列:生产者把消息放入一个列表中，等待消息的消费者用 [RPOP](http://www.redis.cn/commands/rpop.html) 命令（用轮询方式）或者用 BRPOP 命令（如果客户端使用阻塞操作会更好）来得到这个消息。因为消息有可能会丢失，所以这种队列并是不安全的。例如，当接收到消息后，出现了网络问题或者消费者端崩溃了， 那么这个消息就丢失了。\n\n   RPOPLPUSH (或者其阻塞版本的BRPOPLPUSH） 可以避免这个问题：消费者端取到消息的同时把该消息放入一个正在处理中的列表。 当消息被处理了之后，可以使用 LREM 命令来移除正在处理中列表中的对应消息。也可以添加一个客户端来监控这个正在处理中列表，如果有某些消息已经在这个列表中存在很长时间了（即超过一定的处理时限）， 那么这个客户端会把这些超时消息重新加入到队列中。\n\n2. 循环列表\n\n   RPOPLPUSH 命令的 source 和 destination 是相同的话， 那么客户端在访问一个拥有n个元素的列表时，可以在 O(N) 时间里一个接一个获取列表元素， 而不用像 LRANGE那样需要把整个列表从服务器端传送到客户端。\n\n   这个模式让我们可以很容易地实现这样一个系统：有 N 个客户端，需要连续不断地对一批元素进行处理，而且处理的过程必须尽可能地快。 一个典型的例子就是服务器上的监控程序：它们需要在尽可能短的时间内，并行地检查一批网站，确保它们的可访问性。\n\n   值得注意的是，使用这个模式的客户端是易于扩展（scalable）且安全的（reliable），因为即使客户端把接收到的消息丢失了， 这个消息依然存在于队列中，等下次迭代到它的时候，可以由其他客户端进行处理。","source":"_posts/redis_command/list/rpoplpush.md","raw":"---\n\ntitle: RPOPLPUSH(rpoplpush)\ncopyright: true\ndate: 2020-03-24 10:21:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,rpoplpush\naside: list\n\n---\n## RPOPLPUSH source destination \n>起始版本：1.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 原子性地返回并移除存储在 source 的列表的最后一个元素（列表尾部元素）， 并把该元素放入存储在 destination 的列表的第一个元素位置（列表头部）。\n\n  例如：假设 source 存储着列表 a,b,c， destination存储着列表 x,y,z。 执行 RPOPLPUSH 得到的结果是 source 保存着列表 a,b ，而 destination 保存着列表 c,x,y,z。\n\n  如果 source 不存在，那么会返回 nil 值，并且不会执行任何操作。 如果 source 和 destination 是同样的，那么这个操作等同于移除列表最后一个元素并且把该元素放在列表头部， 所以这个命令也可以当作是一个旋转列表的命令。\n\n#### 返回值\n\n**bulk-string-reply**: 被移除和放入的元素\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"one\"\n(integer) 1\nredis> RPUSH mylist \"two\"\n(integer) 2\nredis> RPUSH mylist \"three\"\n(integer) 3\nredis> RPOPLPUSH mylist myotherlist\n\"three\"\nredis> LRANGE mylist 0 -1\n1) \"one\"\n2) \"two\"\nredis> LRANGE myotherlist 0 -1\n1) \"three\"\nredis> \n```\n\n#### 使用场景\n\n1. 消息队列中的备份队列(类似于RabbitMQ中的备份交换机的功能)\n\n   Redis列表通常会被用作消息队列:生产者把消息放入一个列表中，等待消息的消费者用 [RPOP](http://www.redis.cn/commands/rpop.html) 命令（用轮询方式）或者用 BRPOP 命令（如果客户端使用阻塞操作会更好）来得到这个消息。因为消息有可能会丢失，所以这种队列并是不安全的。例如，当接收到消息后，出现了网络问题或者消费者端崩溃了， 那么这个消息就丢失了。\n\n   RPOPLPUSH (或者其阻塞版本的BRPOPLPUSH） 可以避免这个问题：消费者端取到消息的同时把该消息放入一个正在处理中的列表。 当消息被处理了之后，可以使用 LREM 命令来移除正在处理中列表中的对应消息。也可以添加一个客户端来监控这个正在处理中列表，如果有某些消息已经在这个列表中存在很长时间了（即超过一定的处理时限）， 那么这个客户端会把这些超时消息重新加入到队列中。\n\n2. 循环列表\n\n   RPOPLPUSH 命令的 source 和 destination 是相同的话， 那么客户端在访问一个拥有n个元素的列表时，可以在 O(N) 时间里一个接一个获取列表元素， 而不用像 LRANGE那样需要把整个列表从服务器端传送到客户端。\n\n   这个模式让我们可以很容易地实现这样一个系统：有 N 个客户端，需要连续不断地对一批元素进行处理，而且处理的过程必须尽可能地快。 一个典型的例子就是服务器上的监控程序：它们需要在尽可能短的时间内，并行地检查一批网站，确保它们的可访问性。\n\n   值得注意的是，使用这个模式的客户端是易于扩展（scalable）且安全的（reliable），因为即使客户端把接收到的消息丢失了， 这个消息依然存在于队列中，等下次迭代到它的时候，可以由其他客户端进行处理。","slug":"redis_command/list/rpoplpush","published":1,"updated":"2021-03-14T03:04:50.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfput003bhyjf12stp5n6","content":"<h2 id=\"RPOPLPUSH-source-destination\"><a href=\"#RPOPLPUSH-source-destination\" class=\"headerlink\" title=\"RPOPLPUSH source destination\"></a>RPOPLPUSH source destination</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>原子性地返回并移除存储在 source 的列表的最后一个元素（列表尾部元素）， 并把该元素放入存储在 destination 的列表的第一个元素位置（列表头部）。</p>\n<p>例如：假设 source 存储着列表 a,b,c， destination存储着列表 x,y,z。 执行 RPOPLPUSH 得到的结果是 source 保存着列表 a,b ，而 destination 保存着列表 c,x,y,z。</p>\n<p>如果 source 不存在，那么会返回 nil 值，并且不会执行任何操作。 如果 source 和 destination 是同样的，那么这个操作等同于移除列表最后一个元素并且把该元素放在列表头部， 所以这个命令也可以当作是一个旋转列表的命令。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>: 被移除和放入的元素</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; RPOPLPUSH mylist myotherlist</span><br><span class=\"line\"><span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt; LRANGE myotherlist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ol>\n<li><p>消息队列中的备份队列(类似于RabbitMQ中的备份交换机的功能)</p>\n<p>Redis列表通常会被用作消息队列:生产者把消息放入一个列表中，等待消息的消费者用 <a href=\"http://www.redis.cn/commands/rpop.html\" target=\"_blank\" rel=\"noopener\">RPOP</a> 命令（用轮询方式）或者用 BRPOP 命令（如果客户端使用阻塞操作会更好）来得到这个消息。因为消息有可能会丢失，所以这种队列并是不安全的。例如，当接收到消息后，出现了网络问题或者消费者端崩溃了， 那么这个消息就丢失了。</p>\n<p>RPOPLPUSH (或者其阻塞版本的BRPOPLPUSH） 可以避免这个问题：消费者端取到消息的同时把该消息放入一个正在处理中的列表。 当消息被处理了之后，可以使用 LREM 命令来移除正在处理中列表中的对应消息。也可以添加一个客户端来监控这个正在处理中列表，如果有某些消息已经在这个列表中存在很长时间了（即超过一定的处理时限）， 那么这个客户端会把这些超时消息重新加入到队列中。</p>\n</li>\n<li><p>循环列表</p>\n<p>RPOPLPUSH 命令的 source 和 destination 是相同的话， 那么客户端在访问一个拥有n个元素的列表时，可以在 O(N) 时间里一个接一个获取列表元素， 而不用像 LRANGE那样需要把整个列表从服务器端传送到客户端。</p>\n<p>这个模式让我们可以很容易地实现这样一个系统：有 N 个客户端，需要连续不断地对一批元素进行处理，而且处理的过程必须尽可能地快。 一个典型的例子就是服务器上的监控程序：它们需要在尽可能短的时间内，并行地检查一批网站，确保它们的可访问性。</p>\n<p>值得注意的是，使用这个模式的客户端是易于扩展（scalable）且安全的（reliable），因为即使客户端把接收到的消息丢失了， 这个消息依然存在于队列中，等下次迭代到它的时候，可以由其他客户端进行处理。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"RPOPLPUSH-source-destination\"><a href=\"#RPOPLPUSH-source-destination\" class=\"headerlink\" title=\"RPOPLPUSH source destination\"></a>RPOPLPUSH source destination</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>原子性地返回并移除存储在 source 的列表的最后一个元素（列表尾部元素）， 并把该元素放入存储在 destination 的列表的第一个元素位置（列表头部）。</p>\n<p>例如：假设 source 存储着列表 a,b,c， destination存储着列表 x,y,z。 执行 RPOPLPUSH 得到的结果是 source 保存着列表 a,b ，而 destination 保存着列表 c,x,y,z。</p>\n<p>如果 source 不存在，那么会返回 nil 值，并且不会执行任何操作。 如果 source 和 destination 是同样的，那么这个操作等同于移除列表最后一个元素并且把该元素放在列表头部， 所以这个命令也可以当作是一个旋转列表的命令。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>: 被移除和放入的元素</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; RPOPLPUSH mylist myotherlist</span><br><span class=\"line\"><span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt; LRANGE myotherlist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ol>\n<li><p>消息队列中的备份队列(类似于RabbitMQ中的备份交换机的功能)</p>\n<p>Redis列表通常会被用作消息队列:生产者把消息放入一个列表中，等待消息的消费者用 <a href=\"http://www.redis.cn/commands/rpop.html\" target=\"_blank\" rel=\"noopener\">RPOP</a> 命令（用轮询方式）或者用 BRPOP 命令（如果客户端使用阻塞操作会更好）来得到这个消息。因为消息有可能会丢失，所以这种队列并是不安全的。例如，当接收到消息后，出现了网络问题或者消费者端崩溃了， 那么这个消息就丢失了。</p>\n<p>RPOPLPUSH (或者其阻塞版本的BRPOPLPUSH） 可以避免这个问题：消费者端取到消息的同时把该消息放入一个正在处理中的列表。 当消息被处理了之后，可以使用 LREM 命令来移除正在处理中列表中的对应消息。也可以添加一个客户端来监控这个正在处理中列表，如果有某些消息已经在这个列表中存在很长时间了（即超过一定的处理时限）， 那么这个客户端会把这些超时消息重新加入到队列中。</p>\n</li>\n<li><p>循环列表</p>\n<p>RPOPLPUSH 命令的 source 和 destination 是相同的话， 那么客户端在访问一个拥有n个元素的列表时，可以在 O(N) 时间里一个接一个获取列表元素， 而不用像 LRANGE那样需要把整个列表从服务器端传送到客户端。</p>\n<p>这个模式让我们可以很容易地实现这样一个系统：有 N 个客户端，需要连续不断地对一批元素进行处理，而且处理的过程必须尽可能地快。 一个典型的例子就是服务器上的监控程序：它们需要在尽可能短的时间内，并行地检查一批网站，确保它们的可访问性。</p>\n<p>值得注意的是，使用这个模式的客户端是易于扩展（scalable）且安全的（reliable），因为即使客户端把接收到的消息丢失了， 这个消息依然存在于队列中，等下次迭代到它的时候，可以由其他客户端进行处理。</p>\n</li>\n</ol>\n"},{"title":"RPUSH(rpush)","copyright":true,"date":"2020-03-24T02:20:24.000Z","keywords":"Redis命令,rpush","aside":"list","_content":"## RPUSH key value [value ...] \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 向存于 key 的列表的尾部插入所有指定的值。如果 key 不存在，那么会创建一个空的列表然后再进行 push 操作。 当 key 保存的不是一个列表，那么会返回一个错误。\n* 可以使用一个命令把多个元素打入队列，只需要在命令后面指定多个参数。元素是从左到右一个接一个从列表尾部插入。 比如命令 RPUSH mylist a b c 会返回一个列表，其第一个元素是 a ，第二个元素是 b ，第三个元素是 c。\n\n#### 返回值\n\n**integer-reply**: 在 push 操作后的列表长度。\n\n\n#### 历史\n\n\n2.4版本以上（包括2.4）: 接受多个 value 参数。 在小于 2.4 的 Redis 版本中，一条命令只能 push 单一个值。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"hello\"\n(integer) 1\nredis> RPUSH mylist \"world\"\n(integer) 2\nredis> LRANGE mylist 0 -1\n1) \"hello\"\n2) \"world\"\nredis> \n```","source":"_posts/redis_command/list/rpush.md","raw":"---\n\ntitle: RPUSH(rpush)\ncopyright: true\ndate: 2020-03-24 10:20:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,rpush\naside: list\n\n---\n## RPUSH key value [value ...] \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 向存于 key 的列表的尾部插入所有指定的值。如果 key 不存在，那么会创建一个空的列表然后再进行 push 操作。 当 key 保存的不是一个列表，那么会返回一个错误。\n* 可以使用一个命令把多个元素打入队列，只需要在命令后面指定多个参数。元素是从左到右一个接一个从列表尾部插入。 比如命令 RPUSH mylist a b c 会返回一个列表，其第一个元素是 a ，第二个元素是 b ，第三个元素是 c。\n\n#### 返回值\n\n**integer-reply**: 在 push 操作后的列表长度。\n\n\n#### 历史\n\n\n2.4版本以上（包括2.4）: 接受多个 value 参数。 在小于 2.4 的 Redis 版本中，一条命令只能 push 单一个值。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"hello\"\n(integer) 1\nredis> RPUSH mylist \"world\"\n(integer) 2\nredis> LRANGE mylist 0 -1\n1) \"hello\"\n2) \"world\"\nredis> \n```","slug":"redis_command/list/rpush","published":1,"updated":"2021-03-14T03:04:50.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpuu003dhyjfng89q1zt","content":"<h2 id=\"RPUSH-key-value-value-…\"><a href=\"#RPUSH-key-value-value-…\" class=\"headerlink\" title=\"RPUSH key value [value …]\"></a>RPUSH key value [value …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>向存于 key 的列表的尾部插入所有指定的值。如果 key 不存在，那么会创建一个空的列表然后再进行 push 操作。 当 key 保存的不是一个列表，那么会返回一个错误。</li>\n<li>可以使用一个命令把多个元素打入队列，只需要在命令后面指定多个参数。元素是从左到右一个接一个从列表尾部插入。 比如命令 RPUSH mylist a b c 会返回一个列表，其第一个元素是 a ，第二个元素是 b ，第三个元素是 c。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 在 push 操作后的列表长度。</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>2.4版本以上（包括2.4）: 接受多个 value 参数。 在小于 2.4 的 Redis 版本中，一条命令只能 push 单一个值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"world\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"world\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"RPUSH-key-value-value-…\"><a href=\"#RPUSH-key-value-value-…\" class=\"headerlink\" title=\"RPUSH key value [value …]\"></a>RPUSH key value [value …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>向存于 key 的列表的尾部插入所有指定的值。如果 key 不存在，那么会创建一个空的列表然后再进行 push 操作。 当 key 保存的不是一个列表，那么会返回一个错误。</li>\n<li>可以使用一个命令把多个元素打入队列，只需要在命令后面指定多个参数。元素是从左到右一个接一个从列表尾部插入。 比如命令 RPUSH mylist a b c 会返回一个列表，其第一个元素是 a ，第二个元素是 b ，第三个元素是 c。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 在 push 操作后的列表长度。</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>2.4版本以上（包括2.4）: 接受多个 value 参数。 在小于 2.4 的 Redis 版本中，一条命令只能 push 单一个值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"world\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"world\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"RPUSHX(rpushx)","copyright":true,"date":"2020-03-24T02:19:24.000Z","keywords":"Redis命令,rpushx","aside":"list","_content":"## RPUSHX key value \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将值 value 插入到列表 key 的表尾, 当且仅当 key 存在并且是一个列表。 和 RPUSH 命令相反, 当 key 不存在时，RPUSHX 命令什么也不做。\n\n#### 返回值\n\n**integer-reply**: RPUSHX 命令执行之后，表的长度。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"Hello\"\n(integer) 1\nredis> RPUSHX mylist \"World\"\n(integer) 2\nredis> RPUSHX myotherlist \"World\"\n(integer) 0\nredis> LRANGE mylist 0 -1\n1) \"Hello\"\n2) \"World\"\nredis> LRANGE myotherlist 0 -1\n(empty list or set)\nredis> \n```","source":"_posts/redis_command/list/rpushx.md","raw":"---\n\ntitle: RPUSHX(rpushx)\ncopyright: true\ndate: 2020-03-24 10:19:24\ncategories: \n- Redis命令大全\n- List\nkeywords: Redis命令,rpushx\naside: list\n\n---\n## RPUSHX key value \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将值 value 插入到列表 key 的表尾, 当且仅当 key 存在并且是一个列表。 和 RPUSH 命令相反, 当 key 不存在时，RPUSHX 命令什么也不做。\n\n#### 返回值\n\n**integer-reply**: RPUSHX 命令执行之后，表的长度。\n\n\n#### 示例\n\n```c\nredis> RPUSH mylist \"Hello\"\n(integer) 1\nredis> RPUSHX mylist \"World\"\n(integer) 2\nredis> RPUSHX myotherlist \"World\"\n(integer) 0\nredis> LRANGE mylist 0 -1\n1) \"Hello\"\n2) \"World\"\nredis> LRANGE myotherlist 0 -1\n(empty list or set)\nredis> \n```","slug":"redis_command/list/rpushx","published":1,"updated":"2021-03-14T03:04:50.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpuw003ghyjflz9r4nat","content":"<h2 id=\"RPUSHX-key-value\"><a href=\"#RPUSHX-key-value\" class=\"headerlink\" title=\"RPUSHX key value\"></a>RPUSHX key value</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将值 value 插入到列表 key 的表尾, 当且仅当 key 存在并且是一个列表。 和 RPUSH 命令相反, 当 key 不存在时，RPUSHX 命令什么也不做。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: RPUSHX 命令执行之后，表的长度。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSHX mylist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSHX myotherlist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\">redis&gt; LRANGE myotherlist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"RPUSHX-key-value\"><a href=\"#RPUSHX-key-value\" class=\"headerlink\" title=\"RPUSHX key value\"></a>RPUSHX key value</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将值 value 插入到列表 key 的表尾, 当且仅当 key 存在并且是一个列表。 和 RPUSH 命令相反, 当 key 不存在时，RPUSHX 命令什么也不做。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: RPUSHX 命令执行之后，表的长度。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; RPUSH mylist <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; RPUSHX mylist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; RPUSHX myotherlist <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; LRANGE mylist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\">redis&gt; LRANGE myotherlist <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"BZPOPMAX(bzpopmax)","copyright":true,"date":"2020-03-31T05:40:31.000Z","keywords":"Redis命令,bzpopmax","aside":"sorted_set","_content":"# BZPOPMAX key [key ...] timeout\n\n>**起始版本：5.0.0**\n>\n>**时间复杂度：**O(log(N)) N是已排序集合中元素的个数。\n\n\n#### 说明:\n* `BZPOPMAX` 是有序集合命令 `ZPOPMAX`带有阻塞功能的版本。\n* 在参数中的所有有序集合均为空的情况下，阻塞连接。参数中包含多个有序集合时，按照参数中key的顺序，返回第一个非空key中分数最大的成员和对应的分数\n* 参数 `timeout` 可以理解为客户端被阻塞的最大秒数值，0 表示永久阻塞。\n* `BZPOPMAX`返回非空有序集合 key中分数最大的成员，而`BZPOPMIN`返回该key中分数最小的成员，除此之外，两条命令无其他差别。\n\n#### 返回值\n\n**array-reply**:当有序集合无结果返回且超时设置过期时返回 `nil`\n\n返回三元素multi-bulk结果，第一元素key名称，第二元素成员名称，第三元素分数\n\n\n#### 示例\n\n```c\nredis> DEL zset1 zset2\n(integer) 0\nredis> ZADD zset1 0 a 1 b 2 c\n(integer) 3\nredis> BZPOPMAX zset1 zset2 0\n1) \"zet1\"\n2) \"2\"\n2) \"c\"\n```","source":"_posts/redis_command/sorted_set/bzpopmax.md","raw":"---\n\ntitle: BZPOPMAX(bzpopmax)\ncopyright: true\ndate: 2020-03-31 13:40:31\ncategories: \n\n- Redis命令大全\n- ZSet\nkeywords: Redis命令,bzpopmax\naside: sorted_set\n\n---\n# BZPOPMAX key [key ...] timeout\n\n>**起始版本：5.0.0**\n>\n>**时间复杂度：**O(log(N)) N是已排序集合中元素的个数。\n\n\n#### 说明:\n* `BZPOPMAX` 是有序集合命令 `ZPOPMAX`带有阻塞功能的版本。\n* 在参数中的所有有序集合均为空的情况下，阻塞连接。参数中包含多个有序集合时，按照参数中key的顺序，返回第一个非空key中分数最大的成员和对应的分数\n* 参数 `timeout` 可以理解为客户端被阻塞的最大秒数值，0 表示永久阻塞。\n* `BZPOPMAX`返回非空有序集合 key中分数最大的成员，而`BZPOPMIN`返回该key中分数最小的成员，除此之外，两条命令无其他差别。\n\n#### 返回值\n\n**array-reply**:当有序集合无结果返回且超时设置过期时返回 `nil`\n\n返回三元素multi-bulk结果，第一元素key名称，第二元素成员名称，第三元素分数\n\n\n#### 示例\n\n```c\nredis> DEL zset1 zset2\n(integer) 0\nredis> ZADD zset1 0 a 1 b 2 c\n(integer) 3\nredis> BZPOPMAX zset1 zset2 0\n1) \"zet1\"\n2) \"2\"\n2) \"c\"\n```","slug":"redis_command/sorted_set/bzpopmax","published":1,"updated":"2021-03-14T03:04:50.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpux003ihyjf6in5zmq3","content":"<h1 id=\"BZPOPMAX-key-key-…-timeout\"><a href=\"#BZPOPMAX-key-key-…-timeout\" class=\"headerlink\" title=\"BZPOPMAX key [key …] timeout\"></a>BZPOPMAX key [key …] timeout</h1><blockquote>\n<p><strong>起始版本：5.0.0</strong></p>\n<p><strong>时间复杂度：</strong>O(log(N)) N是已排序集合中元素的个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><code>BZPOPMAX</code> 是有序集合命令 <code>ZPOPMAX</code>带有阻塞功能的版本。</li>\n<li>在参数中的所有有序集合均为空的情况下，阻塞连接。参数中包含多个有序集合时，按照参数中key的顺序，返回第一个非空key中分数最大的成员和对应的分数</li>\n<li>参数 <code>timeout</code> 可以理解为客户端被阻塞的最大秒数值，0 表示永久阻塞。</li>\n<li><code>BZPOPMAX</code>返回非空有序集合 key中分数最大的成员，而<code>BZPOPMIN</code>返回该key中分数最小的成员，除此之外，两条命令无其他差别。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>:当有序集合无结果返回且超时设置过期时返回 <code>nil</code></p>\n<p>返回三元素multi-bulk结果，第一元素key名称，第二元素成员名称，第三元素分数</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; DEL zset1 zset2</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">0</span> a <span class=\"number\">1</span> b <span class=\"number\">2</span> c</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; BZPOPMAX zset1 zset2 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"zet1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"c\"</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BZPOPMAX-key-key-…-timeout\"><a href=\"#BZPOPMAX-key-key-…-timeout\" class=\"headerlink\" title=\"BZPOPMAX key [key …] timeout\"></a>BZPOPMAX key [key …] timeout</h1><blockquote>\n<p><strong>起始版本：5.0.0</strong></p>\n<p><strong>时间复杂度：</strong>O(log(N)) N是已排序集合中元素的个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><code>BZPOPMAX</code> 是有序集合命令 <code>ZPOPMAX</code>带有阻塞功能的版本。</li>\n<li>在参数中的所有有序集合均为空的情况下，阻塞连接。参数中包含多个有序集合时，按照参数中key的顺序，返回第一个非空key中分数最大的成员和对应的分数</li>\n<li>参数 <code>timeout</code> 可以理解为客户端被阻塞的最大秒数值，0 表示永久阻塞。</li>\n<li><code>BZPOPMAX</code>返回非空有序集合 key中分数最大的成员，而<code>BZPOPMIN</code>返回该key中分数最小的成员，除此之外，两条命令无其他差别。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>:当有序集合无结果返回且超时设置过期时返回 <code>nil</code></p>\n<p>返回三元素multi-bulk结果，第一元素key名称，第二元素成员名称，第三元素分数</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; DEL zset1 zset2</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">0</span> a <span class=\"number\">1</span> b <span class=\"number\">2</span> c</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; BZPOPMAX zset1 zset2 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"zet1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"c\"</span></span><br></pre></td></tr></table></figure>"},{"title":"BZPOPMIN(bzpopmin)","copyright":true,"date":"2020-03-31T05:39:31.000Z","keywords":"Redis命令,bzpopmin","aside":"sorted_set","_content":"# BZPOPMIN key [key ...] timeout \n\n>**起始版本：5.0.0**\n>\n>**时间复杂度：**O(log(N)) N是已排序集合中元素的个数。\n\n\n#### 说明:\n* `BZPOPMIN` 是有序集合命令 `ZPOPMIN`带有阻塞功能的版本。\n\n* 在参数中的所有有序集合均为空的情况下，阻塞连接。参数中包含多个有序集合时，按照参数中key的顺序，返回第一个非空key中分数最小的成员和对应的分数\n\n* 参数 `timeout` 可以理解为客户端被阻塞的最大秒数值，0 表示永久阻塞。\n\n  详细说明请参照BLPOP，`BZPOPMIN`适用有序集合类型的key，BLPOP适用列表类型的key，除此之外，两条命令无其他差别。\n\n#### 返回值\n\n**integer-reply**: 当有序集合无结果返回且超时设置过期时返回 `nil`\n\n返回三元素multi-bulk结果，第一元素key名称，第二元素成员名称，第三元素分数\n\n\n#### 示例\n\n```c\nredis> DEL zset1 zset2\n(integer) 0\nredis> ZADD zset1 0 a 1 b 2 c\n(integer) 3\nredis> BZPOPMIN zset1 zset2 0\n1) \"zet1\"\n2) \"0\"\n2) \"a\"\n```","source":"_posts/redis_command/sorted_set/bzpopmin.md","raw":"---\n\ntitle: BZPOPMIN(bzpopmin)\ncopyright: true\ndate: 2020-03-31 13:39:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,bzpopmin\naside: sorted_set\n\n---\n# BZPOPMIN key [key ...] timeout \n\n>**起始版本：5.0.0**\n>\n>**时间复杂度：**O(log(N)) N是已排序集合中元素的个数。\n\n\n#### 说明:\n* `BZPOPMIN` 是有序集合命令 `ZPOPMIN`带有阻塞功能的版本。\n\n* 在参数中的所有有序集合均为空的情况下，阻塞连接。参数中包含多个有序集合时，按照参数中key的顺序，返回第一个非空key中分数最小的成员和对应的分数\n\n* 参数 `timeout` 可以理解为客户端被阻塞的最大秒数值，0 表示永久阻塞。\n\n  详细说明请参照BLPOP，`BZPOPMIN`适用有序集合类型的key，BLPOP适用列表类型的key，除此之外，两条命令无其他差别。\n\n#### 返回值\n\n**integer-reply**: 当有序集合无结果返回且超时设置过期时返回 `nil`\n\n返回三元素multi-bulk结果，第一元素key名称，第二元素成员名称，第三元素分数\n\n\n#### 示例\n\n```c\nredis> DEL zset1 zset2\n(integer) 0\nredis> ZADD zset1 0 a 1 b 2 c\n(integer) 3\nredis> BZPOPMIN zset1 zset2 0\n1) \"zet1\"\n2) \"0\"\n2) \"a\"\n```","slug":"redis_command/sorted_set/bzpopmin","published":1,"updated":"2021-03-14T03:04:50.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpuy003lhyjf65gdw98p","content":"<h1 id=\"BZPOPMIN-key-key-…-timeout\"><a href=\"#BZPOPMIN-key-key-…-timeout\" class=\"headerlink\" title=\"BZPOPMIN key [key …] timeout\"></a>BZPOPMIN key [key …] timeout</h1><blockquote>\n<p><strong>起始版本：5.0.0</strong></p>\n<p><strong>时间复杂度：</strong>O(log(N)) N是已排序集合中元素的个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p><code>BZPOPMIN</code> 是有序集合命令 <code>ZPOPMIN</code>带有阻塞功能的版本。</p>\n</li>\n<li><p>在参数中的所有有序集合均为空的情况下，阻塞连接。参数中包含多个有序集合时，按照参数中key的顺序，返回第一个非空key中分数最小的成员和对应的分数</p>\n</li>\n<li><p>参数 <code>timeout</code> 可以理解为客户端被阻塞的最大秒数值，0 表示永久阻塞。</p>\n<p>详细说明请参照BLPOP，<code>BZPOPMIN</code>适用有序集合类型的key，BLPOP适用列表类型的key，除此之外，两条命令无其他差别。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 当有序集合无结果返回且超时设置过期时返回 <code>nil</code></p>\n<p>返回三元素multi-bulk结果，第一元素key名称，第二元素成员名称，第三元素分数</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; DEL zset1 zset2</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">0</span> a <span class=\"number\">1</span> b <span class=\"number\">2</span> c</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; BZPOPMIN zset1 zset2 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"zet1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"0\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"a\"</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BZPOPMIN-key-key-…-timeout\"><a href=\"#BZPOPMIN-key-key-…-timeout\" class=\"headerlink\" title=\"BZPOPMIN key [key …] timeout\"></a>BZPOPMIN key [key …] timeout</h1><blockquote>\n<p><strong>起始版本：5.0.0</strong></p>\n<p><strong>时间复杂度：</strong>O(log(N)) N是已排序集合中元素的个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p><code>BZPOPMIN</code> 是有序集合命令 <code>ZPOPMIN</code>带有阻塞功能的版本。</p>\n</li>\n<li><p>在参数中的所有有序集合均为空的情况下，阻塞连接。参数中包含多个有序集合时，按照参数中key的顺序，返回第一个非空key中分数最小的成员和对应的分数</p>\n</li>\n<li><p>参数 <code>timeout</code> 可以理解为客户端被阻塞的最大秒数值，0 表示永久阻塞。</p>\n<p>详细说明请参照BLPOP，<code>BZPOPMIN</code>适用有序集合类型的key，BLPOP适用列表类型的key，除此之外，两条命令无其他差别。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 当有序集合无结果返回且超时设置过期时返回 <code>nil</code></p>\n<p>返回三元素multi-bulk结果，第一元素key名称，第二元素成员名称，第三元素分数</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; DEL zset1 zset2</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">0</span> a <span class=\"number\">1</span> b <span class=\"number\">2</span> c</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; BZPOPMIN zset1 zset2 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"zet1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"0\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"a\"</span></span><br></pre></td></tr></table></figure>"},{"title":"ZADD(zadd)","copyright":true,"date":"2020-03-31T05:40:31.000Z","keywords":"Redis命令,zadd","aside":"sorted_set","_content":"## ZADD key [NX|XX] [CH] [INCR] score member [score member ...] \n>起始版本：1.2.0<br/>时间复杂度：O(log(N)) N为已排序集合中的元素数。 \n\n\n#### 说明:\n* 将所有指定成员添加到键为key有序集合（sorted set）里面。 添加时可以指定多个分数/成员（score/member）对。 如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置。\n* 如果key不存在，将会创建一个新的有序集合（sorted set）并将分数/成员（score/member）对添加到有序集合，就像原来存在一个空的有序集合一样。如果key存在，但是类型不是有序集合，将会返回一个错误应答。\n* 分数值是一个双精度的浮点型数字字符串。`+inf`和`-inf`都是有效值。\n\n##### ZADD 参数（options） (>= Redis 3.0.2)\n\nZADD 命令在`key`后面分数/成员（score/member）对前面支持一些参数，他们是：\n\n- **XX**: 仅仅更新存在的成员，不添加新成员。\n- **NX**: 不更新存在的成员。只添加新成员。\n- **CH**: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 *changed* 的意思)。更改的元素是**新添加的成员**，已经存在的成员**更新分数**。 所以在命令中指定的成员有相同的分数将不被计算在内。注：在通常情况下，`ZADD`返回值只计算新添加成员的数量。\n- **INCR**: 当`ZADD`指定这个选项时，成员的操作就等同ZINCRBY命令，对成员的分数进行递增操作\n\n##### 分数可以精确的表示的整数的范围\n\nRedis 有序集合的分数使用*双精度64位浮点数*。我们支持所有的架构，这表示为一个**IEEE 754 floating point number**，它能包括的整数范围是`-(2^53)` 到 `+(2^53)`。或者说是-9007199254740992 到 9007199254740992。更大的整数在内部用指数形式表示，所以，如果为分数设置一个非常大的整数，你得到的是一个近似的十进制数。\n\n##### Sorted sets 101\n\n有序集合按照分数以递增的方式进行排序。相同的成员（member）只存在一次，有序集合不允许存在重复的成员。 分数可以通过`ZADD`命令进行更新或者也可以通过`ZINCRBY`命令递增来修改之前的值，相应的他们的排序位置也会随着分数变化而改变。\n\n获取一个成员当前的分数可以使用ZSCORE命令，也可以用它来验证成员是否存在。\n\n##### 相同分数的成员\n\n有序集合里面的成员是不能重复的都是唯一的，但是，不同成员间有可能*有相同的分数*。当多个成员有相同的分数时，他们将是*有序的字典*（ordered lexicographically）（仍由分数作为第一排序条件，然后，相同分数的成员按照字典规则相对排序）。\n\n字典顺序排序用的是二进制，它比较的是字符串的字节数组。\n\n如果用户将所有元素设置相同分数（例如0），有序集合里面的所有元素将按照字典顺序进行排序，范围查询元素可以使用ZRANGEBYLEX命令（注：范围查询分数可以使用ZRANGEBYSCORE命令）\n\n#### 返回值\n\n**Integer reply:**包括:\n\n- 添加到有序集合的成员数量，不包括已经存在更新分数的成员。如果指定`INCR`参数, 返回将会变成**bulk-string-reply**\n\n- 成员的新分数（双精度的浮点型数字）字符串。\n\n#### 历史\n\n\n\\>= 2.4: 接受多个成员。 在Redis 2.4以前，命令只能添加或者更新一个成员。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 1 \"uno\"\n(integer) 1\nredis> ZADD myzset 2 \"two\" 3 \"three\"\n(integer) 2\nredis> ZRANGE myzset 0 -1 WITHSCORES\n1) \"one\"\n2) \"1\"\n3) \"uno\"\n4) \"1\"\n5) \"two\"\n6) \"2\"\n7) \"three\"\n8) \"3\"\nredis> \n```","source":"_posts/redis_command/sorted_set/zadd.md","raw":"---\n\ntitle: ZADD(zadd)\ncopyright: true\ndate: 2020-03-31 13:40:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zadd\naside: sorted_set\n\n---\n## ZADD key [NX|XX] [CH] [INCR] score member [score member ...] \n>起始版本：1.2.0<br/>时间复杂度：O(log(N)) N为已排序集合中的元素数。 \n\n\n#### 说明:\n* 将所有指定成员添加到键为key有序集合（sorted set）里面。 添加时可以指定多个分数/成员（score/member）对。 如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置。\n* 如果key不存在，将会创建一个新的有序集合（sorted set）并将分数/成员（score/member）对添加到有序集合，就像原来存在一个空的有序集合一样。如果key存在，但是类型不是有序集合，将会返回一个错误应答。\n* 分数值是一个双精度的浮点型数字字符串。`+inf`和`-inf`都是有效值。\n\n##### ZADD 参数（options） (>= Redis 3.0.2)\n\nZADD 命令在`key`后面分数/成员（score/member）对前面支持一些参数，他们是：\n\n- **XX**: 仅仅更新存在的成员，不添加新成员。\n- **NX**: 不更新存在的成员。只添加新成员。\n- **CH**: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 *changed* 的意思)。更改的元素是**新添加的成员**，已经存在的成员**更新分数**。 所以在命令中指定的成员有相同的分数将不被计算在内。注：在通常情况下，`ZADD`返回值只计算新添加成员的数量。\n- **INCR**: 当`ZADD`指定这个选项时，成员的操作就等同ZINCRBY命令，对成员的分数进行递增操作\n\n##### 分数可以精确的表示的整数的范围\n\nRedis 有序集合的分数使用*双精度64位浮点数*。我们支持所有的架构，这表示为一个**IEEE 754 floating point number**，它能包括的整数范围是`-(2^53)` 到 `+(2^53)`。或者说是-9007199254740992 到 9007199254740992。更大的整数在内部用指数形式表示，所以，如果为分数设置一个非常大的整数，你得到的是一个近似的十进制数。\n\n##### Sorted sets 101\n\n有序集合按照分数以递增的方式进行排序。相同的成员（member）只存在一次，有序集合不允许存在重复的成员。 分数可以通过`ZADD`命令进行更新或者也可以通过`ZINCRBY`命令递增来修改之前的值，相应的他们的排序位置也会随着分数变化而改变。\n\n获取一个成员当前的分数可以使用ZSCORE命令，也可以用它来验证成员是否存在。\n\n##### 相同分数的成员\n\n有序集合里面的成员是不能重复的都是唯一的，但是，不同成员间有可能*有相同的分数*。当多个成员有相同的分数时，他们将是*有序的字典*（ordered lexicographically）（仍由分数作为第一排序条件，然后，相同分数的成员按照字典规则相对排序）。\n\n字典顺序排序用的是二进制，它比较的是字符串的字节数组。\n\n如果用户将所有元素设置相同分数（例如0），有序集合里面的所有元素将按照字典顺序进行排序，范围查询元素可以使用ZRANGEBYLEX命令（注：范围查询分数可以使用ZRANGEBYSCORE命令）\n\n#### 返回值\n\n**Integer reply:**包括:\n\n- 添加到有序集合的成员数量，不包括已经存在更新分数的成员。如果指定`INCR`参数, 返回将会变成**bulk-string-reply**\n\n- 成员的新分数（双精度的浮点型数字）字符串。\n\n#### 历史\n\n\n\\>= 2.4: 接受多个成员。 在Redis 2.4以前，命令只能添加或者更新一个成员。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 1 \"uno\"\n(integer) 1\nredis> ZADD myzset 2 \"two\" 3 \"three\"\n(integer) 2\nredis> ZRANGE myzset 0 -1 WITHSCORES\n1) \"one\"\n2) \"1\"\n3) \"uno\"\n4) \"1\"\n5) \"two\"\n6) \"2\"\n7) \"three\"\n8) \"3\"\nredis> \n```","slug":"redis_command/sorted_set/zadd","published":1,"updated":"2021-03-14T03:04:50.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpuz003nhyjfjwdltki0","content":"<h2 id=\"ZADD-key-NX-XX-CH-INCR-score-member-score-member-…\"><a href=\"#ZADD-key-NX-XX-CH-INCR-score-member-score-member-…\" class=\"headerlink\" title=\"ZADD key [NX|XX] [CH] [INCR] score member [score member …]\"></a>ZADD key [NX|XX] [CH] [INCR] score member [score member …]</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(log(N)) N为已排序集合中的元素数。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将所有指定成员添加到键为key有序集合（sorted set）里面。 添加时可以指定多个分数/成员（score/member）对。 如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置。</li>\n<li>如果key不存在，将会创建一个新的有序集合（sorted set）并将分数/成员（score/member）对添加到有序集合，就像原来存在一个空的有序集合一样。如果key存在，但是类型不是有序集合，将会返回一个错误应答。</li>\n<li>分数值是一个双精度的浮点型数字字符串。<code>+inf</code>和<code>-inf</code>都是有效值。</li>\n</ul>\n<h5 id=\"ZADD-参数（options）-gt-Redis-3-0-2\"><a href=\"#ZADD-参数（options）-gt-Redis-3-0-2\" class=\"headerlink\" title=\"ZADD 参数（options） (&gt;= Redis 3.0.2)\"></a>ZADD 参数（options） (&gt;= Redis 3.0.2)</h5><p>ZADD 命令在<code>key</code>后面分数/成员（score/member）对前面支持一些参数，他们是：</p>\n<ul>\n<li><strong>XX</strong>: 仅仅更新存在的成员，不添加新成员。</li>\n<li><strong>NX</strong>: 不更新存在的成员。只添加新成员。</li>\n<li><strong>CH</strong>: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 <em>changed</em> 的意思)。更改的元素是<strong>新添加的成员</strong>，已经存在的成员<strong>更新分数</strong>。 所以在命令中指定的成员有相同的分数将不被计算在内。注：在通常情况下，<code>ZADD</code>返回值只计算新添加成员的数量。</li>\n<li><strong>INCR</strong>: 当<code>ZADD</code>指定这个选项时，成员的操作就等同ZINCRBY命令，对成员的分数进行递增操作</li>\n</ul>\n<h5 id=\"分数可以精确的表示的整数的范围\"><a href=\"#分数可以精确的表示的整数的范围\" class=\"headerlink\" title=\"分数可以精确的表示的整数的范围\"></a>分数可以精确的表示的整数的范围</h5><p>Redis 有序集合的分数使用<em>双精度64位浮点数</em>。我们支持所有的架构，这表示为一个<strong>IEEE 754 floating point number</strong>，它能包括的整数范围是<code>-(2^53)</code> 到 <code>+(2^53)</code>。或者说是-9007199254740992 到 9007199254740992。更大的整数在内部用指数形式表示，所以，如果为分数设置一个非常大的整数，你得到的是一个近似的十进制数。</p>\n<h5 id=\"Sorted-sets-101\"><a href=\"#Sorted-sets-101\" class=\"headerlink\" title=\"Sorted sets 101\"></a>Sorted sets 101</h5><p>有序集合按照分数以递增的方式进行排序。相同的成员（member）只存在一次，有序集合不允许存在重复的成员。 分数可以通过<code>ZADD</code>命令进行更新或者也可以通过<code>ZINCRBY</code>命令递增来修改之前的值，相应的他们的排序位置也会随着分数变化而改变。</p>\n<p>获取一个成员当前的分数可以使用ZSCORE命令，也可以用它来验证成员是否存在。</p>\n<h5 id=\"相同分数的成员\"><a href=\"#相同分数的成员\" class=\"headerlink\" title=\"相同分数的成员\"></a>相同分数的成员</h5><p>有序集合里面的成员是不能重复的都是唯一的，但是，不同成员间有可能<em>有相同的分数</em>。当多个成员有相同的分数时，他们将是<em>有序的字典</em>（ordered lexicographically）（仍由分数作为第一排序条件，然后，相同分数的成员按照字典规则相对排序）。</p>\n<p>字典顺序排序用的是二进制，它比较的是字符串的字节数组。</p>\n<p>如果用户将所有元素设置相同分数（例如0），有序集合里面的所有元素将按照字典顺序进行排序，范围查询元素可以使用ZRANGEBYLEX命令（注：范围查询分数可以使用ZRANGEBYSCORE命令）</p>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply:</strong>包括:</p>\n<ul>\n<li><p>添加到有序集合的成员数量，不包括已经存在更新分数的成员。如果指定<code>INCR</code>参数, 返回将会变成<strong>bulk-string-reply</strong></p>\n</li>\n<li><p>成员的新分数（双精度的浮点型数字）字符串。</p>\n</li>\n</ul>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>>= 2.4: 接受多个成员。 在Redis 2.4以前，命令只能添加或者更新一个成员。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"uno\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span> <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"uno\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZADD-key-NX-XX-CH-INCR-score-member-score-member-…\"><a href=\"#ZADD-key-NX-XX-CH-INCR-score-member-score-member-…\" class=\"headerlink\" title=\"ZADD key [NX|XX] [CH] [INCR] score member [score member …]\"></a>ZADD key [NX|XX] [CH] [INCR] score member [score member …]</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(log(N)) N为已排序集合中的元素数。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将所有指定成员添加到键为key有序集合（sorted set）里面。 添加时可以指定多个分数/成员（score/member）对。 如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置。</li>\n<li>如果key不存在，将会创建一个新的有序集合（sorted set）并将分数/成员（score/member）对添加到有序集合，就像原来存在一个空的有序集合一样。如果key存在，但是类型不是有序集合，将会返回一个错误应答。</li>\n<li>分数值是一个双精度的浮点型数字字符串。<code>+inf</code>和<code>-inf</code>都是有效值。</li>\n</ul>\n<h5 id=\"ZADD-参数（options）-gt-Redis-3-0-2\"><a href=\"#ZADD-参数（options）-gt-Redis-3-0-2\" class=\"headerlink\" title=\"ZADD 参数（options） (&gt;= Redis 3.0.2)\"></a>ZADD 参数（options） (&gt;= Redis 3.0.2)</h5><p>ZADD 命令在<code>key</code>后面分数/成员（score/member）对前面支持一些参数，他们是：</p>\n<ul>\n<li><strong>XX</strong>: 仅仅更新存在的成员，不添加新成员。</li>\n<li><strong>NX</strong>: 不更新存在的成员。只添加新成员。</li>\n<li><strong>CH</strong>: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 <em>changed</em> 的意思)。更改的元素是<strong>新添加的成员</strong>，已经存在的成员<strong>更新分数</strong>。 所以在命令中指定的成员有相同的分数将不被计算在内。注：在通常情况下，<code>ZADD</code>返回值只计算新添加成员的数量。</li>\n<li><strong>INCR</strong>: 当<code>ZADD</code>指定这个选项时，成员的操作就等同ZINCRBY命令，对成员的分数进行递增操作</li>\n</ul>\n<h5 id=\"分数可以精确的表示的整数的范围\"><a href=\"#分数可以精确的表示的整数的范围\" class=\"headerlink\" title=\"分数可以精确的表示的整数的范围\"></a>分数可以精确的表示的整数的范围</h5><p>Redis 有序集合的分数使用<em>双精度64位浮点数</em>。我们支持所有的架构，这表示为一个<strong>IEEE 754 floating point number</strong>，它能包括的整数范围是<code>-(2^53)</code> 到 <code>+(2^53)</code>。或者说是-9007199254740992 到 9007199254740992。更大的整数在内部用指数形式表示，所以，如果为分数设置一个非常大的整数，你得到的是一个近似的十进制数。</p>\n<h5 id=\"Sorted-sets-101\"><a href=\"#Sorted-sets-101\" class=\"headerlink\" title=\"Sorted sets 101\"></a>Sorted sets 101</h5><p>有序集合按照分数以递增的方式进行排序。相同的成员（member）只存在一次，有序集合不允许存在重复的成员。 分数可以通过<code>ZADD</code>命令进行更新或者也可以通过<code>ZINCRBY</code>命令递增来修改之前的值，相应的他们的排序位置也会随着分数变化而改变。</p>\n<p>获取一个成员当前的分数可以使用ZSCORE命令，也可以用它来验证成员是否存在。</p>\n<h5 id=\"相同分数的成员\"><a href=\"#相同分数的成员\" class=\"headerlink\" title=\"相同分数的成员\"></a>相同分数的成员</h5><p>有序集合里面的成员是不能重复的都是唯一的，但是，不同成员间有可能<em>有相同的分数</em>。当多个成员有相同的分数时，他们将是<em>有序的字典</em>（ordered lexicographically）（仍由分数作为第一排序条件，然后，相同分数的成员按照字典规则相对排序）。</p>\n<p>字典顺序排序用的是二进制，它比较的是字符串的字节数组。</p>\n<p>如果用户将所有元素设置相同分数（例如0），有序集合里面的所有元素将按照字典顺序进行排序，范围查询元素可以使用ZRANGEBYLEX命令（注：范围查询分数可以使用ZRANGEBYSCORE命令）</p>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply:</strong>包括:</p>\n<ul>\n<li><p>添加到有序集合的成员数量，不包括已经存在更新分数的成员。如果指定<code>INCR</code>参数, 返回将会变成<strong>bulk-string-reply</strong></p>\n</li>\n<li><p>成员的新分数（双精度的浮点型数字）字符串。</p>\n</li>\n</ul>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>>= 2.4: 接受多个成员。 在Redis 2.4以前，命令只能添加或者更新一个成员。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"uno\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span> <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"uno\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZCOUNT(zcount)","copyright":true,"date":"2020-03-31T05:38:31.000Z","keywords":"Redis命令,zcount","aside":"sorted_set","_content":"## ZCOUNT key min max \n>起始版本：2.0.0<br/>时间复杂度：O(log(N)) N是已排序集合中的元素个数。\n\n\n#### 说明:\n* 返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员。 关于参数min和max的详细使用方法，请参考ZRANGEBYSCORE命令。\n\n#### 返回值\n\n**integer-reply**: 指定分数范围的元素个数。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZCOUNT myzset -inf +inf\n(integer) 3\nredis> ZCOUNT myzset (1 3\n(integer) 2\nredis> \n```","source":"_posts/redis_command/sorted_set/zcount.md","raw":"---\n\ntitle: ZCOUNT(zcount)\ncopyright: true\ndate: 2020-03-31 13:38:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zcount\naside: sorted_set\n\n---\n## ZCOUNT key min max \n>起始版本：2.0.0<br/>时间复杂度：O(log(N)) N是已排序集合中的元素个数。\n\n\n#### 说明:\n* 返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员。 关于参数min和max的详细使用方法，请参考ZRANGEBYSCORE命令。\n\n#### 返回值\n\n**integer-reply**: 指定分数范围的元素个数。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZCOUNT myzset -inf +inf\n(integer) 3\nredis> ZCOUNT myzset (1 3\n(integer) 2\nredis> \n```","slug":"redis_command/sorted_set/zcount","published":1,"updated":"2021-03-14T03:04:50.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv0003qhyjf3481mkho","content":"<h2 id=\"ZCOUNT-key-min-max\"><a href=\"#ZCOUNT-key-min-max\" class=\"headerlink\" title=\"ZCOUNT key min max\"></a>ZCOUNT key min max</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(log(N)) N是已排序集合中的元素个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员。 关于参数min和max的详细使用方法，请参考ZRANGEBYSCORE命令。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 指定分数范围的元素个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZCOUNT myzset -inf +inf</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; <span class=\"function\">ZCOUNT <span class=\"title\">myzset</span> <span class=\"params\">(<span class=\"number\">1</span> <span class=\"number\">3</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(integer) <span class=\"number\">2</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">redis&gt;</span></span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZCOUNT-key-min-max\"><a href=\"#ZCOUNT-key-min-max\" class=\"headerlink\" title=\"ZCOUNT key min max\"></a>ZCOUNT key min max</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(log(N)) N是已排序集合中的元素个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员。 关于参数min和max的详细使用方法，请参考ZRANGEBYSCORE命令。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 指定分数范围的元素个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZCOUNT myzset -inf +inf</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; <span class=\"function\">ZCOUNT <span class=\"title\">myzset</span> <span class=\"params\">(<span class=\"number\">1</span> <span class=\"number\">3</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(integer) <span class=\"number\">2</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">redis&gt;</span></span></span><br></pre></td></tr></table></figure>"},{"title":"ZCARD(zcard)","copyright":true,"date":"2020-03-31T05:39:31.000Z","keywords":"Redis命令,zcard","aside":"sorted_set","_content":"## ZCARD key \n>起始版本：1.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回key的有序集元素个数。\n\n#### 返回值\n\n\n**integer-reply**: key存在的时候，返回有序集的元素个数，否则返回0。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZCARD myzset\n(integer) 2\nredis> \n```","source":"_posts/redis_command/sorted_set/zcard.md","raw":"---\n\ntitle: ZCARD(zcard)\ncopyright: true\ndate: 2020-03-31 13:39:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zcard\naside: sorted_set\n\n---\n## ZCARD key \n>起始版本：1.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回key的有序集元素个数。\n\n#### 返回值\n\n\n**integer-reply**: key存在的时候，返回有序集的元素个数，否则返回0。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZCARD myzset\n(integer) 2\nredis> \n```","slug":"redis_command/sorted_set/zcard","published":1,"updated":"2021-03-14T03:04:50.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv1003shyjfmn5r72u4","content":"<h2 id=\"ZCARD-key\"><a href=\"#ZCARD-key\" class=\"headerlink\" title=\"ZCARD key\"></a>ZCARD key</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回key的有序集元素个数。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: key存在的时候，返回有序集的元素个数，否则返回0。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZCARD myzset</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZCARD-key\"><a href=\"#ZCARD-key\" class=\"headerlink\" title=\"ZCARD key\"></a>ZCARD key</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回key的有序集元素个数。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: key存在的时候，返回有序集的元素个数，否则返回0。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZCARD myzset</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZINCRBY(zincrby)","copyright":true,"date":"2020-03-31T05:37:31.000Z","keywords":"Redis命令,zincrby","aside":"sorted_set","_content":"## ZINCRBY key increment member \n>起始版本：1.2.0<br/>时间复杂度：O(log(N)) N为已排序集合中的元素个数。\n\n\n#### 说明:\n* 为有序集key的成员member的score值加上增量increment。如果key中不存在member，就在key中添加一个member，score是increment（就好像它之前的score是0.0）。如果key不存在，就创建一个只含有指定member成员的有序集合。\n* 当key不是有序集类型时，返回一个错误。\n* score值必须是字符串表示的整数值或双精度浮点数，并且能接受double精度的浮点数。也有可能给一个负数来减少score的值。\n\n#### 返回值\n\n**Bulk string reply**: member成员的新score值，以字符串形式表示。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZINCRBY myzset 2 \"one\"\n\"3\"\nredis> ZRANGE myzset 0 -1 WITHSCORES\n1) \"two\"\n2) \"2\"\n3) \"one\"\n4) \"3\"\nredis> \n```","source":"_posts/redis_command/sorted_set/zincrby.md","raw":"---\n\ntitle: ZINCRBY(zincrby)\ncopyright: true\ndate: 2020-03-31 13:37:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zincrby\naside: sorted_set\n\n---\n## ZINCRBY key increment member \n>起始版本：1.2.0<br/>时间复杂度：O(log(N)) N为已排序集合中的元素个数。\n\n\n#### 说明:\n* 为有序集key的成员member的score值加上增量increment。如果key中不存在member，就在key中添加一个member，score是increment（就好像它之前的score是0.0）。如果key不存在，就创建一个只含有指定member成员的有序集合。\n* 当key不是有序集类型时，返回一个错误。\n* score值必须是字符串表示的整数值或双精度浮点数，并且能接受double精度的浮点数。也有可能给一个负数来减少score的值。\n\n#### 返回值\n\n**Bulk string reply**: member成员的新score值，以字符串形式表示。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZINCRBY myzset 2 \"one\"\n\"3\"\nredis> ZRANGE myzset 0 -1 WITHSCORES\n1) \"two\"\n2) \"2\"\n3) \"one\"\n4) \"3\"\nredis> \n```","slug":"redis_command/sorted_set/zincrby","published":1,"updated":"2021-03-14T03:04:50.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv2003vhyjffr83mjuu","content":"<h2 id=\"ZINCRBY-key-increment-member\"><a href=\"#ZINCRBY-key-increment-member\" class=\"headerlink\" title=\"ZINCRBY key increment member\"></a>ZINCRBY key increment member</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(log(N)) N为已排序集合中的元素个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>为有序集key的成员member的score值加上增量increment。如果key中不存在member，就在key中添加一个member，score是increment（就好像它之前的score是0.0）。如果key不存在，就创建一个只含有指定member成员的有序集合。</li>\n<li>当key不是有序集类型时，返回一个错误。</li>\n<li>score值必须是字符串表示的整数值或双精度浮点数，并且能接受double精度的浮点数。也有可能给一个负数来减少score的值。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Bulk string reply</strong>: member成员的新score值，以字符串形式表示。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZINCRBY myzset <span class=\"number\">2</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZINCRBY-key-increment-member\"><a href=\"#ZINCRBY-key-increment-member\" class=\"headerlink\" title=\"ZINCRBY key increment member\"></a>ZINCRBY key increment member</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(log(N)) N为已排序集合中的元素个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>为有序集key的成员member的score值加上增量increment。如果key中不存在member，就在key中添加一个member，score是increment（就好像它之前的score是0.0）。如果key不存在，就创建一个只含有指定member成员的有序集合。</li>\n<li>当key不是有序集类型时，返回一个错误。</li>\n<li>score值必须是字符串表示的整数值或双精度浮点数，并且能接受double精度的浮点数。也有可能给一个负数来减少score的值。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Bulk string reply</strong>: member成员的新score值，以字符串形式表示。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZINCRBY myzset <span class=\"number\">2</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZINTERSTORE(zinterstore)","copyright":true,"date":"2020-03-31T05:36:31.000Z","keywords":"Redis命令,zinterstore","aside":"sorted_set","_content":"## ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX] \n>起始版本：2.0.0<br/>时间复杂度：O(N*K)+O(M*log(M)) 最坏情况，N是最小的输入排序集，K是输入排序集的个数，M是最终排序集的元素个数。\n\n\n#### 说明:\n* 计算给定的numkeys个有序集合的交集，并且把结果放到destination中。 在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。\n* 默认情况下，结果中一个元素的分数是有序集合中该元素分数之和，前提是该元素在这些有序集合中都存在。因为交集要求其成员必须是给定的每个有序集合中的成员，结果集中的每个元素的分数和输入的有序集合个数相等。\n* 对于WEIGHTS和AGGREGATE参数的描述，参见命令ZUNIONSTORE。\n* 如果destination存在，就把它覆盖。\n\n#### 返回值\n\n\n**integer-reply**: 结果有序集合destination中元素个数。\n\n\n#### 示例\n\n```c\nredis> ZADD zset1 1 \"one\"\n(integer) 1\nredis> ZADD zset1 2 \"two\"\n(integer) 1\nredis> ZADD zset2 1 \"one\"\n(integer) 1\nredis> ZADD zset2 2 \"two\"\n(integer) 1\nredis> ZADD zset2 3 \"three\"\n(integer) 1\nredis> ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3\n(integer) 2\nredis> ZRANGE out 0 -1 WITHSCORES\n1) \"one\"\n2) \"5\"\n3) \"two\"\n4) \"10\"\nredis> \n```","source":"_posts/redis_command/sorted_set/zinterstore.md","raw":"---\n\ntitle: ZINTERSTORE(zinterstore)\ncopyright: true\ndate: 2020-03-31 13:36:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zinterstore\naside: sorted_set\n\n---\n## ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX] \n>起始版本：2.0.0<br/>时间复杂度：O(N*K)+O(M*log(M)) 最坏情况，N是最小的输入排序集，K是输入排序集的个数，M是最终排序集的元素个数。\n\n\n#### 说明:\n* 计算给定的numkeys个有序集合的交集，并且把结果放到destination中。 在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。\n* 默认情况下，结果中一个元素的分数是有序集合中该元素分数之和，前提是该元素在这些有序集合中都存在。因为交集要求其成员必须是给定的每个有序集合中的成员，结果集中的每个元素的分数和输入的有序集合个数相等。\n* 对于WEIGHTS和AGGREGATE参数的描述，参见命令ZUNIONSTORE。\n* 如果destination存在，就把它覆盖。\n\n#### 返回值\n\n\n**integer-reply**: 结果有序集合destination中元素个数。\n\n\n#### 示例\n\n```c\nredis> ZADD zset1 1 \"one\"\n(integer) 1\nredis> ZADD zset1 2 \"two\"\n(integer) 1\nredis> ZADD zset2 1 \"one\"\n(integer) 1\nredis> ZADD zset2 2 \"two\"\n(integer) 1\nredis> ZADD zset2 3 \"three\"\n(integer) 1\nredis> ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3\n(integer) 2\nredis> ZRANGE out 0 -1 WITHSCORES\n1) \"one\"\n2) \"5\"\n3) \"two\"\n4) \"10\"\nredis> \n```","slug":"redis_command/sorted_set/zinterstore","published":1,"updated":"2021-03-14T03:04:50.708Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv3003xhyjfwjfcm1du","content":"<h2 id=\"ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-SUM-MIN-MAX\"><a href=\"#ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-SUM-MIN-MAX\" class=\"headerlink\" title=\"ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM|MIN|MAX]\"></a>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM|MIN|MAX]</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N<em>K)+O(M</em>log(M)) 最坏情况，N是最小的输入排序集，K是输入排序集的个数，M是最终排序集的元素个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>计算给定的numkeys个有序集合的交集，并且把结果放到destination中。 在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。</li>\n<li>默认情况下，结果中一个元素的分数是有序集合中该元素分数之和，前提是该元素在这些有序集合中都存在。因为交集要求其成员必须是给定的每个有序集合中的成员，结果集中的每个元素的分数和输入的有序集合个数相等。</li>\n<li>对于WEIGHTS和AGGREGATE参数的描述，参见命令ZUNIONSTORE。</li>\n<li>如果destination存在，就把它覆盖。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 结果有序集合destination中元素个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZINTERSTORE out <span class=\"number\">2</span> zset1 zset2 WEIGHTS <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZRANGE out <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"5\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"10\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-SUM-MIN-MAX\"><a href=\"#ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-SUM-MIN-MAX\" class=\"headerlink\" title=\"ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM|MIN|MAX]\"></a>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM|MIN|MAX]</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N<em>K)+O(M</em>log(M)) 最坏情况，N是最小的输入排序集，K是输入排序集的个数，M是最终排序集的元素个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>计算给定的numkeys个有序集合的交集，并且把结果放到destination中。 在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。</li>\n<li>默认情况下，结果中一个元素的分数是有序集合中该元素分数之和，前提是该元素在这些有序集合中都存在。因为交集要求其成员必须是给定的每个有序集合中的成员，结果集中的每个元素的分数和输入的有序集合个数相等。</li>\n<li>对于WEIGHTS和AGGREGATE参数的描述，参见命令ZUNIONSTORE。</li>\n<li>如果destination存在，就把它覆盖。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 结果有序集合destination中元素个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZINTERSTORE out <span class=\"number\">2</span> zset1 zset2 WEIGHTS <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZRANGE out <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"5\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"10\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZLEXCOUNT(zlexcount)","copyright":true,"date":"2020-03-31T05:35:31.000Z","keywords":"Redis命令,zlexcount","aside":"sorted_set","_content":"## ZLEXCOUNT key min max \n>起始版本：2.8.9<br/>时间复杂度：O(log(N)) N是已排序集合中元素的个数\n\n\n#### 说明:\n* `ZLEXCOUNT` 命令用于计算有序集合中指定成员之间的成员数量。\n\n```c\nzlexcount zset [member1 [member5\n```\n\n| 指令      | 是否必须 | 说明                           |\n| --------- | -------- | ------------------------------ |\n| zlexcount | 是       | 指令                           |\n| key       | 是       | 有序集合键名称                 |\n| min       | 是       | 在有序集合中分数排名较小的成员 |\n| max       | 是       | 在有序集合中分数排名较大的成员 |\n\n- 成员名称前需要加 `[` 符号作为开头, `[` 符号与成员之间不能有空格\n- 可以使用 `-` 和 `+` 表示得分最小值和最大值\n- `min` 和 `max` 不能反, `max` 放前面 `min`放后面会导致返回结果为0\n- 计算成员之间的成员数量时,参数 `min` 和 `max` 的位置也计算在内。\n- `min` 和 `max` 参数的含义与 `zrangebylex` 命令中所描述的相同\n\n#### 返回值\n\n**integer-reply**:有序集合中成员名称 min 和 max 之间的成员数量\n\n### 示例\n计算成员之间成员数量\n\n```c\n\nredis> ZADD myzset 0 a 0 b 0 c 0 d 0 e\n(integer) 5\nredis> ZADD myzset 0 f 0 g\n(integer) 2\nredis> ZLEXCOUNT myzset - +\n(integer) 7\nredis> ZLEXCOUNT myzset [b [f\n(integer) 5\nredis> \n```\n计算某个成员之前或者之后的成员数量\n```c\n//- 表示得分最小值的成员 + 表示得分最大值的成员\nredis> ZADD myzset 1 a 2 b 3 c 4 d 5 e 6 f 7 g\n(integer) 7\nredis> zrange myzset 0 -1\n1) \"a\"\n2) \"b\"\n3) \"c\"\n4) \"d\"\n5) \"e\"\n6) \"f\"\n7) \"g\"\nredis> ZLEXCOUNT myzset - +\n(integer) 7\nredis> ZLEXCOUNT myzset [c +\n(integer) 5\nredis> ZLEXCOUNT myzset - [c\n(integer) 3\nredis> \n```\n分数值位置的重要性\n```c\nredis> del myzset\n(integer) 1\nredis> ZADD myzset 1 a 2 b 3 c 4 d 5 e 6 f 7 g\n(integer) 7\nredis> zrange myzset 0 -1\n1) \"a\"\n2) \"b\"\n3) \"c\"\n4) \"d\"\n5) \"e\"\n6) \"f\"\n7) \"g\"\nredis> ZLEXCOUNT myzset [c [f\n(integer) 4\nredis> ZLEXCOUNT myzset [f [c\n(integer) 0\nredis> \n```","source":"_posts/redis_command/sorted_set/zlexcount.md","raw":"---\n\ntitle: ZLEXCOUNT(zlexcount)\ncopyright: true\ndate: 2020-03-31 13:35:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zlexcount\naside: sorted_set\n\n---\n## ZLEXCOUNT key min max \n>起始版本：2.8.9<br/>时间复杂度：O(log(N)) N是已排序集合中元素的个数\n\n\n#### 说明:\n* `ZLEXCOUNT` 命令用于计算有序集合中指定成员之间的成员数量。\n\n```c\nzlexcount zset [member1 [member5\n```\n\n| 指令      | 是否必须 | 说明                           |\n| --------- | -------- | ------------------------------ |\n| zlexcount | 是       | 指令                           |\n| key       | 是       | 有序集合键名称                 |\n| min       | 是       | 在有序集合中分数排名较小的成员 |\n| max       | 是       | 在有序集合中分数排名较大的成员 |\n\n- 成员名称前需要加 `[` 符号作为开头, `[` 符号与成员之间不能有空格\n- 可以使用 `-` 和 `+` 表示得分最小值和最大值\n- `min` 和 `max` 不能反, `max` 放前面 `min`放后面会导致返回结果为0\n- 计算成员之间的成员数量时,参数 `min` 和 `max` 的位置也计算在内。\n- `min` 和 `max` 参数的含义与 `zrangebylex` 命令中所描述的相同\n\n#### 返回值\n\n**integer-reply**:有序集合中成员名称 min 和 max 之间的成员数量\n\n### 示例\n计算成员之间成员数量\n\n```c\n\nredis> ZADD myzset 0 a 0 b 0 c 0 d 0 e\n(integer) 5\nredis> ZADD myzset 0 f 0 g\n(integer) 2\nredis> ZLEXCOUNT myzset - +\n(integer) 7\nredis> ZLEXCOUNT myzset [b [f\n(integer) 5\nredis> \n```\n计算某个成员之前或者之后的成员数量\n```c\n//- 表示得分最小值的成员 + 表示得分最大值的成员\nredis> ZADD myzset 1 a 2 b 3 c 4 d 5 e 6 f 7 g\n(integer) 7\nredis> zrange myzset 0 -1\n1) \"a\"\n2) \"b\"\n3) \"c\"\n4) \"d\"\n5) \"e\"\n6) \"f\"\n7) \"g\"\nredis> ZLEXCOUNT myzset - +\n(integer) 7\nredis> ZLEXCOUNT myzset [c +\n(integer) 5\nredis> ZLEXCOUNT myzset - [c\n(integer) 3\nredis> \n```\n分数值位置的重要性\n```c\nredis> del myzset\n(integer) 1\nredis> ZADD myzset 1 a 2 b 3 c 4 d 5 e 6 f 7 g\n(integer) 7\nredis> zrange myzset 0 -1\n1) \"a\"\n2) \"b\"\n3) \"c\"\n4) \"d\"\n5) \"e\"\n6) \"f\"\n7) \"g\"\nredis> ZLEXCOUNT myzset [c [f\n(integer) 4\nredis> ZLEXCOUNT myzset [f [c\n(integer) 0\nredis> \n```","slug":"redis_command/sorted_set/zlexcount","published":1,"updated":"2021-03-14T03:04:50.708Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv40040hyjfndc3pe9f","content":"<h2 id=\"ZLEXCOUNT-key-min-max\"><a href=\"#ZLEXCOUNT-key-min-max\" class=\"headerlink\" title=\"ZLEXCOUNT key min max\"></a>ZLEXCOUNT key min max</h2><blockquote>\n<p>起始版本：2.8.9<br>时间复杂度：O(log(N)) N是已排序集合中元素的个数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><code>ZLEXCOUNT</code> 命令用于计算有序集合中指定成员之间的成员数量。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zlexcount zset [member1 [member5</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>是否必须</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zlexcount</td>\n<td>是</td>\n<td>指令</td>\n</tr>\n<tr>\n<td>key</td>\n<td>是</td>\n<td>有序集合键名称</td>\n</tr>\n<tr>\n<td>min</td>\n<td>是</td>\n<td>在有序集合中分数排名较小的成员</td>\n</tr>\n<tr>\n<td>max</td>\n<td>是</td>\n<td>在有序集合中分数排名较大的成员</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>成员名称前需要加 <code>[</code> 符号作为开头, <code>[</code> 符号与成员之间不能有空格</li>\n<li>可以使用 <code>-</code> 和 <code>+</code> 表示得分最小值和最大值</li>\n<li><code>min</code> 和 <code>max</code> 不能反, <code>max</code> 放前面 <code>min</code>放后面会导致返回结果为0</li>\n<li>计算成员之间的成员数量时,参数 <code>min</code> 和 <code>max</code> 的位置也计算在内。</li>\n<li><code>min</code> 和 <code>max</code> 参数的含义与 <code>zrangebylex</code> 命令中所描述的相同</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:有序集合中成员名称 min 和 max 之间的成员数量</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>计算成员之间成员数量</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">0</span> a <span class=\"number\">0</span> b <span class=\"number\">0</span> c <span class=\"number\">0</span> d <span class=\"number\">0</span> e</span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">0</span> f <span class=\"number\">0</span> g</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset - +</span><br><span class=\"line\">(integer) <span class=\"number\">7</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset [b [f</span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n<p>计算某个成员之前或者之后的成员数量<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//- 表示得分最小值的成员 + 表示得分最大值的成员</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> a <span class=\"number\">2</span> b <span class=\"number\">3</span> c <span class=\"number\">4</span> d <span class=\"number\">5</span> e <span class=\"number\">6</span> f <span class=\"number\">7</span> g</span><br><span class=\"line\">(integer) <span class=\"number\">7</span></span><br><span class=\"line\">redis&gt; zrange myzset <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"e\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"f\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"g\"</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset - +</span><br><span class=\"line\">(integer) <span class=\"number\">7</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset [c +</span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset - [c</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure></p>\n<p>分数值位置的重要性<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; del myzset</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> a <span class=\"number\">2</span> b <span class=\"number\">3</span> c <span class=\"number\">4</span> d <span class=\"number\">5</span> e <span class=\"number\">6</span> f <span class=\"number\">7</span> g</span><br><span class=\"line\">(integer) <span class=\"number\">7</span></span><br><span class=\"line\">redis&gt; zrange myzset <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"e\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"f\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"g\"</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset [c [f</span><br><span class=\"line\">(integer) <span class=\"number\">4</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset [f [c</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZLEXCOUNT-key-min-max\"><a href=\"#ZLEXCOUNT-key-min-max\" class=\"headerlink\" title=\"ZLEXCOUNT key min max\"></a>ZLEXCOUNT key min max</h2><blockquote>\n<p>起始版本：2.8.9<br>时间复杂度：O(log(N)) N是已排序集合中元素的个数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><code>ZLEXCOUNT</code> 命令用于计算有序集合中指定成员之间的成员数量。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zlexcount zset [member1 [member5</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>是否必须</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zlexcount</td>\n<td>是</td>\n<td>指令</td>\n</tr>\n<tr>\n<td>key</td>\n<td>是</td>\n<td>有序集合键名称</td>\n</tr>\n<tr>\n<td>min</td>\n<td>是</td>\n<td>在有序集合中分数排名较小的成员</td>\n</tr>\n<tr>\n<td>max</td>\n<td>是</td>\n<td>在有序集合中分数排名较大的成员</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>成员名称前需要加 <code>[</code> 符号作为开头, <code>[</code> 符号与成员之间不能有空格</li>\n<li>可以使用 <code>-</code> 和 <code>+</code> 表示得分最小值和最大值</li>\n<li><code>min</code> 和 <code>max</code> 不能反, <code>max</code> 放前面 <code>min</code>放后面会导致返回结果为0</li>\n<li>计算成员之间的成员数量时,参数 <code>min</code> 和 <code>max</code> 的位置也计算在内。</li>\n<li><code>min</code> 和 <code>max</code> 参数的含义与 <code>zrangebylex</code> 命令中所描述的相同</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:有序集合中成员名称 min 和 max 之间的成员数量</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>计算成员之间成员数量</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">0</span> a <span class=\"number\">0</span> b <span class=\"number\">0</span> c <span class=\"number\">0</span> d <span class=\"number\">0</span> e</span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">0</span> f <span class=\"number\">0</span> g</span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset - +</span><br><span class=\"line\">(integer) <span class=\"number\">7</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset [b [f</span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n<p>计算某个成员之前或者之后的成员数量<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//- 表示得分最小值的成员 + 表示得分最大值的成员</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> a <span class=\"number\">2</span> b <span class=\"number\">3</span> c <span class=\"number\">4</span> d <span class=\"number\">5</span> e <span class=\"number\">6</span> f <span class=\"number\">7</span> g</span><br><span class=\"line\">(integer) <span class=\"number\">7</span></span><br><span class=\"line\">redis&gt; zrange myzset <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"e\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"f\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"g\"</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset - +</span><br><span class=\"line\">(integer) <span class=\"number\">7</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset [c +</span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset - [c</span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure></p>\n<p>分数值位置的重要性<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; del myzset</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> a <span class=\"number\">2</span> b <span class=\"number\">3</span> c <span class=\"number\">4</span> d <span class=\"number\">5</span> e <span class=\"number\">6</span> f <span class=\"number\">7</span> g</span><br><span class=\"line\">(integer) <span class=\"number\">7</span></span><br><span class=\"line\">redis&gt; zrange myzset <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"e\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"f\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"g\"</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset [c [f</span><br><span class=\"line\">(integer) <span class=\"number\">4</span></span><br><span class=\"line\">redis&gt; ZLEXCOUNT myzset [f [c</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"ZPOPMIN(zpopmin)","copyright":true,"date":"2020-03-31T05:33:31.000Z","keywords":"Redis命令,zpopmin","aside":"sorted_set","_content":"## ZPOPMIN key [count] \n>起始版本：5.0.0<br/>时间复杂度：O(log(N)*M) N是已排序集合中的元素数，M是弹出的元素数。  \n\n\n#### 说明:\n* 删除并返回有序集合key中的最多count个具有最低得分的成员。\n* 如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最低的元素将是第一个元素，然后是分数较高的元素。\n\n#### 返回值\n\n**array-reply**: 弹出的元素和分数列表。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZPOPMIN myzset\n1) \"1\"\n2) \"one\"\nredis> \n```","source":"_posts/redis_command/sorted_set/zpopmin.md","raw":"---\n\ntitle: ZPOPMIN(zpopmin)\ncopyright: true\ndate: 2020-03-31 13:33:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zpopmin\naside: sorted_set\n\n---\n## ZPOPMIN key [count] \n>起始版本：5.0.0<br/>时间复杂度：O(log(N)*M) N是已排序集合中的元素数，M是弹出的元素数。  \n\n\n#### 说明:\n* 删除并返回有序集合key中的最多count个具有最低得分的成员。\n* 如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最低的元素将是第一个元素，然后是分数较高的元素。\n\n#### 返回值\n\n**array-reply**: 弹出的元素和分数列表。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZPOPMIN myzset\n1) \"1\"\n2) \"one\"\nredis> \n```","slug":"redis_command/sorted_set/zpopmin","published":1,"updated":"2021-03-14T03:04:50.708Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv40042hyjfdr9dut5e","content":"<h2 id=\"ZPOPMIN-key-count\"><a href=\"#ZPOPMIN-key-count\" class=\"headerlink\" title=\"ZPOPMIN key [count]\"></a>ZPOPMIN key [count]</h2><blockquote>\n<p>起始版本：5.0.0<br>时间复杂度：O(log(N)*M) N是已排序集合中的元素数，M是弹出的元素数。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>删除并返回有序集合key中的最多count个具有最低得分的成员。</li>\n<li>如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最低的元素将是第一个元素，然后是分数较高的元素。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 弹出的元素和分数列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZPOPMIN myzset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZPOPMIN-key-count\"><a href=\"#ZPOPMIN-key-count\" class=\"headerlink\" title=\"ZPOPMIN key [count]\"></a>ZPOPMIN key [count]</h2><blockquote>\n<p>起始版本：5.0.0<br>时间复杂度：O(log(N)*M) N是已排序集合中的元素数，M是弹出的元素数。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>删除并返回有序集合key中的最多count个具有最低得分的成员。</li>\n<li>如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最低的元素将是第一个元素，然后是分数较高的元素。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 弹出的元素和分数列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZPOPMIN myzset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZPOPMAX(zpopmax)","copyright":true,"date":"2020-03-31T05:34:31.000Z","keywords":"Redis命令,zpopmax","aside":"sorted_set","_content":"## ZPOPMAX key [count] \n>起始版本：5.0.0<br/>时间复杂度：O(log(N)*M) N是已排序集合中的元素数，M是弹出的元素数。 \n\n\n#### 说明:\n* 删除并返回有序集合key中的最多count个具有最高得分的成员。\n* 如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最高的元素将是第一个元素，然后是分数较低的元素。\n\n#### 返回值\n\n\n**array-reply**: 弹出的元素和分数列表。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZPOPMAX myzset\n1) \"3\"\n2) \"three\"\nredis> \n```","source":"_posts/redis_command/sorted_set/zpopmax.md","raw":"---\n\ntitle: ZPOPMAX(zpopmax)\ncopyright: true\ndate: 2020-03-31 13:34:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zpopmax\naside: sorted_set\n\n---\n## ZPOPMAX key [count] \n>起始版本：5.0.0<br/>时间复杂度：O(log(N)*M) N是已排序集合中的元素数，M是弹出的元素数。 \n\n\n#### 说明:\n* 删除并返回有序集合key中的最多count个具有最高得分的成员。\n* 如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最高的元素将是第一个元素，然后是分数较低的元素。\n\n#### 返回值\n\n\n**array-reply**: 弹出的元素和分数列表。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZPOPMAX myzset\n1) \"3\"\n2) \"three\"\nredis> \n```","slug":"redis_command/sorted_set/zpopmax","published":1,"updated":"2021-03-14T03:04:50.708Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv50045hyjfhornuqk1","content":"<h2 id=\"ZPOPMAX-key-count\"><a href=\"#ZPOPMAX-key-count\" class=\"headerlink\" title=\"ZPOPMAX key [count]\"></a>ZPOPMAX key [count]</h2><blockquote>\n<p>起始版本：5.0.0<br>时间复杂度：O(log(N)*M) N是已排序集合中的元素数，M是弹出的元素数。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>删除并返回有序集合key中的最多count个具有最高得分的成员。</li>\n<li>如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最高的元素将是第一个元素，然后是分数较低的元素。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 弹出的元素和分数列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZPOPMAX myzset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZPOPMAX-key-count\"><a href=\"#ZPOPMAX-key-count\" class=\"headerlink\" title=\"ZPOPMAX key [count]\"></a>ZPOPMAX key [count]</h2><blockquote>\n<p>起始版本：5.0.0<br>时间复杂度：O(log(N)*M) N是已排序集合中的元素数，M是弹出的元素数。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>删除并返回有序集合key中的最多count个具有最高得分的成员。</li>\n<li>如未指定，count的默认值为1。指定一个大于有序集合的基数的count不会产生错误。 当返回多个元素时候，得分最高的元素将是第一个元素，然后是分数较低的元素。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 弹出的元素和分数列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZPOPMAX myzset</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZRANGEBYLEX(zrangebylex)","copyright":true,"date":"2020-03-31T05:31:31.000Z","keywords":"Redis命令,zrangebylex","aside":"sorted_set","_content":"## ZRANGEBYLEX key min max [LIMIT offset count] \n>起始版本：2.8.9<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。\n\n\n#### 说明:\n* ZRANGEBYLEX 返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同。 在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行排序时,可以使用Redis中SortSet这种数据结构来处理。\n\n| 指令        | 是否必须 | 说明                                                         |\n| ----------- | -------- | ------------------------------------------------------------ |\n| ZRANGEBYLEX | 是       | 指令                                                         |\n| key         | 是       | 有序集合键名称                                               |\n| min         | 是       | 字典中排序位置较小的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"-\"代替 |\n| max         | 是       | 字典中排序位置较大的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"+\"代替 |\n| LIMIT       | 否       | 返回结果是否分页,指令中包含LIMIT后offset、count必须输入      |\n| offset      | 否       | 返回结果起始位置                                             |\n| count       | 否       | 返回结果数量                                                 |\n\n- 分数必须相同, 如果有序集合中的成员分数有不一致的,返回的结果就不准。\n- 成员字符串作为二进制数组的字节数进行比较。\n- 默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。\n- 默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。\n- “max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。\n- 可以使用 “-“ 和 “+” 表示得分最小值和最大值\n- “min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空\n- 与ZRANGEBYLEX获取顺序相反的指令是[ZREVRANGEBYLEX](http://www.redis.cn/commands/zrevrangebylex.html)。\n- 源码中采用C语言中` memcmp() `函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠后。\n\n#### 返回值\n\n指定成员范围的元素列表。\n#### 示例\n不要在分数不一致的SortSet集合中去使用 ZRANGEBYLEX 指令,因为获取的结果并不准确。\n\n1. 获取所有值,可以使用 “-“ 和 “+” 表示得分最小值和最大值\n\n```c\nredis> zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1\n(integer) 12\nredis> ZRANGEBYLEX zset - +\n 1) \"a\"\n 2) \"aa\"\n 3) \"abc\"\n 4) \"apple\"\n 5) \"b\"\n 6) \"c\"\n 7) \"d\"\n 8) \"d1\"\n 9) \"dd\"\n10) \"dobble\"\n11) \"z\"\n12) \"z1\"\n```\n\n2. 获取分页数据\n\n```c\nredis> ZRANGEBYLEX zset - + LIMIT 0 3\n1) \"a\"\n2) \"aa\"\n3) \"abc\"\nredis> ZRANGEBYLEX zset - + LIMIT 3 3\n1) \"apple\"\n2) \"b\"\n3) \"c\"\n```\n\n3. 获取成员之间的元素\n   默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。\n   “[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。\n\n```c\nredis> ZRANGEBYLEX zset [aa [c\n1) \"aa\"\n2) \"abc\"\n3) \"apple\"\n4) \"b\"\n5) \"c\"\n```\n\n“min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空\n\n```c\nredis> ZRANGEBYLEX zset [c [aa\n(empty list or set)\n```\n\n4. 使用 “(“ 小于号获取成员之间的元素\n\n   “max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。\n   返回成员结果集不会包含 “max” 和 “min” 成员。\n\n```c\nredis> ZRANGEBYLEX zset [aa (c\n1) \"aa\"\n2) \"abc\"\n3) \"apple\"\n4) \"b\"\n```\n\n5. ASCII码的影响\n\n```c\nredis> zadd zset 0 aBc\n(integer) 1\nredis> ZRANGEBYLEX zset - +\n 1) \"a\"\n 2) \"aBc\"\n 3) \"aa\"\n 4) \"abc\"\n 5) \"apple\"\n 6) \"b\"\n 7) \"c\"\n 8) \"d\"\n 9) \"d1\"\n10) \"dd\"\n11) \"dobble\"\n12) \"z\"\n13) \"z1\"\nredis> ZRANGEBYLEX zset - + LIMIT 0 3\n1) \"a\"\n2) \"aBc\"\n3) \"aa\"\n```\n\n#### 使用场景示例\n\n1. 电话号码排序\n\n我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:\n\n```c\nredis> zadd phone 0 13100111100 0 13110114300 0 13132110901 \n(integer) 3\nredis> zadd phone 0 13200111100 0 13210414300 0 13252110901 \n(integer) 3\nredis> zadd phone 0 13300111100 0 13310414300 0 13352110901 \n(integer) 3\n```\n\n获取所有号码:\n\n```c\nredis> ZRANGEBYLEX phone - +\n1) \"13100111100\"\n2) \"13110114300\"\n3) \"13132110901\"\n4) \"13200111100\"\n5) \"13210414300\"\n6) \"13252110901\"\n7) \"13300111100\"\n8) \"13310414300\"\n9) \"13352110901\"\n```\n\n获取132号段:\n\n```c\nredis> ZRANGEBYLEX phone [132 (133\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n```\n\n获取132、133号段:\n\n```c\nredis> ZRANGEBYLEX phone [132 (134\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n4) \"13300111100\"\n5) \"13310414300\"\n6) \"13352110901\"\n```\n\n2. 姓名排序\n\n将名称存储到SortSet中:\n\n```c\nredis> zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua \n(integer) 6\n```\n\n获取所有人的名字:\n\n```c\nredis> ZRANGEBYLEX names - +\n1) \"Aidehua\"\n2) \"Aimini\"\n3) \"Bluetuo\"\n4) \"Gaodeng\"\n5) \"Jake\"\n6) \"Toumas\"\n```\n\n获取名字中大写字母A开头的所有人:\n\n```c\nredis> ZRANGEBYLEX names [A (B\n1) \"Aidehua\"\n2) \"Aimini\"\n```\n\n获取名字中大写字母C到Z的所有人:\n\n```c\nredis> ZRANGEBYLEX names [C [Z\n1) \"Gaodeng\"\n2) \"Jake\"\n3) \"Toumas\"\n```\n\n","source":"_posts/redis_command/sorted_set/zrangebylex.md","raw":"---\n\ntitle: ZRANGEBYLEX(zrangebylex)\ncopyright: true\ndate: 2020-03-31 13:31:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zrangebylex\naside: sorted_set\n\n---\n## ZRANGEBYLEX key min max [LIMIT offset count] \n>起始版本：2.8.9<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。\n\n\n#### 说明:\n* ZRANGEBYLEX 返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同。 在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行排序时,可以使用Redis中SortSet这种数据结构来处理。\n\n| 指令        | 是否必须 | 说明                                                         |\n| ----------- | -------- | ------------------------------------------------------------ |\n| ZRANGEBYLEX | 是       | 指令                                                         |\n| key         | 是       | 有序集合键名称                                               |\n| min         | 是       | 字典中排序位置较小的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"-\"代替 |\n| max         | 是       | 字典中排序位置较大的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"+\"代替 |\n| LIMIT       | 否       | 返回结果是否分页,指令中包含LIMIT后offset、count必须输入      |\n| offset      | 否       | 返回结果起始位置                                             |\n| count       | 否       | 返回结果数量                                                 |\n\n- 分数必须相同, 如果有序集合中的成员分数有不一致的,返回的结果就不准。\n- 成员字符串作为二进制数组的字节数进行比较。\n- 默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。\n- 默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。\n- “max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。\n- 可以使用 “-“ 和 “+” 表示得分最小值和最大值\n- “min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空\n- 与ZRANGEBYLEX获取顺序相反的指令是[ZREVRANGEBYLEX](http://www.redis.cn/commands/zrevrangebylex.html)。\n- 源码中采用C语言中` memcmp() `函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠后。\n\n#### 返回值\n\n指定成员范围的元素列表。\n#### 示例\n不要在分数不一致的SortSet集合中去使用 ZRANGEBYLEX 指令,因为获取的结果并不准确。\n\n1. 获取所有值,可以使用 “-“ 和 “+” 表示得分最小值和最大值\n\n```c\nredis> zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1\n(integer) 12\nredis> ZRANGEBYLEX zset - +\n 1) \"a\"\n 2) \"aa\"\n 3) \"abc\"\n 4) \"apple\"\n 5) \"b\"\n 6) \"c\"\n 7) \"d\"\n 8) \"d1\"\n 9) \"dd\"\n10) \"dobble\"\n11) \"z\"\n12) \"z1\"\n```\n\n2. 获取分页数据\n\n```c\nredis> ZRANGEBYLEX zset - + LIMIT 0 3\n1) \"a\"\n2) \"aa\"\n3) \"abc\"\nredis> ZRANGEBYLEX zset - + LIMIT 3 3\n1) \"apple\"\n2) \"b\"\n3) \"c\"\n```\n\n3. 获取成员之间的元素\n   默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。\n   “[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。\n\n```c\nredis> ZRANGEBYLEX zset [aa [c\n1) \"aa\"\n2) \"abc\"\n3) \"apple\"\n4) \"b\"\n5) \"c\"\n```\n\n“min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空\n\n```c\nredis> ZRANGEBYLEX zset [c [aa\n(empty list or set)\n```\n\n4. 使用 “(“ 小于号获取成员之间的元素\n\n   “max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。\n   返回成员结果集不会包含 “max” 和 “min” 成员。\n\n```c\nredis> ZRANGEBYLEX zset [aa (c\n1) \"aa\"\n2) \"abc\"\n3) \"apple\"\n4) \"b\"\n```\n\n5. ASCII码的影响\n\n```c\nredis> zadd zset 0 aBc\n(integer) 1\nredis> ZRANGEBYLEX zset - +\n 1) \"a\"\n 2) \"aBc\"\n 3) \"aa\"\n 4) \"abc\"\n 5) \"apple\"\n 6) \"b\"\n 7) \"c\"\n 8) \"d\"\n 9) \"d1\"\n10) \"dd\"\n11) \"dobble\"\n12) \"z\"\n13) \"z1\"\nredis> ZRANGEBYLEX zset - + LIMIT 0 3\n1) \"a\"\n2) \"aBc\"\n3) \"aa\"\n```\n\n#### 使用场景示例\n\n1. 电话号码排序\n\n我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:\n\n```c\nredis> zadd phone 0 13100111100 0 13110114300 0 13132110901 \n(integer) 3\nredis> zadd phone 0 13200111100 0 13210414300 0 13252110901 \n(integer) 3\nredis> zadd phone 0 13300111100 0 13310414300 0 13352110901 \n(integer) 3\n```\n\n获取所有号码:\n\n```c\nredis> ZRANGEBYLEX phone - +\n1) \"13100111100\"\n2) \"13110114300\"\n3) \"13132110901\"\n4) \"13200111100\"\n5) \"13210414300\"\n6) \"13252110901\"\n7) \"13300111100\"\n8) \"13310414300\"\n9) \"13352110901\"\n```\n\n获取132号段:\n\n```c\nredis> ZRANGEBYLEX phone [132 (133\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n```\n\n获取132、133号段:\n\n```c\nredis> ZRANGEBYLEX phone [132 (134\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n4) \"13300111100\"\n5) \"13310414300\"\n6) \"13352110901\"\n```\n\n2. 姓名排序\n\n将名称存储到SortSet中:\n\n```c\nredis> zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua \n(integer) 6\n```\n\n获取所有人的名字:\n\n```c\nredis> ZRANGEBYLEX names - +\n1) \"Aidehua\"\n2) \"Aimini\"\n3) \"Bluetuo\"\n4) \"Gaodeng\"\n5) \"Jake\"\n6) \"Toumas\"\n```\n\n获取名字中大写字母A开头的所有人:\n\n```c\nredis> ZRANGEBYLEX names [A (B\n1) \"Aidehua\"\n2) \"Aimini\"\n```\n\n获取名字中大写字母C到Z的所有人:\n\n```c\nredis> ZRANGEBYLEX names [C [Z\n1) \"Gaodeng\"\n2) \"Jake\"\n3) \"Toumas\"\n```\n\n","slug":"redis_command/sorted_set/zrangebylex","published":1,"updated":"2021-03-14T03:04:50.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv60047hyjfptteat65","content":"<h2 id=\"ZRANGEBYLEX-key-min-max-LIMIT-offset-count\"><a href=\"#ZRANGEBYLEX-key-min-max-LIMIT-offset-count\" class=\"headerlink\" title=\"ZRANGEBYLEX key min max [LIMIT offset count]\"></a>ZRANGEBYLEX key min max [LIMIT offset count]</h2><blockquote>\n<p>起始版本：2.8.9<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>ZRANGEBYLEX 返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同。 在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行排序时,可以使用Redis中SortSet这种数据结构来处理。</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>是否必须</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZRANGEBYLEX</td>\n<td>是</td>\n<td>指令</td>\n</tr>\n<tr>\n<td>key</td>\n<td>是</td>\n<td>有序集合键名称</td>\n</tr>\n<tr>\n<td>min</td>\n<td>是</td>\n<td>字典中排序位置较小的成员,必须以”[“开头,或者以”(“开头,可使用”-“代替</td>\n</tr>\n<tr>\n<td>max</td>\n<td>是</td>\n<td>字典中排序位置较大的成员,必须以”[“开头,或者以”(“开头,可使用”+”代替</td>\n</tr>\n<tr>\n<td>LIMIT</td>\n<td>否</td>\n<td>返回结果是否分页,指令中包含LIMIT后offset、count必须输入</td>\n</tr>\n<tr>\n<td>offset</td>\n<td>否</td>\n<td>返回结果起始位置</td>\n</tr>\n<tr>\n<td>count</td>\n<td>否</td>\n<td>返回结果数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>分数必须相同, 如果有序集合中的成员分数有不一致的,返回的结果就不准。</li>\n<li>成员字符串作为二进制数组的字节数进行比较。</li>\n<li>默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。</li>\n<li>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。</li>\n<li>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。</li>\n<li>可以使用 “-“ 和 “+” 表示得分最小值和最大值</li>\n<li>“min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空</li>\n<li>与ZRANGEBYLEX获取顺序相反的指令是<a href=\"http://www.redis.cn/commands/zrevrangebylex.html\" target=\"_blank\" rel=\"noopener\">ZREVRANGEBYLEX</a>。</li>\n<li>源码中采用C语言中<code>memcmp()</code>函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠后。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>指定成员范围的元素列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>不要在分数不一致的SortSet集合中去使用 ZRANGEBYLEX 指令,因为获取的结果并不准确。</p>\n<ol>\n<li>获取所有值,可以使用 “-“ 和 “+” 表示得分最小值和最大值</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> a <span class=\"number\">0</span> aa <span class=\"number\">0</span> abc <span class=\"number\">0</span> apple <span class=\"number\">0</span> b <span class=\"number\">0</span> c <span class=\"number\">0</span> d <span class=\"number\">0</span> d1 <span class=\"number\">0</span> dd <span class=\"number\">0</span> dobble <span class=\"number\">0</span> z <span class=\"number\">0</span> z1</span><br><span class=\"line\">(integer) <span class=\"number\">12</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"> <span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"> <span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"> <span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"> <span class=\"number\">4</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"> <span class=\"number\">5</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"> <span class=\"number\">6</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"> <span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"> <span class=\"number\">8</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"> <span class=\"number\">9</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">12</span>) <span class=\"string\">\"z1\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>获取分页数据</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset - + LIMIT <span class=\"number\">0</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - + LIMIT <span class=\"number\">3</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"c\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>获取成员之间的元素<br>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。<br>“[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset [aa [c</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"c\"</span></span><br></pre></td></tr></table></figure>\n<p>“min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset [c [aa</span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>使用 “(“ 小于号获取成员之间的元素</p>\n<p>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。<br>返回成员结果集不会包含 “max” 和 “min” 成员。</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset [aa (c</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"b\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>ASCII码的影响</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> aBc</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"> <span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"> <span class=\"number\">2</span>) <span class=\"string\">\"aBc\"</span></span><br><span class=\"line\"> <span class=\"number\">3</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"> <span class=\"number\">4</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"> <span class=\"number\">5</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"> <span class=\"number\">6</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"> <span class=\"number\">7</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"> <span class=\"number\">8</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"> <span class=\"number\">9</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">12</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">13</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - + LIMIT <span class=\"number\">0</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"aBc\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"aa\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用场景示例\"><a href=\"#使用场景示例\" class=\"headerlink\" title=\"使用场景示例\"></a>使用场景示例</h4><ol>\n<li>电话号码排序</li>\n</ol>\n<p>我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13100111100</span> <span class=\"number\">0</span> <span class=\"number\">13110114300</span> <span class=\"number\">0</span> <span class=\"number\">13132110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13200111100</span> <span class=\"number\">0</span> <span class=\"number\">13210414300</span> <span class=\"number\">0</span> <span class=\"number\">13252110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13300111100</span> <span class=\"number\">0</span> <span class=\"number\">13310414300</span> <span class=\"number\">0</span> <span class=\"number\">13352110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>获取所有号码:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13100111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13110114300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13132110901\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">9</span>) <span class=\"string\">\"13352110901\"</span></span><br></pre></td></tr></table></figure>\n<p>获取132号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone [<span class=\"number\">132</span> (<span class=\"number\">133</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13252110901\"</span></span><br></pre></td></tr></table></figure>\n<p>获取132、133号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone [<span class=\"number\">132</span> (<span class=\"number\">134</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13352110901\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>姓名排序</li>\n</ol>\n<p>将名称存储到SortSet中:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd names <span class=\"number\">0</span> Toumas <span class=\"number\">0</span> Jake <span class=\"number\">0</span> Bluetuo <span class=\"number\">0</span> Gaodeng <span class=\"number\">0</span> Aimini <span class=\"number\">0</span> Aidehua </span><br><span class=\"line\">(integer) <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>获取所有人的名字:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Aidehua\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Aimini\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Bluetuo\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"Gaodeng\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"Toumas\"</span></span><br></pre></td></tr></table></figure>\n<p>获取名字中大写字母A开头的所有人:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names [A (B</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Aidehua\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Aimini\"</span></span><br></pre></td></tr></table></figure>\n<p>获取名字中大写字母C到Z的所有人:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names [C [Z</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Gaodeng\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Toumas\"</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZRANGEBYLEX-key-min-max-LIMIT-offset-count\"><a href=\"#ZRANGEBYLEX-key-min-max-LIMIT-offset-count\" class=\"headerlink\" title=\"ZRANGEBYLEX key min max [LIMIT offset count]\"></a>ZRANGEBYLEX key min max [LIMIT offset count]</h2><blockquote>\n<p>起始版本：2.8.9<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>ZRANGEBYLEX 返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同。 在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行排序时,可以使用Redis中SortSet这种数据结构来处理。</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>是否必须</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZRANGEBYLEX</td>\n<td>是</td>\n<td>指令</td>\n</tr>\n<tr>\n<td>key</td>\n<td>是</td>\n<td>有序集合键名称</td>\n</tr>\n<tr>\n<td>min</td>\n<td>是</td>\n<td>字典中排序位置较小的成员,必须以”[“开头,或者以”(“开头,可使用”-“代替</td>\n</tr>\n<tr>\n<td>max</td>\n<td>是</td>\n<td>字典中排序位置较大的成员,必须以”[“开头,或者以”(“开头,可使用”+”代替</td>\n</tr>\n<tr>\n<td>LIMIT</td>\n<td>否</td>\n<td>返回结果是否分页,指令中包含LIMIT后offset、count必须输入</td>\n</tr>\n<tr>\n<td>offset</td>\n<td>否</td>\n<td>返回结果起始位置</td>\n</tr>\n<tr>\n<td>count</td>\n<td>否</td>\n<td>返回结果数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>分数必须相同, 如果有序集合中的成员分数有不一致的,返回的结果就不准。</li>\n<li>成员字符串作为二进制数组的字节数进行比较。</li>\n<li>默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。</li>\n<li>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。</li>\n<li>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。</li>\n<li>可以使用 “-“ 和 “+” 表示得分最小值和最大值</li>\n<li>“min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空</li>\n<li>与ZRANGEBYLEX获取顺序相反的指令是<a href=\"http://www.redis.cn/commands/zrevrangebylex.html\" target=\"_blank\" rel=\"noopener\">ZREVRANGEBYLEX</a>。</li>\n<li>源码中采用C语言中<code>memcmp()</code>函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠后。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>指定成员范围的元素列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>不要在分数不一致的SortSet集合中去使用 ZRANGEBYLEX 指令,因为获取的结果并不准确。</p>\n<ol>\n<li>获取所有值,可以使用 “-“ 和 “+” 表示得分最小值和最大值</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> a <span class=\"number\">0</span> aa <span class=\"number\">0</span> abc <span class=\"number\">0</span> apple <span class=\"number\">0</span> b <span class=\"number\">0</span> c <span class=\"number\">0</span> d <span class=\"number\">0</span> d1 <span class=\"number\">0</span> dd <span class=\"number\">0</span> dobble <span class=\"number\">0</span> z <span class=\"number\">0</span> z1</span><br><span class=\"line\">(integer) <span class=\"number\">12</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"> <span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"> <span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"> <span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"> <span class=\"number\">4</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"> <span class=\"number\">5</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"> <span class=\"number\">6</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"> <span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"> <span class=\"number\">8</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"> <span class=\"number\">9</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">12</span>) <span class=\"string\">\"z1\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>获取分页数据</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset - + LIMIT <span class=\"number\">0</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - + LIMIT <span class=\"number\">3</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"c\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>获取成员之间的元素<br>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。<br>“[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset [aa [c</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"c\"</span></span><br></pre></td></tr></table></figure>\n<p>“min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset [c [aa</span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>使用 “(“ 小于号获取成员之间的元素</p>\n<p>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。<br>返回成员结果集不会包含 “max” 和 “min” 成员。</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset [aa (c</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"b\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>ASCII码的影响</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> aBc</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"> <span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"> <span class=\"number\">2</span>) <span class=\"string\">\"aBc\"</span></span><br><span class=\"line\"> <span class=\"number\">3</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"> <span class=\"number\">4</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"> <span class=\"number\">5</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"> <span class=\"number\">6</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"> <span class=\"number\">7</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"> <span class=\"number\">8</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"> <span class=\"number\">9</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">12</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">13</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - + LIMIT <span class=\"number\">0</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"aBc\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"aa\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用场景示例\"><a href=\"#使用场景示例\" class=\"headerlink\" title=\"使用场景示例\"></a>使用场景示例</h4><ol>\n<li>电话号码排序</li>\n</ol>\n<p>我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13100111100</span> <span class=\"number\">0</span> <span class=\"number\">13110114300</span> <span class=\"number\">0</span> <span class=\"number\">13132110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13200111100</span> <span class=\"number\">0</span> <span class=\"number\">13210414300</span> <span class=\"number\">0</span> <span class=\"number\">13252110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13300111100</span> <span class=\"number\">0</span> <span class=\"number\">13310414300</span> <span class=\"number\">0</span> <span class=\"number\">13352110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>获取所有号码:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13100111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13110114300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13132110901\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">9</span>) <span class=\"string\">\"13352110901\"</span></span><br></pre></td></tr></table></figure>\n<p>获取132号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone [<span class=\"number\">132</span> (<span class=\"number\">133</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13252110901\"</span></span><br></pre></td></tr></table></figure>\n<p>获取132、133号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone [<span class=\"number\">132</span> (<span class=\"number\">134</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13352110901\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>姓名排序</li>\n</ol>\n<p>将名称存储到SortSet中:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd names <span class=\"number\">0</span> Toumas <span class=\"number\">0</span> Jake <span class=\"number\">0</span> Bluetuo <span class=\"number\">0</span> Gaodeng <span class=\"number\">0</span> Aimini <span class=\"number\">0</span> Aidehua </span><br><span class=\"line\">(integer) <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>获取所有人的名字:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Aidehua\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Aimini\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Bluetuo\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"Gaodeng\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"Toumas\"</span></span><br></pre></td></tr></table></figure>\n<p>获取名字中大写字母A开头的所有人:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names [A (B</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Aidehua\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Aimini\"</span></span><br></pre></td></tr></table></figure>\n<p>获取名字中大写字母C到Z的所有人:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names [C [Z</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Gaodeng\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Toumas\"</span></span><br></pre></td></tr></table></figure>\n"},{"title":"ZRANGE(zrange)","copyright":true,"date":"2020-03-31T05:32:31.000Z","keywords":"Redis命令,zrange","aside":"sorted_set","_content":"## ZRANGE key start stop [WITHSCORES] \n>起始版本：1.2.0<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。\n\n\n#### 说明:\n* 返回存储在有序集合key中的指定范围的元素。 返回的元素可以认为是按得分从最低到最高排列。 如果得分相同，将按字典排序。\n* 当你需要元素从最高分到最低分排列时，请参阅ZREVRANGE（相同的得分将使用字典倒序排序）。\n* 参数`start`和`stop`都是基于零的索引，即`0`是第一个元素，`1`是第二个元素，以此类推。 它们也可以是负数，表示从有序集合的末尾的偏移量，其中`-1`是有序集合的最后一个元素，`-2`是倒数第二个元素，等等。\n* `start`和`stop`都是**全包含的区间**，因此例如`ZRANGE myzset 0 1`将会返回有序集合的第一个和第二个元素。\n* 超出范围的索引不会产生错误。 如果`start`参数的值大于有序集合中的最大索引，或者`start > stop`，将会返回一个空列表。 如果`stop`的值大于有序集合的末尾，Redis会将其视为有序集合的最后一个元素。\n* 可以传递`WITHSCORES`选项，以便将元素的分数与元素一起返回。这样，返回的列表将包含`value1,score1,...,valueN,scoreN`，而不是`value1,...,valueN`。 客户端类库可以自由地返回更合适的数据类型（建议：具有值和得分的数组或记录）。\n\n#### 返回值\n\n**array-reply**：给定范围内的元素列表（如果指定了WITHSCORES选项，将同时返回它们的得分）。\n\n\n#### 示例\n\n```c\n127.0.0.1:6379> ZADD myzset 1 \"one\"\n(integer) 1\n127.0.0.1:6379> ZADD myzset 2 \"two\"\n(integer) 1\n127.0.0.1:6379> ZADD myzset 3 \"three\"\n(integer) 1\n127.0.0.1:6379> ZRANGE myzset 0 -1\n1) \"one\"\n2) \"two\"\n3) \"three\"\n127.0.0.1:6379> ZRANGE myzset 2 3\n1) \"three\"\n127.0.0.1:6379> ZRANGE myzset -2 -1\n1) \"two\"\n2) \"three\"\n127.0.0.1:6379> ZRANGE myzset 0 1 WITHSCORES\n1) \"one\"\n2) \"1\"\n3) \"two\"\n4) \"2\"\n```\n\n","source":"_posts/redis_command/sorted_set/zrange.md","raw":"---\n\ntitle: ZRANGE(zrange)\ncopyright: true\ndate: 2020-03-31 13:32:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zrange\naside: sorted_set\n\n---\n## ZRANGE key start stop [WITHSCORES] \n>起始版本：1.2.0<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。\n\n\n#### 说明:\n* 返回存储在有序集合key中的指定范围的元素。 返回的元素可以认为是按得分从最低到最高排列。 如果得分相同，将按字典排序。\n* 当你需要元素从最高分到最低分排列时，请参阅ZREVRANGE（相同的得分将使用字典倒序排序）。\n* 参数`start`和`stop`都是基于零的索引，即`0`是第一个元素，`1`是第二个元素，以此类推。 它们也可以是负数，表示从有序集合的末尾的偏移量，其中`-1`是有序集合的最后一个元素，`-2`是倒数第二个元素，等等。\n* `start`和`stop`都是**全包含的区间**，因此例如`ZRANGE myzset 0 1`将会返回有序集合的第一个和第二个元素。\n* 超出范围的索引不会产生错误。 如果`start`参数的值大于有序集合中的最大索引，或者`start > stop`，将会返回一个空列表。 如果`stop`的值大于有序集合的末尾，Redis会将其视为有序集合的最后一个元素。\n* 可以传递`WITHSCORES`选项，以便将元素的分数与元素一起返回。这样，返回的列表将包含`value1,score1,...,valueN,scoreN`，而不是`value1,...,valueN`。 客户端类库可以自由地返回更合适的数据类型（建议：具有值和得分的数组或记录）。\n\n#### 返回值\n\n**array-reply**：给定范围内的元素列表（如果指定了WITHSCORES选项，将同时返回它们的得分）。\n\n\n#### 示例\n\n```c\n127.0.0.1:6379> ZADD myzset 1 \"one\"\n(integer) 1\n127.0.0.1:6379> ZADD myzset 2 \"two\"\n(integer) 1\n127.0.0.1:6379> ZADD myzset 3 \"three\"\n(integer) 1\n127.0.0.1:6379> ZRANGE myzset 0 -1\n1) \"one\"\n2) \"two\"\n3) \"three\"\n127.0.0.1:6379> ZRANGE myzset 2 3\n1) \"three\"\n127.0.0.1:6379> ZRANGE myzset -2 -1\n1) \"two\"\n2) \"three\"\n127.0.0.1:6379> ZRANGE myzset 0 1 WITHSCORES\n1) \"one\"\n2) \"1\"\n3) \"two\"\n4) \"2\"\n```\n\n","slug":"redis_command/sorted_set/zrange","published":1,"updated":"2021-03-14T03:04:50.708Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv6004ahyjf6cli8w7r","content":"<h2 id=\"ZRANGE-key-start-stop-WITHSCORES\"><a href=\"#ZRANGE-key-start-stop-WITHSCORES\" class=\"headerlink\" title=\"ZRANGE key start stop [WITHSCORES]\"></a>ZRANGE key start stop [WITHSCORES]</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回存储在有序集合key中的指定范围的元素。 返回的元素可以认为是按得分从最低到最高排列。 如果得分相同，将按字典排序。</li>\n<li>当你需要元素从最高分到最低分排列时，请参阅ZREVRANGE（相同的得分将使用字典倒序排序）。</li>\n<li>参数<code>start</code>和<code>stop</code>都是基于零的索引，即<code>0</code>是第一个元素，<code>1</code>是第二个元素，以此类推。 它们也可以是负数，表示从有序集合的末尾的偏移量，其中<code>-1</code>是有序集合的最后一个元素，<code>-2</code>是倒数第二个元素，等等。</li>\n<li><code>start</code>和<code>stop</code>都是<strong>全包含的区间</strong>，因此例如<code>ZRANGE myzset 0 1</code>将会返回有序集合的第一个和第二个元素。</li>\n<li>超出范围的索引不会产生错误。 如果<code>start</code>参数的值大于有序集合中的最大索引，或者<code>start &gt; stop</code>，将会返回一个空列表。 如果<code>stop</code>的值大于有序集合的末尾，Redis会将其视为有序集合的最后一个元素。</li>\n<li>可以传递<code>WITHSCORES</code>选项，以便将元素的分数与元素一起返回。这样，返回的列表将包含<code>value1,score1,...,valueN,scoreN</code>，而不是<code>value1,...,valueN</code>。 客户端类库可以自由地返回更合适的数据类型（建议：具有值和得分的数组或记录）。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>：给定范围内的元素列表（如果指定了WITHSCORES选项，将同时返回它们的得分）。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZRANGE myzset <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZRANGE myzset <span class=\"number\">-2</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"2\"</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZRANGE-key-start-stop-WITHSCORES\"><a href=\"#ZRANGE-key-start-stop-WITHSCORES\" class=\"headerlink\" title=\"ZRANGE key start stop [WITHSCORES]\"></a>ZRANGE key start stop [WITHSCORES]</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回存储在有序集合key中的指定范围的元素。 返回的元素可以认为是按得分从最低到最高排列。 如果得分相同，将按字典排序。</li>\n<li>当你需要元素从最高分到最低分排列时，请参阅ZREVRANGE（相同的得分将使用字典倒序排序）。</li>\n<li>参数<code>start</code>和<code>stop</code>都是基于零的索引，即<code>0</code>是第一个元素，<code>1</code>是第二个元素，以此类推。 它们也可以是负数，表示从有序集合的末尾的偏移量，其中<code>-1</code>是有序集合的最后一个元素，<code>-2</code>是倒数第二个元素，等等。</li>\n<li><code>start</code>和<code>stop</code>都是<strong>全包含的区间</strong>，因此例如<code>ZRANGE myzset 0 1</code>将会返回有序集合的第一个和第二个元素。</li>\n<li>超出范围的索引不会产生错误。 如果<code>start</code>参数的值大于有序集合中的最大索引，或者<code>start &gt; stop</code>，将会返回一个空列表。 如果<code>stop</code>的值大于有序集合的末尾，Redis会将其视为有序集合的最后一个元素。</li>\n<li>可以传递<code>WITHSCORES</code>选项，以便将元素的分数与元素一起返回。这样，返回的列表将包含<code>value1,score1,...,valueN,scoreN</code>，而不是<code>value1,...,valueN</code>。 客户端类库可以自由地返回更合适的数据类型（建议：具有值和得分的数组或记录）。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>：给定范围内的元素列表（如果指定了WITHSCORES选项，将同时返回它们的得分）。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZRANGE myzset <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZRANGE myzset <span class=\"number\">-2</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"2\"</span></span><br></pre></td></tr></table></figure>\n"},{"title":"ZREM(zrem)","copyright":true,"date":"2020-03-31T05:27:31.000Z","keywords":"Redis命令,zrem","aside":"sorted_set","_content":"## ZREM key member [member ...] \n>起始版本：1.2.0<br/>时间复杂度：O(M*log(N)) N为已排序集合中的元素数，M为要删除的元素数。  \n\n\n#### 说明:\n* 删除集合元素，当key存在，但是其不是有序集合类型，就返回一个错误。\n\n#### 返回值\n\n**integer-reply**：返回的是从有序集合中删除的成员个数，不包括不存在的成员。\n\n\n#### 历史\n\n\\>= 2.4: 接受多个元素。在2.4之前的版本中，每次只能删除一个成员。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREM myzset \"two\"\n(integer) 1\nredis> ZRANGE myzset 0 -1 WITHSCORES\n1) \"one\"\n2) \"1\"\n3) \"three\"\n4) \"3\"\nredis> \n```","source":"_posts/redis_command/sorted_set/zrem.md","raw":"---\n\ntitle: ZREM(zrem)\ncopyright: true\ndate: 2020-03-31 13:27:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zrem\naside: sorted_set\n\n---\n## ZREM key member [member ...] \n>起始版本：1.2.0<br/>时间复杂度：O(M*log(N)) N为已排序集合中的元素数，M为要删除的元素数。  \n\n\n#### 说明:\n* 删除集合元素，当key存在，但是其不是有序集合类型，就返回一个错误。\n\n#### 返回值\n\n**integer-reply**：返回的是从有序集合中删除的成员个数，不包括不存在的成员。\n\n\n#### 历史\n\n\\>= 2.4: 接受多个元素。在2.4之前的版本中，每次只能删除一个成员。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREM myzset \"two\"\n(integer) 1\nredis> ZRANGE myzset 0 -1 WITHSCORES\n1) \"one\"\n2) \"1\"\n3) \"three\"\n4) \"3\"\nredis> \n```","slug":"redis_command/sorted_set/zrem","published":1,"updated":"2021-03-14T03:04:50.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv7004chyjf5qcgens1","content":"<h2 id=\"ZREM-key-member-member-…\"><a href=\"#ZREM-key-member-member-…\" class=\"headerlink\" title=\"ZREM key member [member …]\"></a>ZREM key member [member …]</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(M*log(N)) N为已排序集合中的元素数，M为要删除的元素数。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>删除集合元素，当key存在，但是其不是有序集合类型，就返回一个错误。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：返回的是从有序集合中删除的成员个数，不包括不存在的成员。</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>>= 2.4: 接受多个元素。在2.4之前的版本中，每次只能删除一个成员。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREM myzset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZREM-key-member-member-…\"><a href=\"#ZREM-key-member-member-…\" class=\"headerlink\" title=\"ZREM key member [member …]\"></a>ZREM key member [member …]</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(M*log(N)) N为已排序集合中的元素数，M为要删除的元素数。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>删除集合元素，当key存在，但是其不是有序集合类型，就返回一个错误。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：返回的是从有序集合中删除的成员个数，不包括不存在的成员。</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>>= 2.4: 接受多个元素。在2.4之前的版本中，每次只能删除一个成员。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREM myzset <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZRANGEBYSCORE(zrangebyscore)","copyright":true,"date":"2020-03-31T05:29:31.000Z","keywords":"Redis命令,zrangebyscore","aside":"sorted_set","_content":"## ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] \n>起始版本：1.0.5<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。\n\n\n#### 说明:\n* 如果M是常量（比如，用limit总是请求前10个元素），你可以认为是O(log(N))。\n\n* 返回key的有序集合中的分数在min和max之间的所有元素（包括分数等于max或者min的元素）。元素被认为是从低分到高分排序的。\n\n* 具有相同分数的元素按字典序排列（这个根据redis对有序集合实现的情况而定，并不需要进一步计算）。\n\n* 可选的LIMIT参数指定返回结果的数量及区间（类似SQL中SELECT LIMIT offset, count）。注意，如果offset太大，定位offset就可能遍历整个有序集合，这会增加O(N)的复杂度。\n\n* 可选参数WITHSCORES会返回元素和其分数，而不只是元素。这个选项在redis2.0之后的版本都可用。\n\n* min和max可以是-inf和+inf，这样一来，你就可以在不知道有序集的最低和最高score值的情况下，使用ZRANGEBYSCORE这类命令。\n\n* 默认情况下，区间的取值使用闭区间(小于等于或大于等于)，你也可以通过给参数前增加(符号来使用可选的开区间(小于或大于)。\n\n  ```c\n  //返回所有符合条件1 < score <= 5的成员\n  ZRANGEBYSCORE zset (1 5\n                      \n  //返回所有符合条件5 < score < 10 的成员。                \n  ZRANGEBYSCORE zset (5 (10\n  ```\n\n#### 返回值\n\n**array-reply** 指定分数范围的元素列表(也可以返回他们的分数)。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZRANGEBYSCORE myzset -inf +inf\n1) \"one\"\n2) \"two\"\n3) \"three\"\nredis> ZRANGEBYSCORE myzset 1 2\n1) \"one\"\n2) \"two\"\nredis> ZRANGEBYSCORE myzset (1 2\n1) \"two\"\nredis> ZRANGEBYSCORE myzset (1 (2\n(empty list or set)\nredis> \n\n```","source":"_posts/redis_command/sorted_set/zrangebyscore.md","raw":"---\n\ntitle: ZRANGEBYSCORE(zrangebyscore)\ncopyright: true\ndate: 2020-03-31 13:29:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zrangebyscore\naside: sorted_set\n\n---\n## ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] \n>起始版本：1.0.5<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。\n\n\n#### 说明:\n* 如果M是常量（比如，用limit总是请求前10个元素），你可以认为是O(log(N))。\n\n* 返回key的有序集合中的分数在min和max之间的所有元素（包括分数等于max或者min的元素）。元素被认为是从低分到高分排序的。\n\n* 具有相同分数的元素按字典序排列（这个根据redis对有序集合实现的情况而定，并不需要进一步计算）。\n\n* 可选的LIMIT参数指定返回结果的数量及区间（类似SQL中SELECT LIMIT offset, count）。注意，如果offset太大，定位offset就可能遍历整个有序集合，这会增加O(N)的复杂度。\n\n* 可选参数WITHSCORES会返回元素和其分数，而不只是元素。这个选项在redis2.0之后的版本都可用。\n\n* min和max可以是-inf和+inf，这样一来，你就可以在不知道有序集的最低和最高score值的情况下，使用ZRANGEBYSCORE这类命令。\n\n* 默认情况下，区间的取值使用闭区间(小于等于或大于等于)，你也可以通过给参数前增加(符号来使用可选的开区间(小于或大于)。\n\n  ```c\n  //返回所有符合条件1 < score <= 5的成员\n  ZRANGEBYSCORE zset (1 5\n                      \n  //返回所有符合条件5 < score < 10 的成员。                \n  ZRANGEBYSCORE zset (5 (10\n  ```\n\n#### 返回值\n\n**array-reply** 指定分数范围的元素列表(也可以返回他们的分数)。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZRANGEBYSCORE myzset -inf +inf\n1) \"one\"\n2) \"two\"\n3) \"three\"\nredis> ZRANGEBYSCORE myzset 1 2\n1) \"one\"\n2) \"two\"\nredis> ZRANGEBYSCORE myzset (1 2\n1) \"two\"\nredis> ZRANGEBYSCORE myzset (1 (2\n(empty list or set)\nredis> \n\n```","slug":"redis_command/sorted_set/zrangebyscore","published":1,"updated":"2021-03-14T03:04:50.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv8004fhyjfgejr4dva","content":"<h2 id=\"ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count\"><a href=\"#ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count\" class=\"headerlink\" title=\"ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\"></a>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</h2><blockquote>\n<p>起始版本：1.0.5<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>如果M是常量（比如，用limit总是请求前10个元素），你可以认为是O(log(N))。</p>\n</li>\n<li><p>返回key的有序集合中的分数在min和max之间的所有元素（包括分数等于max或者min的元素）。元素被认为是从低分到高分排序的。</p>\n</li>\n<li><p>具有相同分数的元素按字典序排列（这个根据redis对有序集合实现的情况而定，并不需要进一步计算）。</p>\n</li>\n<li><p>可选的LIMIT参数指定返回结果的数量及区间（类似SQL中SELECT LIMIT offset, count）。注意，如果offset太大，定位offset就可能遍历整个有序集合，这会增加O(N)的复杂度。</p>\n</li>\n<li><p>可选参数WITHSCORES会返回元素和其分数，而不只是元素。这个选项在redis2.0之后的版本都可用。</p>\n</li>\n<li><p>min和max可以是-inf和+inf，这样一来，你就可以在不知道有序集的最低和最高score值的情况下，使用ZRANGEBYSCORE这类命令。</p>\n</li>\n<li><p>默认情况下，区间的取值使用闭区间(小于等于或大于等于)，你也可以通过给参数前增加(符号来使用可选的开区间(小于或大于)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回所有符合条件1 &lt; score &lt;= 5的成员</span></span><br><span class=\"line\"><span class=\"function\">ZRANGEBYSCORE <span class=\"title\">zset</span> <span class=\"params\">(<span class=\"number\">1</span> <span class=\"number\">5</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"comment\">//返回所有符合条件5 &lt; score &lt; 10 的成员。                </span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">ZRANGEBYSCORE zset (<span class=\"number\">5</span> (<span class=\"number\">10</span></span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong> 指定分数范围的元素列表(也可以返回他们的分数)。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANGEBYSCORE myzset -inf +inf</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt; ZRANGEBYSCORE myzset <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt; <span class=\"function\">ZRANGEBYSCORE <span class=\"title\">myzset</span> <span class=\"params\">(<span class=\"number\">1</span> <span class=\"number\">2</span></span></span></span><br><span class=\"line\">1) \"two\"</span><br><span class=\"line\">redis&gt; <span class=\"function\">ZRANGEBYSCORE <span class=\"title\">myzset</span> <span class=\"params\">(<span class=\"number\">1</span> (<span class=\"number\">2</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">redis&gt;</span></span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count\"><a href=\"#ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count\" class=\"headerlink\" title=\"ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\"></a>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</h2><blockquote>\n<p>起始版本：1.0.5<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>如果M是常量（比如，用limit总是请求前10个元素），你可以认为是O(log(N))。</p>\n</li>\n<li><p>返回key的有序集合中的分数在min和max之间的所有元素（包括分数等于max或者min的元素）。元素被认为是从低分到高分排序的。</p>\n</li>\n<li><p>具有相同分数的元素按字典序排列（这个根据redis对有序集合实现的情况而定，并不需要进一步计算）。</p>\n</li>\n<li><p>可选的LIMIT参数指定返回结果的数量及区间（类似SQL中SELECT LIMIT offset, count）。注意，如果offset太大，定位offset就可能遍历整个有序集合，这会增加O(N)的复杂度。</p>\n</li>\n<li><p>可选参数WITHSCORES会返回元素和其分数，而不只是元素。这个选项在redis2.0之后的版本都可用。</p>\n</li>\n<li><p>min和max可以是-inf和+inf，这样一来，你就可以在不知道有序集的最低和最高score值的情况下，使用ZRANGEBYSCORE这类命令。</p>\n</li>\n<li><p>默认情况下，区间的取值使用闭区间(小于等于或大于等于)，你也可以通过给参数前增加(符号来使用可选的开区间(小于或大于)。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回所有符合条件1 &lt; score &lt;= 5的成员</span></span><br><span class=\"line\"><span class=\"function\">ZRANGEBYSCORE <span class=\"title\">zset</span> <span class=\"params\">(<span class=\"number\">1</span> <span class=\"number\">5</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"comment\">//返回所有符合条件5 &lt; score &lt; 10 的成员。                </span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">ZRANGEBYSCORE zset (<span class=\"number\">5</span> (<span class=\"number\">10</span></span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong> 指定分数范围的元素列表(也可以返回他们的分数)。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANGEBYSCORE myzset -inf +inf</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\">redis&gt; ZRANGEBYSCORE myzset <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt; <span class=\"function\">ZRANGEBYSCORE <span class=\"title\">myzset</span> <span class=\"params\">(<span class=\"number\">1</span> <span class=\"number\">2</span></span></span></span><br><span class=\"line\">1) \"two\"</span><br><span class=\"line\">redis&gt; <span class=\"function\">ZRANGEBYSCORE <span class=\"title\">myzset</span> <span class=\"params\">(<span class=\"number\">1</span> (<span class=\"number\">2</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">redis&gt;</span></span></span><br></pre></td></tr></table></figure>"},{"title":"ZRANK(zrank)","copyright":true,"date":"2020-03-31T05:28:31.000Z","keywords":"Redis命令,zrank","aside":"sorted_set","_content":"## ZRANK key member \n>起始版本：2.0.0<br/>时间复杂度：O(log(N))  \n\n\n#### 说明:\n* 返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列。排名以0为底，也就是说，score值最小的成员排名为0。\n* 使用ZREVRANK命令可以获得成员按score值递减(从大到小)排列的排名。\n\n#### 返回值\n\n如果member是有序集key的成员，返回**integer-reply**：member的排名。\n如果member不是有序集key的成员，返回**bulk-string-reply**: nil。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZRANK myzset \"three\"\n(integer) 2\nredis> ZRANK myzset \"four\"\n(nil)\nredis> \n```","source":"_posts/redis_command/sorted_set/zrank.md","raw":"---\n\ntitle: ZRANK(zrank)\ncopyright: true\ndate: 2020-03-31 13:28:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zrank\naside: sorted_set\n\n---\n## ZRANK key member \n>起始版本：2.0.0<br/>时间复杂度：O(log(N))  \n\n\n#### 说明:\n* 返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列。排名以0为底，也就是说，score值最小的成员排名为0。\n* 使用ZREVRANK命令可以获得成员按score值递减(从大到小)排列的排名。\n\n#### 返回值\n\n如果member是有序集key的成员，返回**integer-reply**：member的排名。\n如果member不是有序集key的成员，返回**bulk-string-reply**: nil。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZRANK myzset \"three\"\n(integer) 2\nredis> ZRANK myzset \"four\"\n(nil)\nredis> \n```","slug":"redis_command/sorted_set/zrank","published":1,"updated":"2021-03-14T03:04:50.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpv8004hhyjfun9ohvka","content":"<h2 id=\"ZRANK-key-member\"><a href=\"#ZRANK-key-member\" class=\"headerlink\" title=\"ZRANK key member\"></a>ZRANK key member</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(log(N))  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列。排名以0为底，也就是说，score值最小的成员排名为0。</li>\n<li>使用ZREVRANK命令可以获得成员按score值递减(从大到小)排列的排名。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>如果member是有序集key的成员，返回<strong>integer-reply</strong>：member的排名。<br>如果member不是有序集key的成员，返回<strong>bulk-string-reply</strong>: nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANK myzset <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZRANK myzset <span class=\"string\">\"four\"</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZRANK-key-member\"><a href=\"#ZRANK-key-member\" class=\"headerlink\" title=\"ZRANK key member\"></a>ZRANK key member</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(log(N))  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列。排名以0为底，也就是说，score值最小的成员排名为0。</li>\n<li>使用ZREVRANK命令可以获得成员按score值递减(从大到小)排列的排名。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>如果member是有序集key的成员，返回<strong>integer-reply</strong>：member的排名。<br>如果member不是有序集key的成员，返回<strong>bulk-string-reply</strong>: nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANK myzset <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZRANK myzset <span class=\"string\">\"four\"</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZREMRANGEBYLEX(zremrangebylex)","copyright":true,"date":"2020-03-31T05:26:31.000Z","keywords":"Redis命令,zremrangebylex","aside":"sorted_set","_content":"## ZREMRANGEBYLEX key min max \n>起始版本：2.8.9<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。\n\n\n#### 说明:\n* ZREMRANGEBYLEX 删除名称按字典由低到高排序成员之间所有成员。\n* 不要在成员分数不同的有序集合中使用此命令, 因为它是基于分数一致的有序集合设计的,如果使用,会导致删除的结果不正确。\n* 待删除的有序集合中,分数最好相同,否则删除结果会不正常。\n\n```c\nZREMRANGEBYLEX key min max\n```\n\n| 指令           | 是否必须 | 说明                                                         |\n| -------------- | -------- | ------------------------------------------------------------ |\n| ZREMRANGEBYLEX | 是       | 指令                                                         |\n| key            | 是       | 有序集合键名称                                               |\n| min            | 是       | 字典中排序位置较小的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"-\"代替 |\n| max            | 是       | 字典中排序位置较大的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"+\"代替 |\n\n- 有序集合中分数必须相同! 如果有序集合中的成员分数有不一致的,结果就不准。\n- 成员顺序是按成员字符串作为二进制数组的字节数进行比较。\n- 默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。\n- 源码中采用C语言中` memcmp() `函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠后。\n- 默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “max”和 “min”\n- “max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。\n- 可以使用 “-“ 和 “+” 表示得分最小值和最大值\n- “max”和 “min” 不能反, “max” 放后面 “min”放前面会删除不了元素\n\n#### 返回值\n\n删除元素的个数。\n#### 示例\n**注意：**不要在分数不一致的SortSet集合中去使用 ZREMRANGEBYLEX 指令,因为获取的结果并不准确。\n\n1. 删除所有元素\n可以使用 “-“ 和 “+” 表示最小值和最大值\n```c\nredis> zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1\n   (integer) 12\n   redis> ZRANGEBYLEX zset + -\n    1) \"a\"\n    2) \"aa\"\n    3) \"abc\"\n    4) \"apple\"\n    5) \"b\"\n    6) \"c\"\n    7) \"d\"\n    8) \"d1\"\n    9) \"dd\"\n   10) \"dobble\"\n   11) \"z\"\n   12) \"z1\"\n   redis> ZREMRANGEBYLEX zset - +\n   (integer) 7\n   redis> ZRANGEBYLEX zset - +\n   (empty list or set)\n```\n2. 按名称删除某个元素\n\n下面是删除d1这个元素\n```c\nredis> zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1\n(integer) 12\nredis> ZRANGEBYLEX zset - +\n1) \"a\"\n2) \"aa\"\n3) \"abc\"\n4) \"apple\"\n5) \"b\"\n6) \"c\"\n7) \"d\"\n8) \"d1\"\n9) \"dd\"\n10) \"dobble\"\n11) \"z\"\n12) \"z1\"\nredis> ZREMRANGEBYLEX zset [d1 (dd\n(integer) 1\nredis> ZRANGEBYLEX zset - +\n1) \"a\"\n2) \"aa\"\n3) \"abc\"\n4) \"apple\"\n5) \"b\"\n6) \"c\"\n7) \"d\"\n8) \"dd\"\n9) \"dobble\"\n10) \"z\"\n11) \"z1\"\n```\n3. 按名称删除成员之间的元素,包含”max” 和 “min”成员\n\n默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。“[” 符号与成员之间不能有空格, 删除成员包含参数 “min” 和 “max” 。\n```c\nredis> ZRANGEBYLEX zset - +\n 1) \"a\"\n 2) \"aa\"\n 3) \"abc\"\n 4) \"apple\"\n 5) \"b\"\n 6) \"c\"\n 7) \"d\"\n 8) \"dd\"\n 9) \"dobble\"\n10) \"z\"\n11) \"z1\"\nredis> ZREMRANGEBYLEX zset [a [apple\n(integer) 4\nredis> ZRANGEBYLEX zset - +\n1) \"b\"\n2) \"c\"\n3) \"d\"\n4) \"dd\"\n5) \"dobble\"\n6) \"z\"\n7) \"z1\"\n```\n“min” 和 “max” 不能反, “min” 放前面 “max”放后面会导致无法删除元素\n```c\nredis> ZREMRANGEBYLEX zset [dobble [d\n(integer) 0\n```\n4. 按名称删除成员之间的元素,不包含”max” 和 “min”成员\n\n“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。\n删除成员不会包含 “max” 和 “min” 成员。\n```c\nredis> ZRANGEBYLEX zset - +\n1) \"b\"\n2) \"c\"\n3) \"d\"\n4) \"dd\"\n5) \"dobble\"\n6) \"z\"\n7) \"z1\"     \nredis> ZREMRANGEBYLEX zset (d (dobble\n(integer) 1\nredis> ZRANGEBYLEX zset - +\n1) \"b\"\n2) \"c\"\n3) \"d\"\n4) \"dobble\"\n5) \"z\"\n6) \"z1\"\n```","source":"_posts/redis_command/sorted_set/zremrangebylex.md","raw":"---\n\ntitle: ZREMRANGEBYLEX(zremrangebylex)\ncopyright: true\ndate: 2020-03-31 13:26:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zremrangebylex\naside: sorted_set\n\n---\n## ZREMRANGEBYLEX key min max \n>起始版本：2.8.9<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。\n\n\n#### 说明:\n* ZREMRANGEBYLEX 删除名称按字典由低到高排序成员之间所有成员。\n* 不要在成员分数不同的有序集合中使用此命令, 因为它是基于分数一致的有序集合设计的,如果使用,会导致删除的结果不正确。\n* 待删除的有序集合中,分数最好相同,否则删除结果会不正常。\n\n```c\nZREMRANGEBYLEX key min max\n```\n\n| 指令           | 是否必须 | 说明                                                         |\n| -------------- | -------- | ------------------------------------------------------------ |\n| ZREMRANGEBYLEX | 是       | 指令                                                         |\n| key            | 是       | 有序集合键名称                                               |\n| min            | 是       | 字典中排序位置较小的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"-\"代替 |\n| max            | 是       | 字典中排序位置较大的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"+\"代替 |\n\n- 有序集合中分数必须相同! 如果有序集合中的成员分数有不一致的,结果就不准。\n- 成员顺序是按成员字符串作为二进制数组的字节数进行比较。\n- 默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。\n- 源码中采用C语言中` memcmp() `函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠后。\n- 默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “max”和 “min”\n- “max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。\n- 可以使用 “-“ 和 “+” 表示得分最小值和最大值\n- “max”和 “min” 不能反, “max” 放后面 “min”放前面会删除不了元素\n\n#### 返回值\n\n删除元素的个数。\n#### 示例\n**注意：**不要在分数不一致的SortSet集合中去使用 ZREMRANGEBYLEX 指令,因为获取的结果并不准确。\n\n1. 删除所有元素\n可以使用 “-“ 和 “+” 表示最小值和最大值\n```c\nredis> zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1\n   (integer) 12\n   redis> ZRANGEBYLEX zset + -\n    1) \"a\"\n    2) \"aa\"\n    3) \"abc\"\n    4) \"apple\"\n    5) \"b\"\n    6) \"c\"\n    7) \"d\"\n    8) \"d1\"\n    9) \"dd\"\n   10) \"dobble\"\n   11) \"z\"\n   12) \"z1\"\n   redis> ZREMRANGEBYLEX zset - +\n   (integer) 7\n   redis> ZRANGEBYLEX zset - +\n   (empty list or set)\n```\n2. 按名称删除某个元素\n\n下面是删除d1这个元素\n```c\nredis> zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1\n(integer) 12\nredis> ZRANGEBYLEX zset - +\n1) \"a\"\n2) \"aa\"\n3) \"abc\"\n4) \"apple\"\n5) \"b\"\n6) \"c\"\n7) \"d\"\n8) \"d1\"\n9) \"dd\"\n10) \"dobble\"\n11) \"z\"\n12) \"z1\"\nredis> ZREMRANGEBYLEX zset [d1 (dd\n(integer) 1\nredis> ZRANGEBYLEX zset - +\n1) \"a\"\n2) \"aa\"\n3) \"abc\"\n4) \"apple\"\n5) \"b\"\n6) \"c\"\n7) \"d\"\n8) \"dd\"\n9) \"dobble\"\n10) \"z\"\n11) \"z1\"\n```\n3. 按名称删除成员之间的元素,包含”max” 和 “min”成员\n\n默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。“[” 符号与成员之间不能有空格, 删除成员包含参数 “min” 和 “max” 。\n```c\nredis> ZRANGEBYLEX zset - +\n 1) \"a\"\n 2) \"aa\"\n 3) \"abc\"\n 4) \"apple\"\n 5) \"b\"\n 6) \"c\"\n 7) \"d\"\n 8) \"dd\"\n 9) \"dobble\"\n10) \"z\"\n11) \"z1\"\nredis> ZREMRANGEBYLEX zset [a [apple\n(integer) 4\nredis> ZRANGEBYLEX zset - +\n1) \"b\"\n2) \"c\"\n3) \"d\"\n4) \"dd\"\n5) \"dobble\"\n6) \"z\"\n7) \"z1\"\n```\n“min” 和 “max” 不能反, “min” 放前面 “max”放后面会导致无法删除元素\n```c\nredis> ZREMRANGEBYLEX zset [dobble [d\n(integer) 0\n```\n4. 按名称删除成员之间的元素,不包含”max” 和 “min”成员\n\n“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。\n删除成员不会包含 “max” 和 “min” 成员。\n```c\nredis> ZRANGEBYLEX zset - +\n1) \"b\"\n2) \"c\"\n3) \"d\"\n4) \"dd\"\n5) \"dobble\"\n6) \"z\"\n7) \"z1\"     \nredis> ZREMRANGEBYLEX zset (d (dobble\n(integer) 1\nredis> ZRANGEBYLEX zset - +\n1) \"b\"\n2) \"c\"\n3) \"d\"\n4) \"dobble\"\n5) \"z\"\n6) \"z1\"\n```","slug":"redis_command/sorted_set/zremrangebylex","published":1,"updated":"2021-03-14T03:04:50.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpva004khyjfxx6o44zy","content":"<h2 id=\"ZREMRANGEBYLEX-key-min-max\"><a href=\"#ZREMRANGEBYLEX-key-min-max\" class=\"headerlink\" title=\"ZREMRANGEBYLEX key min max\"></a>ZREMRANGEBYLEX key min max</h2><blockquote>\n<p>起始版本：2.8.9<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>ZREMRANGEBYLEX 删除名称按字典由低到高排序成员之间所有成员。</li>\n<li>不要在成员分数不同的有序集合中使用此命令, 因为它是基于分数一致的有序集合设计的,如果使用,会导致删除的结果不正确。</li>\n<li>待删除的有序集合中,分数最好相同,否则删除结果会不正常。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZREMRANGEBYLEX key min max</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>是否必须</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZREMRANGEBYLEX</td>\n<td>是</td>\n<td>指令</td>\n</tr>\n<tr>\n<td>key</td>\n<td>是</td>\n<td>有序集合键名称</td>\n</tr>\n<tr>\n<td>min</td>\n<td>是</td>\n<td>字典中排序位置较小的成员,必须以”[“开头,或者以”(“开头,可使用”-“代替</td>\n</tr>\n<tr>\n<td>max</td>\n<td>是</td>\n<td>字典中排序位置较大的成员,必须以”[“开头,或者以”(“开头,可使用”+”代替</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>有序集合中分数必须相同! 如果有序集合中的成员分数有不一致的,结果就不准。</li>\n<li>成员顺序是按成员字符串作为二进制数组的字节数进行比较。</li>\n<li>默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。</li>\n<li>源码中采用C语言中<code>memcmp()</code>函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠后。</li>\n<li>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “max”和 “min”</li>\n<li>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。</li>\n<li>可以使用 “-“ 和 “+” 表示得分最小值和最大值</li>\n<li>“max”和 “min” 不能反, “max” 放后面 “min”放前面会删除不了元素</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>删除元素的个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p><strong>注意：</strong>不要在分数不一致的SortSet集合中去使用 ZREMRANGEBYLEX 指令,因为获取的结果并不准确。</p>\n<ol>\n<li><p>删除所有元素<br>可以使用 “-“ 和 “+” 表示最小值和最大值</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> a <span class=\"number\">0</span> aa <span class=\"number\">0</span> abc <span class=\"number\">0</span> apple <span class=\"number\">0</span> b <span class=\"number\">0</span> c <span class=\"number\">0</span> d <span class=\"number\">0</span> d1 <span class=\"number\">0</span> dd <span class=\"number\">0</span> dobble <span class=\"number\">0</span> z <span class=\"number\">0</span> z1</span><br><span class=\"line\">   (integer) <span class=\"number\">12</span></span><br><span class=\"line\">   redis&gt; ZRANGEBYLEX zset + -</span><br><span class=\"line\">    <span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\">    <span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\">    <span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\">    <span class=\"number\">4</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\">    <span class=\"number\">5</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\">    <span class=\"number\">6</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\">    <span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\">    <span class=\"number\">8</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\">    <span class=\"number\">9</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\">   <span class=\"number\">10</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\">   <span class=\"number\">11</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\">   <span class=\"number\">12</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\">   redis&gt; ZREMRANGEBYLEX zset - +</span><br><span class=\"line\">   (integer) <span class=\"number\">7</span></span><br><span class=\"line\">   redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\">   (empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>按名称删除某个元素</p>\n</li>\n</ol>\n<p>下面是删除d1这个元素<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> a <span class=\"number\">0</span> aa <span class=\"number\">0</span> abc <span class=\"number\">0</span> apple <span class=\"number\">0</span> b <span class=\"number\">0</span> c <span class=\"number\">0</span> d <span class=\"number\">0</span> d1 <span class=\"number\">0</span> dd <span class=\"number\">0</span> dobble <span class=\"number\">0</span> z <span class=\"number\">0</span> z1</span><br><span class=\"line\">(integer) <span class=\"number\">12</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"><span class=\"number\">9</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">12</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\">redis&gt; ZREMRANGEBYLEX zset [d1 (dd</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">9</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"z1\"</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>按名称删除成员之间的元素,包含”max” 和 “min”成员</li>\n</ol>\n<p>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。“[” 符号与成员之间不能有空格, 删除成员包含参数 “min” 和 “max” 。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"> <span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"> <span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"> <span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"> <span class=\"number\">4</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"> <span class=\"number\">5</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"> <span class=\"number\">6</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"> <span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"> <span class=\"number\">8</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"> <span class=\"number\">9</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\">redis&gt; ZREMRANGEBYLEX zset [a [apple</span><br><span class=\"line\">(integer) <span class=\"number\">4</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"z1\"</span></span><br></pre></td></tr></table></figure></p>\n<p>“min” 和 “max” 不能反, “min” 放前面 “max”放后面会导致无法删除元素<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREMRANGEBYLEX zset [dobble [d</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>按名称删除成员之间的元素,不包含”max” 和 “min”成员</li>\n</ol>\n<p>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。<br>删除成员不会包含 “max” 和 “min” 成员。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"z1\"</span>     </span><br><span class=\"line\">redis&gt; <span class=\"function\">ZREMRANGEBYLEX <span class=\"title\">zset</span> <span class=\"params\">(d (dobble</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(integer) <span class=\"number\">1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">redis&gt; ZRANGEBYLEX zset - +</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"number\">1</span>) <span class=\"string\">\"b\"</span></span></span></span><br><span class=\"line\">2) \"c\"</span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"z1\"</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZREMRANGEBYLEX-key-min-max\"><a href=\"#ZREMRANGEBYLEX-key-min-max\" class=\"headerlink\" title=\"ZREMRANGEBYLEX key min max\"></a>ZREMRANGEBYLEX key min max</h2><blockquote>\n<p>起始版本：2.8.9<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>ZREMRANGEBYLEX 删除名称按字典由低到高排序成员之间所有成员。</li>\n<li>不要在成员分数不同的有序集合中使用此命令, 因为它是基于分数一致的有序集合设计的,如果使用,会导致删除的结果不正确。</li>\n<li>待删除的有序集合中,分数最好相同,否则删除结果会不正常。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZREMRANGEBYLEX key min max</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>是否必须</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZREMRANGEBYLEX</td>\n<td>是</td>\n<td>指令</td>\n</tr>\n<tr>\n<td>key</td>\n<td>是</td>\n<td>有序集合键名称</td>\n</tr>\n<tr>\n<td>min</td>\n<td>是</td>\n<td>字典中排序位置较小的成员,必须以”[“开头,或者以”(“开头,可使用”-“代替</td>\n</tr>\n<tr>\n<td>max</td>\n<td>是</td>\n<td>字典中排序位置较大的成员,必须以”[“开头,或者以”(“开头,可使用”+”代替</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>有序集合中分数必须相同! 如果有序集合中的成员分数有不一致的,结果就不准。</li>\n<li>成员顺序是按成员字符串作为二进制数组的字节数进行比较。</li>\n<li>默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。</li>\n<li>源码中采用C语言中<code>memcmp()</code>函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠后。</li>\n<li>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “max”和 “min”</li>\n<li>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。</li>\n<li>可以使用 “-“ 和 “+” 表示得分最小值和最大值</li>\n<li>“max”和 “min” 不能反, “max” 放后面 “min”放前面会删除不了元素</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>删除元素的个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p><strong>注意：</strong>不要在分数不一致的SortSet集合中去使用 ZREMRANGEBYLEX 指令,因为获取的结果并不准确。</p>\n<ol>\n<li><p>删除所有元素<br>可以使用 “-“ 和 “+” 表示最小值和最大值</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> a <span class=\"number\">0</span> aa <span class=\"number\">0</span> abc <span class=\"number\">0</span> apple <span class=\"number\">0</span> b <span class=\"number\">0</span> c <span class=\"number\">0</span> d <span class=\"number\">0</span> d1 <span class=\"number\">0</span> dd <span class=\"number\">0</span> dobble <span class=\"number\">0</span> z <span class=\"number\">0</span> z1</span><br><span class=\"line\">   (integer) <span class=\"number\">12</span></span><br><span class=\"line\">   redis&gt; ZRANGEBYLEX zset + -</span><br><span class=\"line\">    <span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\">    <span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\">    <span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\">    <span class=\"number\">4</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\">    <span class=\"number\">5</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\">    <span class=\"number\">6</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\">    <span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\">    <span class=\"number\">8</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\">    <span class=\"number\">9</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\">   <span class=\"number\">10</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\">   <span class=\"number\">11</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\">   <span class=\"number\">12</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\">   redis&gt; ZREMRANGEBYLEX zset - +</span><br><span class=\"line\">   (integer) <span class=\"number\">7</span></span><br><span class=\"line\">   redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\">   (empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>按名称删除某个元素</p>\n</li>\n</ol>\n<p>下面是删除d1这个元素<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> a <span class=\"number\">0</span> aa <span class=\"number\">0</span> abc <span class=\"number\">0</span> apple <span class=\"number\">0</span> b <span class=\"number\">0</span> c <span class=\"number\">0</span> d <span class=\"number\">0</span> d1 <span class=\"number\">0</span> dd <span class=\"number\">0</span> dobble <span class=\"number\">0</span> z <span class=\"number\">0</span> z1</span><br><span class=\"line\">(integer) <span class=\"number\">12</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"><span class=\"number\">9</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">12</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\">redis&gt; ZREMRANGEBYLEX zset [d1 (dd</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">9</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"z1\"</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>按名称删除成员之间的元素,包含”max” 和 “min”成员</li>\n</ol>\n<p>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。“[” 符号与成员之间不能有空格, 删除成员包含参数 “min” 和 “max” 。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"> <span class=\"number\">1</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\"> <span class=\"number\">2</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"> <span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"> <span class=\"number\">4</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"> <span class=\"number\">5</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"> <span class=\"number\">6</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"> <span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"> <span class=\"number\">8</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"> <span class=\"number\">9</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\">redis&gt; ZREMRANGEBYLEX zset [a [apple</span><br><span class=\"line\">(integer) <span class=\"number\">4</span></span><br><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"z1\"</span></span><br></pre></td></tr></table></figure></p>\n<p>“min” 和 “max” 不能反, “min” 放前面 “max”放后面会导致无法删除元素<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREMRANGEBYLEX zset [dobble [d</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>按名称删除成员之间的元素,不包含”max” 和 “min”成员</li>\n</ol>\n<p>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。<br>删除成员不会包含 “max” 和 “min” 成员。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX zset - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"z1\"</span>     </span><br><span class=\"line\">redis&gt; <span class=\"function\">ZREMRANGEBYLEX <span class=\"title\">zset</span> <span class=\"params\">(d (dobble</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(integer) <span class=\"number\">1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">redis&gt; ZRANGEBYLEX zset - +</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"number\">1</span>) <span class=\"string\">\"b\"</span></span></span></span><br><span class=\"line\">2) \"c\"</span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"z1\"</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"ZREMRANGEBYRANK(zremrangebyrank)","copyright":true,"date":"2020-03-31T05:25:31.000Z","keywords":"Redis命令,zremrangebyrank","aside":"sorted_set","_content":"## ZREMRANGEBYRANK key start stop \n>起始版本：2.0.0<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。\n\n\n#### 说明:\n* 移除有序集key中，指定排名(rank)区间内的所有成员。下标参数start和stop都以0为底，0处是分数最小的那个元素。这些索引也可是负数，表示位移从最高分处开始数。例如，-1是分数最高的元素，-2是分数第二高的，依次类推。\n\n#### 返回值\n\n**integer-reply**: 被移除成员的数量。\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREMRANGEBYRANK myzset 0 1\n(integer) 2\nredis> ZRANGE myzset 0 -1 WITHSCORES\n1) \"three\"\n2) \"3\"\nredis>\n```","source":"_posts/redis_command/sorted_set/zremrangebyrank.md","raw":"---\n\ntitle: ZREMRANGEBYRANK(zremrangebyrank)\ncopyright: true\ndate: 2020-03-31 13:25:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zremrangebyrank\naside: sorted_set\n\n---\n## ZREMRANGEBYRANK key start stop \n>起始版本：2.0.0<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。\n\n\n#### 说明:\n* 移除有序集key中，指定排名(rank)区间内的所有成员。下标参数start和stop都以0为底，0处是分数最小的那个元素。这些索引也可是负数，表示位移从最高分处开始数。例如，-1是分数最高的元素，-2是分数第二高的，依次类推。\n\n#### 返回值\n\n**integer-reply**: 被移除成员的数量。\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREMRANGEBYRANK myzset 0 1\n(integer) 2\nredis> ZRANGE myzset 0 -1 WITHSCORES\n1) \"three\"\n2) \"3\"\nredis>\n```","slug":"redis_command/sorted_set/zremrangebyrank","published":1,"updated":"2021-03-14T03:04:50.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvc004mhyjf2qh32yex","content":"<h2 id=\"ZREMRANGEBYRANK-key-start-stop\"><a href=\"#ZREMRANGEBYRANK-key-start-stop\" class=\"headerlink\" title=\"ZREMRANGEBYRANK key start stop\"></a>ZREMRANGEBYRANK key start stop</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>移除有序集key中，指定排名(rank)区间内的所有成员。下标参数start和stop都以0为底，0处是分数最小的那个元素。这些索引也可是负数，表示位移从最高分处开始数。例如，-1是分数最高的元素，-2是分数第二高的，依次类推。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 被移除成员的数量。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREMRANGEBYRANK myzset <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZREMRANGEBYRANK-key-start-stop\"><a href=\"#ZREMRANGEBYRANK-key-start-stop\" class=\"headerlink\" title=\"ZREMRANGEBYRANK key start stop\"></a>ZREMRANGEBYRANK key start stop</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>移除有序集key中，指定排名(rank)区间内的所有成员。下标参数start和stop都以0为底，0处是分数最小的那个元素。这些索引也可是负数，表示位移从最高分处开始数。例如，-1是分数最高的元素，-2是分数第二高的，依次类推。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 被移除成员的数量。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREMRANGEBYRANK myzset <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZREVRANGE(zrevrange)","copyright":true,"date":"2020-03-31T05:23:31.000Z","keywords":"Redis命令,zrevrange","aside":"sorted_set","_content":"## ZREVRANGE key start stop [WITHSCORES] \n>起始版本：1.2.0<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。\n\n\n#### 说明:\n* 返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列。具有相同score值的成员按字典序的反序排列。 除了成员按score值递减的次序排列这一点外，ZREVRANGE命令的其他方面和ZRANGE命令一样。\n\n#### 返回值\n\n\n**array-reply**: 指定范围的元素列表(可选是否含有分数)。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREVRANGE myzset 0 -1\n1) \"three\"\n2) \"two\"\n3) \"one\"\nredis> ZREVRANGE myzset 2 3\n1) \"one\"\nredis> ZREVRANGE myzset -2 -1\n1) \"two\"\n2) \"one\"\nredis> \n```","source":"_posts/redis_command/sorted_set/zrevrange.md","raw":"---\n\ntitle: ZREVRANGE(zrevrange)\ncopyright: true\ndate: 2020-03-31 13:23:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zrevrange\naside: sorted_set\n\n---\n## ZREVRANGE key start stop [WITHSCORES] \n>起始版本：1.2.0<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。\n\n\n#### 说明:\n* 返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列。具有相同score值的成员按字典序的反序排列。 除了成员按score值递减的次序排列这一点外，ZREVRANGE命令的其他方面和ZRANGE命令一样。\n\n#### 返回值\n\n\n**array-reply**: 指定范围的元素列表(可选是否含有分数)。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREVRANGE myzset 0 -1\n1) \"three\"\n2) \"two\"\n3) \"one\"\nredis> ZREVRANGE myzset 2 3\n1) \"one\"\nredis> ZREVRANGE myzset -2 -1\n1) \"two\"\n2) \"one\"\nredis> \n```","slug":"redis_command/sorted_set/zrevrange","published":1,"updated":"2021-03-14T03:04:50.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvd004phyjfn1kz2z9m","content":"<h2 id=\"ZREVRANGE-key-start-stop-WITHSCORES\"><a href=\"#ZREVRANGE-key-start-stop-WITHSCORES\" class=\"headerlink\" title=\"ZREVRANGE key start stop [WITHSCORES]\"></a>ZREVRANGE key start stop [WITHSCORES]</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列。具有相同score值的成员按字典序的反序排列。 除了成员按score值递减的次序排列这一点外，ZREVRANGE命令的其他方面和ZRANGE命令一样。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 指定范围的元素列表(可选是否含有分数)。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGE myzset <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGE myzset <span class=\"number\">-2</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZREVRANGE-key-start-stop-WITHSCORES\"><a href=\"#ZREVRANGE-key-start-stop-WITHSCORES\" class=\"headerlink\" title=\"ZREVRANGE key start stop [WITHSCORES]\"></a>ZREVRANGE key start stop [WITHSCORES]</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列。具有相同score值的成员按字典序的反序排列。 除了成员按score值递减的次序排列这一点外，ZREVRANGE命令的其他方面和ZRANGE命令一样。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 指定范围的元素列表(可选是否含有分数)。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGE myzset <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGE myzset <span class=\"number\">-2</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZREMRANGEBYSCORE(zremrangebyscore)","copyright":true,"date":"2020-03-31T05:24:31.000Z","keywords":"Redis命令,zremrangebyscore","aside":"sorted_set","_content":"## ZREMRANGEBYSCORE key min max \n>起始版本：1.2.0<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。\n\n\n#### 说明:\n* 移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员。 自版本2.1.6开始，score值等于min或max的成员也可以不包括在内，语法请参见ZRANGEBYSCORE命令。\n\n#### 返回值\n\n**integer-reply**: 删除的元素的个数。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREMRANGEBYSCORE myzset -inf (2\n(integer) 1\nredis> ZRANGE myzset 0 -1 WITHSCORES\n1) \"two\"\n2) \"2\"\n3) \"three\"\n4) \"3\"\nredis> \n```","source":"_posts/redis_command/sorted_set/zremrangebyscore.md","raw":"---\n\ntitle: ZREMRANGEBYSCORE(zremrangebyscore)\ncopyright: true\ndate: 2020-03-31 13:24:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zremrangebyscore\naside: sorted_set\n\n---\n## ZREMRANGEBYSCORE key min max \n>起始版本：1.2.0<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。\n\n\n#### 说明:\n* 移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员。 自版本2.1.6开始，score值等于min或max的成员也可以不包括在内，语法请参见ZRANGEBYSCORE命令。\n\n#### 返回值\n\n**integer-reply**: 删除的元素的个数。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREMRANGEBYSCORE myzset -inf (2\n(integer) 1\nredis> ZRANGE myzset 0 -1 WITHSCORES\n1) \"two\"\n2) \"2\"\n3) \"three\"\n4) \"3\"\nredis> \n```","slug":"redis_command/sorted_set/zremrangebyscore","published":1,"updated":"2021-03-14T03:04:50.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpve004rhyjf500csmsp","content":"<h2 id=\"ZREMRANGEBYSCORE-key-min-max\"><a href=\"#ZREMRANGEBYSCORE-key-min-max\" class=\"headerlink\" title=\"ZREMRANGEBYSCORE key min max\"></a>ZREMRANGEBYSCORE key min max</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员。 自版本2.1.6开始，score值等于min或max的成员也可以不包括在内，语法请参见ZRANGEBYSCORE命令。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 删除的元素的个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREMRANGEBYSCORE myzset -inf (<span class=\"number\">2</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZREMRANGEBYSCORE-key-min-max\"><a href=\"#ZREMRANGEBYSCORE-key-min-max\" class=\"headerlink\" title=\"ZREMRANGEBYSCORE key min max\"></a>ZREMRANGEBYSCORE key min max</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为操作移除的元素数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员。 自版本2.1.6开始，score值等于min或max的成员也可以不包括在内，语法请参见ZRANGEBYSCORE命令。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 删除的元素的个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREMRANGEBYSCORE myzset -inf (<span class=\"number\">2</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZRANGE myzset <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZREVRANGEBYSCORE(zrevrangebyscore)","copyright":true,"date":"2020-03-31T05:22:31.000Z","keywords":"Redis命令,zrevrangebyscore","aside":"sorted_set","_content":"## ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] \n>起始版本：2.2.0<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。 \n\n\n#### 说明:\n* ZREVRANGEBYSCORE 返回有序集合中指定分数区间内的成员，分数由高到低排序。\n\n```c\nZREVRANGEBYSCORE key max min WITHSCORES LIMIT offset count\n```\n\n| 指令             | 是否必须 | 说明                                                    |\n| ---------------- | -------- | ------------------------------------------------------- |\n| ZREVRANGEBYSCORE | 是       | 指令                                                    |\n| key              | 是       | 有序集合键名称                                          |\n| max              | 是       | 最大分数值,可使用\"+inf\"代替                             |\n| min              | 是       | 最小分数值,可使用\"-inf\"代替                             |\n| WITHSCORES       | 否       | 将成员分数一并返回                                      |\n| LIMIT            | 否       | 返回结果是否分页,指令中包含LIMIT后offset、count必须输入 |\n| offset           | 否       | 返回结果起始位置                                        |\n| count            | 否       | 返回结果数量                                            |\n\n**提示:**\n\n- `\"max\"` 和 `\"min\"`参数前可以加 `\"(\"` 符号作为开头表示小于, `\"(\"` 符号与成员之间不能有空格\n- 可以使用 `\"+inf\"` 和 `\"-inf\"` 表示得分最大值和最小值\n- `\"max\"` 和 `\"min\"` 不能反, `\"max\"` 放后面 `\"min\"`放前面会导致返回结果为空\n- 计算成员之间的成员数量不加 `\"(\"` 符号时,参数 `\"min\"` 和 `\"max\"` 的位置也计算在内。\n- `ZREVRANGEBYSCORE`集合中按得分从高到底排序,所以`\"max\"`在前面,`\"min\"`在后面, `ZRANGEBYSCORE`集合中按得分从底到高排序,所以`\"min\"`在前面,`\"max\"`在后面。\n\n#### 返回值\n\n指定分数范围的元素列表。\n\n#### 示例\n\n1. 按分数倒序返回成员\n\n\"+inf\" 或者 \"-inf\" 来表示记录中最大值和最小值。 \"(\" 左括号来表示小于某个值。目前只支持小于操作的 \"(\" 左括号, 右括号(大于)目前还不能支持。\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREVRANGEBYSCORE myzset +inf -inf\n1) \"three\"\n2) \"two\"\n3) \"one\"\nredis> ZREVRANGEBYSCORE myzset 2 1\n1) \"two\"\n2) \"one\"\nredis> ZREVRANGEBYSCORE myzset 2 (1\n1) \"two\"\nredis> ZREVRANGEBYSCORE myzset (2 (1\n(empty list or set)\nredis> \n```\n2. 按分数倒序返回成员以及分数\n\nZREVRANGEBYSCORE 指令中, 还可以使用WITHSCORES 关键字来要求返回成员列表以及分数。\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREVRANGEBYSCORE myzset +inf -inf WITHSCORES\n1) \"three\"\n2) \"3\"\n3) \"two\"\n4) \"2\"\n5) \"three\"\n6) \"1\"\nredis> ZREVRANGEBYSCORE myzset 2 1 WITHSCORES\n1) \"two\"\n2) \"2\"\n3) \"one\"\n4) \"1\"\nredis> ZREVRANGEBYSCORE myzset 2 (1\n1) \"two\"\nredis> ZREVRANGEBYSCORE myzset (2 (1\n(empty list or set)\nredis> \n```\n3. 分页返回数据\n\n可以通过 LIMIT 对满足条件的成员列表进行分页。一般会配合 \"+inf\" 或者 \"-inf\" 来表示最大值和最小值。 下面的\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREVRANGEBYSCORE myzset +inf (2 WITHSCORES LIMIT 0 1 \n1) \"three\"\n2) \"3\"\nredis> ZREVRANGEBYSCORE myzset +inf (2 WITHSCORES LIMIT 2 3\n(empty list or set)\nredis> \n```","source":"_posts/redis_command/sorted_set/zrevrangebyscore.md","raw":"---\n\ntitle: ZREVRANGEBYSCORE(zrevrangebyscore)\ncopyright: true\ndate: 2020-03-31 13:22:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zrevrangebyscore\naside: sorted_set\n\n---\n## ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] \n>起始版本：2.2.0<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。 \n\n\n#### 说明:\n* ZREVRANGEBYSCORE 返回有序集合中指定分数区间内的成员，分数由高到低排序。\n\n```c\nZREVRANGEBYSCORE key max min WITHSCORES LIMIT offset count\n```\n\n| 指令             | 是否必须 | 说明                                                    |\n| ---------------- | -------- | ------------------------------------------------------- |\n| ZREVRANGEBYSCORE | 是       | 指令                                                    |\n| key              | 是       | 有序集合键名称                                          |\n| max              | 是       | 最大分数值,可使用\"+inf\"代替                             |\n| min              | 是       | 最小分数值,可使用\"-inf\"代替                             |\n| WITHSCORES       | 否       | 将成员分数一并返回                                      |\n| LIMIT            | 否       | 返回结果是否分页,指令中包含LIMIT后offset、count必须输入 |\n| offset           | 否       | 返回结果起始位置                                        |\n| count            | 否       | 返回结果数量                                            |\n\n**提示:**\n\n- `\"max\"` 和 `\"min\"`参数前可以加 `\"(\"` 符号作为开头表示小于, `\"(\"` 符号与成员之间不能有空格\n- 可以使用 `\"+inf\"` 和 `\"-inf\"` 表示得分最大值和最小值\n- `\"max\"` 和 `\"min\"` 不能反, `\"max\"` 放后面 `\"min\"`放前面会导致返回结果为空\n- 计算成员之间的成员数量不加 `\"(\"` 符号时,参数 `\"min\"` 和 `\"max\"` 的位置也计算在内。\n- `ZREVRANGEBYSCORE`集合中按得分从高到底排序,所以`\"max\"`在前面,`\"min\"`在后面, `ZRANGEBYSCORE`集合中按得分从底到高排序,所以`\"min\"`在前面,`\"max\"`在后面。\n\n#### 返回值\n\n指定分数范围的元素列表。\n\n#### 示例\n\n1. 按分数倒序返回成员\n\n\"+inf\" 或者 \"-inf\" 来表示记录中最大值和最小值。 \"(\" 左括号来表示小于某个值。目前只支持小于操作的 \"(\" 左括号, 右括号(大于)目前还不能支持。\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREVRANGEBYSCORE myzset +inf -inf\n1) \"three\"\n2) \"two\"\n3) \"one\"\nredis> ZREVRANGEBYSCORE myzset 2 1\n1) \"two\"\n2) \"one\"\nredis> ZREVRANGEBYSCORE myzset 2 (1\n1) \"two\"\nredis> ZREVRANGEBYSCORE myzset (2 (1\n(empty list or set)\nredis> \n```\n2. 按分数倒序返回成员以及分数\n\nZREVRANGEBYSCORE 指令中, 还可以使用WITHSCORES 关键字来要求返回成员列表以及分数。\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREVRANGEBYSCORE myzset +inf -inf WITHSCORES\n1) \"three\"\n2) \"3\"\n3) \"two\"\n4) \"2\"\n5) \"three\"\n6) \"1\"\nredis> ZREVRANGEBYSCORE myzset 2 1 WITHSCORES\n1) \"two\"\n2) \"2\"\n3) \"one\"\n4) \"1\"\nredis> ZREVRANGEBYSCORE myzset 2 (1\n1) \"two\"\nredis> ZREVRANGEBYSCORE myzset (2 (1\n(empty list or set)\nredis> \n```\n3. 分页返回数据\n\n可以通过 LIMIT 对满足条件的成员列表进行分页。一般会配合 \"+inf\" 或者 \"-inf\" 来表示最大值和最小值。 下面的\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREVRANGEBYSCORE myzset +inf (2 WITHSCORES LIMIT 0 1 \n1) \"three\"\n2) \"3\"\nredis> ZREVRANGEBYSCORE myzset +inf (2 WITHSCORES LIMIT 2 3\n(empty list or set)\nredis> \n```","slug":"redis_command/sorted_set/zrevrangebyscore","published":1,"updated":"2021-03-14T03:04:50.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvf004uhyjfipa9atr1","content":"<h2 id=\"ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count\"><a href=\"#ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count\" class=\"headerlink\" title=\"ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]\"></a>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>ZREVRANGEBYSCORE 返回有序集合中指定分数区间内的成员，分数由高到低排序。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZREVRANGEBYSCORE key max min WITHSCORES LIMIT offset count</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>是否必须</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZREVRANGEBYSCORE</td>\n<td>是</td>\n<td>指令</td>\n</tr>\n<tr>\n<td>key</td>\n<td>是</td>\n<td>有序集合键名称</td>\n</tr>\n<tr>\n<td>max</td>\n<td>是</td>\n<td>最大分数值,可使用”+inf”代替</td>\n</tr>\n<tr>\n<td>min</td>\n<td>是</td>\n<td>最小分数值,可使用”-inf”代替</td>\n</tr>\n<tr>\n<td>WITHSCORES</td>\n<td>否</td>\n<td>将成员分数一并返回</td>\n</tr>\n<tr>\n<td>LIMIT</td>\n<td>否</td>\n<td>返回结果是否分页,指令中包含LIMIT后offset、count必须输入</td>\n</tr>\n<tr>\n<td>offset</td>\n<td>否</td>\n<td>返回结果起始位置</td>\n</tr>\n<tr>\n<td>count</td>\n<td>否</td>\n<td>返回结果数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>&quot;max&quot;</code> 和 <code>&quot;min&quot;</code>参数前可以加 <code>&quot;(&quot;</code> 符号作为开头表示小于, <code>&quot;(&quot;</code> 符号与成员之间不能有空格</li>\n<li>可以使用 <code>&quot;+inf&quot;</code> 和 <code>&quot;-inf&quot;</code> 表示得分最大值和最小值</li>\n<li><code>&quot;max&quot;</code> 和 <code>&quot;min&quot;</code> 不能反, <code>&quot;max&quot;</code> 放后面 <code>&quot;min&quot;</code>放前面会导致返回结果为空</li>\n<li>计算成员之间的成员数量不加 <code>&quot;(&quot;</code> 符号时,参数 <code>&quot;min&quot;</code> 和 <code>&quot;max&quot;</code> 的位置也计算在内。</li>\n<li><code>ZREVRANGEBYSCORE</code>集合中按得分从高到底排序,所以<code>&quot;max&quot;</code>在前面,<code>&quot;min&quot;</code>在后面, <code>ZRANGEBYSCORE</code>集合中按得分从底到高排序,所以<code>&quot;min&quot;</code>在前面,<code>&quot;max&quot;</code>在后面。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>指定分数范围的元素列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><ol>\n<li>按分数倒序返回成员</li>\n</ol>\n<p>“+inf” 或者 “-inf” 来表示记录中最大值和最小值。 “(“ 左括号来表示小于某个值。目前只支持小于操作的 “(“ 左括号, 右括号(大于)目前还不能支持。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset +inf -inf</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset <span class=\"number\">2</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset <span class=\"number\">2</span> (<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYSCORE <span class=\"title\">myzset</span> <span class=\"params\">(<span class=\"number\">2</span> (<span class=\"number\">1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">redis&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>按分数倒序返回成员以及分数</li>\n</ol>\n<p>ZREVRANGEBYSCORE 指令中, 还可以使用WITHSCORES 关键字来要求返回成员列表以及分数。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset +inf -inf WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset <span class=\"number\">2</span> <span class=\"number\">1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset <span class=\"number\">2</span> (<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYSCORE <span class=\"title\">myzset</span> <span class=\"params\">(<span class=\"number\">2</span> (<span class=\"number\">1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">redis&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>分页返回数据</li>\n</ol>\n<p>可以通过 LIMIT 对满足条件的成员列表进行分页。一般会配合 “+inf” 或者 “-inf” 来表示最大值和最小值。 下面的<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset +inf (<span class=\"number\">2</span> WITHSCORES LIMIT <span class=\"number\">0</span> <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset +inf (<span class=\"number\">2</span> WITHSCORES LIMIT <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count\"><a href=\"#ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count\" class=\"headerlink\" title=\"ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]\"></a>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>ZREVRANGEBYSCORE 返回有序集合中指定分数区间内的成员，分数由高到低排序。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZREVRANGEBYSCORE key max min WITHSCORES LIMIT offset count</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>是否必须</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZREVRANGEBYSCORE</td>\n<td>是</td>\n<td>指令</td>\n</tr>\n<tr>\n<td>key</td>\n<td>是</td>\n<td>有序集合键名称</td>\n</tr>\n<tr>\n<td>max</td>\n<td>是</td>\n<td>最大分数值,可使用”+inf”代替</td>\n</tr>\n<tr>\n<td>min</td>\n<td>是</td>\n<td>最小分数值,可使用”-inf”代替</td>\n</tr>\n<tr>\n<td>WITHSCORES</td>\n<td>否</td>\n<td>将成员分数一并返回</td>\n</tr>\n<tr>\n<td>LIMIT</td>\n<td>否</td>\n<td>返回结果是否分页,指令中包含LIMIT后offset、count必须输入</td>\n</tr>\n<tr>\n<td>offset</td>\n<td>否</td>\n<td>返回结果起始位置</td>\n</tr>\n<tr>\n<td>count</td>\n<td>否</td>\n<td>返回结果数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>&quot;max&quot;</code> 和 <code>&quot;min&quot;</code>参数前可以加 <code>&quot;(&quot;</code> 符号作为开头表示小于, <code>&quot;(&quot;</code> 符号与成员之间不能有空格</li>\n<li>可以使用 <code>&quot;+inf&quot;</code> 和 <code>&quot;-inf&quot;</code> 表示得分最大值和最小值</li>\n<li><code>&quot;max&quot;</code> 和 <code>&quot;min&quot;</code> 不能反, <code>&quot;max&quot;</code> 放后面 <code>&quot;min&quot;</code>放前面会导致返回结果为空</li>\n<li>计算成员之间的成员数量不加 <code>&quot;(&quot;</code> 符号时,参数 <code>&quot;min&quot;</code> 和 <code>&quot;max&quot;</code> 的位置也计算在内。</li>\n<li><code>ZREVRANGEBYSCORE</code>集合中按得分从高到底排序,所以<code>&quot;max&quot;</code>在前面,<code>&quot;min&quot;</code>在后面, <code>ZRANGEBYSCORE</code>集合中按得分从底到高排序,所以<code>&quot;min&quot;</code>在前面,<code>&quot;max&quot;</code>在后面。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>指定分数范围的元素列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><ol>\n<li>按分数倒序返回成员</li>\n</ol>\n<p>“+inf” 或者 “-inf” 来表示记录中最大值和最小值。 “(“ 左括号来表示小于某个值。目前只支持小于操作的 “(“ 左括号, 右括号(大于)目前还不能支持。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset +inf -inf</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset <span class=\"number\">2</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset <span class=\"number\">2</span> (<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYSCORE <span class=\"title\">myzset</span> <span class=\"params\">(<span class=\"number\">2</span> (<span class=\"number\">1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">redis&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>按分数倒序返回成员以及分数</li>\n</ol>\n<p>ZREVRANGEBYSCORE 指令中, 还可以使用WITHSCORES 关键字来要求返回成员列表以及分数。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset +inf -inf WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset <span class=\"number\">2</span> <span class=\"number\">1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"2\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"1\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset <span class=\"number\">2</span> (<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYSCORE <span class=\"title\">myzset</span> <span class=\"params\">(<span class=\"number\">2</span> (<span class=\"number\">1</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">redis&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>分页返回数据</li>\n</ol>\n<p>可以通过 LIMIT 对满足条件的成员列表进行分页。一般会配合 “+inf” 或者 “-inf” 来表示最大值和最小值。 下面的<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset +inf (<span class=\"number\">2</span> WITHSCORES LIMIT <span class=\"number\">0</span> <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"3\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYSCORE myzset +inf (<span class=\"number\">2</span> WITHSCORES LIMIT <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"ZREVRANGEBYLEX(zrevrangebylex)","copyright":true,"date":"2020-03-31T05:30:31.000Z","keywords":"Redis命令,zrevrangebylex","aside":"sorted_set","_content":"## ZREVRANGEBYLEX key max min [LIMIT offset count] \n>起始版本：2.8.9<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。 \n\n\n#### 说明:\n* ZREVRANGEBYLEX 返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同。\n* 在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行倒序排列时,可以使用Redis中SortSet这种数据结构来处理。\n\n```c\nZREVRANGEBYLEX key max min [LIMIT offset count]\n```\n\n| 指令           | 是否必须 | 说明                                                         |\n| -------------- | -------- | ------------------------------------------------------------ |\n| ZREVRANGEBYLEX | 是       | 指令                                                         |\n| key            | 是       | 有序集合键名称                                               |\n| max            | 是       | 字典中排序位置较大的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"+\"代替 |\n| min            | 是       | 字典中排序位置较小的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"-\"代替 |\n| LIMIT          | 否       | 返回结果是否分页,指令中包含LIMIT后offset、count必须输入      |\n| offset         | 否       | 返回结果起始位置                                             |\n| count          | 否       | 返回结果数量                                                 |\n\n- 分数必须相同! 如果有序集合中的成员分数有不一致的,返回的结果就不准。\n- 成员字符串作为二进制数组的字节数进行比较。\n- 默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。\n- 源码中采用C语言中` memcmp() `函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠前。\n- 默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “max”和 “min”\n- “max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。\n- 可以使用 “-“ 和 “+” 表示得分最小值和最大值\n- “max”和 “min” 不能反, “max” 放后面 “min”放前面会导致返回结果为空\n- 与ZREVRANGEBYLEX获取顺序相反的指令是ZREVRANGEBYLEX\n\n#### 返回值\n\n指定成员范围的元素列表。\n\n#### 示例\n\n不要在分数不一致的SortSet集合中去使用 ZREVRANGEBYLEX 指令,因为获取的结果并不准确。\n1. 获取所有值\n\n可以使用 “-“ 和 “+” 表示最小值和最大值\n```c\nredis> zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1\n(integer) 12\nredis> ZREVRANGEBYLEX zset + -\n 1) \"z1\"\n 2) \"z\"\n 3) \"dobble\"\n 4) \"dd\"\n 5) \"d1\"\n 6) \"d\"\n 7) \"c\"\n 8) \"b\"\n 9) \"apple\"\n10) \"abc\"\n11) \"aa\"\n12) \"a\"\n```\n2. 获取分页数据\n\n```c\nredis> ZREVRANGEBYLEX zset + - LIMIT 0 3\n1) \"z1\"\n2) \"z\"\n3) \"dobble\"\nredis> ZREVRANGEBYLEX zset + - LIMIT 3 3\n1) \"dd\"\n2) \"d1\"\n3) \"d\"\n```\n3. 获取成员之间的元素\n\n默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。\n“[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。\n```c\nredis> ZREVRANGEBYLEX zset [c [aa\n1) \"c\"\n2) \"b\"\n3) \"apple\"\n4) \"abc\"\n5) \"aa\"\n```\n“min” 和 “max” 不能反, “min” 放前面 “max”放后面会导致返回结果为空\n```c\nredis> ZREVRANGEBYLEX zset [aa [c\n(empty list or set)\n```\n4. 使用 “(“ 小于号获取成员之间的元素\n\n“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。\n返回成员结果集不会包含 “max” 和 “min” 成员。\n```c\nredis> ZREVRANGEBYLEX zset (c [aa\n1) \"b\"\n2) \"apple\"\n3) \"abc\"\n4) \"aa\"\n```\n5. ASCII码的影响\n\n成员字符串作为二进制数组的字节数进行比较。\n默认是以ASCII字符集的顺序进行排列。\n如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。\n```c\nredis> zadd zset 0 dB\n(integer) 1\nredis> ZREVRANGEBYLEX zset + -\n 1) \"z1\"\n 2) \"z\"\n 3) \"dobble\"\n 4) \"dd\"\n 5) \"dB\"\n 6) \"d1\"\n 7) \"d\"\n 8) \"c\"\n 9) \"b\"\n10) \"apple\"\n11) \"abc\"\n12) \"aa\"\n13) \"a\"\nredis> ZREVRANGEBYLEX zset + - limit 0 3\n1) \"z1\"\n2) \"z\"\n3) \"dobble\"\nredis> ZREVRANGEBYLEX zset + - limit 3 3\n1) \"dd\"\n2) \"dB\"\n3) \"d1\"\n```\n#### 使用场景示例\n1. 电话号码排序\n\n我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:\n```c\nredis> zadd phone 0 13100111100 0 13110114300 0 13132110901 \n(integer) 3\nredis> zadd phone 0 13200111100 0 13210414300 0 13252110901 \n(integer) 3\nredis> zadd phone 0 13300111100 0 13310414300 0 13352110901 \n(integer) 3\n```\n从大到小获取所有号码:\n```c\nredis> ZREVRANGEBYLEX phone + -\n1) \"13352110901\"\n2) \"13310414300\"\n3) \"13300111100\"\n4) \"13252110901\"\n5) \"13210414300\"\n6) \"13200111100\"\n7) \"13132110901\"\n8) \"13110114300\"\n9) \"13100111100\"\n```\n获取132号段:\n```c\nredis> ZREVRANGEBYLEX phone (133 [132\n1) \"13252110901\"\n2) \"13210414300\"\n3) \"13200111100\"\n```\n获取132、133号段:\n```c\nredis> ZREVRANGEBYLEX phone (134 [132\n1) \"13352110901\"\n2) \"13310414300\"\n3) \"13300111100\"\n4) \"13252110901\"\n5) \"13210414300\"\n6) \"13200111100\"\n```\n2. 姓名排序\n\n将名称存储到SortSet中:\n\n```c\nredis> zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua \n(integer) 6\n```\n获取所有人的名字倒序排列:\n```c\nredis> ZREVRANGEBYLEX names + -\n1) \"Toumas\"\n2) \"Jake\"\n3) \"Gaodeng\"\n4) \"Bluetuo\"\n5) \"Aimini\"\n6) \"Aidehua\"\n```\n获取名字中大写字母A开头的所有人:\n```c\nredis> ZREVRANGEBYLEX names (B [A\n1) \"Aimini\"\n2) \"Aidehua\"\n```\n获取名字中大写字母C到Z的所有人:\n```c\nredis> ZREVRANGEBYLEX names [Z [C\n1) \"Toumas\"\n2) \"Jake\"\n3) \"Gaodeng\"\n```","source":"_posts/redis_command/sorted_set/zrevrangebylex.md","raw":"---\n\ntitle: ZREVRANGEBYLEX(zrevrangebylex)\ncopyright: true\ndate: 2020-03-31 13:30:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zrevrangebylex\naside: sorted_set\n---\n## ZREVRANGEBYLEX key max min [LIMIT offset count] \n>起始版本：2.8.9<br/>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。 \n\n\n#### 说明:\n* ZREVRANGEBYLEX 返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同。\n* 在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行倒序排列时,可以使用Redis中SortSet这种数据结构来处理。\n\n```c\nZREVRANGEBYLEX key max min [LIMIT offset count]\n```\n\n| 指令           | 是否必须 | 说明                                                         |\n| -------------- | -------- | ------------------------------------------------------------ |\n| ZREVRANGEBYLEX | 是       | 指令                                                         |\n| key            | 是       | 有序集合键名称                                               |\n| max            | 是       | 字典中排序位置较大的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"+\"代替 |\n| min            | 是       | 字典中排序位置较小的成员,必须以\"[\"开头,或者以\"(\"开头,可使用\"-\"代替 |\n| LIMIT          | 否       | 返回结果是否分页,指令中包含LIMIT后offset、count必须输入      |\n| offset         | 否       | 返回结果起始位置                                             |\n| count          | 否       | 返回结果数量                                                 |\n\n- 分数必须相同! 如果有序集合中的成员分数有不一致的,返回的结果就不准。\n- 成员字符串作为二进制数组的字节数进行比较。\n- 默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。\n- 源码中采用C语言中` memcmp() `函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠前。\n- 默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “max”和 “min”\n- “max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。\n- 可以使用 “-“ 和 “+” 表示得分最小值和最大值\n- “max”和 “min” 不能反, “max” 放后面 “min”放前面会导致返回结果为空\n- 与ZREVRANGEBYLEX获取顺序相反的指令是ZREVRANGEBYLEX\n\n#### 返回值\n\n指定成员范围的元素列表。\n\n#### 示例\n\n不要在分数不一致的SortSet集合中去使用 ZREVRANGEBYLEX 指令,因为获取的结果并不准确。\n1. 获取所有值\n\n可以使用 “-“ 和 “+” 表示最小值和最大值\n```c\nredis> zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1\n(integer) 12\nredis> ZREVRANGEBYLEX zset + -\n 1) \"z1\"\n 2) \"z\"\n 3) \"dobble\"\n 4) \"dd\"\n 5) \"d1\"\n 6) \"d\"\n 7) \"c\"\n 8) \"b\"\n 9) \"apple\"\n10) \"abc\"\n11) \"aa\"\n12) \"a\"\n```\n2. 获取分页数据\n\n```c\nredis> ZREVRANGEBYLEX zset + - LIMIT 0 3\n1) \"z1\"\n2) \"z\"\n3) \"dobble\"\nredis> ZREVRANGEBYLEX zset + - LIMIT 3 3\n1) \"dd\"\n2) \"d1\"\n3) \"d\"\n```\n3. 获取成员之间的元素\n\n默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。\n“[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。\n```c\nredis> ZREVRANGEBYLEX zset [c [aa\n1) \"c\"\n2) \"b\"\n3) \"apple\"\n4) \"abc\"\n5) \"aa\"\n```\n“min” 和 “max” 不能反, “min” 放前面 “max”放后面会导致返回结果为空\n```c\nredis> ZREVRANGEBYLEX zset [aa [c\n(empty list or set)\n```\n4. 使用 “(“ 小于号获取成员之间的元素\n\n“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。\n返回成员结果集不会包含 “max” 和 “min” 成员。\n```c\nredis> ZREVRANGEBYLEX zset (c [aa\n1) \"b\"\n2) \"apple\"\n3) \"abc\"\n4) \"aa\"\n```\n5. ASCII码的影响\n\n成员字符串作为二进制数组的字节数进行比较。\n默认是以ASCII字符集的顺序进行排列。\n如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。\n```c\nredis> zadd zset 0 dB\n(integer) 1\nredis> ZREVRANGEBYLEX zset + -\n 1) \"z1\"\n 2) \"z\"\n 3) \"dobble\"\n 4) \"dd\"\n 5) \"dB\"\n 6) \"d1\"\n 7) \"d\"\n 8) \"c\"\n 9) \"b\"\n10) \"apple\"\n11) \"abc\"\n12) \"aa\"\n13) \"a\"\nredis> ZREVRANGEBYLEX zset + - limit 0 3\n1) \"z1\"\n2) \"z\"\n3) \"dobble\"\nredis> ZREVRANGEBYLEX zset + - limit 3 3\n1) \"dd\"\n2) \"dB\"\n3) \"d1\"\n```\n#### 使用场景示例\n1. 电话号码排序\n\n我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:\n```c\nredis> zadd phone 0 13100111100 0 13110114300 0 13132110901 \n(integer) 3\nredis> zadd phone 0 13200111100 0 13210414300 0 13252110901 \n(integer) 3\nredis> zadd phone 0 13300111100 0 13310414300 0 13352110901 \n(integer) 3\n```\n从大到小获取所有号码:\n```c\nredis> ZREVRANGEBYLEX phone + -\n1) \"13352110901\"\n2) \"13310414300\"\n3) \"13300111100\"\n4) \"13252110901\"\n5) \"13210414300\"\n6) \"13200111100\"\n7) \"13132110901\"\n8) \"13110114300\"\n9) \"13100111100\"\n```\n获取132号段:\n```c\nredis> ZREVRANGEBYLEX phone (133 [132\n1) \"13252110901\"\n2) \"13210414300\"\n3) \"13200111100\"\n```\n获取132、133号段:\n```c\nredis> ZREVRANGEBYLEX phone (134 [132\n1) \"13352110901\"\n2) \"13310414300\"\n3) \"13300111100\"\n4) \"13252110901\"\n5) \"13210414300\"\n6) \"13200111100\"\n```\n2. 姓名排序\n\n将名称存储到SortSet中:\n\n```c\nredis> zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua \n(integer) 6\n```\n获取所有人的名字倒序排列:\n```c\nredis> ZREVRANGEBYLEX names + -\n1) \"Toumas\"\n2) \"Jake\"\n3) \"Gaodeng\"\n4) \"Bluetuo\"\n5) \"Aimini\"\n6) \"Aidehua\"\n```\n获取名字中大写字母A开头的所有人:\n```c\nredis> ZREVRANGEBYLEX names (B [A\n1) \"Aimini\"\n2) \"Aidehua\"\n```\n获取名字中大写字母C到Z的所有人:\n```c\nredis> ZREVRANGEBYLEX names [Z [C\n1) \"Toumas\"\n2) \"Jake\"\n3) \"Gaodeng\"\n```","slug":"redis_command/sorted_set/zrevrangebylex","published":1,"updated":"2021-03-14T03:04:50.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvh004whyjfilyytc84","content":"<h2 id=\"ZREVRANGEBYLEX-key-max-min-LIMIT-offset-count\"><a href=\"#ZREVRANGEBYLEX-key-max-min-LIMIT-offset-count\" class=\"headerlink\" title=\"ZREVRANGEBYLEX key max min [LIMIT offset count]\"></a>ZREVRANGEBYLEX key max min [LIMIT offset count]</h2><blockquote>\n<p>起始版本：2.8.9<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>ZREVRANGEBYLEX 返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同。</li>\n<li>在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行倒序排列时,可以使用Redis中SortSet这种数据结构来处理。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>是否必须</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZREVRANGEBYLEX</td>\n<td>是</td>\n<td>指令</td>\n</tr>\n<tr>\n<td>key</td>\n<td>是</td>\n<td>有序集合键名称</td>\n</tr>\n<tr>\n<td>max</td>\n<td>是</td>\n<td>字典中排序位置较大的成员,必须以”[“开头,或者以”(“开头,可使用”+”代替</td>\n</tr>\n<tr>\n<td>min</td>\n<td>是</td>\n<td>字典中排序位置较小的成员,必须以”[“开头,或者以”(“开头,可使用”-“代替</td>\n</tr>\n<tr>\n<td>LIMIT</td>\n<td>否</td>\n<td>返回结果是否分页,指令中包含LIMIT后offset、count必须输入</td>\n</tr>\n<tr>\n<td>offset</td>\n<td>否</td>\n<td>返回结果起始位置</td>\n</tr>\n<tr>\n<td>count</td>\n<td>否</td>\n<td>返回结果数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>分数必须相同! 如果有序集合中的成员分数有不一致的,返回的结果就不准。</li>\n<li>成员字符串作为二进制数组的字节数进行比较。</li>\n<li>默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。</li>\n<li>源码中采用C语言中<code>memcmp()</code>函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠前。</li>\n<li>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “max”和 “min”</li>\n<li>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。</li>\n<li>可以使用 “-“ 和 “+” 表示得分最小值和最大值</li>\n<li>“max”和 “min” 不能反, “max” 放后面 “min”放前面会导致返回结果为空</li>\n<li>与ZREVRANGEBYLEX获取顺序相反的指令是ZREVRANGEBYLEX</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>指定成员范围的元素列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>不要在分数不一致的SortSet集合中去使用 ZREVRANGEBYLEX 指令,因为获取的结果并不准确。</p>\n<ol>\n<li>获取所有值</li>\n</ol>\n<p>可以使用 “-“ 和 “+” 表示最小值和最大值<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> a <span class=\"number\">0</span> aa <span class=\"number\">0</span> abc <span class=\"number\">0</span> apple <span class=\"number\">0</span> b <span class=\"number\">0</span> c <span class=\"number\">0</span> d <span class=\"number\">0</span> d1 <span class=\"number\">0</span> dd <span class=\"number\">0</span> dobble <span class=\"number\">0</span> z <span class=\"number\">0</span> z1</span><br><span class=\"line\">(integer) <span class=\"number\">12</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + -</span><br><span class=\"line\"> <span class=\"number\">1</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\"> <span class=\"number\">2</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"> <span class=\"number\">3</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"> <span class=\"number\">4</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"> <span class=\"number\">5</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"> <span class=\"number\">6</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"> <span class=\"number\">7</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"> <span class=\"number\">8</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"> <span class=\"number\">9</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">12</span>) <span class=\"string\">\"a\"</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>获取分页数据</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + - LIMIT <span class=\"number\">0</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + - LIMIT <span class=\"number\">3</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"d\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>获取成员之间的元素</li>\n</ol>\n<p>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。<br>“[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset [c [aa</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"aa\"</span></span><br></pre></td></tr></table></figure></p>\n<p>“min” 和 “max” 不能反, “min” 放前面 “max”放后面会导致返回结果为空<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset [aa [c</span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>使用 “(“ 小于号获取成员之间的元素</li>\n</ol>\n<p>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。<br>返回成员结果集不会包含 “max” 和 “min” 成员。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYLEX <span class=\"title\">zset</span> <span class=\"params\">(c [aa</span></span></span><br><span class=\"line\">1) \"b\"</span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"aa\"</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>ASCII码的影响</li>\n</ol>\n<p>成员字符串作为二进制数组的字节数进行比较。<br>默认是以ASCII字符集的顺序进行排列。<br>如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> dB</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + -</span><br><span class=\"line\"> <span class=\"number\">1</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\"> <span class=\"number\">2</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"> <span class=\"number\">3</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"> <span class=\"number\">4</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"> <span class=\"number\">5</span>) <span class=\"string\">\"dB\"</span></span><br><span class=\"line\"> <span class=\"number\">6</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"> <span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"> <span class=\"number\">8</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"> <span class=\"number\">9</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">12</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">13</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + - limit <span class=\"number\">0</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + - limit <span class=\"number\">3</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"dB\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"d1\"</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用场景示例\"><a href=\"#使用场景示例\" class=\"headerlink\" title=\"使用场景示例\"></a>使用场景示例</h4><ol>\n<li>电话号码排序</li>\n</ol>\n<p>我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13100111100</span> <span class=\"number\">0</span> <span class=\"number\">13110114300</span> <span class=\"number\">0</span> <span class=\"number\">13132110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13200111100</span> <span class=\"number\">0</span> <span class=\"number\">13210414300</span> <span class=\"number\">0</span> <span class=\"number\">13252110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13300111100</span> <span class=\"number\">0</span> <span class=\"number\">13310414300</span> <span class=\"number\">0</span> <span class=\"number\">13352110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br></pre></td></tr></table></figure></p>\n<p>从大到小获取所有号码:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX phone + -</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13352110901\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"13132110901\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"13110114300\"</span></span><br><span class=\"line\"><span class=\"number\">9</span>) <span class=\"string\">\"13100111100\"</span></span><br></pre></td></tr></table></figure></p>\n<p>获取132号段:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYLEX <span class=\"title\">phone</span> <span class=\"params\">(<span class=\"number\">133</span> [<span class=\"number\">132</span></span></span></span><br><span class=\"line\">1) \"13252110901\"</span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13200111100\"</span></span><br></pre></td></tr></table></figure></p>\n<p>获取132、133号段:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYLEX <span class=\"title\">phone</span> <span class=\"params\">(<span class=\"number\">134</span> [<span class=\"number\">132</span></span></span></span><br><span class=\"line\">1) \"13352110901\"</span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13200111100\"</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>姓名排序</li>\n</ol>\n<p>将名称存储到SortSet中:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd names <span class=\"number\">0</span> Toumas <span class=\"number\">0</span> Jake <span class=\"number\">0</span> Bluetuo <span class=\"number\">0</span> Gaodeng <span class=\"number\">0</span> Aimini <span class=\"number\">0</span> Aidehua </span><br><span class=\"line\">(integer) <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>获取所有人的名字倒序排列:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX names + -</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Toumas\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Gaodeng\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"Bluetuo\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"Aimini\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"Aidehua\"</span></span><br></pre></td></tr></table></figure></p>\n<p>获取名字中大写字母A开头的所有人:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYLEX <span class=\"title\">names</span> <span class=\"params\">(B [A</span></span></span><br><span class=\"line\">1) \"Aimini\"</span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Aidehua\"</span></span><br></pre></td></tr></table></figure></p>\n<p>获取名字中大写字母C到Z的所有人:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX names [Z [C</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Toumas\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Gaodeng\"</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZREVRANGEBYLEX-key-max-min-LIMIT-offset-count\"><a href=\"#ZREVRANGEBYLEX-key-max-min-LIMIT-offset-count\" class=\"headerlink\" title=\"ZREVRANGEBYLEX key max min [LIMIT offset count]\"></a>ZREVRANGEBYLEX key max min [LIMIT offset count]</h2><blockquote>\n<p>起始版本：2.8.9<br>时间复杂度：O(log(N)+M) N为已排序集合中的元素数，M为返回的元素数。如果M是常数(比如总是要求前10个元素有极限)，你可以认为它是O(log(N))。 </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>ZREVRANGEBYLEX 返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同。</li>\n<li>在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行倒序排列时,可以使用Redis中SortSet这种数据结构来处理。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>是否必须</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ZREVRANGEBYLEX</td>\n<td>是</td>\n<td>指令</td>\n</tr>\n<tr>\n<td>key</td>\n<td>是</td>\n<td>有序集合键名称</td>\n</tr>\n<tr>\n<td>max</td>\n<td>是</td>\n<td>字典中排序位置较大的成员,必须以”[“开头,或者以”(“开头,可使用”+”代替</td>\n</tr>\n<tr>\n<td>min</td>\n<td>是</td>\n<td>字典中排序位置较小的成员,必须以”[“开头,或者以”(“开头,可使用”-“代替</td>\n</tr>\n<tr>\n<td>LIMIT</td>\n<td>否</td>\n<td>返回结果是否分页,指令中包含LIMIT后offset、count必须输入</td>\n</tr>\n<tr>\n<td>offset</td>\n<td>否</td>\n<td>返回结果起始位置</td>\n</tr>\n<tr>\n<td>count</td>\n<td>否</td>\n<td>返回结果数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>分数必须相同! 如果有序集合中的成员分数有不一致的,返回的结果就不准。</li>\n<li>成员字符串作为二进制数组的字节数进行比较。</li>\n<li>默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。</li>\n<li>源码中采用C语言中<code>memcmp()</code>函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠前。</li>\n<li>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “max”和 “min”</li>\n<li>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。</li>\n<li>可以使用 “-“ 和 “+” 表示得分最小值和最大值</li>\n<li>“max”和 “min” 不能反, “max” 放后面 “min”放前面会导致返回结果为空</li>\n<li>与ZREVRANGEBYLEX获取顺序相反的指令是ZREVRANGEBYLEX</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>指定成员范围的元素列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>不要在分数不一致的SortSet集合中去使用 ZREVRANGEBYLEX 指令,因为获取的结果并不准确。</p>\n<ol>\n<li>获取所有值</li>\n</ol>\n<p>可以使用 “-“ 和 “+” 表示最小值和最大值<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> a <span class=\"number\">0</span> aa <span class=\"number\">0</span> abc <span class=\"number\">0</span> apple <span class=\"number\">0</span> b <span class=\"number\">0</span> c <span class=\"number\">0</span> d <span class=\"number\">0</span> d1 <span class=\"number\">0</span> dd <span class=\"number\">0</span> dobble <span class=\"number\">0</span> z <span class=\"number\">0</span> z1</span><br><span class=\"line\">(integer) <span class=\"number\">12</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + -</span><br><span class=\"line\"> <span class=\"number\">1</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\"> <span class=\"number\">2</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"> <span class=\"number\">3</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"> <span class=\"number\">4</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"> <span class=\"number\">5</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"> <span class=\"number\">6</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"> <span class=\"number\">7</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"> <span class=\"number\">8</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"> <span class=\"number\">9</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">12</span>) <span class=\"string\">\"a\"</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>获取分页数据</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + - LIMIT <span class=\"number\">0</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + - LIMIT <span class=\"number\">3</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"d\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>获取成员之间的元素</li>\n</ol>\n<p>默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。<br>“[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset [c [aa</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"aa\"</span></span><br></pre></td></tr></table></figure></p>\n<p>“min” 和 “max” 不能反, “min” 放前面 “max”放后面会导致返回结果为空<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset [aa [c</span><br><span class=\"line\">(empty <span class=\"built_in\">list</span> <span class=\"keyword\">or</span> <span class=\"built_in\">set</span>)</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>使用 “(“ 小于号获取成员之间的元素</li>\n</ol>\n<p>“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。<br>返回成员结果集不会包含 “max” 和 “min” 成员。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYLEX <span class=\"title\">zset</span> <span class=\"params\">(c [aa</span></span></span><br><span class=\"line\">1) \"b\"</span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"aa\"</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>ASCII码的影响</li>\n</ol>\n<p>成员字符串作为二进制数组的字节数进行比较。<br>默认是以ASCII字符集的顺序进行排列。<br>如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd zset <span class=\"number\">0</span> dB</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + -</span><br><span class=\"line\"> <span class=\"number\">1</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\"> <span class=\"number\">2</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"> <span class=\"number\">3</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\"> <span class=\"number\">4</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"> <span class=\"number\">5</span>) <span class=\"string\">\"dB\"</span></span><br><span class=\"line\"> <span class=\"number\">6</span>) <span class=\"string\">\"d1\"</span></span><br><span class=\"line\"> <span class=\"number\">7</span>) <span class=\"string\">\"d\"</span></span><br><span class=\"line\"> <span class=\"number\">8</span>) <span class=\"string\">\"c\"</span></span><br><span class=\"line\"> <span class=\"number\">9</span>) <span class=\"string\">\"b\"</span></span><br><span class=\"line\"><span class=\"number\">10</span>) <span class=\"string\">\"apple\"</span></span><br><span class=\"line\"><span class=\"number\">11</span>) <span class=\"string\">\"abc\"</span></span><br><span class=\"line\"><span class=\"number\">12</span>) <span class=\"string\">\"aa\"</span></span><br><span class=\"line\"><span class=\"number\">13</span>) <span class=\"string\">\"a\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + - limit <span class=\"number\">0</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"z1\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"z\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"dobble\"</span></span><br><span class=\"line\">redis&gt; ZREVRANGEBYLEX zset + - limit <span class=\"number\">3</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"dd\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"dB\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"d1\"</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用场景示例\"><a href=\"#使用场景示例\" class=\"headerlink\" title=\"使用场景示例\"></a>使用场景示例</h4><ol>\n<li>电话号码排序</li>\n</ol>\n<p>我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13100111100</span> <span class=\"number\">0</span> <span class=\"number\">13110114300</span> <span class=\"number\">0</span> <span class=\"number\">13132110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13200111100</span> <span class=\"number\">0</span> <span class=\"number\">13210414300</span> <span class=\"number\">0</span> <span class=\"number\">13252110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13300111100</span> <span class=\"number\">0</span> <span class=\"number\">13310414300</span> <span class=\"number\">0</span> <span class=\"number\">13352110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br></pre></td></tr></table></figure></p>\n<p>从大到小获取所有号码:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX phone + -</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13352110901\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"13132110901\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"13110114300\"</span></span><br><span class=\"line\"><span class=\"number\">9</span>) <span class=\"string\">\"13100111100\"</span></span><br></pre></td></tr></table></figure></p>\n<p>获取132号段:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYLEX <span class=\"title\">phone</span> <span class=\"params\">(<span class=\"number\">133</span> [<span class=\"number\">132</span></span></span></span><br><span class=\"line\">1) \"13252110901\"</span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13200111100\"</span></span><br></pre></td></tr></table></figure></p>\n<p>获取132、133号段:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYLEX <span class=\"title\">phone</span> <span class=\"params\">(<span class=\"number\">134</span> [<span class=\"number\">132</span></span></span></span><br><span class=\"line\">1) \"13352110901\"</span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13200111100\"</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>姓名排序</li>\n</ol>\n<p>将名称存储到SortSet中:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd names <span class=\"number\">0</span> Toumas <span class=\"number\">0</span> Jake <span class=\"number\">0</span> Bluetuo <span class=\"number\">0</span> Gaodeng <span class=\"number\">0</span> Aimini <span class=\"number\">0</span> Aidehua </span><br><span class=\"line\">(integer) <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>获取所有人的名字倒序排列:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX names + -</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Toumas\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Gaodeng\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"Bluetuo\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"Aimini\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"Aidehua\"</span></span><br></pre></td></tr></table></figure></p>\n<p>获取名字中大写字母A开头的所有人:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; <span class=\"function\">ZREVRANGEBYLEX <span class=\"title\">names</span> <span class=\"params\">(B [A</span></span></span><br><span class=\"line\">1) \"Aimini\"</span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Aidehua\"</span></span><br></pre></td></tr></table></figure></p>\n<p>获取名字中大写字母C到Z的所有人:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZREVRANGEBYLEX names [Z [C</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Toumas\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Gaodeng\"</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"ZREVRANK(zrevrank)","copyright":true,"date":"2020-03-31T05:21:31.000Z","keywords":"Redis命令,zrevrank","aside":"sorted_set","_content":"## ZREVRANK key member \n>起始版本：2.0.0<br/>时间复杂度：O(log(N))  \n\n\n#### 说明:\n* 返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列。排名以0为底，也就是说，score值最大的成员排名为0。\n* 使用ZRANK命令可以获得成员按score值递增(从小到大)排列的排名。\n\n#### 返回值\n\n如果member是有序集key的成员，返回**integer-reply**:member的排名。\n如果member不是有序集key的成员，返回**bulk-string-reply**: nil。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREVRANK myzset \"one\"\n(integer) 2\nredis> ZREVRANK myzset \"four\"\n(nil)\nredis> \n```","source":"_posts/redis_command/sorted_set/zrevrank.md","raw":"---\n\ntitle: ZREVRANK(zrevrank)\ncopyright: true\ndate: 2020-03-31 13:21:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zrevrank\naside: sorted_set\n\n---\n## ZREVRANK key member \n>起始版本：2.0.0<br/>时间复杂度：O(log(N))  \n\n\n#### 说明:\n* 返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列。排名以0为底，也就是说，score值最大的成员排名为0。\n* 使用ZRANK命令可以获得成员按score值递增(从小到大)排列的排名。\n\n#### 返回值\n\n如果member是有序集key的成员，返回**integer-reply**:member的排名。\n如果member不是有序集key的成员，返回**bulk-string-reply**: nil。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZADD myzset 2 \"two\"\n(integer) 1\nredis> ZADD myzset 3 \"three\"\n(integer) 1\nredis> ZREVRANK myzset \"one\"\n(integer) 2\nredis> ZREVRANK myzset \"four\"\n(nil)\nredis> \n```","slug":"redis_command/sorted_set/zrevrank","published":1,"updated":"2021-03-14T03:04:50.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvi004zhyjfqhxlqs0h","content":"<h2 id=\"ZREVRANK-key-member\"><a href=\"#ZREVRANK-key-member\" class=\"headerlink\" title=\"ZREVRANK key member\"></a>ZREVRANK key member</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(log(N))  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列。排名以0为底，也就是说，score值最大的成员排名为0。</li>\n<li>使用ZRANK命令可以获得成员按score值递增(从小到大)排列的排名。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>如果member是有序集key的成员，返回<strong>integer-reply</strong>:member的排名。<br>如果member不是有序集key的成员，返回<strong>bulk-string-reply</strong>: nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANK myzset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZREVRANK myzset <span class=\"string\">\"four\"</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZREVRANK-key-member\"><a href=\"#ZREVRANK-key-member\" class=\"headerlink\" title=\"ZREVRANK key member\"></a>ZREVRANK key member</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(log(N))  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列。排名以0为底，也就是说，score值最大的成员排名为0。</li>\n<li>使用ZRANK命令可以获得成员按score值递增(从小到大)排列的排名。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>如果member是有序集key的成员，返回<strong>integer-reply</strong>:member的排名。<br>如果member不是有序集key的成员，返回<strong>bulk-string-reply</strong>: nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZREVRANK myzset <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\">redis&gt; ZREVRANK myzset <span class=\"string\">\"four\"</span></span><br><span class=\"line\">(nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZSCORE(zscore)","copyright":true,"date":"2020-03-31T05:20:31.000Z","keywords":"Redis命令,zscore","aside":"sorted_set","_content":"## ZSCORE key member \n>起始版本：1.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回有序集key中，成员member的score值。\n* 如果member元素不是有序集key的成员，或key不存在，返回nil。\n\n#### 返回值\n\n\n**bulk-string-reply**: member成员的score值（double型浮点数），以字符串形式表示。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZSCORE myzset \"one\"\n\"1\"\nredis> \n```","source":"_posts/redis_command/sorted_set/zscore.md","raw":"---\n\ntitle: ZSCORE(zscore)\ncopyright: true\ndate: 2020-03-31 13:20:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zscore\naside: sorted_set\n\n---\n## ZSCORE key member \n>起始版本：1.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回有序集key中，成员member的score值。\n* 如果member元素不是有序集key的成员，或key不存在，返回nil。\n\n#### 返回值\n\n\n**bulk-string-reply**: member成员的score值（double型浮点数），以字符串形式表示。\n\n\n#### 示例\n\n```c\nredis> ZADD myzset 1 \"one\"\n(integer) 1\nredis> ZSCORE myzset \"one\"\n\"1\"\nredis> \n```","slug":"redis_command/sorted_set/zscore","published":1,"updated":"2021-03-14T03:04:50.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvj0051hyjfc1lhkowm","content":"<h2 id=\"ZSCORE-key-member\"><a href=\"#ZSCORE-key-member\" class=\"headerlink\" title=\"ZSCORE key member\"></a>ZSCORE key member</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回有序集key中，成员member的score值。</li>\n<li>如果member元素不是有序集key的成员，或key不存在，返回nil。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>: member成员的score值（double型浮点数），以字符串形式表示。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZSCORE myzset <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"string\">\"1\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZSCORE-key-member\"><a href=\"#ZSCORE-key-member\" class=\"headerlink\" title=\"ZSCORE key member\"></a>ZSCORE key member</h2><blockquote>\n<p>起始版本：1.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回有序集key中，成员member的score值。</li>\n<li>如果member元素不是有序集key的成员，或key不存在，返回nil。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>: member成员的score值（double型浮点数），以字符串形式表示。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD myzset <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZSCORE myzset <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"string\">\"1\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZUNIONSTORE(zunionstore)","copyright":true,"date":"2020-03-31T05:19:31.000Z","keywords":"Redis命令,zunionstore","aside":"sorted_set","_content":"## ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX] \n>起始版本：2.0.0<br/>时间复杂度：O(N)+O(M log(M)) N为输入排序集大小的和，M为最终排序集的元素个数。\n\n\n#### 说明:\n* 计算给定的numkeys个有序集合的并集，并且把结果放到destination中。在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。 默认情况下，结果集中某个成员的score值是所有给定集下该成员score值之和。\n* 使用WEIGHTS选项，你可以为每个给定的有序集指定一个乘法因子，意思就是，每个给定有序集的所有成员的score值在传递给聚合函数之前都要先乘以该因子。如果WEIGHTS没有给定，默认就是1。\n* 使用AGGREGATE选项，你可以指定并集的结果集的聚合方式。默认使用的参数SUM，可以将所有集合中某个成员的score值之和作为结果集中该成员的score值。如果使用参数MIN或者MAX，结果集就是所有集合中元素最小或最大的元素。\n* 如果key destination存在，就被覆盖。\n\n#### 返回值\n\n**integer-reply**: 结果有序集合destination中元素个数。\n\n\n#### 示例\n\n```c\nredis> ZADD zset1 1 \"one\"\n(integer) 1\nredis> ZADD zset1 2 \"two\"\n(integer) 1\nredis> ZADD zset2 1 \"one\"\n(integer) 1\nredis> ZADD zset2 2 \"two\"\n(integer) 1\nredis> ZADD zset2 3 \"three\"\n(integer) 1\nredis> ZUNIONSTORE out 2 zset1 zset2 WEIGHTS 2 3\n(integer) 3\nredis> ZRANGE out 0 -1 WITHSCORES\n1) \"one\"\n2) \"5\"\n3) \"three\"\n4) \"9\"\n5) \"two\"\n6) \"10\"\nredis> \n```","source":"_posts/redis_command/sorted_set/zunionstore.md","raw":"---\n\ntitle: ZUNIONSTORE(zunionstore)\ncopyright: true\ndate: 2020-03-31 13:19:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zunionstore\naside: sorted_set\n\n---\n## ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX] \n>起始版本：2.0.0<br/>时间复杂度：O(N)+O(M log(M)) N为输入排序集大小的和，M为最终排序集的元素个数。\n\n\n#### 说明:\n* 计算给定的numkeys个有序集合的并集，并且把结果放到destination中。在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。 默认情况下，结果集中某个成员的score值是所有给定集下该成员score值之和。\n* 使用WEIGHTS选项，你可以为每个给定的有序集指定一个乘法因子，意思就是，每个给定有序集的所有成员的score值在传递给聚合函数之前都要先乘以该因子。如果WEIGHTS没有给定，默认就是1。\n* 使用AGGREGATE选项，你可以指定并集的结果集的聚合方式。默认使用的参数SUM，可以将所有集合中某个成员的score值之和作为结果集中该成员的score值。如果使用参数MIN或者MAX，结果集就是所有集合中元素最小或最大的元素。\n* 如果key destination存在，就被覆盖。\n\n#### 返回值\n\n**integer-reply**: 结果有序集合destination中元素个数。\n\n\n#### 示例\n\n```c\nredis> ZADD zset1 1 \"one\"\n(integer) 1\nredis> ZADD zset1 2 \"two\"\n(integer) 1\nredis> ZADD zset2 1 \"one\"\n(integer) 1\nredis> ZADD zset2 2 \"two\"\n(integer) 1\nredis> ZADD zset2 3 \"three\"\n(integer) 1\nredis> ZUNIONSTORE out 2 zset1 zset2 WEIGHTS 2 3\n(integer) 3\nredis> ZRANGE out 0 -1 WITHSCORES\n1) \"one\"\n2) \"5\"\n3) \"three\"\n4) \"9\"\n5) \"two\"\n6) \"10\"\nredis> \n```","slug":"redis_command/sorted_set/zunionstore","published":1,"updated":"2021-03-14T03:04:50.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvk0054hyjfz8bayluf","content":"<h2 id=\"ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-SUM-MIN-MAX\"><a href=\"#ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-SUM-MIN-MAX\" class=\"headerlink\" title=\"ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM|MIN|MAX]\"></a>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM|MIN|MAX]</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N)+O(M log(M)) N为输入排序集大小的和，M为最终排序集的元素个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>计算给定的numkeys个有序集合的并集，并且把结果放到destination中。在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。 默认情况下，结果集中某个成员的score值是所有给定集下该成员score值之和。</li>\n<li>使用WEIGHTS选项，你可以为每个给定的有序集指定一个乘法因子，意思就是，每个给定有序集的所有成员的score值在传递给聚合函数之前都要先乘以该因子。如果WEIGHTS没有给定，默认就是1。</li>\n<li>使用AGGREGATE选项，你可以指定并集的结果集的聚合方式。默认使用的参数SUM，可以将所有集合中某个成员的score值之和作为结果集中该成员的score值。如果使用参数MIN或者MAX，结果集就是所有集合中元素最小或最大的元素。</li>\n<li>如果key destination存在，就被覆盖。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 结果有序集合destination中元素个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZUNIONSTORE out <span class=\"number\">2</span> zset1 zset2 WEIGHTS <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; ZRANGE out <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"5\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"9\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"10\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-SUM-MIN-MAX\"><a href=\"#ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-SUM-MIN-MAX\" class=\"headerlink\" title=\"ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM|MIN|MAX]\"></a>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight] [SUM|MIN|MAX]</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N)+O(M log(M)) N为输入排序集大小的和，M为最终排序集的元素个数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>计算给定的numkeys个有序集合的并集，并且把结果放到destination中。在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。 默认情况下，结果集中某个成员的score值是所有给定集下该成员score值之和。</li>\n<li>使用WEIGHTS选项，你可以为每个给定的有序集指定一个乘法因子，意思就是，每个给定有序集的所有成员的score值在传递给聚合函数之前都要先乘以该因子。如果WEIGHTS没有给定，默认就是1。</li>\n<li>使用AGGREGATE选项，你可以指定并集的结果集的聚合方式。默认使用的参数SUM，可以将所有集合中某个成员的score值之和作为结果集中该成员的score值。如果使用参数MIN或者MAX，结果集就是所有集合中元素最小或最大的元素。</li>\n<li>如果key destination存在，就被覆盖。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>: 结果有序集合destination中元素个数。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset1 <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">1</span> <span class=\"string\">\"one\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">2</span> <span class=\"string\">\"two\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZADD zset2 <span class=\"number\">3</span> <span class=\"string\">\"three\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; ZUNIONSTORE out <span class=\"number\">2</span> zset1 zset2 WEIGHTS <span class=\"number\">2</span> <span class=\"number\">3</span></span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; ZRANGE out <span class=\"number\">0</span> <span class=\"number\">-1</span> WITHSCORES</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"one\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"5\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"three\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"9\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"two\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"10\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HDEL(hdel)","copyright":true,"date":"2020-03-18T10:23:18.000Z","keywords":"Redis命令,hdel","aside":"Hash","_content":"## HDEL key field [field ...] \n>起始版本：2.0.0<br/>时间复杂度：O(N) N是被删除的字段数量。  \n\n\n#### 说明:\n* 从 key 指定的哈希集中移除指定的域。在哈希集中不存在的域将被忽略。\n* 如果 key 指定的哈希集不存在，它将被认为是一个空的哈希集，该命令将返回0。\n\n#### 返回值\n\n**integer-reply**： 返回从哈希集中成功移除的域的数量，不包括指出但不存在的那些域\n\n\n#### 历史\n\n\n在 2.4及以上版本中 ：可接受多个域作为参数。小于 2.4版本 的 Redis 每次调用只能移除一个域 要在早期版本中以原子方式从哈希集中移除多个域，可考虑 MULTI/EXEC。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"foo\"\n(integer) 1\nredis> HDEL myhash field1\n(integer) 1\nredis> HDEL myhash field2\n(integer) 0\nredis> \n```","source":"_posts/redis_command/hash/hdel.md","raw":"---\n\ntitle: HDEL(hdel)\ncopyright: true\ndate: 2020-03-18 18:23:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hdel\naside: Hash\n---\n## HDEL key field [field ...] \n>起始版本：2.0.0<br/>时间复杂度：O(N) N是被删除的字段数量。  \n\n\n#### 说明:\n* 从 key 指定的哈希集中移除指定的域。在哈希集中不存在的域将被忽略。\n* 如果 key 指定的哈希集不存在，它将被认为是一个空的哈希集，该命令将返回0。\n\n#### 返回值\n\n**integer-reply**： 返回从哈希集中成功移除的域的数量，不包括指出但不存在的那些域\n\n\n#### 历史\n\n\n在 2.4及以上版本中 ：可接受多个域作为参数。小于 2.4版本 的 Redis 每次调用只能移除一个域 要在早期版本中以原子方式从哈希集中移除多个域，可考虑 MULTI/EXEC。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"foo\"\n(integer) 1\nredis> HDEL myhash field1\n(integer) 1\nredis> HDEL myhash field2\n(integer) 0\nredis> \n```","slug":"redis_command/hash/hdel","published":1,"updated":"2021-03-14T03:04:50.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvl0056hyjf2l0xki6s","content":"<h2 id=\"HDEL-key-field-field-…\"><a href=\"#HDEL-key-field-field-…\" class=\"headerlink\" title=\"HDEL key field [field …]\"></a>HDEL key field [field …]</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N) N是被删除的字段数量。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>从 key 指定的哈希集中移除指定的域。在哈希集中不存在的域将被忽略。</li>\n<li>如果 key 指定的哈希集不存在，它将被认为是一个空的哈希集，该命令将返回0。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>： 返回从哈希集中成功移除的域的数量，不包括指出但不存在的那些域</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>在 2.4及以上版本中 ：可接受多个域作为参数。小于 2.4版本 的 Redis 每次调用只能移除一个域 要在早期版本中以原子方式从哈希集中移除多个域，可考虑 MULTI/EXEC。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;foo&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HDEL myhash field1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HDEL myhash field2</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HDEL-key-field-field-…\"><a href=\"#HDEL-key-field-field-…\" class=\"headerlink\" title=\"HDEL key field [field …]\"></a>HDEL key field [field …]</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N) N是被删除的字段数量。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>从 key 指定的哈希集中移除指定的域。在哈希集中不存在的域将被忽略。</li>\n<li>如果 key 指定的哈希集不存在，它将被认为是一个空的哈希集，该命令将返回0。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>： 返回从哈希集中成功移除的域的数量，不包括指出但不存在的那些域</p>\n<h4 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h4><p>在 2.4及以上版本中 ：可接受多个域作为参数。小于 2.4版本 的 Redis 每次调用只能移除一个域 要在早期版本中以原子方式从哈希集中移除多个域，可考虑 MULTI/EXEC。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;foo&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HDEL myhash field1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HDEL myhash field2</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ZSCAN(zscan)","copyright":true,"date":"2020-03-31T05:18:31.000Z","keywords":"Redis命令,zscan","aside":"sorted_set","_content":"## ZSCAN key cursor [MATCH pattern] [COUNT count] \n>起始版本：2.8.0<br/>时间复杂度：O(1) 对于一个完整的迭代，包括足够的命令调用，使光标返回到0。N是集合中元素的数量。.  \n\n\n#### 说明:\n* 请参考SCAN\n\n","source":"_posts/redis_command/sorted_set/zscan.md","raw":"---\n\ntitle: ZSCAN(zscan)\ncopyright: true\ndate: 2020-03-31 13:18:31\ncategories: \n- Redis命令大全\n- ZSet\nkeywords: Redis命令,zscan\naside: sorted_set\n\n---\n## ZSCAN key cursor [MATCH pattern] [COUNT count] \n>起始版本：2.8.0<br/>时间复杂度：O(1) 对于一个完整的迭代，包括足够的命令调用，使光标返回到0。N是集合中元素的数量。.  \n\n\n#### 说明:\n* 请参考SCAN\n\n","slug":"redis_command/sorted_set/zscan","published":1,"updated":"2021-03-14T03:04:50.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvm0059hyjfjg6rllo4","content":"<h2 id=\"ZSCAN-key-cursor-MATCH-pattern-COUNT-count\"><a href=\"#ZSCAN-key-cursor-MATCH-pattern-COUNT-count\" class=\"headerlink\" title=\"ZSCAN key cursor [MATCH pattern] [COUNT count]\"></a>ZSCAN key cursor [MATCH pattern] [COUNT count]</h2><blockquote>\n<p>起始版本：2.8.0<br>时间复杂度：O(1) 对于一个完整的迭代，包括足够的命令调用，使光标返回到0。N是集合中元素的数量。.  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>请参考SCAN</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZSCAN-key-cursor-MATCH-pattern-COUNT-count\"><a href=\"#ZSCAN-key-cursor-MATCH-pattern-COUNT-count\" class=\"headerlink\" title=\"ZSCAN key cursor [MATCH pattern] [COUNT count]\"></a>ZSCAN key cursor [MATCH pattern] [COUNT count]</h2><blockquote>\n<p>起始版本：2.8.0<br>时间复杂度：O(1) 对于一个完整的迭代，包括足够的命令调用，使光标返回到0。N是集合中元素的数量。.  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>请参考SCAN</li>\n</ul>\n"},{"title":"HGETALL(hgetall)","copyright":true,"date":"2020-03-18T10:20:18.000Z","keywords":"Redis命令,hgetall","aside":"Hash","_content":"## HGETALL key \n>起始版本：2.0.0<br/>时间复杂度：O(N)  N是Hash的长度\n\n\n#### 说明:\n* 返回 key 指定的哈希集中所有的字段和值。返回值中，每个字段名的下一个是它的值，所以返回值的长度是哈希集大小的两倍。\n\n\n#### 返回值\n\n**array-reply**：哈希集中字段和值的列表。当 key 指定的哈希集不存在时返回空列表。\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HSET myhash field2 \"World\"\n(integer) 1\nredis> HGETALL myhash\n1) \"field1\"\n2) \"Hello\"\n3) \"field2\"\n4) \"World\"\nredis> \n```","source":"_posts/redis_command/hash/hgetall.md","raw":"---\n\ntitle: HGETALL(hgetall)\ncopyright: true\ndate: 2020-03-18 18:20:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hgetall\naside: Hash\n---\n## HGETALL key \n>起始版本：2.0.0<br/>时间复杂度：O(N)  N是Hash的长度\n\n\n#### 说明:\n* 返回 key 指定的哈希集中所有的字段和值。返回值中，每个字段名的下一个是它的值，所以返回值的长度是哈希集大小的两倍。\n\n\n#### 返回值\n\n**array-reply**：哈希集中字段和值的列表。当 key 指定的哈希集不存在时返回空列表。\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HSET myhash field2 \"World\"\n(integer) 1\nredis> HGETALL myhash\n1) \"field1\"\n2) \"Hello\"\n3) \"field2\"\n4) \"World\"\nredis> \n```","slug":"redis_command/hash/hgetall","published":1,"updated":"2021-03-14T03:04:50.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvn005bhyjf52yc15yo","content":"<h2 id=\"HGETALL-key\"><a href=\"#HGETALL-key\" class=\"headerlink\" title=\"HGETALL key\"></a>HGETALL key</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N)  N是Hash的长度</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集中所有的字段和值。返回值中，每个字段名的下一个是它的值，所以返回值的长度是哈希集大小的两倍。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>：哈希集中字段和值的列表。当 key 指定的哈希集不存在时返回空列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSET myhash field2 &quot;World&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HGETALL myhash</span><br><span class=\"line\">1) &quot;field1&quot;</span><br><span class=\"line\">2) &quot;Hello&quot;</span><br><span class=\"line\">3) &quot;field2&quot;</span><br><span class=\"line\">4) &quot;World&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HGETALL-key\"><a href=\"#HGETALL-key\" class=\"headerlink\" title=\"HGETALL key\"></a>HGETALL key</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N)  N是Hash的长度</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集中所有的字段和值。返回值中，每个字段名的下一个是它的值，所以返回值的长度是哈希集大小的两倍。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>：哈希集中字段和值的列表。当 key 指定的哈希集不存在时返回空列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSET myhash field2 &quot;World&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HGETALL myhash</span><br><span class=\"line\">1) &quot;field1&quot;</span><br><span class=\"line\">2) &quot;Hello&quot;</span><br><span class=\"line\">3) &quot;field2&quot;</span><br><span class=\"line\">4) &quot;World&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HEXISTS(hexists)","copyright":true,"date":"2020-03-18T10:22:18.000Z","keywords":"Redis命令,hexists","aside":"Hash","_content":"## HEXISTS key field \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回hash里面field是否存在\n\n#### 返回值\n\n\n**integer-reply**, 含义如下：\n1 hash里面包含该field。\n0 hash里面不包含该field或者key不存在。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"foo\"\n(integer) 1\nredis> HEXISTS myhash field1\n(integer) 1\nredis> HEXISTS myhash field2\n(integer) 0\nredis> \n```","source":"_posts/redis_command/hash/hexists.md","raw":"---\n\ntitle: HEXISTS(hexists)\ncopyright: true\ndate: 2020-03-18 18:22:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hexists\naside: Hash\n---\n## HEXISTS key field \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回hash里面field是否存在\n\n#### 返回值\n\n\n**integer-reply**, 含义如下：\n1 hash里面包含该field。\n0 hash里面不包含该field或者key不存在。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"foo\"\n(integer) 1\nredis> HEXISTS myhash field1\n(integer) 1\nredis> HEXISTS myhash field2\n(integer) 0\nredis> \n```","slug":"redis_command/hash/hexists","published":1,"updated":"2021-03-14T03:04:50.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvo005ehyjfhbarev9t","content":"<h2 id=\"HEXISTS-key-field\"><a href=\"#HEXISTS-key-field\" class=\"headerlink\" title=\"HEXISTS key field\"></a>HEXISTS key field</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回hash里面field是否存在</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>, 含义如下：<br>1 hash里面包含该field。<br>0 hash里面不包含该field或者key不存在。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;foo&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HEXISTS myhash field1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HEXISTS myhash field2</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HEXISTS-key-field\"><a href=\"#HEXISTS-key-field\" class=\"headerlink\" title=\"HEXISTS key field\"></a>HEXISTS key field</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回hash里面field是否存在</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>, 含义如下：<br>1 hash里面包含该field。<br>0 hash里面不包含该field或者key不存在。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;foo&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HEXISTS myhash field1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HEXISTS myhash field2</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HGET(hget)","copyright":true,"date":"2020-03-18T10:21:18.000Z","keywords":"Redis命令,hget","aside":"Hash","_content":"## HGET key field \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回 key 指定的哈希集中该字段所关联的值\n\n#### 返回值\n\n**bulk-string-reply**：该字段所关联的值。当字段不存在或者 key 不存在时返回nil。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"foo\"\n(integer) 1\nredis> HGET myhash field1\n\"foo\"\nredis> HGET myhash field2\n(nil)\nredis> \n```","source":"_posts/redis_command/hash/hget.md","raw":"---\n\ntitle: HGET(hget)\ncopyright: true\ndate: 2020-03-18 18:21:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hget\naside: Hash\n---\n## HGET key field \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回 key 指定的哈希集中该字段所关联的值\n\n#### 返回值\n\n**bulk-string-reply**：该字段所关联的值。当字段不存在或者 key 不存在时返回nil。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"foo\"\n(integer) 1\nredis> HGET myhash field1\n\"foo\"\nredis> HGET myhash field2\n(nil)\nredis> \n```","slug":"redis_command/hash/hget","published":1,"updated":"2021-03-14T03:04:50.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvo005ghyjfgo9bsv48","content":"<h2 id=\"HGET-key-field\"><a href=\"#HGET-key-field\" class=\"headerlink\" title=\"HGET key field\"></a>HGET key field</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集中该字段所关联的值</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>：该字段所关联的值。当字段不存在或者 key 不存在时返回nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;foo&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HGET myhash field1</span><br><span class=\"line\">&quot;foo&quot;</span><br><span class=\"line\">redis&gt; HGET myhash field2</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HGET-key-field\"><a href=\"#HGET-key-field\" class=\"headerlink\" title=\"HGET key field\"></a>HGET key field</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集中该字段所关联的值</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>：该字段所关联的值。当字段不存在或者 key 不存在时返回nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;foo&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HGET myhash field1</span><br><span class=\"line\">&quot;foo&quot;</span><br><span class=\"line\">redis&gt; HGET myhash field2</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HINCRBY(hincrby)","copyright":true,"date":"2020-03-18T10:19:18.000Z","keywords":"Redis命令,hincrby","aside":"Hash","_content":"## HINCRBY key field increment \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 增加 key 指定的哈希集中指定字段的数值。如果 key 不存在，会创建一个新的哈希集并与 key 关联。如果字段不存在，则字段的值在该操作执行前被设置为 0\n* HINCRBY 支持的值的范围限定在 64位 有符号整数\n\n#### 返回值\n\n**integer-reply**：增值操作执行后的该字段的值。\n\n\n#### 示例\n\n```\nredis> HSET myhash field 5\n(integer) 1\nredis> HINCRBY myhash field 1\n(integer) 6\nredis> HINCRBY myhash field -1\n(integer) 5\nredis> HINCRBY myhash field -10\n(integer) -5\nredis> \n```","source":"_posts/redis_command/hash/hincrby.md","raw":"---\n\ntitle: HINCRBY(hincrby)\ncopyright: true\ndate: 2020-03-18 18:19:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hincrby\naside: Hash\n---\n## HINCRBY key field increment \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 增加 key 指定的哈希集中指定字段的数值。如果 key 不存在，会创建一个新的哈希集并与 key 关联。如果字段不存在，则字段的值在该操作执行前被设置为 0\n* HINCRBY 支持的值的范围限定在 64位 有符号整数\n\n#### 返回值\n\n**integer-reply**：增值操作执行后的该字段的值。\n\n\n#### 示例\n\n```\nredis> HSET myhash field 5\n(integer) 1\nredis> HINCRBY myhash field 1\n(integer) 6\nredis> HINCRBY myhash field -1\n(integer) 5\nredis> HINCRBY myhash field -10\n(integer) -5\nredis> \n```","slug":"redis_command/hash/hincrby","published":1,"updated":"2021-03-14T03:04:50.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvp005jhyjfquts20ia","content":"<h2 id=\"HINCRBY-key-field-increment\"><a href=\"#HINCRBY-key-field-increment\" class=\"headerlink\" title=\"HINCRBY key field increment\"></a>HINCRBY key field increment</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>增加 key 指定的哈希集中指定字段的数值。如果 key 不存在，会创建一个新的哈希集并与 key 关联。如果字段不存在，则字段的值在该操作执行前被设置为 0</li>\n<li>HINCRBY 支持的值的范围限定在 64位 有符号整数</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：增值操作执行后的该字段的值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field 5</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HINCRBY myhash field 1</span><br><span class=\"line\">(integer) 6</span><br><span class=\"line\">redis&gt; HINCRBY myhash field -1</span><br><span class=\"line\">(integer) 5</span><br><span class=\"line\">redis&gt; HINCRBY myhash field -10</span><br><span class=\"line\">(integer) -5</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HINCRBY-key-field-increment\"><a href=\"#HINCRBY-key-field-increment\" class=\"headerlink\" title=\"HINCRBY key field increment\"></a>HINCRBY key field increment</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>增加 key 指定的哈希集中指定字段的数值。如果 key 不存在，会创建一个新的哈希集并与 key 关联。如果字段不存在，则字段的值在该操作执行前被设置为 0</li>\n<li>HINCRBY 支持的值的范围限定在 64位 有符号整数</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：增值操作执行后的该字段的值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field 5</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HINCRBY myhash field 1</span><br><span class=\"line\">(integer) 6</span><br><span class=\"line\">redis&gt; HINCRBY myhash field -1</span><br><span class=\"line\">(integer) 5</span><br><span class=\"line\">redis&gt; HINCRBY myhash field -10</span><br><span class=\"line\">(integer) -5</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HINCRBYFLOAT(hincrbyfloat)","copyright":true,"date":"2020-03-18T10:18:18.000Z","keywords":"Redis命令,hincrbyfloat","aside":"Hash","_content":"## HINCRBYFLOAT key field increment \n>起始版本：2.6.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 为指定key的hash的field字段值执行float类型的increment。如果field不存在，则在执行该操作前设置为0.如果出现下列情况之一，则返回错误：\n* field的值包含的类型错误(不是字符串)。\n\n#### 返回值\n\n**bulk-string-reply**： field执行increment后的值\n\n\n#### 示例\n\n```\nredis> HSET mykey field 10.50\n(integer) 1\nredis> HINCRBYFLOAT mykey field 0.1\n\"10.6\"\nredis> HSET mykey field 5.0e3\n(integer) 0\nredis> HINCRBYFLOAT mykey field 2.0e2\n\"5200\"\nredis> \n```","source":"_posts/redis_command/hash/hincrbyfloat.md","raw":"---\n\ntitle: HINCRBYFLOAT(hincrbyfloat)\ncopyright: true\ndate: 2020-03-18 18:18:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hincrbyfloat\naside: Hash\n---\n## HINCRBYFLOAT key field increment \n>起始版本：2.6.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 为指定key的hash的field字段值执行float类型的increment。如果field不存在，则在执行该操作前设置为0.如果出现下列情况之一，则返回错误：\n* field的值包含的类型错误(不是字符串)。\n\n#### 返回值\n\n**bulk-string-reply**： field执行increment后的值\n\n\n#### 示例\n\n```\nredis> HSET mykey field 10.50\n(integer) 1\nredis> HINCRBYFLOAT mykey field 0.1\n\"10.6\"\nredis> HSET mykey field 5.0e3\n(integer) 0\nredis> HINCRBYFLOAT mykey field 2.0e2\n\"5200\"\nredis> \n```","slug":"redis_command/hash/hincrbyfloat","published":1,"updated":"2021-03-14T03:04:50.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvs005lhyjfrnqjlk4a","content":"<h2 id=\"HINCRBYFLOAT-key-field-increment\"><a href=\"#HINCRBYFLOAT-key-field-increment\" class=\"headerlink\" title=\"HINCRBYFLOAT key field increment\"></a>HINCRBYFLOAT key field increment</h2><blockquote>\n<p>起始版本：2.6.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>为指定key的hash的field字段值执行float类型的increment。如果field不存在，则在执行该操作前设置为0.如果出现下列情况之一，则返回错误：</li>\n<li>field的值包含的类型错误(不是字符串)。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>： field执行increment后的值</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET mykey field 10.50</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HINCRBYFLOAT mykey field 0.1</span><br><span class=\"line\">&quot;10.6&quot;</span><br><span class=\"line\">redis&gt; HSET mykey field 5.0e3</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt; HINCRBYFLOAT mykey field 2.0e2</span><br><span class=\"line\">&quot;5200&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HINCRBYFLOAT-key-field-increment\"><a href=\"#HINCRBYFLOAT-key-field-increment\" class=\"headerlink\" title=\"HINCRBYFLOAT key field increment\"></a>HINCRBYFLOAT key field increment</h2><blockquote>\n<p>起始版本：2.6.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>为指定key的hash的field字段值执行float类型的increment。如果field不存在，则在执行该操作前设置为0.如果出现下列情况之一，则返回错误：</li>\n<li>field的值包含的类型错误(不是字符串)。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>： field执行increment后的值</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET mykey field 10.50</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HINCRBYFLOAT mykey field 0.1</span><br><span class=\"line\">&quot;10.6&quot;</span><br><span class=\"line\">redis&gt; HSET mykey field 5.0e3</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt; HINCRBYFLOAT mykey field 2.0e2</span><br><span class=\"line\">&quot;5200&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HLEN(hlen)","copyright":true,"date":"2020-03-18T10:16:18.000Z","keywords":"Redis命令,hlen","aside":"Hash","_content":"## HLEN key \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回 key 指定的哈希集包含的字段的数量。\n\n#### 返回值\n\n\n**integer-reply**： 哈希集中字段的数量，当 key 指定的哈希集不存在时返回 0\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HSET myhash field2 \"World\"\n(integer) 1\nredis> HLEN myhash\n(integer) 2\nredis> \n```","source":"_posts/redis_command/hash/hlen.md","raw":"---\n\ntitle: HLEN(hlen)\ncopyright: true\ndate: 2020-03-18 18:16:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hlen\naside: Hash\n---\n## HLEN key \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回 key 指定的哈希集包含的字段的数量。\n\n#### 返回值\n\n\n**integer-reply**： 哈希集中字段的数量，当 key 指定的哈希集不存在时返回 0\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HSET myhash field2 \"World\"\n(integer) 1\nredis> HLEN myhash\n(integer) 2\nredis> \n```","slug":"redis_command/hash/hlen","published":1,"updated":"2021-03-14T03:04:50.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvu005ohyjfxmfle6rp","content":"<h2 id=\"HLEN-key\"><a href=\"#HLEN-key\" class=\"headerlink\" title=\"HLEN key\"></a>HLEN key</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集包含的字段的数量。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>： 哈希集中字段的数量，当 key 指定的哈希集不存在时返回 0</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSET myhash field2 &quot;World&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HLEN myhash</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HLEN-key\"><a href=\"#HLEN-key\" class=\"headerlink\" title=\"HLEN key\"></a>HLEN key</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集包含的字段的数量。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>： 哈希集中字段的数量，当 key 指定的哈希集不存在时返回 0</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSET myhash field2 &quot;World&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HLEN myhash</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HMGET(hmget)","copyright":true,"date":"2020-03-18T10:15:18.000Z","keywords":"Redis命令,hmget","aside":"Hash","_content":"## HMGET key field [field ...] \n>起始版本：2.0.0<br/>时间复杂度：O(N) 其中N是请求的字段数\n\n\n#### 说明:\n* 返回 key 指定的哈希集中指定字段的值。\n* 对于哈希集中不存在的每个字段，返回 nil 值。因为不存在的keys被认为是一个空的哈希集，对一个不存在的 key 执行 HMGET 将返回一个只含有 nil 值的列表\n\n#### 返回值\n\n**array-reply**：含有给定字段及其值的列表，并保持与请求相同的顺序。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HSET myhash field2 \"World\"\n(integer) 1\nredis> HMGET myhash field1 field2 nofield\n1) \"Hello\"\n2) \"World\"\n3) (nil)\nredis> \n```","source":"_posts/redis_command/hash/hmget.md","raw":"---\n\ntitle: HMGET(hmget)\ncopyright: true\ndate: 2020-03-18 18:15:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hmget\naside: Hash\n---\n## HMGET key field [field ...] \n>起始版本：2.0.0<br/>时间复杂度：O(N) 其中N是请求的字段数\n\n\n#### 说明:\n* 返回 key 指定的哈希集中指定字段的值。\n* 对于哈希集中不存在的每个字段，返回 nil 值。因为不存在的keys被认为是一个空的哈希集，对一个不存在的 key 执行 HMGET 将返回一个只含有 nil 值的列表\n\n#### 返回值\n\n**array-reply**：含有给定字段及其值的列表，并保持与请求相同的顺序。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HSET myhash field2 \"World\"\n(integer) 1\nredis> HMGET myhash field1 field2 nofield\n1) \"Hello\"\n2) \"World\"\n3) (nil)\nredis> \n```","slug":"redis_command/hash/hmget","published":1,"updated":"2021-03-14T03:04:50.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvv005qhyjftn600mb7","content":"<h2 id=\"HMGET-key-field-field-…\"><a href=\"#HMGET-key-field-field-…\" class=\"headerlink\" title=\"HMGET key field [field …]\"></a>HMGET key field [field …]</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N) 其中N是请求的字段数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集中指定字段的值。</li>\n<li>对于哈希集中不存在的每个字段，返回 nil 值。因为不存在的keys被认为是一个空的哈希集，对一个不存在的 key 执行 HMGET 将返回一个只含有 nil 值的列表</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>：含有给定字段及其值的列表，并保持与请求相同的顺序。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSET myhash field2 &quot;World&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HMGET myhash field1 field2 nofield</span><br><span class=\"line\">1) &quot;Hello&quot;</span><br><span class=\"line\">2) &quot;World&quot;</span><br><span class=\"line\">3) (nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HMGET-key-field-field-…\"><a href=\"#HMGET-key-field-field-…\" class=\"headerlink\" title=\"HMGET key field [field …]\"></a>HMGET key field [field …]</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N) 其中N是请求的字段数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集中指定字段的值。</li>\n<li>对于哈希集中不存在的每个字段，返回 nil 值。因为不存在的keys被认为是一个空的哈希集，对一个不存在的 key 执行 HMGET 将返回一个只含有 nil 值的列表</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>：含有给定字段及其值的列表，并保持与请求相同的顺序。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSET myhash field2 &quot;World&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HMGET myhash field1 field2 nofield</span><br><span class=\"line\">1) &quot;Hello&quot;</span><br><span class=\"line\">2) &quot;World&quot;</span><br><span class=\"line\">3) (nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HKEYS(hkeys)","copyright":true,"date":"2020-03-18T10:17:18.000Z","keywords":"Redis命令,hkeys","aside":"Hash","_content":"## HKEYS key \n>起始版本：2.0.0<br/>时间复杂度：O(N) N是Hash的长度\n\n\n#### 说明:\n* 返回 key 指定的哈希集中所有字段的名字。\n\n#### 返回值\n\n**array-reply**：哈希集中的字段列表，当 key 指定的哈希集不存在时返回空列表。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HSET myhash field2 \"World\"\n(integer) 1\nredis> HKEYS myhash\n1) \"field1\"\n2) \"field2\"\nredis> \n```","source":"_posts/redis_command/hash/hkeys.md","raw":"---\n\ntitle: HKEYS(hkeys)\ncopyright: true\ndate: 2020-03-18 18:17:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hkeys\naside: Hash\n---\n## HKEYS key \n>起始版本：2.0.0<br/>时间复杂度：O(N) N是Hash的长度\n\n\n#### 说明:\n* 返回 key 指定的哈希集中所有字段的名字。\n\n#### 返回值\n\n**array-reply**：哈希集中的字段列表，当 key 指定的哈希集不存在时返回空列表。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HSET myhash field2 \"World\"\n(integer) 1\nredis> HKEYS myhash\n1) \"field1\"\n2) \"field2\"\nredis> \n```","slug":"redis_command/hash/hkeys","published":1,"updated":"2021-03-14T03:04:50.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvw005shyjfpzzazmm2","content":"<h2 id=\"HKEYS-key\"><a href=\"#HKEYS-key\" class=\"headerlink\" title=\"HKEYS key\"></a>HKEYS key</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N) N是Hash的长度</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集中所有字段的名字。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>：哈希集中的字段列表，当 key 指定的哈希集不存在时返回空列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSET myhash field2 &quot;World&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HKEYS myhash</span><br><span class=\"line\">1) &quot;field1&quot;</span><br><span class=\"line\">2) &quot;field2&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HKEYS-key\"><a href=\"#HKEYS-key\" class=\"headerlink\" title=\"HKEYS key\"></a>HKEYS key</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N) N是Hash的长度</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集中所有字段的名字。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>：哈希集中的字段列表，当 key 指定的哈希集不存在时返回空列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSET myhash field2 &quot;World&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HKEYS myhash</span><br><span class=\"line\">1) &quot;field1&quot;</span><br><span class=\"line\">2) &quot;field2&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HMSET(hmset)","copyright":true,"date":"2020-03-18T10:14:18.000Z","keywords":"Redis命令,hmset","aside":"Hash","_content":"## HMSET key field value [field value ...] \n>起始版本：2.0.0<br/>时间复杂度：O(N) 其中N是设置的字段数\n\n\n#### 说明:\n* 设置 key 指定的哈希集中指定字段的值。该命令将重写所有在哈希集中存在的字段。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联\n\n#### 返回值\n\n**simple-string-reply**\n\n\n#### 示例\n\n```\nredis> HMSET myhash field1 \"Hello\" field2 \"World\"\nOK\nredis> HGET myhash field1\n\"Hello\"\nredis> HGET myhash field2\n\"World\"\nredis> \n```","source":"_posts/redis_command/hash/hmset.md","raw":"---\n\ntitle: HMSET(hmset)\ncopyright: true\ndate: 2020-03-18 18:14:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hmset\naside: Hash\n---\n## HMSET key field value [field value ...] \n>起始版本：2.0.0<br/>时间复杂度：O(N) 其中N是设置的字段数\n\n\n#### 说明:\n* 设置 key 指定的哈希集中指定字段的值。该命令将重写所有在哈希集中存在的字段。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联\n\n#### 返回值\n\n**simple-string-reply**\n\n\n#### 示例\n\n```\nredis> HMSET myhash field1 \"Hello\" field2 \"World\"\nOK\nredis> HGET myhash field1\n\"Hello\"\nredis> HGET myhash field2\n\"World\"\nredis> \n```","slug":"redis_command/hash/hmset","published":1,"updated":"2021-03-14T03:04:50.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvy005vhyjfgkw5lo31","content":"<h2 id=\"HMSET-key-field-value-field-value-…\"><a href=\"#HMSET-key-field-value-field-value-…\" class=\"headerlink\" title=\"HMSET key field value [field value …]\"></a>HMSET key field value [field value …]</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N) 其中N是设置的字段数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>设置 key 指定的哈希集中指定字段的值。该命令将重写所有在哈希集中存在的字段。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong></p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; HGET myhash field1</span><br><span class=\"line\">&quot;Hello&quot;</span><br><span class=\"line\">redis&gt; HGET myhash field2</span><br><span class=\"line\">&quot;World&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HMSET-key-field-value-field-value-…\"><a href=\"#HMSET-key-field-value-field-value-…\" class=\"headerlink\" title=\"HMSET key field value [field value …]\"></a>HMSET key field value [field value …]</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N) 其中N是设置的字段数</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>设置 key 指定的哈希集中指定字段的值。该命令将重写所有在哈希集中存在的字段。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong></p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; HGET myhash field1</span><br><span class=\"line\">&quot;Hello&quot;</span><br><span class=\"line\">redis&gt; HGET myhash field2</span><br><span class=\"line\">&quot;World&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HSCAN(hscan)","copyright":true,"date":"2020-03-18T10:09:18.000Z","keywords":"Redis命令,hscan","aside":"Hash","_content":"## HSCAN key cursor [MATCH pattern] [COUNT count] \n>起始版本：2.8.0<br/>时间复杂度：O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..  \n\n\n#### 说明:\n* 请参考 SCAN命令， HSCAN与之类似 。\n\n","source":"_posts/redis_command/hash/hscan.md","raw":"---\n\ntitle: HSCAN(hscan)\ncopyright: true\ndate: 2020-03-18 18:09:18\ncategories: \n\n- Redis命令大全\n- Hash\nkeywords: Redis命令,hscan\naside: Hash\n---\n## HSCAN key cursor [MATCH pattern] [COUNT count] \n>起始版本：2.8.0<br/>时间复杂度：O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..  \n\n\n#### 说明:\n* 请参考 SCAN命令， HSCAN与之类似 。\n\n","slug":"redis_command/hash/hscan","published":1,"updated":"2021-03-14T03:04:50.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpvz005xhyjf6scirzck","content":"<h2 id=\"HSCAN-key-cursor-MATCH-pattern-COUNT-count\"><a href=\"#HSCAN-key-cursor-MATCH-pattern-COUNT-count\" class=\"headerlink\" title=\"HSCAN key cursor [MATCH pattern] [COUNT count]\"></a>HSCAN key cursor [MATCH pattern] [COUNT count]</h2><blockquote>\n<p>起始版本：2.8.0<br>时间复杂度：O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>请参考 SCAN命令， HSCAN与之类似 。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HSCAN-key-cursor-MATCH-pattern-COUNT-count\"><a href=\"#HSCAN-key-cursor-MATCH-pattern-COUNT-count\" class=\"headerlink\" title=\"HSCAN key cursor [MATCH pattern] [COUNT count]\"></a>HSCAN key cursor [MATCH pattern] [COUNT count]</h2><blockquote>\n<p>起始版本：2.8.0<br>时间复杂度：O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>请参考 SCAN命令， HSCAN与之类似 。</li>\n</ul>\n"},{"title":"HSET(hset)","copyright":true,"date":"2020-03-18T10:13:18.000Z","keywords":"Redis命令,hset","aside":"Hash","_content":"## HSET key field value \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 设置 key 指定的哈希集中指定字段的值。\n* 如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。\n* 如果字段在哈希集中存在，它将被重写。\n\n#### 返回值\n\n**integer-reply**：含义如下\n1 如果field是一个新的字段\n0 如果field原来在map里面已经存在\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HGET myhash field1\n\"Hello\"\nredis> \n```","source":"_posts/redis_command/hash/hset.md","raw":"---\n\ntitle: HSET(hset)\ncopyright: true\ndate: 2020-03-18 18:13:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hset\naside: Hash\n---\n## HSET key field value \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 设置 key 指定的哈希集中指定字段的值。\n* 如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。\n* 如果字段在哈希集中存在，它将被重写。\n\n#### 返回值\n\n**integer-reply**：含义如下\n1 如果field是一个新的字段\n0 如果field原来在map里面已经存在\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HGET myhash field1\n\"Hello\"\nredis> \n```","slug":"redis_command/hash/hset","published":1,"updated":"2021-03-14T03:04:50.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw00060hyjfagubriyo","content":"<h2 id=\"HSET-key-field-value\"><a href=\"#HSET-key-field-value\" class=\"headerlink\" title=\"HSET key field value\"></a>HSET key field value</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>设置 key 指定的哈希集中指定字段的值。</li>\n<li>如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。</li>\n<li>如果字段在哈希集中存在，它将被重写。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：含义如下<br>1 如果field是一个新的字段<br>0 如果field原来在map里面已经存在</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HGET myhash field1</span><br><span class=\"line\">&quot;Hello&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HSET-key-field-value\"><a href=\"#HSET-key-field-value\" class=\"headerlink\" title=\"HSET key field value\"></a>HSET key field value</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>设置 key 指定的哈希集中指定字段的值。</li>\n<li>如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。</li>\n<li>如果字段在哈希集中存在，它将被重写。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：含义如下<br>1 如果field是一个新的字段<br>0 如果field原来在map里面已经存在</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HGET myhash field1</span><br><span class=\"line\">&quot;Hello&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HSETNX(hsetnx)","copyright":true,"date":"2020-03-18T10:12:18.000Z","keywords":"Redis命令,hsetnx","aside":"Hash","_content":"## HSETNX key field value \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 只在 key 指定的哈希集中不存在指定的字段时，设置字段的值。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段已存在，该操作无效果。\n\n#### 返回值\n\n**integer-reply**：含义如下\n1：如果字段是个新的字段，并成功赋值\n0：如果哈希集中已存在该字段，没有操作被执行\n\n\n#### 示例\n\n```\nredis> HSETNX myhash field \"Hello\"\n(integer) 1\nredis> HSETNX myhash field \"World\"\n(integer) 0\nredis> HGET myhash field\n\"Hello\"\nredis> \n```","source":"_posts/redis_command/hash/hsetnx.md","raw":"---\n\ntitle: HSETNX(hsetnx)\ncopyright: true\ndate: 2020-03-18 18:12:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hsetnx\naside: Hash\n---\n## HSETNX key field value \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 只在 key 指定的哈希集中不存在指定的字段时，设置字段的值。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段已存在，该操作无效果。\n\n#### 返回值\n\n**integer-reply**：含义如下\n1：如果字段是个新的字段，并成功赋值\n0：如果哈希集中已存在该字段，没有操作被执行\n\n\n#### 示例\n\n```\nredis> HSETNX myhash field \"Hello\"\n(integer) 1\nredis> HSETNX myhash field \"World\"\n(integer) 0\nredis> HGET myhash field\n\"Hello\"\nredis> \n```","slug":"redis_command/hash/hsetnx","published":1,"updated":"2021-03-14T03:04:50.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw10062hyjf0qfumkuq","content":"<h2 id=\"HSETNX-key-field-value\"><a href=\"#HSETNX-key-field-value\" class=\"headerlink\" title=\"HSETNX key field value\"></a>HSETNX key field value</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>只在 key 指定的哈希集中不存在指定的字段时，设置字段的值。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段已存在，该操作无效果。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：含义如下<br>1：如果字段是个新的字段，并成功赋值<br>0：如果哈希集中已存在该字段，没有操作被执行</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSETNX myhash field &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSETNX myhash field &quot;World&quot;</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt; HGET myhash field</span><br><span class=\"line\">&quot;Hello&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HSETNX-key-field-value\"><a href=\"#HSETNX-key-field-value\" class=\"headerlink\" title=\"HSETNX key field value\"></a>HSETNX key field value</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>只在 key 指定的哈希集中不存在指定的字段时，设置字段的值。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段已存在，该操作无效果。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：含义如下<br>1：如果字段是个新的字段，并成功赋值<br>0：如果哈希集中已存在该字段，没有操作被执行</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSETNX myhash field &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSETNX myhash field &quot;World&quot;</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">redis&gt; HGET myhash field</span><br><span class=\"line\">&quot;Hello&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HSTRLEN(hstrlen)","copyright":true,"date":"2020-03-18T10:11:18.000Z","keywords":"Redis命令,hstrlen","aside":"Hash","_content":"## HSTRLEN key field \n>起始版本：3.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0.\n\n#### 返回值\n\n**integer-reply**:返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0.\n\n\n#### 示例\n\n```\nredis> HMSET myhash f1 HelloWorld f2 99 f3 -256\nOK\nredis> HSTRLEN myhash f1\n(integer) 10\nredis> HSTRLEN myhash f2\n(integer) 2\nredis> HSTRLEN myhash f3\n(integer) 4\nredis> \n```","source":"_posts/redis_command/hash/hstrlen.md","raw":"---\n\ntitle: HSTRLEN(hstrlen)\ncopyright: true\ndate: 2020-03-18 18:11:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hstrlen\naside: Hash\n---\n## HSTRLEN key field \n>起始版本：3.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0.\n\n#### 返回值\n\n**integer-reply**:返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0.\n\n\n#### 示例\n\n```\nredis> HMSET myhash f1 HelloWorld f2 99 f3 -256\nOK\nredis> HSTRLEN myhash f1\n(integer) 10\nredis> HSTRLEN myhash f2\n(integer) 2\nredis> HSTRLEN myhash f3\n(integer) 4\nredis> \n```","slug":"redis_command/hash/hstrlen","published":1,"updated":"2021-03-14T03:04:50.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw10065hyjfiqgtogpr","content":"<h2 id=\"HSTRLEN-key-field\"><a href=\"#HSTRLEN-key-field\" class=\"headerlink\" title=\"HSTRLEN key field\"></a>HSTRLEN key field</h2><blockquote>\n<p>起始版本：3.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HMSET myhash f1 HelloWorld f2 99 f3 -256</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; HSTRLEN myhash f1</span><br><span class=\"line\">(integer) 10</span><br><span class=\"line\">redis&gt; HSTRLEN myhash f2</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">redis&gt; HSTRLEN myhash f3</span><br><span class=\"line\">(integer) 4</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HSTRLEN-key-field\"><a href=\"#HSTRLEN-key-field\" class=\"headerlink\" title=\"HSTRLEN key field\"></a>HSTRLEN key field</h2><blockquote>\n<p>起始版本：3.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0.</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HMSET myhash f1 HelloWorld f2 99 f3 -256</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; HSTRLEN myhash f1</span><br><span class=\"line\">(integer) 10</span><br><span class=\"line\">redis&gt; HSTRLEN myhash f2</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">redis&gt; HSTRLEN myhash f3</span><br><span class=\"line\">(integer) 4</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"HVALS(hvals)","copyright":true,"date":"2020-03-18T10:10:18.000Z","keywords":"Redis命令,hvals","aside":"Hash","_content":"## HVALS key \n>起始版本：2.0.0<br/>时间复杂度：O(N) where N is the size of the hash.  \n\n\n#### 说明:\n* 返回 key 指定的哈希集中所有字段的值。\n\n#### 返回值\n\n\narray-reply：哈希集中的值的列表，当 key 指定的哈希集不存在时返回空列表。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HSET myhash field2 \"World\"\n(integer) 1\nredis> HVALS myhash\n1) \"Hello\"\n2) \"World\"\nredis> \n```","source":"_posts/redis_command/hash/hvals.md","raw":"---\n\ntitle: HVALS(hvals)\ncopyright: true\ndate: 2020-03-18 18:10:18\ncategories: \n- Redis命令大全\n- Hash\nkeywords: Redis命令,hvals\naside: Hash\n---\n## HVALS key \n>起始版本：2.0.0<br/>时间复杂度：O(N) where N is the size of the hash.  \n\n\n#### 说明:\n* 返回 key 指定的哈希集中所有字段的值。\n\n#### 返回值\n\n\narray-reply：哈希集中的值的列表，当 key 指定的哈希集不存在时返回空列表。\n\n\n#### 示例\n\n```\nredis> HSET myhash field1 \"Hello\"\n(integer) 1\nredis> HSET myhash field2 \"World\"\n(integer) 1\nredis> HVALS myhash\n1) \"Hello\"\n2) \"World\"\nredis> \n```","slug":"redis_command/hash/hvals","published":1,"updated":"2021-03-14T03:04:50.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw20067hyjfp1z1631g","content":"<h2 id=\"HVALS-key\"><a href=\"#HVALS-key\" class=\"headerlink\" title=\"HVALS key\"></a>HVALS key</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N) where N is the size of the hash.  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集中所有字段的值。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>array-reply：哈希集中的值的列表，当 key 指定的哈希集不存在时返回空列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSET myhash field2 &quot;World&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HVALS myhash</span><br><span class=\"line\">1) &quot;Hello&quot;</span><br><span class=\"line\">2) &quot;World&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HVALS-key\"><a href=\"#HVALS-key\" class=\"headerlink\" title=\"HVALS key\"></a>HVALS key</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(N) where N is the size of the hash.  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回 key 指定的哈希集中所有字段的值。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p>array-reply：哈希集中的值的列表，当 key 指定的哈希集不存在时返回空列表。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; HSET myhash field1 &quot;Hello&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HSET myhash field2 &quot;World&quot;</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">redis&gt; HVALS myhash</span><br><span class=\"line\">1) &quot;Hello&quot;</span><br><span class=\"line\">2) &quot;World&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"APPEND(append)","copyright":true,"date":"2020-04-02T05:11:02.000Z","keywords":"Redis命令,append","aside":"string","_content":"## APPEND key value \n>起始版本：2.0.0<br/>时间复杂度：O(1)。均摊时间复杂度是O(1)， 因为redis用的动态字符串的库在每次分配空间的时候会增加一倍的可用空闲空间，所以在添加的value较小而且已经存在的 value是任意大小的情况下，均摊时间复杂度是O(1) 。  \n\n\n#### 说明:\n* 如果 key 已经存在，并且值为字符串，那么这个命令会把 value 追加到原来值（value）的结尾。 如果 key 不存在，那么它将首先创建一个空字符串的key，再执行追加操作，这种情况 APPEND 将类似于 SET 操作。\n\n#### 返回值\n\n**Integer reply**：返回append后字符串值（value）的长度。\n\n\n#### 示例\n\n```c\nredis> EXISTS mykey\n(integer) 0\nredis> APPEND mykey \"Hello\"\n(integer) 5\nredis> APPEND mykey \" World\"\n(integer) 11\nredis> GET mykey\n\"Hello World\"\nredis>\n```\n","source":"_posts/redis_command/string/append.md","raw":"---\n\ntitle: APPEND(append)\ncopyright: true\ndate: 2020-04-02 13:11:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,append\naside: string\n\n---\n## APPEND key value \n>起始版本：2.0.0<br/>时间复杂度：O(1)。均摊时间复杂度是O(1)， 因为redis用的动态字符串的库在每次分配空间的时候会增加一倍的可用空闲空间，所以在添加的value较小而且已经存在的 value是任意大小的情况下，均摊时间复杂度是O(1) 。  \n\n\n#### 说明:\n* 如果 key 已经存在，并且值为字符串，那么这个命令会把 value 追加到原来值（value）的结尾。 如果 key 不存在，那么它将首先创建一个空字符串的key，再执行追加操作，这种情况 APPEND 将类似于 SET 操作。\n\n#### 返回值\n\n**Integer reply**：返回append后字符串值（value）的长度。\n\n\n#### 示例\n\n```c\nredis> EXISTS mykey\n(integer) 0\nredis> APPEND mykey \"Hello\"\n(integer) 5\nredis> APPEND mykey \" World\"\n(integer) 11\nredis> GET mykey\n\"Hello World\"\nredis>\n```\n","slug":"redis_command/string/append","published":1,"updated":"2021-03-14T03:04:50.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw3006ahyjfnhd33no1","content":"<h2 id=\"APPEND-key-value\"><a href=\"#APPEND-key-value\" class=\"headerlink\" title=\"APPEND key value\"></a>APPEND key value</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)。均摊时间复杂度是O(1)， 因为redis用的动态字符串的库在每次分配空间的时候会增加一倍的可用空闲空间，所以在添加的value较小而且已经存在的 value是任意大小的情况下，均摊时间复杂度是O(1) 。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>如果 key 已经存在，并且值为字符串，那么这个命令会把 value 追加到原来值（value）的结尾。 如果 key 不存在，那么它将首先创建一个空字符串的key，再执行追加操作，这种情况 APPEND 将类似于 SET 操作。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply</strong>：返回append后字符串值（value）的长度。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; EXISTS mykey</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; APPEND mykey <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt; APPEND mykey <span class=\"string\">\" World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">11</span></span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"APPEND-key-value\"><a href=\"#APPEND-key-value\" class=\"headerlink\" title=\"APPEND key value\"></a>APPEND key value</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)。均摊时间复杂度是O(1)， 因为redis用的动态字符串的库在每次分配空间的时候会增加一倍的可用空闲空间，所以在添加的value较小而且已经存在的 value是任意大小的情况下，均摊时间复杂度是O(1) 。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>如果 key 已经存在，并且值为字符串，那么这个命令会把 value 追加到原来值（value）的结尾。 如果 key 不存在，那么它将首先创建一个空字符串的key，再执行追加操作，这种情况 APPEND 将类似于 SET 操作。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply</strong>：返回append后字符串值（value）的长度。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; EXISTS mykey</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; APPEND mykey <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt; APPEND mykey <span class=\"string\">\" World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">11</span></span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"DECR(decr)","copyright":true,"date":"2020-04-02T05:06:02.000Z","keywords":"Redis命令,decr","aside":"string","_content":"## DECR key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 对key对应的数字做减1操作。如果key不存在，那么在操作之前，这个key对应的值会被置为0。如果key有一个错误类型的value或者是一个不能表示成数字的字符串，就返回错误。这个操作最大支持在64位有符号的整型数字。\n* 查看命令INCR了解关于增减操作的额外信息。\n\n#### 返回值\n\n**integer-reply**：减小之后的value\n\n\n#### 示例\n\n```c\nredis> SET mykey \"10\"\nOK\nredis> DECR mykey\n(integer) 9\nredis> SET mykey \"234293482390480948029348230948\"\nOK\nredis> DECR mykey\nERR value is not an integer or out of range\nredis> \n```","source":"_posts/redis_command/string/decr.md","raw":"---\n\ntitle: DECR(decr)\ncopyright: true\ndate: 2020-04-02 13:06:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,decr\naside: string\n\n---\n## DECR key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 对key对应的数字做减1操作。如果key不存在，那么在操作之前，这个key对应的值会被置为0。如果key有一个错误类型的value或者是一个不能表示成数字的字符串，就返回错误。这个操作最大支持在64位有符号的整型数字。\n* 查看命令INCR了解关于增减操作的额外信息。\n\n#### 返回值\n\n**integer-reply**：减小之后的value\n\n\n#### 示例\n\n```c\nredis> SET mykey \"10\"\nOK\nredis> DECR mykey\n(integer) 9\nredis> SET mykey \"234293482390480948029348230948\"\nOK\nredis> DECR mykey\nERR value is not an integer or out of range\nredis> \n```","slug":"redis_command/string/decr","published":1,"updated":"2021-03-14T03:04:50.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw4006chyjfkkml08oc","content":"<h2 id=\"DECR-key\"><a href=\"#DECR-key\" class=\"headerlink\" title=\"DECR key\"></a>DECR key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>对key对应的数字做减1操作。如果key不存在，那么在操作之前，这个key对应的值会被置为0。如果key有一个错误类型的value或者是一个不能表示成数字的字符串，就返回错误。这个操作最大支持在64位有符号的整型数字。</li>\n<li>查看命令INCR了解关于增减操作的额外信息。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：减小之后的value</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"10\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; DECR mykey</span><br><span class=\"line\">(integer) <span class=\"number\">9</span></span><br><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"234293482390480948029348230948\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; DECR mykey</span><br><span class=\"line\">ERR value is <span class=\"keyword\">not</span> an integer <span class=\"keyword\">or</span> out of range</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"DECR-key\"><a href=\"#DECR-key\" class=\"headerlink\" title=\"DECR key\"></a>DECR key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>对key对应的数字做减1操作。如果key不存在，那么在操作之前，这个key对应的值会被置为0。如果key有一个错误类型的value或者是一个不能表示成数字的字符串，就返回错误。这个操作最大支持在64位有符号的整型数字。</li>\n<li>查看命令INCR了解关于增减操作的额外信息。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：减小之后的value</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"10\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; DECR mykey</span><br><span class=\"line\">(integer) <span class=\"number\">9</span></span><br><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"234293482390480948029348230948\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; DECR mykey</span><br><span class=\"line\">ERR value is <span class=\"keyword\">not</span> an integer <span class=\"keyword\">or</span> out of range</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"DECRBY(decrby)","copyright":true,"date":"2020-04-02T05:05:02.000Z","keywords":"Redis命令,decrby","aside":"string","_content":"## DECRBY key decrement \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将key对应的数字减decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。\n* 查看命令INCR了解关于增减操作的额外信息。似。\n\n#### 返回值\n\n\n**integer-reply**：减少之后的value值。\n\n\n#### 示例\n\n```c\nredis> SET mykey \"10\"\nOK\nredis> DECRBY mykey 5\n(integer) 5\nredis> \n```","source":"_posts/redis_command/string/decrby.md","raw":"---\n\ntitle: DECRBY(decrby)\ncopyright: true\ndate: 2020-04-02 13:05:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,decrby\naside: string\n\n---\n## DECRBY key decrement \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将key对应的数字减decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。\n* 查看命令INCR了解关于增减操作的额外信息。似。\n\n#### 返回值\n\n\n**integer-reply**：减少之后的value值。\n\n\n#### 示例\n\n```c\nredis> SET mykey \"10\"\nOK\nredis> DECRBY mykey 5\n(integer) 5\nredis> \n```","slug":"redis_command/string/decrby","published":1,"updated":"2021-03-14T03:04:50.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw4006fhyjf18ger2cs","content":"<h2 id=\"DECRBY-key-decrement\"><a href=\"#DECRBY-key-decrement\" class=\"headerlink\" title=\"DECRBY key decrement\"></a>DECRBY key decrement</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将key对应的数字减decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。</li>\n<li>查看命令INCR了解关于增减操作的额外信息。似。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：减少之后的value值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"10\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; DECRBY mykey <span class=\"number\">5</span></span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"DECRBY-key-decrement\"><a href=\"#DECRBY-key-decrement\" class=\"headerlink\" title=\"DECRBY key decrement\"></a>DECRBY key decrement</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将key对应的数字减decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。</li>\n<li>查看命令INCR了解关于增减操作的额外信息。似。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：减少之后的value值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"10\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; DECRBY mykey <span class=\"number\">5</span></span><br><span class=\"line\">(integer) <span class=\"number\">5</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"GETRANGE(getrange)","copyright":true,"date":"2020-04-02T05:02:02.000Z","keywords":"Redis命令,getrange","aside":"string","_content":"## GETRANGE key start end \n>起始版本：2.4.0<br/>时间复杂度：O(N) N是字符串长度，复杂度由最终返回长度决定，但由于通过一个字符串创建子字符串是很容易的，它可以被认为是O(1)。  \n\n\n#### 说明:\n* 警告：这个命令是被改成GETRANGE的，在小于2.0的Redis版本中叫SUBSTR。 返回key对应的字符串value的子串，这个子串是由start和end位移决定的（两者都在string内）。可以用负的位移来表示从string尾部开始数的下标。所以-1就是最后一个字符，-2就是倒数第二个，以此类推。\n* 这个函数处理超出范围的请求时，都把结果限制在string内。\n\n#### 返回值\n\n**bulk-reply**\n\n\n#### 示例\n\n```c\nredis> SET mykey \"This is a string\"\nOK\nredis> GETRANGE mykey 0 3\n\"This\"\nredis> GETRANGE mykey -3 -1\n\"ing\"\nredis> GETRANGE mykey 0 -1\n\"This is a string\"\nredis> GETRANGE mykey 10 100\n\"string\"\nredis> \n```","source":"_posts/redis_command/string/getrange.md","raw":"---\n\ntitle: GETRANGE(getrange)\ncopyright: true\ndate: 2020-04-02 13:02:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,getrange\naside: string\n\n---\n## GETRANGE key start end \n>起始版本：2.4.0<br/>时间复杂度：O(N) N是字符串长度，复杂度由最终返回长度决定，但由于通过一个字符串创建子字符串是很容易的，它可以被认为是O(1)。  \n\n\n#### 说明:\n* 警告：这个命令是被改成GETRANGE的，在小于2.0的Redis版本中叫SUBSTR。 返回key对应的字符串value的子串，这个子串是由start和end位移决定的（两者都在string内）。可以用负的位移来表示从string尾部开始数的下标。所以-1就是最后一个字符，-2就是倒数第二个，以此类推。\n* 这个函数处理超出范围的请求时，都把结果限制在string内。\n\n#### 返回值\n\n**bulk-reply**\n\n\n#### 示例\n\n```c\nredis> SET mykey \"This is a string\"\nOK\nredis> GETRANGE mykey 0 3\n\"This\"\nredis> GETRANGE mykey -3 -1\n\"ing\"\nredis> GETRANGE mykey 0 -1\n\"This is a string\"\nredis> GETRANGE mykey 10 100\n\"string\"\nredis> \n```","slug":"redis_command/string/getrange","published":1,"updated":"2021-03-14T03:04:50.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw5006hhyjf7cimql31","content":"<h2 id=\"GETRANGE-key-start-end\"><a href=\"#GETRANGE-key-start-end\" class=\"headerlink\" title=\"GETRANGE key start end\"></a>GETRANGE key start end</h2><blockquote>\n<p>起始版本：2.4.0<br>时间复杂度：O(N) N是字符串长度，复杂度由最终返回长度决定，但由于通过一个字符串创建子字符串是很容易的，它可以被认为是O(1)。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>警告：这个命令是被改成GETRANGE的，在小于2.0的Redis版本中叫SUBSTR。 返回key对应的字符串value的子串，这个子串是由start和end位移决定的（两者都在string内）。可以用负的位移来表示从string尾部开始数的下标。所以-1就是最后一个字符，-2就是倒数第二个，以此类推。</li>\n<li>这个函数处理超出范围的请求时，都把结果限制在string内。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-reply</strong></p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"This is a string\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; GETRANGE mykey <span class=\"number\">0</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"string\">\"This\"</span></span><br><span class=\"line\">redis&gt; GETRANGE mykey <span class=\"number\">-3</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"string\">\"ing\"</span></span><br><span class=\"line\">redis&gt; GETRANGE mykey <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"string\">\"This is a string\"</span></span><br><span class=\"line\">redis&gt; GETRANGE mykey <span class=\"number\">10</span> <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"string\">\"string\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"GETRANGE-key-start-end\"><a href=\"#GETRANGE-key-start-end\" class=\"headerlink\" title=\"GETRANGE key start end\"></a>GETRANGE key start end</h2><blockquote>\n<p>起始版本：2.4.0<br>时间复杂度：O(N) N是字符串长度，复杂度由最终返回长度决定，但由于通过一个字符串创建子字符串是很容易的，它可以被认为是O(1)。  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>警告：这个命令是被改成GETRANGE的，在小于2.0的Redis版本中叫SUBSTR。 返回key对应的字符串value的子串，这个子串是由start和end位移决定的（两者都在string内）。可以用负的位移来表示从string尾部开始数的下标。所以-1就是最后一个字符，-2就是倒数第二个，以此类推。</li>\n<li>这个函数处理超出范围的请求时，都把结果限制在string内。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-reply</strong></p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"This is a string\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; GETRANGE mykey <span class=\"number\">0</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"string\">\"This\"</span></span><br><span class=\"line\">redis&gt; GETRANGE mykey <span class=\"number\">-3</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"string\">\"ing\"</span></span><br><span class=\"line\">redis&gt; GETRANGE mykey <span class=\"number\">0</span> <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"string\">\"This is a string\"</span></span><br><span class=\"line\">redis&gt; GETRANGE mykey <span class=\"number\">10</span> <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"string\">\"string\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"GET(get)","copyright":true,"date":"2020-04-02T05:04:02.000Z","keywords":"Redis命令,get","aside":"String","_content":"## GET key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回key的value。如果key不存在，返回特殊值nil。如果key的value不是string，就返回错误，因为GET只处理string类型的values。\n\n#### 返回值\n\n**simple-string-reply**:key对应的value，或者nil（key不存在时）\n\n\n#### 示例\n\n```c\nredis> GET nonexisting\n(nil)\nredis> SET mykey \"Hello\"\nOK\nredis> GET mykey\n\"Hello\"\nredis> \n```","source":"_posts/redis_command/string/get.md","raw":"---\n\ntitle: GET(get)\ncopyright: true\ndate: 2020-04-02 13:04:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,get\naside: String\n\n---\n## GET key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回key的value。如果key不存在，返回特殊值nil。如果key的value不是string，就返回错误，因为GET只处理string类型的values。\n\n#### 返回值\n\n**simple-string-reply**:key对应的value，或者nil（key不存在时）\n\n\n#### 示例\n\n```c\nredis> GET nonexisting\n(nil)\nredis> SET mykey \"Hello\"\nOK\nredis> GET mykey\n\"Hello\"\nredis> \n```","slug":"redis_command/string/get","published":1,"updated":"2021-03-14T03:04:50.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw6006khyjf114c901i","content":"<h2 id=\"GET-key\"><a href=\"#GET-key\" class=\"headerlink\" title=\"GET key\"></a>GET key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回key的value。如果key不存在，返回特殊值nil。如果key的value不是string，就返回错误，因为GET只处理string类型的values。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong>:key对应的value，或者nil（key不存在时）</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; GET nonexisting</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"GET-key\"><a href=\"#GET-key\" class=\"headerlink\" title=\"GET key\"></a>GET key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回key的value。如果key不存在，返回特殊值nil。如果key的value不是string，就返回错误，因为GET只处理string类型的values。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong>:key对应的value，或者nil（key不存在时）</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; GET nonexisting</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"INCR(incr)","copyright":true,"date":"2020-04-02T05:00:02.000Z","keywords":"Redis命令,incr","aside":"string","_content":"## INCR key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 对存储在指定key的数值执行原子的加1操作。\n* 如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为0。\n\n#### 返回值\n\n\n**integer-reply**:执行递增操作后key对应的值。\n\n\n#### 示例\n\n```c\nredis> SET mykey \"10\"\nOK\nredis> INCR mykey\n(integer) 11\nredis> GET mykey\n\"11\"\nredis> \n```","source":"_posts/redis_command/string/incr.md","raw":"---\n\ntitle: INCR(incr)\ncopyright: true\ndate: 2020-04-02 13:00:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,incr\naside: string\n\n---\n## INCR key \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 对存储在指定key的数值执行原子的加1操作。\n* 如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为0。\n\n#### 返回值\n\n\n**integer-reply**:执行递增操作后key对应的值。\n\n\n#### 示例\n\n```c\nredis> SET mykey \"10\"\nOK\nredis> INCR mykey\n(integer) 11\nredis> GET mykey\n\"11\"\nredis> \n```","slug":"redis_command/string/incr","published":1,"updated":"2021-03-14T03:04:50.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw6006mhyjfrdlywjt4","content":"<h2 id=\"INCR-key\"><a href=\"#INCR-key\" class=\"headerlink\" title=\"INCR key\"></a>INCR key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>对存储在指定key的数值执行原子的加1操作。</li>\n<li>如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为0。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:执行递增操作后key对应的值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"10\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; INCR mykey</span><br><span class=\"line\">(integer) <span class=\"number\">11</span></span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"11\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"INCR-key\"><a href=\"#INCR-key\" class=\"headerlink\" title=\"INCR key\"></a>INCR key</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>对存储在指定key的数值执行原子的加1操作。</li>\n<li>如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为0。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>:执行递增操作后key对应的值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"10\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; INCR mykey</span><br><span class=\"line\">(integer) <span class=\"number\">11</span></span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"11\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"GETSET(getset)","copyright":true,"date":"2020-04-02T05:01:02.000Z","keywords":"Redis命令,getset","aside":"string","_content":"## GETSET key value \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 自动将key对应到value并且返回原来key对应的value。如果key存在但是对应的value不是字符串，就返回错误。\n* GETSET可以和INCR一起使用实现支持重置的计数功能。举个例子：每当有事件发生的时候，一段程序都会调用INCR给key mycounter加1，但是有时我们需要获取计数器的值，并且自动将其重置为0。这可以通过GETSET mycounter “0”来实现：\n\n```c\nINCR mycounter\nGETSET mycounter \"0\"\nGET mycounter\n```\n\n#### 返回值\n\n**bulk-string-reply**:返回之前的旧值，如果之前`Key`不存在将返回`nil`。\n\n\n#### 示例\n\n```c\nredis> INCR mycounter\n(integer) 1\nredis> GETSET mycounter \"0\"\n\"1\"\nredis> GET mycounter\n\"0\"\nredis> \n```","source":"_posts/redis_command/string/getset.md","raw":"---\n\ntitle: GETSET(getset)\ncopyright: true\ndate: 2020-04-02 13:01:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,getset\naside: string\n\n---\n## GETSET key value \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 自动将key对应到value并且返回原来key对应的value。如果key存在但是对应的value不是字符串，就返回错误。\n* GETSET可以和INCR一起使用实现支持重置的计数功能。举个例子：每当有事件发生的时候，一段程序都会调用INCR给key mycounter加1，但是有时我们需要获取计数器的值，并且自动将其重置为0。这可以通过GETSET mycounter “0”来实现：\n\n```c\nINCR mycounter\nGETSET mycounter \"0\"\nGET mycounter\n```\n\n#### 返回值\n\n**bulk-string-reply**:返回之前的旧值，如果之前`Key`不存在将返回`nil`。\n\n\n#### 示例\n\n```c\nredis> INCR mycounter\n(integer) 1\nredis> GETSET mycounter \"0\"\n\"1\"\nredis> GET mycounter\n\"0\"\nredis> \n```","slug":"redis_command/string/getset","published":1,"updated":"2021-03-14T03:04:50.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw7006phyjf5fdrr3ui","content":"<h2 id=\"GETSET-key-value\"><a href=\"#GETSET-key-value\" class=\"headerlink\" title=\"GETSET key value\"></a>GETSET key value</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>自动将key对应到value并且返回原来key对应的value。如果key存在但是对应的value不是字符串，就返回错误。</li>\n<li>GETSET可以和INCR一起使用实现支持重置的计数功能。举个例子：每当有事件发生的时候，一段程序都会调用INCR给key mycounter加1，但是有时我们需要获取计数器的值，并且自动将其重置为0。这可以通过GETSET mycounter “0”来实现：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INCR mycounter</span><br><span class=\"line\">GETSET mycounter <span class=\"string\">\"0\"</span></span><br><span class=\"line\">GET mycounter</span><br></pre></td></tr></table></figure>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>:返回之前的旧值，如果之前<code>Key</code>不存在将返回<code>nil</code>。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; INCR mycounter</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; GETSET mycounter <span class=\"string\">\"0\"</span></span><br><span class=\"line\"><span class=\"string\">\"1\"</span></span><br><span class=\"line\">redis&gt; GET mycounter</span><br><span class=\"line\"><span class=\"string\">\"0\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"GETSET-key-value\"><a href=\"#GETSET-key-value\" class=\"headerlink\" title=\"GETSET key value\"></a>GETSET key value</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>自动将key对应到value并且返回原来key对应的value。如果key存在但是对应的value不是字符串，就返回错误。</li>\n<li>GETSET可以和INCR一起使用实现支持重置的计数功能。举个例子：每当有事件发生的时候，一段程序都会调用INCR给key mycounter加1，但是有时我们需要获取计数器的值，并且自动将其重置为0。这可以通过GETSET mycounter “0”来实现：</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INCR mycounter</span><br><span class=\"line\">GETSET mycounter <span class=\"string\">\"0\"</span></span><br><span class=\"line\">GET mycounter</span><br></pre></td></tr></table></figure>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>bulk-string-reply</strong>:返回之前的旧值，如果之前<code>Key</code>不存在将返回<code>nil</code>。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; INCR mycounter</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; GETSET mycounter <span class=\"string\">\"0\"</span></span><br><span class=\"line\"><span class=\"string\">\"1\"</span></span><br><span class=\"line\">redis&gt; GET mycounter</span><br><span class=\"line\"><span class=\"string\">\"0\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"INCRBYFLOAT(incrbyfloat)","copyright":true,"date":"2020-04-02T04:58:02.000Z","keywords":"Redis命令,incrbyfloat","aside":"string","_content":"## INCRBYFLOAT key increment \n>起始版本：2.6.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 通过指定浮点数`key`来增长浮点数(存放于string中)的值. 当键不存在时,先将其值设为0再操作.下面任一情况都会返回错误:\n  - key 包含非法值(不是一个string).\n  - 当前的key或者相加后的值不能解析为一个双精度的浮点值.(超出精度范围了)\n* 如果操作命令成功, 相加后的值将替换原值存储在对应的键值上, 并以string的类型返回. string中已存的值或者相加参数可以任意选用指数符号,但相加计算的结果会以科学计数法的格式存储. 无论各计算的内部精度如何, 输出精度都固定为小数点后17位.\n\n#### 返回值\n\n**Bulk-string-reply**: 当前key增加increment后的值。\n\n\n#### 示例\n\n```c\nredis> SET mykey 10.50\nOK\nredis> INCRBYFLOAT mykey 0.1\n\"10.6\"\nredis> SET mykey 5.0e3\nOK\nredis> INCRBYFLOAT mykey 2.0e2\n\"5200\"\nredis> \n```","source":"_posts/redis_command/string/incrbyfloat.md","raw":"---\n\ntitle: INCRBYFLOAT(incrbyfloat)\ncopyright: true\ndate: 2020-04-02 12:58:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,incrbyfloat\naside: string\n\n---\n## INCRBYFLOAT key increment \n>起始版本：2.6.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 通过指定浮点数`key`来增长浮点数(存放于string中)的值. 当键不存在时,先将其值设为0再操作.下面任一情况都会返回错误:\n  - key 包含非法值(不是一个string).\n  - 当前的key或者相加后的值不能解析为一个双精度的浮点值.(超出精度范围了)\n* 如果操作命令成功, 相加后的值将替换原值存储在对应的键值上, 并以string的类型返回. string中已存的值或者相加参数可以任意选用指数符号,但相加计算的结果会以科学计数法的格式存储. 无论各计算的内部精度如何, 输出精度都固定为小数点后17位.\n\n#### 返回值\n\n**Bulk-string-reply**: 当前key增加increment后的值。\n\n\n#### 示例\n\n```c\nredis> SET mykey 10.50\nOK\nredis> INCRBYFLOAT mykey 0.1\n\"10.6\"\nredis> SET mykey 5.0e3\nOK\nredis> INCRBYFLOAT mykey 2.0e2\n\"5200\"\nredis> \n```","slug":"redis_command/string/incrbyfloat","published":1,"updated":"2021-03-14T03:04:50.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpw8006rhyjfp20n8nvv","content":"<h2 id=\"INCRBYFLOAT-key-increment\"><a href=\"#INCRBYFLOAT-key-increment\" class=\"headerlink\" title=\"INCRBYFLOAT key increment\"></a>INCRBYFLOAT key increment</h2><blockquote>\n<p>起始版本：2.6.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>通过指定浮点数<code>key</code>来增长浮点数(存放于string中)的值. 当键不存在时,先将其值设为0再操作.下面任一情况都会返回错误:<ul>\n<li>key 包含非法值(不是一个string).</li>\n<li>当前的key或者相加后的值不能解析为一个双精度的浮点值.(超出精度范围了)</li>\n</ul>\n</li>\n<li>如果操作命令成功, 相加后的值将替换原值存储在对应的键值上, 并以string的类型返回. string中已存的值或者相加参数可以任意选用指数符号,但相加计算的结果会以科学计数法的格式存储. 无论各计算的内部精度如何, 输出精度都固定为小数点后17位.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Bulk-string-reply</strong>: 当前key增加increment后的值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"number\">10.50</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; INCRBYFLOAT mykey <span class=\"number\">0.1</span></span><br><span class=\"line\"><span class=\"string\">\"10.6\"</span></span><br><span class=\"line\">redis&gt; SET mykey <span class=\"number\">5.0e3</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; INCRBYFLOAT mykey <span class=\"number\">2.0e2</span></span><br><span class=\"line\"><span class=\"string\">\"5200\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"INCRBYFLOAT-key-increment\"><a href=\"#INCRBYFLOAT-key-increment\" class=\"headerlink\" title=\"INCRBYFLOAT key increment\"></a>INCRBYFLOAT key increment</h2><blockquote>\n<p>起始版本：2.6.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>通过指定浮点数<code>key</code>来增长浮点数(存放于string中)的值. 当键不存在时,先将其值设为0再操作.下面任一情况都会返回错误:<ul>\n<li>key 包含非法值(不是一个string).</li>\n<li>当前的key或者相加后的值不能解析为一个双精度的浮点值.(超出精度范围了)</li>\n</ul>\n</li>\n<li>如果操作命令成功, 相加后的值将替换原值存储在对应的键值上, 并以string的类型返回. string中已存的值或者相加参数可以任意选用指数符号,但相加计算的结果会以科学计数法的格式存储. 无论各计算的内部精度如何, 输出精度都固定为小数点后17位.</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Bulk-string-reply</strong>: 当前key增加increment后的值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"number\">10.50</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; INCRBYFLOAT mykey <span class=\"number\">0.1</span></span><br><span class=\"line\"><span class=\"string\">\"10.6\"</span></span><br><span class=\"line\">redis&gt; SET mykey <span class=\"number\">5.0e3</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; INCRBYFLOAT mykey <span class=\"number\">2.0e2</span></span><br><span class=\"line\"><span class=\"string\">\"5200\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"INCRBY(incrby)","copyright":true,"date":"2020-04-02T04:59:02.000Z","keywords":"Redis命令,incrby","aside":"string","_content":"## INCRBY key increment \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将key对应的数字加decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。\n* 查看命令INCR了解关于增减操作的额外信息。\n\n#### 返回值\n\n**integer-reply**： 增加之后的value值。\n\n\n#### 示例\n\n```c\nredis> SET mykey \"10\"\nOK\nredis> INCRBY mykey 5\n(integer) 15\nredis> \n```","source":"_posts/redis_command/string/incrby.md","raw":"---\n\ntitle: INCRBY(incrby)\ncopyright: true\ndate: 2020-04-02 12:59:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,incrby\naside: string\n\n---\n## INCRBY key increment \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将key对应的数字加decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。\n* 查看命令INCR了解关于增减操作的额外信息。\n\n#### 返回值\n\n**integer-reply**： 增加之后的value值。\n\n\n#### 示例\n\n```c\nredis> SET mykey \"10\"\nOK\nredis> INCRBY mykey 5\n(integer) 15\nredis> \n```","slug":"redis_command/string/incrby","published":1,"updated":"2021-03-14T03:04:50.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwa006uhyjfgt5ch40a","content":"<h2 id=\"INCRBY-key-increment\"><a href=\"#INCRBY-key-increment\" class=\"headerlink\" title=\"INCRBY key increment\"></a>INCRBY key increment</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将key对应的数字加decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。</li>\n<li>查看命令INCR了解关于增减操作的额外信息。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>： 增加之后的value值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"10\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; INCRBY mykey <span class=\"number\">5</span></span><br><span class=\"line\">(integer) <span class=\"number\">15</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"INCRBY-key-increment\"><a href=\"#INCRBY-key-increment\" class=\"headerlink\" title=\"INCRBY key increment\"></a>INCRBY key increment</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将key对应的数字加decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。</li>\n<li>查看命令INCR了解关于增减操作的额外信息。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>： 增加之后的value值。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"10\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; INCRBY mykey <span class=\"number\">5</span></span><br><span class=\"line\">(integer) <span class=\"number\">15</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"MGET(mget)","copyright":true,"date":"2020-04-02T04:57:02.000Z","keywords":"Redis命令,mget","aside":"string","_content":"## MGET key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是要检索的键的数量。\n\n\n#### 说明:\n* 返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。正因为此，这个操作从来不会失败。\n\n#### 返回值\n\n**array-reply**: 指定的key对应的values的list\n\n\n#### 示例\n\n```c\nredis> SET key1 \"Hello\"\nOK\nredis> SET key2 \"World\"\nOK\nredis> MGET key1 key2 nonexisting\n1) \"Hello\"\n2) \"World\"\n3) (nil)\nredis> \n```","source":"_posts/redis_command/string/mget.md","raw":"---\n\ntitle: MGET(mget)\ncopyright: true\ndate: 2020-04-02 12:57:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,mget\naside: string\n\n---\n## MGET key [key ...] \n>起始版本：1.0.0<br/>时间复杂度：O(N) N是要检索的键的数量。\n\n\n#### 说明:\n* 返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。正因为此，这个操作从来不会失败。\n\n#### 返回值\n\n**array-reply**: 指定的key对应的values的list\n\n\n#### 示例\n\n```c\nredis> SET key1 \"Hello\"\nOK\nredis> SET key2 \"World\"\nOK\nredis> MGET key1 key2 nonexisting\n1) \"Hello\"\n2) \"World\"\n3) (nil)\nredis> \n```","slug":"redis_command/string/mget","published":1,"updated":"2021-03-14T03:04:50.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwb006whyjf1lj2drzq","content":"<h2 id=\"MGET-key-key-…\"><a href=\"#MGET-key-key-…\" class=\"headerlink\" title=\"MGET key [key …]\"></a>MGET key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是要检索的键的数量。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。正因为此，这个操作从来不会失败。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 指定的key对应的values的list</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET key1 <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; SET key2 <span class=\"string\">\"World\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; MGET key1 key2 nonexisting</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) (nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MGET-key-key-…\"><a href=\"#MGET-key-key-…\" class=\"headerlink\" title=\"MGET key [key …]\"></a>MGET key [key …]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(N) N是要检索的键的数量。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。正因为此，这个操作从来不会失败。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>array-reply</strong>: 指定的key对应的values的list</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET key1 <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; SET key2 <span class=\"string\">\"World\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; MGET key1 key2 nonexisting</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) (nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"MSET(mset)","copyright":true,"date":"2020-04-02T04:56:02.000Z","keywords":"Redis命令,mset","aside":"string","_content":"## MSET key value [key value ...] \n>起始版本：1.0.1<br/>时间复杂度：O(N) N是要设置的键数。\n\n\n#### 说明:\n* 对应给定的keys到他们相应的values上。MSET会用新的value替换已经存在的value，就像普通的SET命令一样。如果你不想覆盖已经存在的values，请参看命令MSETNX。\n* MSET是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。\n\n#### 返回值\n\n**simple-string-reply**：总是OK，因为MSET不会失败。\n\n\n#### 示例\n\n```c\nredis> MSET key1 \"Hello\" key2 \"World\"\nOK\nredis> GET key1\n\"Hello\"\nredis> GET key2\n\"World\"\nredis> \n```","source":"_posts/redis_command/string/mset.md","raw":"---\n\ntitle: MSET(mset)\ncopyright: true\ndate: 2020-04-02 12:56:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,mset\naside: string\n\n---\n## MSET key value [key value ...] \n>起始版本：1.0.1<br/>时间复杂度：O(N) N是要设置的键数。\n\n\n#### 说明:\n* 对应给定的keys到他们相应的values上。MSET会用新的value替换已经存在的value，就像普通的SET命令一样。如果你不想覆盖已经存在的values，请参看命令MSETNX。\n* MSET是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。\n\n#### 返回值\n\n**simple-string-reply**：总是OK，因为MSET不会失败。\n\n\n#### 示例\n\n```c\nredis> MSET key1 \"Hello\" key2 \"World\"\nOK\nredis> GET key1\n\"Hello\"\nredis> GET key2\n\"World\"\nredis> \n```","slug":"redis_command/string/mset","published":1,"updated":"2021-03-14T03:04:50.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwc006zhyjfa6t1h92x","content":"<h2 id=\"MSET-key-value-key-value-…\"><a href=\"#MSET-key-value-key-value-…\" class=\"headerlink\" title=\"MSET key value [key value …]\"></a>MSET key value [key value …]</h2><blockquote>\n<p>起始版本：1.0.1<br>时间复杂度：O(N) N是要设置的键数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>对应给定的keys到他们相应的values上。MSET会用新的value替换已经存在的value，就像普通的SET命令一样。如果你不想覆盖已经存在的values，请参看命令MSETNX。</li>\n<li>MSET是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong>：总是OK，因为MSET不会失败。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; MSET key1 <span class=\"string\">\"Hello\"</span> key2 <span class=\"string\">\"World\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; GET key1</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt; GET key2</span><br><span class=\"line\"><span class=\"string\">\"World\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MSET-key-value-key-value-…\"><a href=\"#MSET-key-value-key-value-…\" class=\"headerlink\" title=\"MSET key value [key value …]\"></a>MSET key value [key value …]</h2><blockquote>\n<p>起始版本：1.0.1<br>时间复杂度：O(N) N是要设置的键数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>对应给定的keys到他们相应的values上。MSET会用新的value替换已经存在的value，就像普通的SET命令一样。如果你不想覆盖已经存在的values，请参看命令MSETNX。</li>\n<li>MSET是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong>：总是OK，因为MSET不会失败。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; MSET key1 <span class=\"string\">\"Hello\"</span> key2 <span class=\"string\">\"World\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; GET key1</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt; GET key2</span><br><span class=\"line\"><span class=\"string\">\"World\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"MSETNX(msetnx)","copyright":true,"date":"2020-04-02T04:55:02.000Z","keywords":"Redis命令,msetnx","aside":"string","_content":"## MSETNX key value [key value ...] \n>起始版本：1.0.1<br/>时间复杂度：O(N) N是要设置的键数。\n\n\n#### 说明:\n* 对应给定的keys到他们相应的values上。只要有一个key已经存在，MSETNX一个操作都不会执行。 由于这种特性，MSETNX可以实现要么所有的操作都成功，要么一个都不执行，这样可以用来设置不同的key，来表示一个唯一的对象的不同字段。\n* MSETNX是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。\n\n#### 返回值\n\n**integer-reply**，只有以下两种值：\n1 如果所有的key被set\n0 如果没有key被set(至少其中有一个key是存在的)\n\n\n#### 示例\n\n```c\nredis> MSETNX key1 \"Hello\" key2 \"there\"\n(integer) 1\nredis> MSETNX key2 \"there\" key3 \"world\"\n(integer) 0\nredis> MGET key1 key2 key3\n1) \"Hello\"\n2) \"there\"\n3) (nil)\nredis> \n```","source":"_posts/redis_command/string/msetnx.md","raw":"---\n\ntitle: MSETNX(msetnx)\ncopyright: true\ndate: 2020-04-02 12:55:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,msetnx\naside: string\n\n---\n## MSETNX key value [key value ...] \n>起始版本：1.0.1<br/>时间复杂度：O(N) N是要设置的键数。\n\n\n#### 说明:\n* 对应给定的keys到他们相应的values上。只要有一个key已经存在，MSETNX一个操作都不会执行。 由于这种特性，MSETNX可以实现要么所有的操作都成功，要么一个都不执行，这样可以用来设置不同的key，来表示一个唯一的对象的不同字段。\n* MSETNX是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。\n\n#### 返回值\n\n**integer-reply**，只有以下两种值：\n1 如果所有的key被set\n0 如果没有key被set(至少其中有一个key是存在的)\n\n\n#### 示例\n\n```c\nredis> MSETNX key1 \"Hello\" key2 \"there\"\n(integer) 1\nredis> MSETNX key2 \"there\" key3 \"world\"\n(integer) 0\nredis> MGET key1 key2 key3\n1) \"Hello\"\n2) \"there\"\n3) (nil)\nredis> \n```","slug":"redis_command/string/msetnx","published":1,"updated":"2021-03-14T03:04:50.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwd0071hyjf9pcr0ty6","content":"<h2 id=\"MSETNX-key-value-key-value-…\"><a href=\"#MSETNX-key-value-key-value-…\" class=\"headerlink\" title=\"MSETNX key value [key value …]\"></a>MSETNX key value [key value …]</h2><blockquote>\n<p>起始版本：1.0.1<br>时间复杂度：O(N) N是要设置的键数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>对应给定的keys到他们相应的values上。只要有一个key已经存在，MSETNX一个操作都不会执行。 由于这种特性，MSETNX可以实现要么所有的操作都成功，要么一个都不执行，这样可以用来设置不同的key，来表示一个唯一的对象的不同字段。</li>\n<li>MSETNX是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>，只有以下两种值：<br>1 如果所有的key被set<br>0 如果没有key被set(至少其中有一个key是存在的)</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; MSETNX key1 <span class=\"string\">\"Hello\"</span> key2 <span class=\"string\">\"there\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; MSETNX key2 <span class=\"string\">\"there\"</span> key3 <span class=\"string\">\"world\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; MGET key1 key2 key3</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"there\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) (nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MSETNX-key-value-key-value-…\"><a href=\"#MSETNX-key-value-key-value-…\" class=\"headerlink\" title=\"MSETNX key value [key value …]\"></a>MSETNX key value [key value …]</h2><blockquote>\n<p>起始版本：1.0.1<br>时间复杂度：O(N) N是要设置的键数。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>对应给定的keys到他们相应的values上。只要有一个key已经存在，MSETNX一个操作都不会执行。 由于这种特性，MSETNX可以实现要么所有的操作都成功，要么一个都不执行，这样可以用来设置不同的key，来表示一个唯一的对象的不同字段。</li>\n<li>MSETNX是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>，只有以下两种值：<br>1 如果所有的key被set<br>0 如果没有key被set(至少其中有一个key是存在的)</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; MSETNX key1 <span class=\"string\">\"Hello\"</span> key2 <span class=\"string\">\"there\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; MSETNX key2 <span class=\"string\">\"there\"</span> key3 <span class=\"string\">\"world\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; MGET key1 key2 key3</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"there\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) (nil)</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"PSETEX(psetex)","copyright":true,"date":"2020-04-02T04:54:02.000Z","keywords":"Redis命令,psetex","aside":"string","_content":"## PSETEX key milliseconds value \n>起始版本：2.6.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* PSETEX和SETEX一样，唯一的区别是到期时间以毫秒为单位,而不是秒。\n\n#### 示例\n\n```c\nredis> PSETEX mykey 1000 \"Hello\"\nOK\nredis> PTTL mykey\n(integer) 999\nredis> GET mykey\n\"Hello\"\nredis> \n```","source":"_posts/redis_command/string/psetex.md","raw":"---\n\ntitle: PSETEX(psetex)\ncopyright: true\ndate: 2020-04-02 12:54:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,psetex\naside: string\n\n---\n## PSETEX key milliseconds value \n>起始版本：2.6.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* PSETEX和SETEX一样，唯一的区别是到期时间以毫秒为单位,而不是秒。\n\n#### 示例\n\n```c\nredis> PSETEX mykey 1000 \"Hello\"\nOK\nredis> PTTL mykey\n(integer) 999\nredis> GET mykey\n\"Hello\"\nredis> \n```","slug":"redis_command/string/psetex","published":1,"updated":"2021-03-14T03:04:50.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwe0074hyjfrnjzh8k5","content":"<h2 id=\"PSETEX-key-milliseconds-value\"><a href=\"#PSETEX-key-milliseconds-value\" class=\"headerlink\" title=\"PSETEX key milliseconds value\"></a>PSETEX key milliseconds value</h2><blockquote>\n<p>起始版本：2.6.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>PSETEX和SETEX一样，唯一的区别是到期时间以毫秒为单位,而不是秒。</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; PSETEX mykey <span class=\"number\">1000</span> <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; PTTL mykey</span><br><span class=\"line\">(integer) <span class=\"number\">999</span></span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"PSETEX-key-milliseconds-value\"><a href=\"#PSETEX-key-milliseconds-value\" class=\"headerlink\" title=\"PSETEX key milliseconds value\"></a>PSETEX key milliseconds value</h2><blockquote>\n<p>起始版本：2.6.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>PSETEX和SETEX一样，唯一的区别是到期时间以毫秒为单位,而不是秒。</li>\n</ul>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; PSETEX mykey <span class=\"number\">1000</span> <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; PTTL mykey</span><br><span class=\"line\">(integer) <span class=\"number\">999</span></span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SET(set)","copyright":true,"date":"2020-04-02T04:53:02.000Z","keywords":"Redis命令,set","aside":"string","_content":"## SET key value [EX seconds] [PX milliseconds] [NX|XX] \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将键key设定为指定的“字符串”值。\n\n* 如果 key 已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型。\n\n* 当`set`命令执行成功之后，之前设置的过期时间都将失效\n\n* 从2.6.12版本开始，redis为`SET`命令增加了一系列选项:\n\n  - `EX` *seconds* – 设置键key的过期时间，单位时秒\n  - `PX` *milliseconds* – 设置键key的过期时间，单位时毫秒\n  - `NX` – 只有键key不存在的时候才会设置key的值\n  - `XX` – 只有键key存在的时候才会设置key的值\n\n  **注意:** 由于`SET`命令加上选项已经可以完全取代SETNX, SETEX, PSETEX的功能，所以在将来的版本中，redis可能会不推荐使用并且最终抛弃这几个命令。\n\n#### 返回值\n\n**simple-string-reply**:如果SET命令正常执行那么回返回OK，否则如果加了NX 或者 XX选项，但是没有设置条件。那么会返回nil。\n\n\n#### 示例\n\n```c\nredis> SET mykey \"Hello\"\nOK\nredis> GET mykey\n\"Hello\"\nredis> \n```","source":"_posts/redis_command/string/set.md","raw":"---\n\ntitle: SET(set)\ncopyright: true\ndate: 2020-04-02 12:53:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,set\naside: string\n\n---\n## SET key value [EX seconds] [PX milliseconds] [NX|XX] \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将键key设定为指定的“字符串”值。\n\n* 如果 key 已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型。\n\n* 当`set`命令执行成功之后，之前设置的过期时间都将失效\n\n* 从2.6.12版本开始，redis为`SET`命令增加了一系列选项:\n\n  - `EX` *seconds* – 设置键key的过期时间，单位时秒\n  - `PX` *milliseconds* – 设置键key的过期时间，单位时毫秒\n  - `NX` – 只有键key不存在的时候才会设置key的值\n  - `XX` – 只有键key存在的时候才会设置key的值\n\n  **注意:** 由于`SET`命令加上选项已经可以完全取代SETNX, SETEX, PSETEX的功能，所以在将来的版本中，redis可能会不推荐使用并且最终抛弃这几个命令。\n\n#### 返回值\n\n**simple-string-reply**:如果SET命令正常执行那么回返回OK，否则如果加了NX 或者 XX选项，但是没有设置条件。那么会返回nil。\n\n\n#### 示例\n\n```c\nredis> SET mykey \"Hello\"\nOK\nredis> GET mykey\n\"Hello\"\nredis> \n```","slug":"redis_command/string/set","published":1,"updated":"2021-03-14T03:04:50.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwe0076hyjfs2z9trf4","content":"<h2 id=\"SET-key-value-EX-seconds-PX-milliseconds-NX-XX\"><a href=\"#SET-key-value-EX-seconds-PX-milliseconds-NX-XX\" class=\"headerlink\" title=\"SET key value [EX seconds] [PX milliseconds] [NX|XX]\"></a>SET key value [EX seconds] [PX milliseconds] [NX|XX]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>将键key设定为指定的“字符串”值。</p>\n</li>\n<li><p>如果 key 已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型。</p>\n</li>\n<li><p>当<code>set</code>命令执行成功之后，之前设置的过期时间都将失效</p>\n</li>\n<li><p>从2.6.12版本开始，redis为<code>SET</code>命令增加了一系列选项:</p>\n<ul>\n<li><code>EX</code> <em>seconds</em> – 设置键key的过期时间，单位时秒</li>\n<li><code>PX</code> <em>milliseconds</em> – 设置键key的过期时间，单位时毫秒</li>\n<li><code>NX</code> – 只有键key不存在的时候才会设置key的值</li>\n<li><code>XX</code> – 只有键key存在的时候才会设置key的值</li>\n</ul>\n<p><strong>注意:</strong> 由于<code>SET</code>命令加上选项已经可以完全取代SETNX, SETEX, PSETEX的功能，所以在将来的版本中，redis可能会不推荐使用并且最终抛弃这几个命令。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong>:如果SET命令正常执行那么回返回OK，否则如果加了NX 或者 XX选项，但是没有设置条件。那么会返回nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SET-key-value-EX-seconds-PX-milliseconds-NX-XX\"><a href=\"#SET-key-value-EX-seconds-PX-milliseconds-NX-XX\" class=\"headerlink\" title=\"SET key value [EX seconds] [PX milliseconds] [NX|XX]\"></a>SET key value [EX seconds] [PX milliseconds] [NX|XX]</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>将键key设定为指定的“字符串”值。</p>\n</li>\n<li><p>如果 key 已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型。</p>\n</li>\n<li><p>当<code>set</code>命令执行成功之后，之前设置的过期时间都将失效</p>\n</li>\n<li><p>从2.6.12版本开始，redis为<code>SET</code>命令增加了一系列选项:</p>\n<ul>\n<li><code>EX</code> <em>seconds</em> – 设置键key的过期时间，单位时秒</li>\n<li><code>PX</code> <em>milliseconds</em> – 设置键key的过期时间，单位时毫秒</li>\n<li><code>NX</code> – 只有键key不存在的时候才会设置key的值</li>\n<li><code>XX</code> – 只有键key存在的时候才会设置key的值</li>\n</ul>\n<p><strong>注意:</strong> 由于<code>SET</code>命令加上选项已经可以完全取代SETNX, SETEX, PSETEX的功能，所以在将来的版本中，redis可能会不推荐使用并且最终抛弃这几个命令。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong>:如果SET命令正常执行那么回返回OK，否则如果加了NX 或者 XX选项，但是没有设置条件。那么会返回nil。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SETEX(setex)","copyright":true,"date":"2020-04-02T04:51:02.000Z","keywords":"Redis命令,setex","aside":"string","_content":"## SETEX key seconds value \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 设置key对应字符串value，并且设置key在给定的seconds时间之后超时过期。这个命令等效于执行下面的命令：\n\n  ```c\n  SET mykey value\n  EXPIRE mykey seconds\n  ```\n\n* SETEX是原子的，也可以通过把上面两个命令放到[MULTI](http://www.redis.cn/commands/multi.html)/[EXEC](http://www.redis.cn/commands/exec.html)块中执行的方式重现。相比连续执行上面两个命令，它更快，因为当Redis当做缓存使用时，这个操作更加常用。\n\n#### 返回值\n\n**simple-string-reply**\n\n\n#### 示例\n\n```c\nredis> SETEX mykey 10 \"Hello\"\nOK\nredis> TTL mykey\n(integer) 10\nredis> GET mykey\n\"Hello\"\nredis> \n```","source":"_posts/redis_command/string/setex.md","raw":"---\n\ntitle: SETEX(setex)\ncopyright: true\ndate: 2020-04-02 12:51:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,setex\naside: string\n\n---\n## SETEX key seconds value \n>起始版本：2.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 设置key对应字符串value，并且设置key在给定的seconds时间之后超时过期。这个命令等效于执行下面的命令：\n\n  ```c\n  SET mykey value\n  EXPIRE mykey seconds\n  ```\n\n* SETEX是原子的，也可以通过把上面两个命令放到[MULTI](http://www.redis.cn/commands/multi.html)/[EXEC](http://www.redis.cn/commands/exec.html)块中执行的方式重现。相比连续执行上面两个命令，它更快，因为当Redis当做缓存使用时，这个操作更加常用。\n\n#### 返回值\n\n**simple-string-reply**\n\n\n#### 示例\n\n```c\nredis> SETEX mykey 10 \"Hello\"\nOK\nredis> TTL mykey\n(integer) 10\nredis> GET mykey\n\"Hello\"\nredis> \n```","slug":"redis_command/string/setex","published":1,"updated":"2021-03-14T03:04:50.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwf0079hyjfja6htlww","content":"<h2 id=\"SETEX-key-seconds-value\"><a href=\"#SETEX-key-seconds-value\" class=\"headerlink\" title=\"SETEX key seconds value\"></a>SETEX key seconds value</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>设置key对应字符串value，并且设置key在给定的seconds时间之后超时过期。这个命令等效于执行下面的命令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET mykey value</span><br><span class=\"line\">EXPIRE mykey seconds</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SETEX是原子的，也可以通过把上面两个命令放到<a href=\"http://www.redis.cn/commands/multi.html\" target=\"_blank\" rel=\"noopener\">MULTI</a>/<a href=\"http://www.redis.cn/commands/exec.html\" target=\"_blank\" rel=\"noopener\">EXEC</a>块中执行的方式重现。相比连续执行上面两个命令，它更快，因为当Redis当做缓存使用时，这个操作更加常用。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong></p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SETEX mykey <span class=\"number\">10</span> <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; TTL mykey</span><br><span class=\"line\">(integer) <span class=\"number\">10</span></span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SETEX-key-seconds-value\"><a href=\"#SETEX-key-seconds-value\" class=\"headerlink\" title=\"SETEX key seconds value\"></a>SETEX key seconds value</h2><blockquote>\n<p>起始版本：2.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li><p>设置key对应字符串value，并且设置key在给定的seconds时间之后超时过期。这个命令等效于执行下面的命令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET mykey value</span><br><span class=\"line\">EXPIRE mykey seconds</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SETEX是原子的，也可以通过把上面两个命令放到<a href=\"http://www.redis.cn/commands/multi.html\" target=\"_blank\" rel=\"noopener\">MULTI</a>/<a href=\"http://www.redis.cn/commands/exec.html\" target=\"_blank\" rel=\"noopener\">EXEC</a>块中执行的方式重现。相比连续执行上面两个命令，它更快，因为当Redis当做缓存使用时，这个操作更加常用。</p>\n</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>simple-string-reply</strong></p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SETEX mykey <span class=\"number\">10</span> <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; TTL mykey</span><br><span class=\"line\">(integer) <span class=\"number\">10</span></span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SETRANGE(setrange)","copyright":true,"date":"2020-04-02T04:49:02.000Z","keywords":"Redis命令,setrange","aside":"string","_content":"## SETRANGE key offset value \n>起始版本：2.2.0<br/>时间复杂度：O(1) 不计算复制新字符串所需的时间。通常，这个字符串很小所以平摊复杂度是O(1)否则，复杂度为O(M)， M是值参数的长度。\n\n\n#### 说明:\n* 这个命令的作用是覆盖key对应的string的一部分，从指定的offset处开始，覆盖value的长度。如果offset比当前key对应string还要长，那这个string后面就补0以达到offset。不存在的keys被认为是空字符串，所以这个命令可以确保key有一个足够大的字符串，能在offset处设置value。\n* 注意，offset最大可以是229-1(536870911),因为redis字符串限制在512M大小。如果你需要超过这个大小，你可以用多个keys。\n* 当set最后一个字节并且key还没有一个字符串value或者其value是个比较小的字符串时，Redis需要立即分配所有内存，这有可能会导致服务阻塞一会。在一台2010MacBook Pro上，set536870911字节（分配512MB）需要～300ms，set134217728字节(分配128MB)需要～80ms，set33554432比特位（分配32MB）需要～30ms，set8388608比特（分配8MB）需要8ms。注意，一旦第一次内存分配完，后面对同一个key调用SETRANGE就不会预先得到内存分配。\n* 正因为有了SETRANGE命令，你可以把Redis的字符串当成线性数组，随机访问只要O(1)复杂度。这在很多真实场景应用里非常快和高效。\n\n#### 返回值\n\n**integer-reply**：该命令修改后的字符串长度\n\n\n#### 示例\n\n```c\n//基本使用方法:\nredis> SET key1 \"Hello World\"\nOK\nredis> SETRANGE key1 6 \"Redis\"\n(integer) 11\nredis> GET key1\n\"Hello Redis\"\nredis> \n//补0的例子:\nredis> SETRANGE key2 6 \"Redis\"\n(integer) 11\nredis> GET key2\n\"\\x00\\x00\\x00\\x00\\x00\\x00Redis\"\nredis> \n```","source":"_posts/redis_command/string/setrange.md","raw":"---\n\ntitle: SETRANGE(setrange)\ncopyright: true\ndate: 2020-04-02 12:49:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,setrange\naside: string\n\n---\n## SETRANGE key offset value \n>起始版本：2.2.0<br/>时间复杂度：O(1) 不计算复制新字符串所需的时间。通常，这个字符串很小所以平摊复杂度是O(1)否则，复杂度为O(M)， M是值参数的长度。\n\n\n#### 说明:\n* 这个命令的作用是覆盖key对应的string的一部分，从指定的offset处开始，覆盖value的长度。如果offset比当前key对应string还要长，那这个string后面就补0以达到offset。不存在的keys被认为是空字符串，所以这个命令可以确保key有一个足够大的字符串，能在offset处设置value。\n* 注意，offset最大可以是229-1(536870911),因为redis字符串限制在512M大小。如果你需要超过这个大小，你可以用多个keys。\n* 当set最后一个字节并且key还没有一个字符串value或者其value是个比较小的字符串时，Redis需要立即分配所有内存，这有可能会导致服务阻塞一会。在一台2010MacBook Pro上，set536870911字节（分配512MB）需要～300ms，set134217728字节(分配128MB)需要～80ms，set33554432比特位（分配32MB）需要～30ms，set8388608比特（分配8MB）需要8ms。注意，一旦第一次内存分配完，后面对同一个key调用SETRANGE就不会预先得到内存分配。\n* 正因为有了SETRANGE命令，你可以把Redis的字符串当成线性数组，随机访问只要O(1)复杂度。这在很多真实场景应用里非常快和高效。\n\n#### 返回值\n\n**integer-reply**：该命令修改后的字符串长度\n\n\n#### 示例\n\n```c\n//基本使用方法:\nredis> SET key1 \"Hello World\"\nOK\nredis> SETRANGE key1 6 \"Redis\"\n(integer) 11\nredis> GET key1\n\"Hello Redis\"\nredis> \n//补0的例子:\nredis> SETRANGE key2 6 \"Redis\"\n(integer) 11\nredis> GET key2\n\"\\x00\\x00\\x00\\x00\\x00\\x00Redis\"\nredis> \n```","slug":"redis_command/string/setrange","published":1,"updated":"2021-03-14T03:04:50.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwg007bhyjfhjs8cgk4","content":"<h2 id=\"SETRANGE-key-offset-value\"><a href=\"#SETRANGE-key-offset-value\" class=\"headerlink\" title=\"SETRANGE key offset value\"></a>SETRANGE key offset value</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1) 不计算复制新字符串所需的时间。通常，这个字符串很小所以平摊复杂度是O(1)否则，复杂度为O(M)， M是值参数的长度。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>这个命令的作用是覆盖key对应的string的一部分，从指定的offset处开始，覆盖value的长度。如果offset比当前key对应string还要长，那这个string后面就补0以达到offset。不存在的keys被认为是空字符串，所以这个命令可以确保key有一个足够大的字符串，能在offset处设置value。</li>\n<li>注意，offset最大可以是229-1(536870911),因为redis字符串限制在512M大小。如果你需要超过这个大小，你可以用多个keys。</li>\n<li>当set最后一个字节并且key还没有一个字符串value或者其value是个比较小的字符串时，Redis需要立即分配所有内存，这有可能会导致服务阻塞一会。在一台2010MacBook Pro上，set536870911字节（分配512MB）需要～300ms，set134217728字节(分配128MB)需要～80ms，set33554432比特位（分配32MB）需要～30ms，set8388608比特（分配8MB）需要8ms。注意，一旦第一次内存分配完，后面对同一个key调用SETRANGE就不会预先得到内存分配。</li>\n<li>正因为有了SETRANGE命令，你可以把Redis的字符串当成线性数组，随机访问只要O(1)复杂度。这在很多真实场景应用里非常快和高效。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：该命令修改后的字符串长度</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本使用方法:</span></span><br><span class=\"line\">redis&gt; SET key1 <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; SETRANGE key1 <span class=\"number\">6</span> <span class=\"string\">\"Redis\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">11</span></span><br><span class=\"line\">redis&gt; GET key1</span><br><span class=\"line\"><span class=\"string\">\"Hello Redis\"</span></span><br><span class=\"line\">redis&gt; </span><br><span class=\"line\"><span class=\"comment\">//补0的例子:</span></span><br><span class=\"line\">redis&gt; SETRANGE key2 <span class=\"number\">6</span> <span class=\"string\">\"Redis\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">11</span></span><br><span class=\"line\">redis&gt; GET key2</span><br><span class=\"line\"><span class=\"string\">\"\\x00\\x00\\x00\\x00\\x00\\x00Redis\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SETRANGE-key-offset-value\"><a href=\"#SETRANGE-key-offset-value\" class=\"headerlink\" title=\"SETRANGE key offset value\"></a>SETRANGE key offset value</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1) 不计算复制新字符串所需的时间。通常，这个字符串很小所以平摊复杂度是O(1)否则，复杂度为O(M)， M是值参数的长度。</p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>这个命令的作用是覆盖key对应的string的一部分，从指定的offset处开始，覆盖value的长度。如果offset比当前key对应string还要长，那这个string后面就补0以达到offset。不存在的keys被认为是空字符串，所以这个命令可以确保key有一个足够大的字符串，能在offset处设置value。</li>\n<li>注意，offset最大可以是229-1(536870911),因为redis字符串限制在512M大小。如果你需要超过这个大小，你可以用多个keys。</li>\n<li>当set最后一个字节并且key还没有一个字符串value或者其value是个比较小的字符串时，Redis需要立即分配所有内存，这有可能会导致服务阻塞一会。在一台2010MacBook Pro上，set536870911字节（分配512MB）需要～300ms，set134217728字节(分配128MB)需要～80ms，set33554432比特位（分配32MB）需要～30ms，set8388608比特（分配8MB）需要8ms。注意，一旦第一次内存分配完，后面对同一个key调用SETRANGE就不会预先得到内存分配。</li>\n<li>正因为有了SETRANGE命令，你可以把Redis的字符串当成线性数组，随机访问只要O(1)复杂度。这在很多真实场景应用里非常快和高效。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：该命令修改后的字符串长度</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本使用方法:</span></span><br><span class=\"line\">redis&gt; SET key1 <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; SETRANGE key1 <span class=\"number\">6</span> <span class=\"string\">\"Redis\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">11</span></span><br><span class=\"line\">redis&gt; GET key1</span><br><span class=\"line\"><span class=\"string\">\"Hello Redis\"</span></span><br><span class=\"line\">redis&gt; </span><br><span class=\"line\"><span class=\"comment\">//补0的例子:</span></span><br><span class=\"line\">redis&gt; SETRANGE key2 <span class=\"number\">6</span> <span class=\"string\">\"Redis\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">11</span></span><br><span class=\"line\">redis&gt; GET key2</span><br><span class=\"line\"><span class=\"string\">\"\\x00\\x00\\x00\\x00\\x00\\x00Redis\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"SETNX(setnx)","copyright":true,"date":"2020-04-02T04:50:02.000Z","keywords":"Redis命令,setnx","aside":"string","_content":"## SETNX key value \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将key设置值为value，如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做。SETNX是“SET if Not eXists”的简写。\n\n#### 返回值\n\n**Integer reply**, 特定值:\n1 如果key被设置了\n0 如果key没有被设置\n\n\n#### 示例\n\n```c\nredis> SETNX mykey \"Hello\"\n(integer) 1\nredis> SETNX mykey \"World\"\n(integer) 0\nredis> GET mykey\n\"Hello\"\nredis> \n```\n\n","source":"_posts/redis_command/string/setnx.md","raw":"---\n\ntitle: SETNX(setnx)\ncopyright: true\ndate: 2020-04-02 12:50:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,setnx\naside: string\n\n---\n## SETNX key value \n>起始版本：1.0.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 将key设置值为value，如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做。SETNX是“SET if Not eXists”的简写。\n\n#### 返回值\n\n**Integer reply**, 特定值:\n1 如果key被设置了\n0 如果key没有被设置\n\n\n#### 示例\n\n```c\nredis> SETNX mykey \"Hello\"\n(integer) 1\nredis> SETNX mykey \"World\"\n(integer) 0\nredis> GET mykey\n\"Hello\"\nredis> \n```\n\n","slug":"redis_command/string/setnx","published":1,"updated":"2021-03-14T03:04:50.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwg007ehyjffciuzjeg","content":"<h2 id=\"SETNX-key-value\"><a href=\"#SETNX-key-value\" class=\"headerlink\" title=\"SETNX key value\"></a>SETNX key value</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将key设置值为value，如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做。SETNX是“SET if Not eXists”的简写。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply</strong>, 特定值:<br>1 如果key被设置了<br>0 如果key没有被设置</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SETNX mykey <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SETNX mykey <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SETNX-key-value\"><a href=\"#SETNX-key-value\" class=\"headerlink\" title=\"SETNX key value\"></a>SETNX key value</h2><blockquote>\n<p>起始版本：1.0.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>将key设置值为value，如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做。SETNX是“SET if Not eXists”的简写。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>Integer reply</strong>, 特定值:<br>1 如果key被设置了<br>0 如果key没有被设置</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SETNX mykey <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\">redis&gt; SETNX mykey <span class=\"string\">\"World\"</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\"><span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"STRLEN(strlen)","copyright":true,"date":"2020-04-02T04:48:02.000Z","keywords":"Redis命令,strlen","aside":"string","_content":"## STRLEN key \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回key的string类型value的长度。如果key对应的非string类型，就返回错误。\n\n#### 返回值\n\n**integer-reply**：key对应的字符串value的长度，或者0（key不存在）\n\n\n#### 示例\n\n```c\nredis> SET mykey \"Hello world\"\nOK\nredis> STRLEN mykey\n(integer) 11\nredis> STRLEN nonexisting\n(integer) 0\nredis> \n```","source":"_posts/redis_command/string/strlen.md","raw":"---\n\ntitle: STRLEN(strlen)\ncopyright: true\ndate: 2020-04-02 12:48:02\ncategories: \n- Redis命令大全\n- String\nkeywords: Redis命令,strlen\naside: string\n\n---\n## STRLEN key \n>起始版本：2.2.0<br/>时间复杂度：O(1)  \n\n\n#### 说明:\n* 返回key的string类型value的长度。如果key对应的非string类型，就返回错误。\n\n#### 返回值\n\n**integer-reply**：key对应的字符串value的长度，或者0（key不存在）\n\n\n#### 示例\n\n```c\nredis> SET mykey \"Hello world\"\nOK\nredis> STRLEN mykey\n(integer) 11\nredis> STRLEN nonexisting\n(integer) 0\nredis> \n```","slug":"redis_command/string/strlen","published":1,"updated":"2021-03-14T03:04:50.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwh007ghyjf57j3ouxh","content":"<h2 id=\"STRLEN-key\"><a href=\"#STRLEN-key\" class=\"headerlink\" title=\"STRLEN key\"></a>STRLEN key</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回key的string类型value的长度。如果key对应的非string类型，就返回错误。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：key对应的字符串value的长度，或者0（key不存在）</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"Hello world\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; STRLEN mykey</span><br><span class=\"line\">(integer) <span class=\"number\">11</span></span><br><span class=\"line\">redis&gt; STRLEN nonexisting</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"STRLEN-key\"><a href=\"#STRLEN-key\" class=\"headerlink\" title=\"STRLEN key\"></a>STRLEN key</h2><blockquote>\n<p>起始版本：2.2.0<br>时间复杂度：O(1)  </p>\n</blockquote>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明:\"></a>说明:</h4><ul>\n<li>返回key的string类型value的长度。如果key对应的非string类型，就返回错误。</li>\n</ul>\n<h4 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><strong>integer-reply</strong>：key对应的字符串value的长度，或者0（key不存在）</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey <span class=\"string\">\"Hello world\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; STRLEN mykey</span><br><span class=\"line\">(integer) <span class=\"number\">11</span></span><br><span class=\"line\">redis&gt; STRLEN nonexisting</span><br><span class=\"line\">(integer) <span class=\"number\">0</span></span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>"},{"title":"大型网站技术架构(一)大型网站的特点","copyright":true,"date":"2020-04-14T03:29:26.000Z","keywords":"大型网站技术架构","password":"1234qwer","aside":"Notes-LargeSite","_content":"\n第一篇读书笔记准备写写这本《大型网站技术架构》，为什么呢？\n\n不想当将军的士兵不是好码农！作为一个网站的开发人员，自然更想要亲自参与大型网站的开发与设计。而曾经刚毕业的我入职的也是一家电商公司，像淘宝这样的大型电商网站在我们眼里就是殿堂一般的存在。我想任何一个热爱技术热爱开发的同学，对于这些大型网站都会有着浓厚的兴趣。我也学习、研究了很久，但始终如管中规豹，散乱的知识点学到了很多，却始终难以有个整体的认知。\n\n<!--more-->\n\n有幸读到了这本《大型网站技术架构》，终于给我揭开了大型网站的面纱。他让我对大型网站有了更深入更全面的了解，也给了我许多新的观念以及日后学习的方向，对我之后职业生涯的发展也起到了很大的作用！\n\n这本书的作者是李智慧，曾在阿里担任多年架构师。这本书中，作者结合阿里巴巴以及一些一线互联网企业先进的架构经验，从从大型网站演化的角度，为我们描绘了一个大型网站发展的过程中所需要的问题，以及相应的解决方案。它从宏观的角度为我们描绘了一个大型网站架构的蓝图，将网站架构的演化式发展，架构模式，核心要素一一道来。在微观的角度上，从网站的架构设计、快速开发、高效部署、业务监控、服务治理、运维管理等多个角度描述了架构设计的相关重点，涉及的核心技术包括前端优化、CDN、反向代理、缓存、消息队列、分布式存储、分布式服务、 NOSQL存储、搜索、监控、安全等一系列保证大型网站安全可靠运行的关键技术点。\n\n而提到大型网站很多人可能会立马想到某宝、某东、某团、某条、并夕夕等。\n\n仔细想想，与传统企业应用系统相比，这些大型互联网应用系统都有一些共同的特点:\n\n**用户分布广泛，网络情况复杂**：\n\n已经到了21世纪20年代，我想不管你是在黑龙江的漠河，还是海南的三亚，又或者新疆的乌鲁木齐与青藏高原的拉萨，网购都是你生活中必不可少的一部分，每天睁开眼睛刷刷网页也成为了生活中的常态。许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别。\n\n**高并发，大流量：**\n\n在今年的2月份，手机淘宝的月活跃用户为6.45亿、拼多多为3.16亿、京东为2.48亿，它们每天的活跃用户都在几千万，每小时都是上百万的活跃用户，而在一些促销活动的日子如618，双十一的时候活跃用户的数量会更多，如此高的用户数量势必会造成高并发，大流量的访问。\n\n**海量数据：**\n\n在2014年的时候，在阿里数据平台事业部的服务器上，就已经攒下了超过100PB已处理过的数据，100PB相当于什么概念呢，它等于102400个TB，现在市面上个人电脑的硬盘在1TB左右，也就是说2014年的时候就相当于你102400个存满了小电影的硬盘，它相当于4万个西雅图中央图书馆，580亿本藏书。而现在仅淘宝和天猫两个子公司每日新增的数据量，就足以让你连续不断看上28年的小电影。而如果你想一天看完这些电影，一秒钟就要看800集。\n\n**安全环境恶劣：**\n\n人怕出名猪怕壮，树大招风，当你的网站越做越大，势必会引来很多安全性的攻击，而且由于互联网的开放性，使得互联网站更容易受到攻击，大型网站几乎每天都会被黑客攻击，拿2019年双十一来讲，2684亿交易额背后，是全天22亿次的黑产攻击。而且由于用户量巨大，一点小的漏洞都会引来大量的羊毛党来薅你羊毛。\n\n**高可用：**\n\n系统7×24小时不间断服务，是大型网站系统必不可缺的能力，尤其是在大流量高并发的前提下能够实现系统的高可用更是一件难上加难的事情。2019年双十一天猫成交额是2684亿人民币，每小时就是112亿，每分钟就是1.86亿，即使网站宕机一秒钟，也会有三百多万的损失。\n\n**需求快速变更，发布频繁：**\n\n十几年前当我们还在感慨诺基亚的伟大，而今天的市场上它早已销声匿迹，三年前BAT还是行业的领头羊，现如今AT依然强势，B却略显落寞，更是诞生了头条、并夕夕这些新秀。二十一世纪的科技社会，人们的生活日新月异。如果你不能跟得上时代的脚步，适应社会的变化，那么很快就会被淘汰，一些互联网公司更是如此。你针对现在市场设计的一个产品，如果按照传统软件的频率，几个月甚至几年后发布上线，那么到了哪一天也许你会发现，时代变了，你的大清已经忘了，你的产品已经被社会所淘汰。因此，与传统软件的版本发布频率不同，互联网产品必须快速适应市场，满足用户需求。其产品发布频率是极高的。一般大型网站的产品每周都有新的版本发布上线，有些中小型网站甚至会一天发布几十次。\n\n**渐进式发展**\n\n与人类进化史一样，大型互联网站都不是一蹴而就的，淘宝起初只是马云花了几千块钱买的一个PHP的网站改造的，京东、携程等起初也只是.NET+MSSQL搭建的单体网站系统，它们经过了二十年左右的发展才变成了今天这样一个庞然大物，仅仅维护这个庞然大物的开发人员就达到了几千甚至几万人。与传统软件产品或企业应用系统一开始就规划好全部的功能和非功能需求不同，几乎所有的大型互联网站都是从一个小网站开始，渐进地发展起来的。好的互联网产品都是慢慢运营来的，不是一开始就开发好的，这也正好与网站架构的发展演化过程对应的。\n\n那么这些大型网站是如何面对与解决这些问题，它们的庞大的系统架构又是如何演化而来的呢？我们下篇文章接着讲吧！\n\n","source":"_posts/notes/大型网站技术架构/大型网站架构(一)大型网站的特点.md","raw":"---\ntitle: 大型网站技术架构(一)大型网站的特点\ncopyright: true\ndate: 2020-04-14 11:29:26\ntags: \n- 读书笔记\n- 大型网站技术架构\ncategories: \n- 读书笔记\n- 大型网站技术架构\nkeywords: 大型网站技术架构\npassword: 1234qwer\naside: Notes-LargeSite\n---\n\n第一篇读书笔记准备写写这本《大型网站技术架构》，为什么呢？\n\n不想当将军的士兵不是好码农！作为一个网站的开发人员，自然更想要亲自参与大型网站的开发与设计。而曾经刚毕业的我入职的也是一家电商公司，像淘宝这样的大型电商网站在我们眼里就是殿堂一般的存在。我想任何一个热爱技术热爱开发的同学，对于这些大型网站都会有着浓厚的兴趣。我也学习、研究了很久，但始终如管中规豹，散乱的知识点学到了很多，却始终难以有个整体的认知。\n\n<!--more-->\n\n有幸读到了这本《大型网站技术架构》，终于给我揭开了大型网站的面纱。他让我对大型网站有了更深入更全面的了解，也给了我许多新的观念以及日后学习的方向，对我之后职业生涯的发展也起到了很大的作用！\n\n这本书的作者是李智慧，曾在阿里担任多年架构师。这本书中，作者结合阿里巴巴以及一些一线互联网企业先进的架构经验，从从大型网站演化的角度，为我们描绘了一个大型网站发展的过程中所需要的问题，以及相应的解决方案。它从宏观的角度为我们描绘了一个大型网站架构的蓝图，将网站架构的演化式发展，架构模式，核心要素一一道来。在微观的角度上，从网站的架构设计、快速开发、高效部署、业务监控、服务治理、运维管理等多个角度描述了架构设计的相关重点，涉及的核心技术包括前端优化、CDN、反向代理、缓存、消息队列、分布式存储、分布式服务、 NOSQL存储、搜索、监控、安全等一系列保证大型网站安全可靠运行的关键技术点。\n\n而提到大型网站很多人可能会立马想到某宝、某东、某团、某条、并夕夕等。\n\n仔细想想，与传统企业应用系统相比，这些大型互联网应用系统都有一些共同的特点:\n\n**用户分布广泛，网络情况复杂**：\n\n已经到了21世纪20年代，我想不管你是在黑龙江的漠河，还是海南的三亚，又或者新疆的乌鲁木齐与青藏高原的拉萨，网购都是你生活中必不可少的一部分，每天睁开眼睛刷刷网页也成为了生活中的常态。许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别。\n\n**高并发，大流量：**\n\n在今年的2月份，手机淘宝的月活跃用户为6.45亿、拼多多为3.16亿、京东为2.48亿，它们每天的活跃用户都在几千万，每小时都是上百万的活跃用户，而在一些促销活动的日子如618，双十一的时候活跃用户的数量会更多，如此高的用户数量势必会造成高并发，大流量的访问。\n\n**海量数据：**\n\n在2014年的时候，在阿里数据平台事业部的服务器上，就已经攒下了超过100PB已处理过的数据，100PB相当于什么概念呢，它等于102400个TB，现在市面上个人电脑的硬盘在1TB左右，也就是说2014年的时候就相当于你102400个存满了小电影的硬盘，它相当于4万个西雅图中央图书馆，580亿本藏书。而现在仅淘宝和天猫两个子公司每日新增的数据量，就足以让你连续不断看上28年的小电影。而如果你想一天看完这些电影，一秒钟就要看800集。\n\n**安全环境恶劣：**\n\n人怕出名猪怕壮，树大招风，当你的网站越做越大，势必会引来很多安全性的攻击，而且由于互联网的开放性，使得互联网站更容易受到攻击，大型网站几乎每天都会被黑客攻击，拿2019年双十一来讲，2684亿交易额背后，是全天22亿次的黑产攻击。而且由于用户量巨大，一点小的漏洞都会引来大量的羊毛党来薅你羊毛。\n\n**高可用：**\n\n系统7×24小时不间断服务，是大型网站系统必不可缺的能力，尤其是在大流量高并发的前提下能够实现系统的高可用更是一件难上加难的事情。2019年双十一天猫成交额是2684亿人民币，每小时就是112亿，每分钟就是1.86亿，即使网站宕机一秒钟，也会有三百多万的损失。\n\n**需求快速变更，发布频繁：**\n\n十几年前当我们还在感慨诺基亚的伟大，而今天的市场上它早已销声匿迹，三年前BAT还是行业的领头羊，现如今AT依然强势，B却略显落寞，更是诞生了头条、并夕夕这些新秀。二十一世纪的科技社会，人们的生活日新月异。如果你不能跟得上时代的脚步，适应社会的变化，那么很快就会被淘汰，一些互联网公司更是如此。你针对现在市场设计的一个产品，如果按照传统软件的频率，几个月甚至几年后发布上线，那么到了哪一天也许你会发现，时代变了，你的大清已经忘了，你的产品已经被社会所淘汰。因此，与传统软件的版本发布频率不同，互联网产品必须快速适应市场，满足用户需求。其产品发布频率是极高的。一般大型网站的产品每周都有新的版本发布上线，有些中小型网站甚至会一天发布几十次。\n\n**渐进式发展**\n\n与人类进化史一样，大型互联网站都不是一蹴而就的，淘宝起初只是马云花了几千块钱买的一个PHP的网站改造的，京东、携程等起初也只是.NET+MSSQL搭建的单体网站系统，它们经过了二十年左右的发展才变成了今天这样一个庞然大物，仅仅维护这个庞然大物的开发人员就达到了几千甚至几万人。与传统软件产品或企业应用系统一开始就规划好全部的功能和非功能需求不同，几乎所有的大型互联网站都是从一个小网站开始，渐进地发展起来的。好的互联网产品都是慢慢运营来的，不是一开始就开发好的，这也正好与网站架构的发展演化过程对应的。\n\n那么这些大型网站是如何面对与解决这些问题，它们的庞大的系统架构又是如何演化而来的呢？我们下篇文章接着讲吧！\n\n","slug":"notes/大型网站技术架构/大型网站架构(一)大型网站的特点","published":1,"updated":"2021-03-14T03:04:50.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwi007jhyjfu351gneb","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以扫描下方二维码，关注公众号，回复“密码”，即可解锁本站所有文章。</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"695822e9fbfc9d488403f6b1706bbba5497d91228fa7fb291a8da97d664023d3\">18df7c3a2b6b893051d186ef22117f88b1725a14bafd39c7ac8d44d5322ff5921a0465a1e6d3ec7f0604048c618e75c87360cf6c8489a9dc68e60bfcf704b99e913a2fb7cdc19ec77006fc62a10e5b7e7c1b766520b31376eea5a2a57cd8ee2ec3ef29bd4be0f831cc939a3c83e0f50070ec41c2cbfe493af80b1e4423b2bb5c0a5d41af41f4fc7272e783523b6b961dab636d2078e3af2e6c21c414c715b38a35c1d9b38385a0663c863c2fa5725a37c9d227e18a80cbc616ef29c6803ddb9bed0f8646276938af1da6f19304bb2ce9563eca463f55b3418130dbd5982606a08ca9705662c640a081619c753f5dfae9704bc6c62843fd59160ed35d32f17eef83a408b9440763e6ae1eb5ae7de94ff52af2c2ee803a8eaa7d0d395fdc7a8739f2ed9ff80ea79e7b73a8b8aa940075d08122dc9430d2f43ce9d127c82f1b1ea8451517842c6e896efae1a6cc2068e83f9d87eeb9a9a625e7dd3706f395525ca82d4ffd9643e1b88312edf951dd7af39940727e9d70f5808155103d6b52bed3848c0ea1507952d13dfe21aac46643d80a3e72b7436196f9a798025be797d22aa3dbfdc862bc8961991963c3d89cb9acf5a1d0d15bc9784911a05cfe3131703569d9cbb32d0b251e1bdb94889f51c0b37417a187e89b89704eafaae2aa5eace938ceae107011afecf2f57cd9379956484a7db3bc0be7c241e809bf9af2fcc6cb89d80c2d6c9bd3d83a0695d19a43f8702cd0e89c9667c0c5d0df2a5f90a8fbc2fceba6720d8c60184416b10bb412a0c1cbd4c8f4ae42130b9af9e977d84253a9bcfaa41858606f304dae082efb6121bb1811a2af0f7d75b9b7b195c5a9dfef2b0894dce4721ccf2b25c825b33b66f708a743fcf16f3fa812fa42adf180402a5475a4ed74de489b458ad4db89b0fd7e319e1b5f0eaef8532ac4914c428f2928d78ba4d8d40c54810720019c756d788cbb7ab102539041d1f491c85da5cd9772c0b2d9f9bf7d383444b4a08ba2c4178c9ffe1322368268e0133eefa80675f139e6af34438fb0b31eafb41c8b52b8c7627a39c0a980a8fb8b3d6a820178c3439e62290ed2970a713c900ce7ca42c5611bc4dd0bd932b0b10b61af7d59592547a4208a742cbc3fca46108fb7ce69390390350ce6a83dabb63f3d39d7f6b2baffd3252d7f56af8dd63c193788f62a4c5eb2db197fa9aa32af23ad31b279de889ad3f11603b19f33c998652df8dc264c9785eb04b3fe120bfede22569e8a4ea5a680b5e09475fc17b5def8d410cc532a5457066af35bbf88d8233a7b0441bcc65ef126a71bef3593c5a41ac45a007d465c2077a490b646bf626448ce5ba856a92e8028984a4a0b8c5e00098fec7f1c33d03a128ac91511a5f39ed1f56b7d58aa13c90ea39eb2e8cfde1460afda6d8896f346e5883d6772e461f1e90901a1967fa0f47cac33b1d885ac4ff308f6dfeb7c467a88bcc5758540742fe61a21f2ba20506287961cce1611416f0b578d8b77e70fc169600678abf1dcd45cc99957d2a17e6857156423ebb7b7c0f4ff3029c8694b18a6414965baa0932b5f30c8ae07e29b3daec3f4593775e1795677a2cd1a461c74f5895e99ae1f34c4b301c90bb9f04b5ff5d3f5779eefaa6b2ab6508a6c048eb0a5646b7fff42704170c9a9750d1c25bd0a644240ca15411e953bc0b98dab3c18db831ba7e34819b5224bbb307526e175f53faf135062109e45305c4b57a2afd2b37dd185384a705c77aac452bb20491dc04e119f031a87c8f07d57a563c0987d6e884a144e2219533431baacb0ff6e2f0af7577328e6d0b94a3b5fd6ba916b80c087a7d70588a551653f66b0f51d0aaaf3070f772af40af02e00dffe1de29c0a8b96b599a80d580c1206eadd2309485d3de26d53ebe2898ae5cd1477270cddc89cddbf5fee38b287c4080a9dfba410fd6077d8223f8bfe191bd42a7ec631dc866acf0c790c4b7125bf7c3f2d0f6984b13d82bd411907d797156b3f8c899fc75e483d25eda2031abd0c65536ae7c7e3bc323d75bc35d317af984f8f949136e3f424d13003c7d58c3bdc8655bafa1c6542d5440e282b25548db4c73c60841a7d2d47cde8f9097d63d5e81810c8a241b7e25dfcca58fecc05c070ed688d8672782d16ce5b8964b8ecb13922b72950222328fec7c27c5a15a69c05ae28226bf6e5fd7f1efafaf719bb9e445350a7d9a0dc03a02d72385cdba2f09011e53b312c4e487693d823e5bb1d105ddc78117d5dce678b48054d9b923d4671188e7d30c4bb1a6df03a31dcbc50fb80e6519a6082df24fbe31148eb5690d7a16c9b8a30e741491fa7e62416af7322eff9ff4eea7cdc21a4d354fb0c171abcb896d6d268338eb0053ed6032a4eb90e88b37c799639fa644e15df716046bbc37aa870229ab7e171c1de8bd17012d47cb66a1cfe4705e149c6d6e3ad164695890198d56c1a5218b2ba5109df74a7fefce97aca5bb2c17c27136263ace80bae2016a14a28eeb8ac4195414cd7d59814ec9b09340ab1a7917e3cc429a65abb3d0865508bea218d1b1a6d0ef363c3c42ea9151d223060060815e98b630f0208f477e6d479a7c11157150dcba9148a4aff8592fd782181e5ab6dd2af0b960949c212aa7e3c22c33dadf5ea1d86f9f040f5d264f9887af3d6779facf3ab2721fcc1b79c77c3d52e952a4c91ad325c41b11cc7fddc007d7aa042171adbe9409edfa66e5b497bf8ca42e162ffd91d3034f6025fe1278616714cf4ee76c3c60d9b09665939d7439590e6a644754ddc51cdc482725a655467113c9e981657809173dff0b82e9f57cb2d7d380cdf1bf72369a638ce300fbe1125d7efc8b5cdde54db0ccfd92ff1f0a2cd7aabdaf1a637ae4d42cc84bcf80ea62f73ac1d69702b11e4436e0c241928a75d8d9e3fa516e2c1590304028cfe988dcd5594e57f8042b863104e588345793675c346308cdd77f6f6f4fe530447a3bf89131e7ed25ddf7862ce0ce4659e3ffc39b3f58403e59ad65e4d65aba17bfdbb0397a3fb4d1cb8597a8367a796082bf2bdd36165bb6f4421a247c5d726a64adf5a9ad671e078880e0c2c042bdc3ff09a9153300c926b2f4f3feee745d90578b624ac968ef1c0751e6b2100d7942373bc9957c1a866d3899904704302e7996d5daee6cb6319b0d207c6c33bdb6fa17f8a531c376b13428bdfb5e680d3a680b048d107ef1c9512dca732177c5b58c98250b1859fa2135a3de96d6da2ec12be03d19c5169457058e5f32011c2d44d4d2b1cdd5e2e33223e0eed3392679a9431eefc8a6966154070206ae9a17bb0667d5b0a1d5e6a87e89b756224cbe78d8d99a846ac16d5659319b7d05f12672479a58f890365d9652a76d358399067d803c0de0e232605bf9ed693b6742086c6c7278d70c933b73e13f432df1acdc60a9b95c086231e886267a864241a05d9e1a2a008584105683f144818d26ae8cc8d5669b9a9cebe76d5f728e219408d9ce4e8d53509abbc62803d951b2a6e6b8bd7a842a9ddcdc358f8d918aabe9d9d913e58e505f786f658c30d119c4823641d87fdf948ad762e5fe4cae22679cd389e5c4286a6f71f70411728aabd868fe4b7f40e25136c25f5dbe8f283b1df3b5433dba533d85a0b5c2c1cf6553623d1a22af13f832f5b32b1b8c38a617410f477291e419108c71ec012b0ff4a34fc51cf0b03953312cd238eea859936aa00c7255e45a9b0c151578d48f78941da78b15201466b3f6c4b050db4775f93049e5030c274808973f6c84dd2f73a4d6558bb48c95c0416014326a0caec958ea02cc8f9e92e0036c2ef7a4cfe220ad35354d1410f5a3355c1abfab2bb9047d905c2195df253f7f19c9ebd7b665fe961954cb59f20cf8fae89352e7c78a87a45e4f30becb89e9b47041082a28e8a4aa8e0855893cbe813f871275c4fa17e93c7a6ea896fdeee38a0b618c8ec765ef7fbdb53aaa51899b387f5c9d0bd491392304339e6672e75950595bf5fc9cbc080a6f2097a037c1b645755e26d5f31475c03a1c3278df696ba369499dfc0bb7dfbe90c7be41f4821e87e8a699fe27e9fa93a256ec97a6be183e019f35d1d741e9c0590b9b79356dd5fd0477730e607411e78508d156f81b4abc9720959ea063f491067656f592f42f49542867a195417de3174c35b48fb020bade9da779f180f2f9f5bf3459bc4c345235e234dc0ab4b6ff76d2fb4ef17a54421c4dfa3378e99e1767e8abaccb3064c2775bbd5fc863c3a2fcef9d6ab6c1784beda55cc5628d36eaec4444a034322f1eab65f38888b8edd5a805ba6c82622aeef51d380e33c4f2267f7d8a8746a4432e58d430c63454106e590f451fa0e80380a56e02b1e44a55ff214fb6886b3ff932236263a041837aa7394510d881bd101f6591a96304767919571c1574ac2f9e7c92f85e93369c8ac2f5d1be3a6d71b239047885cda596a341f816f3a3cf18672e2e18a64407338643f562cbb05e61cdc763d41b17ddd8a0f8d4ccd57f2daab8730c3d2d2f84734ae26456ba700d94c52f6724f8a45198b65d479a9101909a6af7a1fb26c04d33a8609e353edb3318f66dec0e20fe52d23e1b78e7d2dc42b69c6a7ce9e53a79f05d3cfcaa75ae4600e783e6b5319bffbc90a3adea623f791b7d18b9b85013098b3b95c9f98640350a18fa3291ea99cbe046d71d977df56f7bd9bd16b88af1dfc29b8a9c160fad0491fea9e1c0f7a1447dc92f9ecc958673bf7bf5cb126f055ed7209778150ebd6ac486ad00ef246aacb137c7ffb025fb78da0fb8d8ac845c7a3d05d13d0400842911f8369afc8a5617393cf321f7326756cdb25ffbfdbb7cbc6486eb38893deaf8871b8fa2913f689306ee8bac937be9d4a598ed35e6a0607991197ba4b9bf79145fafa54f3ae1a697872bb9fc595d1f9828a0440e52f7838365873c8ff82fb0188e97d55385393a3c8ec76da7e168490bc55f855f1efb62a65b69c49fcec35046cc1297304e644ef245061df0525ca0a5dc90dd7af38d358b56c034069484e9670f117b3bfe0f69dd57955e1fc3265f90654e7a8975a6ffaf811c156933fd0a023bb1e4519fb2a81f767e369469d6b985698f90221cfe06411c7dc540cc5ce3da877fa56c16f85d072664cfbdd3c0c7a6dc3c31440cc50e1de50b8937a6003f0d519430f26db4b97642304e0549a116e0fdc8bb5fc56af9e3f93a360e1cccff9afc2b7232fea84e695acd4bbebb0ff55f4602ffa00b41120d724d10ec690a7bead392736d0b158754edff7452b2d698766a5f501cbc630f283507a6939f731fbad2263b0407cfa71a2cad384d1105955b661750d77886febe8d945bf60860557bf4abb863ea6cfadcb470f578b5d07658e50aa2f6f5d767a7d3b2a2c38bac603eb15adc6c8cec15bdebe987d73b8204bae81e8b8a7258f00550549268087b595c05be6b8a1a155e7fe77130a98dc99c8430ae267daaea39db25ec74532f434103380413e98200b9821b79bcb3d5062215536627a8eb0e5e2725222fe1241dacf87c82208f99c01e9e7fca615c44b2d3d43193ac4c1dfc019c4e734a78ad2adbc831ddf5c1faf9ec67d8a2484dd8868c14d4afe3cd8fdd8d887dea4e378539774c47ac1ef1124a12578752eed2f24bd7c7f1971957a3b197402917ca10dc8b80db6af02385f49906ddeb64c7a38a4f8b43d021919f8297b00e44660e3f11eb83b92c13182af12487c2a444e7e4a803d6f4c111dae25b05342a72cb0c0ad60fb9150a2927173ab6828df100b2944307a85a880c0cacef822106d046516096803d3812f7c3fbeaea4fb7910e1a33fa81cb79df9afa4fc26367ece03152c3200c0b8c31e59c030440425f12b0e0a9082ce2eb3ed0adadbcee3eb897388d7a67003a464545054c6f8368275322bf03a06a94bb123487a498e0dd822c7ac59b83f058cdb570ac4fe444dfac066c2ee0755e807709eb0c7079e71795c3241cfd423945932106d293bf8930b3f35ed1c65c27187e51c92f749ed8fef37989bbd19cce91ac15c347c59105fe8370aec6caa5fd43c562e1fd35d9a0ae94af1698bc621737a2572597e4f91fa385868411d62f15a57fe85acf2b968253e83d7c08ec13170655a3dd57ec5dd9aa816de47aff5428a700548a2e6d4a4580be18e3dc0c162b708f610f1e4d988b28d646908f8de66b04d81bf7d7ab09970eb0458a15d04c9cdfef8451b51f9e810c0094e9cd4412ee529f72f5bafc802ff49eb56867819aeb0d63dd79ab6ab1c0329ba90447c279fd1e355327e5d8181d227b3e846a44487935a3172f43692d239892909ae69c72b2c746326f878e9b9774fb8e9922ba4184f3610da3cc14e2f6466e3cf3224487b08784e05e0a5c6a211e6014875fda7bb20fef9c2e9e3f8905030cfcfe22939266b059c3408916e460a3613be85c034d69d626ef4db5c427ff8bb6d6a988f4fe1c8562970e7adb970a26060020e573d3b0fe166de31fc0be3e9eadc0a04d7171dabd7451b9570c1babcc403d364249affb7d9b7d0d420f85f41881c841aea62b1dcaa0c51a976074a875f55f82b9a2f2c6a066c0b34118de52616ac89f51ad9d7edbfb5ff099260f66c61a8c49c9e250d72ff6c383f3ec81ba2aba7a548bfe3138f4dfa2eeaa45cd3cdbcc8c0f426436b438f0eddad2c93363e04ba3407130a3adf7f59ab4e309c88280a22c30e75263dc15ac533c69e85873376eadf746189f031abe575f93fc8b2652f4f345ef70d09b5062b97940931fa3f0c1930222594b54c9c44a3988bab7e6ac13081fb9bb214b9dabf5616a51b4ddbd87fce9b4640b92b24b6ff8dc857e13fd265ffde7d231f555f015f5bf28cf963890ead6b35adbfd814bf8195df7f2c566f733a21944150f6e8d11f55ec97641093e7141513eef8bf1c3a87eba61e2482cba50395bf9cc97865429ab060ea68f85ff9f9096765264138da6ebb220fc4e809c281ed00b76acac0d562f742aecc2c49449e3f53a6e7a36cd53003576ee056b781fd4b4ffc79bc0d41f48dc43a24b39f1b46c2145852e60cdf49c3a7fcb043f96a3754d4c22d72424a8b0a84e050b224cd6a48bbe0b6d140320de73eec2eb42f78a86b3306b4e656aa2f92a079a3afe32f5f57516ad5c49217ff4c70426521d1d3ea5129b4a0f10182d6516739ae1abab3b603b64fb50ee4f6a58b6a0892893177199626c1f2cc4e834007655e38dc885ed3d4a48c41ac8b76fac661f5187df1f09ab816b8ce4ae6ab261c0598342358c194cdd538fa619735e0b86814ba95e1efe739f2dabfa532ad72c6e40049c4f07fe370f67f5ecf50069bce1261f3d5d7c8d7fb0da8e4a71b668e47632c78c0115f91aea853ee8475cae6fe9d9dc5508e65a1f189c52d39c85774635b98eedca45d5a3e638015a7343aa18ea2dc21853a9c1dff1f8a7d91f696d135eaec56ce268e5a37fbd53aa8aa10a2df2b626619e009d564ea2f3c1cc072f2bb43f8eb4548e299515bc8584cd12ecac83f1ecc4ba59bbb09bd977040ed796ca8fea60c38bd60557b3ab9f7263a9cfdc9a1e967718955439c75ebd97b9a84e1ea8b038dfc0f15d7fe7446a4d925c58f475b023ad99b24cf1d88cc12007b76bca263666ab92314ca8c36338f3a9b642be4acc22a0f08d9be9c7114964fadc684d1fe36262a6d0af974ab795feb40973ce7e7c3d14cb79ba1692cdd34041572db9e054d4bd75bb55ef7ed05abf77b34c49666449b7a37ba8401a46ad45a73eda57d456860631006da1b00a89aa022c99a3855dc3ef277262a1695ab54ed00df4071e5f6b2895cf6a33777f7963d20e88542ce32c438c45375a26a77dd3a76e040dfc9e8ce6eb24449795413ffc195d2dd093cff5c1fcab33d34fb55837731508ebad0dbd32aad933cf205a35765f8bb96ea8652c932585eb63bc58b26f9d627c938f37ea0b9ad1a401a33defd815bd0b8d2957e5ad064b6a1877c70bb0f550e3e584d40ea6aa51619a1e3f8cbd6a32acc7a4c61dbc521b0cc37d56f451eb3cedda5895fdc652691df579a37055187b235d26335bd891987ac2ee2f157f9205097e6be2bb46858973221c2b55dd82d09b3d57e3e6547d5a520ab0cf3f12431fa21bce11da035ded638e7e30f6a906bc5beff2445b9499ea29183b3ef868064ddfd1636e213f6b00937454b17a6d8c7a9840fc2dd5da6aab2d2b770c1c04dc3fd6889611dedc52edff29da7122b979ad39c7c9b6a7a1a19e73c8d4463ffb3129181222f68bf0d7d72ecc1c425c474996ac53e0d3ed399b3cbb363b554bfea53b20dde91bc08d7154bda340c2c6b059e3932af06520b8305adc8c2cc98716d0e14849c058bfdbe9642c78471cc30fc4ea775aeac41e00a2414cf53cbaa51febaabf2e9012a94dd19ae3f627b490e2673c7be63175289002257aa3aa82013e17e07ae05be1840152e211a189807e7aa5a381c0187ace0d8d36e21f1e278728d74d320b36a6d6a0e3f9aa55864479c1ebf01f32388302c5cc8aff0f3f6bb653b46adc1212827038e5cb87de7382f551d174ea017b63b99170db8aa5f00ffd4856cb031630c2741c7bb76fdcdca9c84db17ce17a63292e8145a9de13541acd935a0435d51b59f3e4cebbc0a448cfa2f2e1b03a4c9c7251a4607b9c7c0760c9a7bb5bd4d789b27c13664dca42fc8a16e3d4e4c727ccf76acc7a8e8925c18781a05081a34cbf1f9c28522a6fe6cd63be93e4663f757ec5795b5253eff465c17d7238110bedbff15d1e01ac6d411a13151d085f5021b6fe027d0d248586d29c774c302342203b3e4508555ff3bb9b77ee735eb3edbc03b5f53214d5d02991aaad05816c983606d93e991e0ff5b671befcc7967b2c35d4ac397b17e5824e8c02d273452407ed5f97fde3a2c3a8825e2fe64ecf98920cf8cd9f478f5c7e31b23546c7e8e9a8ed503298cd28173ffedd93c3d4aa20f86893b4e382895dac5084634da81f5f507c855255133c5b577e9533f6b36414fb33d3883d0ef08a6e67964</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","more":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","origin":"<p>第一篇读书笔记准备写写这本《大型网站技术架构》，为什么呢？</p>\n<p>不想当将军的士兵不是好码农！作为一个网站的开发人员，自然更想要亲自参与大型网站的开发与设计。而曾经刚毕业的我入职的也是一家电商公司，像淘宝这样的大型电商网站在我们眼里就是殿堂一般的存在。我想任何一个热爱技术热爱开发的同学，对于这些大型网站都会有着浓厚的兴趣。我也学习、研究了很久，但始终如管中规豹，散乱的知识点学到了很多，却始终难以有个整体的认知。</p>\n<a id=\"more\"></a>\n<p>有幸读到了这本《大型网站技术架构》，终于给我揭开了大型网站的面纱。他让我对大型网站有了更深入更全面的了解，也给了我许多新的观念以及日后学习的方向，对我之后职业生涯的发展也起到了很大的作用！</p>\n<p>这本书的作者是李智慧，曾在阿里担任多年架构师。这本书中，作者结合阿里巴巴以及一些一线互联网企业先进的架构经验，从从大型网站演化的角度，为我们描绘了一个大型网站发展的过程中所需要的问题，以及相应的解决方案。它从宏观的角度为我们描绘了一个大型网站架构的蓝图，将网站架构的演化式发展，架构模式，核心要素一一道来。在微观的角度上，从网站的架构设计、快速开发、高效部署、业务监控、服务治理、运维管理等多个角度描述了架构设计的相关重点，涉及的核心技术包括前端优化、CDN、反向代理、缓存、消息队列、分布式存储、分布式服务、 NOSQL存储、搜索、监控、安全等一系列保证大型网站安全可靠运行的关键技术点。</p>\n<p>而提到大型网站很多人可能会立马想到某宝、某东、某团、某条、并夕夕等。</p>\n<p>仔细想想，与传统企业应用系统相比，这些大型互联网应用系统都有一些共同的特点:</p>\n<p><strong>用户分布广泛，网络情况复杂</strong>：</p>\n<p>已经到了21世纪20年代，我想不管你是在黑龙江的漠河，还是海南的三亚，又或者新疆的乌鲁木齐与青藏高原的拉萨，网购都是你生活中必不可少的一部分，每天睁开眼睛刷刷网页也成为了生活中的常态。许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别。</p>\n<p><strong>高并发，大流量：</strong></p>\n<p>在今年的2月份，手机淘宝的月活跃用户为6.45亿、拼多多为3.16亿、京东为2.48亿，它们每天的活跃用户都在几千万，每小时都是上百万的活跃用户，而在一些促销活动的日子如618，双十一的时候活跃用户的数量会更多，如此高的用户数量势必会造成高并发，大流量的访问。</p>\n<p><strong>海量数据：</strong></p>\n<p>在2014年的时候，在阿里数据平台事业部的服务器上，就已经攒下了超过100PB已处理过的数据，100PB相当于什么概念呢，它等于102400个TB，现在市面上个人电脑的硬盘在1TB左右，也就是说2014年的时候就相当于你102400个存满了小电影的硬盘，它相当于4万个西雅图中央图书馆，580亿本藏书。而现在仅淘宝和天猫两个子公司每日新增的数据量，就足以让你连续不断看上28年的小电影。而如果你想一天看完这些电影，一秒钟就要看800集。</p>\n<p><strong>安全环境恶劣：</strong></p>\n<p>人怕出名猪怕壮，树大招风，当你的网站越做越大，势必会引来很多安全性的攻击，而且由于互联网的开放性，使得互联网站更容易受到攻击，大型网站几乎每天都会被黑客攻击，拿2019年双十一来讲，2684亿交易额背后，是全天22亿次的黑产攻击。而且由于用户量巨大，一点小的漏洞都会引来大量的羊毛党来薅你羊毛。</p>\n<p><strong>高可用：</strong></p>\n<p>系统7×24小时不间断服务，是大型网站系统必不可缺的能力，尤其是在大流量高并发的前提下能够实现系统的高可用更是一件难上加难的事情。2019年双十一天猫成交额是2684亿人民币，每小时就是112亿，每分钟就是1.86亿，即使网站宕机一秒钟，也会有三百多万的损失。</p>\n<p><strong>需求快速变更，发布频繁：</strong></p>\n<p>十几年前当我们还在感慨诺基亚的伟大，而今天的市场上它早已销声匿迹，三年前BAT还是行业的领头羊，现如今AT依然强势，B却略显落寞，更是诞生了头条、并夕夕这些新秀。二十一世纪的科技社会，人们的生活日新月异。如果你不能跟得上时代的脚步，适应社会的变化，那么很快就会被淘汰，一些互联网公司更是如此。你针对现在市场设计的一个产品，如果按照传统软件的频率，几个月甚至几年后发布上线，那么到了哪一天也许你会发现，时代变了，你的大清已经忘了，你的产品已经被社会所淘汰。因此，与传统软件的版本发布频率不同，互联网产品必须快速适应市场，满足用户需求。其产品发布频率是极高的。一般大型网站的产品每周都有新的版本发布上线，有些中小型网站甚至会一天发布几十次。</p>\n<p><strong>渐进式发展</strong></p>\n<p>与人类进化史一样，大型互联网站都不是一蹴而就的，淘宝起初只是马云花了几千块钱买的一个PHP的网站改造的，京东、携程等起初也只是.NET+MSSQL搭建的单体网站系统，它们经过了二十年左右的发展才变成了今天这样一个庞然大物，仅仅维护这个庞然大物的开发人员就达到了几千甚至几万人。与传统软件产品或企业应用系统一开始就规划好全部的功能和非功能需求不同，几乎所有的大型互联网站都是从一个小网站开始，渐进地发展起来的。好的互联网产品都是慢慢运营来的，不是一开始就开发好的，这也正好与网站架构的发展演化过程对应的。</p>\n<p>那么这些大型网站是如何面对与解决这些问题，它们的庞大的系统架构又是如何演化而来的呢？我们下篇文章接着讲吧！</p>\n","encrypt":true},{"title":"大型网站技术架构(二)大型网站的演化上","copyright":true,"date":"2020-04-27T03:29:26.000Z","keywords":"大型网站技术架构","password":"1234qwer","aside":"Notes-LargeSite","_content":"\n前面我们提到和人类进化史一样，大型互联网站都不是一蹴而就的，没有天选之子从一诞生就拥有庞大的用户，高并发的访问，海量的数据。它们都是建立在业务不断发展的基础上，在不断遇到问题并解决问题的过程中，自然演化出来的。那么一个大型网站到底是如何从一个小鸡仔变成哥斯拉的呢？\n\n#### 1.**初始阶段**\n\n起初你们的网站只是一个小网站，根本没有几个用户，这个时候只需要一台服务器就绰绰有余，把应用程序，文件系统，数据库等所有的资源都在一台服务器上。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%841.png)\n\n这个时候的网站其实是比较简单的。一般功能不太复杂，维护起来也很简单。只要你的团队不写出来太多的bug，一般是不会出现什么问题的。作为团队负责人的你喝喝茶、看看书的“闲暇之余”也能把工作干的很好。\n\n#### 2.**应用服务和数据服务分离**\n\n而随着网站业务的发展，你们的用户多了起来，访问量也变大了，慢慢你会发现一台服务器已经逐渐不能满足需求了：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足。这个时候你就意识到必须做出改变了，如果不改变，那么你的老板就会把你炒掉，如果你的老板不把你炒掉，那么越来越糟糕的用户体验，频繁爆发的问题，就会让你们的客户把你们炒掉。\n\n这时可以将应用和数据分离。应用和数据分离后，整个网站使用三台服务器：应用服务器、文件服务器和数据库服务器。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%842.png)\n\n这么分绝不是瞎鸡儿分的，是有其道理的。应用程序更多的是逻辑计算，数据库需要快速磁盘检索和数据缓存，而文件系统则需要存储大量用户上传的文件。因此应用服务器需要更强大的CPU，数据服务器需要更大的硬盘和内存，而文件服务器需要更大的硬盘。\n\n应用和数据分离后，不同的特性的服务器各司其职，网站的并发处理能力和数据存储空间得到很大的改善，幸运的你发现经过这么改造之后，网站的性能又好了起来，用户的投诉没有了，又可以以支持网站业务进一步的发展了。你成功的保住了自己的工作！\n\n#### 3.**使用缓存改善网站性能**\n\n随着你们业务的进一步发展，用户量也逐渐增多。你会发现dan teng的事又来了。数据库的压力太大导致访问延迟，进而影响整个网站的性能，用户体验受到影响。这时，如果你不想再次被老板叫去喝茶，就需要对网站进一步优化。\n\n仔细分析你就会发现和现实世界的财富分配一样，网站数据的访问也遵循二八原则。80%的业务访问集中在20%的数据上。既然如此，就可以考虑将这20%的数据缓存下来，以避免更频繁的访问数据库，减少数据库的访问压力。\n\n起初你也许会考虑将数据在本地缓存，本地缓存访问速度很快，但是受应用服务器内存的限制，其缓存数据量有限，而且还会出现和应用程序争内存的情况。这时候你可以部署大内存的服务器作为专门的缓存服务器。如果内存还不够你还可以使用集群的方式，这样理论上就可以做到不受内存容量的限制。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%843.png)\n\n#### 4.**使用应用服务器集群改善网站的并发处理能力**\n\n好了，使用缓存后，数据访问压力得到有效缓解。你再一次保住了自己的饭碗。不过慢慢你又发现由于单一应用服务器能够处理的请求连接有限，处理能力也有限，在网站访问高峰期，应用服务器成为整个网站的瓶颈。于是越来越多的用户会502，会请求超时，甚至应用服务器直接崩溃。\n\n起初很多网站会采用更换性能更强大的服务器来解决问题，甚至不惜高价购买昂贵的小型机。但是慢慢会发现，不管多么强大的服务器，都满足不了网站持续增长的业务需求。\n\n这种情况下，更恰当的做法是增加一台服务器以分担原有服务器的访问及存储压力。对网站架构而言，只要能通过增加一台服务器的方式改善负载压力，就可以以同样的方式持续增加服务器不断改善系统性能，从而实现系统的可伸缩性。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%844.png)\n\n在使用应用服务器集群的同时，可以增加负载均衡调度服务器，可以将来自用户浏览器的访问请求分发到应用服务器集群中的任何一套服务器上，如果有更多的用户就在集群中加入更多的应用服务器，使应用服务器的负载压力不再成为整个网站的瓶颈。\n\n#### 5.**数据库读写分离**\n\n没错，当你看到标题的时候就知道，令人dan teng的问题就又双叒叕来了。网站在使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作(缓存访问不命中、缓存过期)和全部的写操作需要访问数据库，在网站的用户达到一定的规模后，数据库因为负载压力过高而有成了网站的瓶颈。\n\n利用数据库主从热备的功能，配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。利用数据库的这一功能，可以实现数据库读写分离，从而改善数据库负载压力。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%845.png)\n\n应用程序在写数据的时候，访问主数据库，主数据库通过主从复制将数据更新同步到从数据库，这样当应用服务器读数据的时候，就可以通过从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器使用专门的数据访问模块，使数据库读写分离对应用透明。\n\n#### 小结\n\n其实以上五个阶段已经可以适应市场上大多数网站了。它们的业务决定了他们大都停留在上面某个阶段。那么对于更大的一些互联网站呢，显然以上几个阶段和方案是远远不够，那么它们在演化的道路上又会遇到哪些问题，又是怎么解决的呢？我们下篇文章接着讲吧！\n\n","source":"_posts/notes/大型网站技术架构/大型网站架构(二)大型网站的演化上.md","raw":"---\ntitle: 大型网站技术架构(二)大型网站的演化上\ncopyright: true\ndate: 2020-04-27 11:29:26\ntags: \n- 读书笔记\n- 大型网站技术架构\ncategories: \n- 读书笔记\n- 大型网站技术架构\nkeywords: 大型网站技术架构\npassword: 1234qwer\naside: Notes-LargeSite\n---\n\n前面我们提到和人类进化史一样，大型互联网站都不是一蹴而就的，没有天选之子从一诞生就拥有庞大的用户，高并发的访问，海量的数据。它们都是建立在业务不断发展的基础上，在不断遇到问题并解决问题的过程中，自然演化出来的。那么一个大型网站到底是如何从一个小鸡仔变成哥斯拉的呢？\n\n#### 1.**初始阶段**\n\n起初你们的网站只是一个小网站，根本没有几个用户，这个时候只需要一台服务器就绰绰有余，把应用程序，文件系统，数据库等所有的资源都在一台服务器上。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%841.png)\n\n这个时候的网站其实是比较简单的。一般功能不太复杂，维护起来也很简单。只要你的团队不写出来太多的bug，一般是不会出现什么问题的。作为团队负责人的你喝喝茶、看看书的“闲暇之余”也能把工作干的很好。\n\n#### 2.**应用服务和数据服务分离**\n\n而随着网站业务的发展，你们的用户多了起来，访问量也变大了，慢慢你会发现一台服务器已经逐渐不能满足需求了：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足。这个时候你就意识到必须做出改变了，如果不改变，那么你的老板就会把你炒掉，如果你的老板不把你炒掉，那么越来越糟糕的用户体验，频繁爆发的问题，就会让你们的客户把你们炒掉。\n\n这时可以将应用和数据分离。应用和数据分离后，整个网站使用三台服务器：应用服务器、文件服务器和数据库服务器。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%842.png)\n\n这么分绝不是瞎鸡儿分的，是有其道理的。应用程序更多的是逻辑计算，数据库需要快速磁盘检索和数据缓存，而文件系统则需要存储大量用户上传的文件。因此应用服务器需要更强大的CPU，数据服务器需要更大的硬盘和内存，而文件服务器需要更大的硬盘。\n\n应用和数据分离后，不同的特性的服务器各司其职，网站的并发处理能力和数据存储空间得到很大的改善，幸运的你发现经过这么改造之后，网站的性能又好了起来，用户的投诉没有了，又可以以支持网站业务进一步的发展了。你成功的保住了自己的工作！\n\n#### 3.**使用缓存改善网站性能**\n\n随着你们业务的进一步发展，用户量也逐渐增多。你会发现dan teng的事又来了。数据库的压力太大导致访问延迟，进而影响整个网站的性能，用户体验受到影响。这时，如果你不想再次被老板叫去喝茶，就需要对网站进一步优化。\n\n仔细分析你就会发现和现实世界的财富分配一样，网站数据的访问也遵循二八原则。80%的业务访问集中在20%的数据上。既然如此，就可以考虑将这20%的数据缓存下来，以避免更频繁的访问数据库，减少数据库的访问压力。\n\n起初你也许会考虑将数据在本地缓存，本地缓存访问速度很快，但是受应用服务器内存的限制，其缓存数据量有限，而且还会出现和应用程序争内存的情况。这时候你可以部署大内存的服务器作为专门的缓存服务器。如果内存还不够你还可以使用集群的方式，这样理论上就可以做到不受内存容量的限制。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%843.png)\n\n#### 4.**使用应用服务器集群改善网站的并发处理能力**\n\n好了，使用缓存后，数据访问压力得到有效缓解。你再一次保住了自己的饭碗。不过慢慢你又发现由于单一应用服务器能够处理的请求连接有限，处理能力也有限，在网站访问高峰期，应用服务器成为整个网站的瓶颈。于是越来越多的用户会502，会请求超时，甚至应用服务器直接崩溃。\n\n起初很多网站会采用更换性能更强大的服务器来解决问题，甚至不惜高价购买昂贵的小型机。但是慢慢会发现，不管多么强大的服务器，都满足不了网站持续增长的业务需求。\n\n这种情况下，更恰当的做法是增加一台服务器以分担原有服务器的访问及存储压力。对网站架构而言，只要能通过增加一台服务器的方式改善负载压力，就可以以同样的方式持续增加服务器不断改善系统性能，从而实现系统的可伸缩性。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%844.png)\n\n在使用应用服务器集群的同时，可以增加负载均衡调度服务器，可以将来自用户浏览器的访问请求分发到应用服务器集群中的任何一套服务器上，如果有更多的用户就在集群中加入更多的应用服务器，使应用服务器的负载压力不再成为整个网站的瓶颈。\n\n#### 5.**数据库读写分离**\n\n没错，当你看到标题的时候就知道，令人dan teng的问题就又双叒叕来了。网站在使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作(缓存访问不命中、缓存过期)和全部的写操作需要访问数据库，在网站的用户达到一定的规模后，数据库因为负载压力过高而有成了网站的瓶颈。\n\n利用数据库主从热备的功能，配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。利用数据库的这一功能，可以实现数据库读写分离，从而改善数据库负载压力。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%845.png)\n\n应用程序在写数据的时候，访问主数据库，主数据库通过主从复制将数据更新同步到从数据库，这样当应用服务器读数据的时候，就可以通过从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器使用专门的数据访问模块，使数据库读写分离对应用透明。\n\n#### 小结\n\n其实以上五个阶段已经可以适应市场上大多数网站了。它们的业务决定了他们大都停留在上面某个阶段。那么对于更大的一些互联网站呢，显然以上几个阶段和方案是远远不够，那么它们在演化的道路上又会遇到哪些问题，又是怎么解决的呢？我们下篇文章接着讲吧！\n\n","slug":"notes/大型网站技术架构/大型网站架构(二)大型网站的演化上","published":1,"updated":"2021-03-14T03:04:50.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwi007lhyjfi1goh27s","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以扫描下方二维码，关注公众号，回复“密码”，即可解锁本站所有文章。</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"848d394d1bf787c6efe07760afc4b4e1a35cda8ffb0b04940f3e55ff22bfe5b9\">38cabacd4dc4203e3d9e0b841f17afc90f8058d01d051a495d4dd51ffd0b4ae969f3b14f018ee53231fdaf190bda9eda1e8e3e981c3082b21934a2617ccd87bee488e41d63b5b973e8ac1c61a5717f524f46d7f98c171734865d7ab1a6a913f4c9aafbdbe55044568501e8fba0037631df3010e223d7e37bb0d3a7311f0a8a83f2e60023444e2bbafab4ed4ab6a77134da4f752b84b083a23be2484a9a1b4dae87523e7ccc6e12a880461ce29d956813546390407121ff954d6a1165b876db8516805cd00ff00f38a252330c463b270979ffd889b2083e37c6d4035208d50ad944455839d8236774c785149f73b13e492a5c1b6730db4d3fa763366a454d0fa6f7cf772aaf156425cdd9b6c7c3c28e96765a57f3577467cb8b9e4f350560193cf544e03d1f66561a3b6b52c9be5544c177fa20f52524baff7fe0c96fb99a928de9928d2a2dd8f4c353ec5ba8dec65776f27c5d88e164a33dbcf9b2fd64a1ee3e8171be4672101101d06580e773322ff666473356b162bcea0e9038b343ed9be0dcd8b432876bb7693d06ff76d7d02f5d43d022a713be507586ff3e097e64482ac56dffe61a2ec7b70c18fdb33d36c8717619b324665f53e190539f1780a8afb9d226cf243d1d8720b2d73beed3fcc0e96d269bc61007c811d6a689c693a2b1c8051f7e5d2dabc01192232f1a87ebb6bca2a5c4790f043f31d21ff73b4c457cca878d1afcb2192b1fff3075e6056e8358cfc454ccd3d21a9c1bb89cb7bdb40e3360f8a5b4e417f890b990c6e3f34fb9a5acdbf0ffadf48fc712cc23f8c5128e50ece948f00e430e1a4f661b359bcb1d4c38e16375e8ce6fa5dfb3684aba71a80a18de7e13459e6e4cd66cc79edb4e4bd68c9bfbe9626994dd48da1de08f303edb342c396872b9187bd9442995fdd3a720d4474a4dc7ab8765e2b8f2dfa281916e6b1325f94eefd366bbe94659d947d7e94cab290b7f5181de1ce09a4f177245c50856a43f9abdc408d32972957a42fad1abcb6e441a4e650cedae938cad739754edc05b2adf82b4f3989e2b67ce2b9d6835de2ed4d50f1337e4ce1cad4a386c4a0b649a76b69b3315ecf2153e085bf6015943062ce726a1d600644a2b4f60389e49d86c8664c0e9f91088309df691fedaca80fe1774c739850e686d872a66f30a9fb87ad6c53acaef6d594ff4cfb48ccfa7eeaeff2f09b8082cebfbcd0de0d1d7ec9d917fcd892c825ae4262de776198e4c2366c900d4b348b99c020179a7084a61a7b227018636f13b117b6004be600f120ff54f4192bee400e86d9a94bd3ccd54a3d8331fc15b2294f8721c13afbdf3d3b0354e59c048d077bfcaa67ca9468c210e5e34ed68be000e653e0b4bccc9e72465c26e49bf870ee0e6237f0e5750b7badba7629fef373b6e408748466823bcd9583a752913317302acb1ac0369b968ce508170c2b294b7b820a68c8c9ac77268f9f0987a74ec566e1093e8b03da157a2a2793dea8950971c77f88dae395f6294fc312f1f2983781d2f7d6545c80cebf6bf5707461557f4bb5dd8e4e4e9700efcee184e8ea76c8a5097f1f1a0a553097d615b5bc8040ac6130bb466afe6a7679adaef5eaa9f7f5764f2023796dc550f631aa4e0e63aa9000db370c64b8b1ceb03ba5bcd78064df83c2d7160ab55d7edf0aa8a399a39f254b1d94d68986bdbbba6e783e1748eaad1ea71cc3c2de8b6b37898b863dbe4aa653a9c46c4634c87ebd29e0472aabd1628726d675199ccefc4234d49e75692bc1b54b9b85c1767374f960330668468421afe8bcd1084d56494d424179b9e4b8fff8620ceeaa8cd98d4bea369d88cc9ff22efd56f1b01c006ecb6f3f1b12ef5e5a10a910af74399f1135699136743137ab36f0128fece0cadb4476d6bae090109452d8e8411e6dd84d418ad043387d96964a783104867e6c102627adce02a7e6ccf54a4f10685d0afa2f300270565905794cb20dd41a0d7e5309f5bea8e1152efb40b759e5c89365ca6af39669837d8f658955adaf957c3de4dcef41f5ea01961b402fb7fd266e021071cf7566b3bfce16037b6d7054486b0b19235c344474f8e92574ae0f22efdada57db42017ca03f1ea12d4f400262576df202b00f6b626833b257c950a6964d6e268a46ca78aeeb3aa2d092a480d01e1c2614dda1464c00a16b6e6d8da783793ebcdd8574db4ee0b203d7566da45990a9b5fab31a3d8bca3878beb357056a0e4d6ab20aa3a9d246315b6c578f343e56d873754687072ec727885715696e7050d903405851773d0cc84974ea5d92873f836d42dae04be4ad4c183db3dd3e782178a79ec605b1484de558927f95fb9649c9f6259422c71c3e1ee2c314ff20b373326a811bd77580a07b97986136d6fcf133a7ff3f9329204c9973293f2e19df03e6cf59742680532aff192b2715bdfa48c8ae710b33570e36066a976a8ab587dc8e662c4b9ad9253c07bb1b892aeb1dfb43b8c50628ed14d5397b24075ed5cffd6996214bd407b19816c09bae9e621fec20f64f2650658f0b58366536b43ef5e1ddb976c680ecc015fa44c15e48a249b3daaa3581c729b3d3441cf3c3cc2e137bfba9a12abd81b9e7015d59ef99e0026fa6530587fff8bd135987bf66551e6f375ee1d6351743edf1eecfcf32e4e9e95c2478f8bd6eef9436e5fe694323c37cb34ad190e8daeb4d8046232c67d90c4b7749a41ab55f896b04911ec882d8b6a855cd61d635608fff64d3cb6d5438b1a63dab67d96b9b133e0fc4fe3ec3aa3e335d07e48b5e9cd31c42383386ae8dba998b006af77810f7b96e67aca75be556bd0360c2a9e8e8ed7289985b5296a585695394e95c65437af795b7c37bcc1ea9d21738001cf738d40a2360d2523124a8c30976c84b7bfa1fcebe5be20ddde209421b02b5c18503af6bf239f51576909a8246c06d2796852a535c306eda00af583ff5c72454edc79ceec331ecc26c93d9c0ee563e8565e7d0cd2bcda18ec588be392107ed9df2a67138b8403c793a1389c2bd5cefbe7e4dd42e696d8e8bfbe168be10f1daa209584aec267503966c7b3bd12135e7d9b11d7795a41dc4acac2fbe31ab65b0226c280e1735476ac837a6385c2a2b30d1638bcc7a88fc41d03f1908adbc5d1a86f1eb09d90dc3cf5402205e63de5af8d60c8160cc3c0b5e233b47915224efd4715cb3c874ca6a08614c61f96ea38c423705e226fc659499ef8e960b9171938d73f60cc4fa82b7b01e96929060b88bbd6efba83b10e74bdc57e62c1b77049ac53b79b5420a2eb883a236a9a2b349ba0be9bd1ff65ba0865d4817db9cf16439aa055af693b38df36be78a5793b83b459c3e18dcd0e14e02146fab874e5249177241a2a006a2544424b201d05b9c253569a3fcc76fe41d8f23210a487af6676653dd847a6a4de9b155c85772bdab59f0421b2e199d5e07b287df19c6a7dd904ccb196dae9bc31b41f383d8956b09ba70dab013b9888de57f4f5b8f52bf428767b850f7aef415ab2244d80dca00c3f47f47a10093e1976dfff9a2bc8be3b7652f5003f8a3224f6d59f9f8e7c393cc9d7a73a4409309af38386448217e0ab922b5bd762a323ade5c4845c6849e5cb8c09f9cbe53c3e40a9649f0ce03013e93e80f1ada3f9bdf921584ed87fc30dbd24d92c19a7fd1d14b5d32505977b8f8843f670bb26a7c276ba59035ce2377afc981332331293c968f74d179be182b75fd520fe126d3af4cf4ad42ef032de2c7a18b16eedd7e4c5967772425db5535ddbfe2d237b32f035a8bc47df721c32c3f08d4d7f6c4e67ce9c69dd1b2c6d5edc1e65ca90862dfbaa4824fc7fb4b2eb2ce0f274611556d5da042a3ab4a9997bb6c52503135822333eecb2e6c41935c6fa18618725c82ed35175c5087a1dd2e286b65c99b1f92b207af217706647c32ae70ff8635116e76877f1b32da5cd75844a7c8615a2f4736a77da68f1c908f22a53ef474e28f7f44dff3b1e58e4da0d5854c1d302308cd56fe612e84ff0b719c100b5fa335441412f1effdf244e5f9881c447b20b654bd17ced208f0b9b76b766d07481059b1787d489074b98d7af1507d298b7586299dbbb832cd27eba33d4d64bf4c002148eda726b6000772d78bf08bd5f8d94caaa444326d09cd79be6fbaaeba84540e39d1c2c493a94bdeda75bc065ee881eff4978128876ef7dc8468a38f1c0f8863d2dc9213553193231c60a558ea5eb2510f4fec50555d53bee4c6c216cb8ae34ee4db9a85efb25283076ad6fabd2f4040b3c87115a2ef513ab89383aa56781211660036418426c319d9a0091fd70de7b556077712ee42e0d6124c6b20db6ce427bccdc8feabe5073398b5414b26e5a0fde8b3ee09df2dc811966feca443cffeccc5a0c952f90aacd48096b581cb0e00a80ff0cfd734dc855c7bdc01fc275d03ee99ceba9a20cd50203285cf6b715d0c2f8e11756f7666f40ecead52ea973eba740f7741b5ccdb88da57258526ddb4b7ac1275b5fe164c550785e2694d557b40db9ff89a7e06db39d279c071d7572523fb1e7f766741b779459eba1725e7858bf7a115c890bf3cda80bd029c8301f0f071beade332d6d6bf6fef4f3e4a82402bdfc6544c417df506d8a6a8e32b7dfc3ff80a13ae29f173829b1a03ed5aa2c83d2f23f8a6a87062600a5b23b98ce4cad2aa880171b97f712a7513a125f03196b2863e2f92444b5ac2ffb45001488c3052061ab165a1cd64954e058c545158243b0a701a8b581db8ea43af558c85619be70f03057fef7962430bd966050b09047902853ee99902f965bce9d00173ea13e0ea3e7fffddfd592ab4b4240293befc5c5061686167767bcb6b35b83d751cf31b2219d78e5d24d9a6e7e627a6438240529e8950365ada636aa099cd25a4a1a380a077a92a51886fc4d0aeb7fc158ce6a3c16687223f3fb375baabde78f98193b99e9e5bbf574dfd718a8bdb86b615c2ccecceb8a990a5cf4b558873ef9e46e8e5c7a083b0586c1876aa1a25081d4f86625cb5d855dd1fdfc5ca4934eecc6278fd9388157adeb1cc09bac553c8c08353a6a7ecb71fbb4f9a7800f90a7fb6d54f76d2fe9726e95ba8b682188d797cd2e63c0970eb3f0a6fab1bb0f6dd4ce85d4f2928d1a12ceacd7c5798ec8cc2281046e78c04753108d5f23c67b40577511144319e0111aa3be0279762e4194e2c5fbe5a2fe49c95269bc598925ffc5b1b09a3feff38642c7eb935ef3bb62581119df052448ce9c0b6613b5311cc68898b78b8b1d406da264244d9673619cb4081dec3f2a21d1e77c764e143126b2dff6d4d46e5ee4c8d281a60b9112b855e5fe6e21168165fb3100bc1a321819f0bdf190d2db05c8c4ebb120da367c390eac387dc4f11f8edeffc91d2a438581dad1018e1b669a3d29b070a0fb89be7b0e5ae7236749831294cca69ebbcfbae0517aae817015b9db5e8cea008edb5324f5dcf753a56215390a8623e5b77dd5a969154cc924589ae8c5a19167926b8d23d57ffe669af82e5a6849db1b524ca420884b4a923324e789b079d81e9c65da18c0816994478ab56168357a2809c141067b86750ba5d0df85bde76b655b4eb855354fe1053869d332674cf9a419343a0d5e6955f8e85157b22b77931ce0a0c1171b7608a705e4b26b9b243a919e6a8309aff26144cf887a758c10278cac6cc5ea54191388e7e7841c4eb9cb96f9c381fab952cf093dd07fd520d6d94962818cfd8ae7ad2946f452b080032b8bdffdb15e0f0e846e10a4d48b9b69109dd0e6a0318892b6f30b62ee1446e7443418619043e667980cd193179f0ce50779f7db58ba5c20b61f70c62b126a9e5ac7663db6510fa617e121091df8530bd48ed75a7c59b1d32059e97143686cce86d640e2607ed6d792e3c9c87f5bb14e5317728c367d0118bf04ec248a9e130bc75c8563b8b1d2afb9edb8156cb792bf8eaee1d73bb7f56f5bc95f463ecd91e3d21bd0d71fa1f5d4af562bc85d600d9232f1ba3fc826ffade83aa9360ede5561b3529497cb120d3c713acbe5faab4a060692ef9f924d14327b19490c782a89a87a27ee502b6137ef29dd7728fbaa176e6cdeaea8d7333a5cf842f23aae9e4160c138ad19ea6e86e35733c4517ac8842e648e5e639c227100fa0b3d9f9df60657e065585072de3cb58f5055fe04e215064cca9cae7d94b2fadab9768109d4cfca98dc848c88de46593b24f298fedf4e7a083ba9c0626e6725d9c7ec11ae0c9257d903736e7b9556fe3c193617d994b2daf62be555243d2ad6e5d629f792f674946b8acc6de49cb4911bfe3e3ffdca1282d22615ee1ad2aff7cda8a9facc5af75a53c0d389e7bf4f7111a3da9376db6a90c2ee7c94162b3ae73c2cbabd396c253762b45bbea220c59c6205e8593bc6a6d0c0c1d576125eb04cb1f386f0389d64d0688160b46b57b54cc76df85ebff09ff7f155ebf4e3358e1e003a929486374154c57a99f080bdd1feab8618306df4c1e894476b6aa4b5ddcd1df8686807c0e2b913229b782ecabd1ab008d3532d491c2b9a1514b2850a6cf02f5f0d6c5c352f5dda33777990b57e77f443c32ae916705adac773bda3ed18ba0e49823f85dfe060e56e0da6df55b13294c6967c05ef1bb9f711f7f7b9bafb50437dd9695336cfad8a4bb553eaa5dfe5a79e518996dcde916d3303b76c563cb53048cbd7b094f977c017273e791f81ac914d5c7689fef581186676fbf2cde1bf1bcbccfd382a06d1a5e8ceaf95a12caf4885400b6a980f1656b907d79c83815311ca3cb5c154766e746e2c1b47a414ba25e7ba79707d0794588cea0a649a0f149ff8e82844d0f8323bc1dbfe3db5d17d69288ef60ab20196f59b47333e69397a1ead3f5f62f81d35a9391eb89bc23bbda060061ebcb3ca320b33753a4d3cae6320ba8b376f33e6aa59f01afe6d7787925580aadfaeed775587abe1f7a86a81d542d42cf8a2669c51940f687f08a82bbd2b688557806df89713aa4e6a5005750f2c2fe321099da8f8c47308ddb7d8a543819faadc1b062160500f40c92538c0bff6d9d74cce6f1a568bf5f0f9db7fa80fcc17c2e523f203866cbfe1b60644245a4e5fcfe4579a61f7badb054524c1b926692e6a7f4ac861c0a7d58dff340ac8c0766695b20b614392248ec24f4634db17f3a3d8dfbbfbb929ad889b51de6e2dcd5e2744203764b766cf7c707c645f91b56c7c6c4c1f56aff4916aabb21a0339b0da2f3f60ee68a8af5b18a1691ad7c02f99693b787899a54e9de000cd851db0a977690051cb28618eee1a7ba214dc6102277151eba304885a808c444eff50405044b068411c4b4674fa526dd0c5f6156d6d118c55a6fd29a931d5793ab8be0fd0cf570cbcb52a56110a2527c8102708ac0c4e58b3dc24ca018d77cd4b84cfe5f39d33e1a5cc01c25f0de363e29776239bf28a6687e928849d01cbaeb122c46b16684fa0162bb30fee0a59d5fcf1960135ac02f2475d5c8d5382b9e3216b78ed55fe87c39760fdbdd3b39060366d2a8474f916a41216ccf9ce83b5fb97376dac8a6b42a0948315e6a5b9d54321daf3cf10df693de04c1c2582f6fe12e6f8c22d93f29b768e1f7c0d841d9b6a1891cc35a6de024fb3638289158cfa05de0bc02712ae3ed1177b22e453f5acbb336d4e13fe94b571e8f3da72641c7f2b8c94edc88f2fbf5d750f9c79f0ffe1525585d84d3156cd6898eb2a062a1caf0d8ee2f2b4b76baa67dd13bf9b3ee21045dd7cb1f1f22cdc0fa6e60abfbdb88cad79ef86b488628bc7fa953f57d63cedf07b8fe0ba26dc0a9fe5b44d4ca9ebf59fb71df88e66791bbadd2241b1bc7d9aac936fabb7d83029139ff0927eb1885db330357413e2299b56bb8e049b64396be5434f3c042244d00f1980228abf237bb305bf1be69dd3aaa80551fb0cd07ccf9db0a0cd5371eab68a8fbfc5d4c4319479af7823882cff02541692740d9fe3f91f1835b7935ccaaddd42b926ba235807e4b9e72feb751e38d447261c75798905712e9820a28f37733545d8986f2667be08c1c8bdce21bdf77f4b4079a62bbe4ede4ce0744ca468d78366da88c539f15f1028f0f22d8d10a380702bc19a7bca58faedf946d590cfc1e168a87c2e1589347d24c6a327f82292b672a3d6e128173ea8890dab18db50e7b723bce1107407cf3a6d50f2abc3e1f5d2ca5b3ddc543851949a586f36557f9eff8f4a721b8c624b330deed2d44d58f616eaf6a6b17fcca4044aecc45e2da19902094348aef486020b31ae3860bdddf178ab2ed7ce4acd487a1f35987322fde7e1004358642211b3c8db5f052564495aaf11e318497f091886cb4e72cbc12e7ce54371379a4f02a5d182dbf7c6357783a0714236fe6fec24d8ab2c551114ae4b42a0d572894f6cb096d314f3cf3edc44b8ef60510dc91666ee54c20a14267a1b6e6bb2b8e66c84706913f96a25b414b1798cc6fddda7cccd676898394f8b5dfa009f8e42c692c99480e63c2b75ecddf5e9fbac3e39a298d753359b29d947b2e4ddaae8c88bf9cd9b6a947ca99ecd86807caebde09649a859229b0ed0d8ffbc2b0a0e84963ceae4214b53872641e4e87c27e4f5f61435eec0f3cb1526e133c3287849bd244a033341f9d7bda1ba7860777776101a5008d8b2d547e383d8b505f3d421a56391a30b90ff5306d92166d5a75c35f8485b482776b6dfb04d3c080ee101f006c6b347d4910cf8ae466fde04720b191c12f9d891fc37ec9889a81bfd333bd7ed5f05a0f9d6da1d99dca88cf7c7f0cbd4da8e4420b6b2c17c1528c0610649b9d00724ff59e018621efd8eeec2f2ffb7fb3018f48bd433d1b2d52043d90b70f976e31bddac85ef723594fb4f81f7606594df6cbc036d638409508409e4f7f6db34df71570acdf5686f970377d0e9803f64ea5a3a3c3c9fc758887f47d7e6d58657a7c4f023eb43e16b84de0b0c569791b9563dc626b11b07fe47c380c6774fcd7aeaa0d8ca4a5c5ebcca298f85d10d789beab62cfe42259792669d9ced890ded1850ef58ebfbff6708a4d33e391d9d3a75df5f05c968067d26582351db70568926bd99341815c549a35cfda28dbeca32028f847b7d5beba5971a7819dd40874cad83ed91be7c91d35c45232284727c6361892f98cd3371c831e52d29fee4f4e72f161474e7e2509ce2044e6a564a8e58393a76f9447cbd1219305b3080a4d8033a7f83b353734f26edee4932e39301c4e64a779946ad27acac8be07b1dfb3c451c2026fa58673dc2dff1b4a9468985cba00155711ede4ff789c5eff4bb0e91542659ec19154a8a3ca96e8362ba36e278f10eaf5c90694d22cc412b5cd1dc5e6bfb69c8a7ff3beaee8f083355003527f69832b94e78b47ac04bfc87d5f22ee382f7718594e00f57c172b7372c473238435a1945586dc8fd8f7405991d2ba6e9d815a7b99b53df8ffaef3bf2acfe60b7a1a6e0a9785b3a39e25ab59ba670bc6c4eaaf70be9d970a10be176ae832dc272dc98283e6de973080e44da5e00612ae2c9c87a5ae4e364bdbdf09cbf4acfca2bf993d861ddc229192d0e00b308f81997ce9682ca0c01314d105259ec9a7f8c21bf4399e91516c6fbeaecb7cb8ad9073cbbaf8be57c668bb16365295c8096b3da70dc764a43170e73c8bdb7e93d116379a33f6f1b7cf8774539530c0f50224b84e39867456c094cd6bfba899a3cb52bb70b20dba626220d6b497b8bfba45ab641e97515d5ed25d94877351f641e4c94ad4570a39c33fc652bea4d982e8c9196dd379f9781ade9d173701a67030e4e84d4bad500b9b68179b2db578ea294c1bc93503570067e27dd93b4e1ce137feb489f9c7800fc941ead4cfdd37c1d58e6630d6d023abda38b0d4522d61e029f57f204e5c02f6ae8173bca5916921530b4f9a67dc3034917aeb47fd08c603f88b67e5152c4c6877c0a6bcac791d03e4a6c395a0b0f104711734a0c8281a1a093b5480e024674344aaeae5a3ed7fec0bab4a150d5273d1482fa7a7dac2b7c86f5fa8dddc91f44d1ffbeb46bf2e6f648adcc19adc3349618f04491da04b473c724aabae54162f3384e8c584508a89205fca30bf8075a254985f2da83a7da5ac04cb15aba6d8233f3ee3a3c84f30378c6c6c93bf44e54706323bdb8a5df920081852da6b3fb0267915ecec45fc0c1320e657360a9e8528a96730eb99f61400e1daa66eca96ff06a81e1688a04a5415847cf9a424b0a81901b4860ccf4d6389df01ce81bf2ac5db12f06250c121319cf498ee0104fec1e7c09fd67cd839a2db5bd9a053341b23fff3cc4b6e574a660288e338f98184cb0abf367cedf8283d054360abbddb579034bcd973e3c9c009eaddabf68cc0a38fbc518631a84a48173960079913b19875402850c7f9006e4b8ea4315f9b66abf38f814872cfd72d4ff4ae66495a63ee74a22e7839ec67a34b816f3ba6f2cec7d822cc7e737dd5cf95a5cf3bc83863c274f57b53617eb49bd725060ecf1556f05e5db04b02c3937fdc217ae87d529d8c92145c0a540f04adfde074a87750627bd91cc31f3a59f2a907d0b2b69e78b2fc0fd352f93e78e5409cfca4f5f9e2bb9ad8602c55e9a145102ab3917acf52006c26f4de2975f01130ff84ce1ccc611d00fc130aa6dd043b97f73f646cc4944a5db1189e54712e938d9d935bf69e22cfa446f33a765e6ed134fa09420133c6bca97dd71446c0f8650e5c3027a4c0fef95dce33032b5539107bc42673d7742d553d27e6d27724a9128380d4720cf8ad9c062ec91deb0e3d40854552bb4b213fd9429594cd75d96417075669759a8abee781ddb8c249505a3afbfd49eb306433f85817d55fc97a3a55168e1e05e1bbbc369a4a538b35fe9220eb43fb78043a545a428585833d1d7f9b9d9c61ea8b8a77ad9fddee73e0a3e12014933fca7d4a15620b4db4c17dee0d35a8ff02928c2bea5b96b3bbb5f9e96062e314fde3c7c0ffbc60a2228adcaf05c1012f73c7e450c1a8d487991a6e9b43d98ed8a81f5939c711bb4e61008c1026d397b5139eadb821a341187f0e5e786f7aed9e0b398c0c5ee7da98aa3628cbaededa7d1b9044d89c6810504203fde219ef60945ed6020a6875b9d28c7df280e2f0fced2ab8c0ff0216e67e5f534710ba8575bd51143df7489dea1588e66f8c863726adc60c327ae867f99ddbc8ee697607c8e86e4b0be72accf1cd839def3c565d16fa46ce699a5c58a4a7ebb429bec3e73f1256af15b8eda6e46540587292f03a104a7faff7c36652dd4b15779dbf845a684c9bba3d951ca112bd7f54bc986624770314e259cb702b4f45a6d29a9837a678d3e1054c8f25e8f726f008546803b3f4c26d5c01e120b7686119ab9714a095b1b5af717bf1d68c4d94cbacb7847bad2920fcad3845cc2d141068f851c94988ccc3abfd1e2fea9f84fa292ee2ea123b6264f11de1009df120eb5ed9d23a58af37475b0a7d34f0cf9b8d49ec5ad71e623b4995146156be452045e69ec7e810fe12bd640fbef76cb3352451b6f9655411cc33436b4ca17f6981c2d28ec69c17ccf1597dbeec3365e5280031ea97712c2a70cf0dce372ee3a750e9a0723e62378e4cd7ac1fa86a456717a643b3e1838d5b437efb40c041beb529f5b81ddb4a55253c82372de01b23cd56c625d381bcea3d7a15b6ed12abbea4dd7d408774769812520b715343ac1c69c8f3398a10bdce4413aacd08084f7148ece9359e0652982da97652a938eda4e907a737fb29c89ea136c2ca4909e0fd679c88124a4123f3d1df4573ba6a21a6ca26dc7d72fb8cc239833cc78254a90026f7d6a9af488cf039200db30f060b29037ebf8177825805833924acec033c9d486584a11dba76877b027d1425385e5b60b9009c60b05f3c47d99071926f3775fd8cbb3235b34b154fdf32cc53733357ddb14ccc63d91c1e0836bebfee73e501d9123e54aa4aef66ff54999a40dbf607aa3b66eae4d4cb34d738abfd84a780782a5826416a91c7fe27b94eb36e9ed23fa04f76999cbf09472289887802c1c8c23c7c8b2a7e183d1d300bc16401f27c8d1613419ce9be4a949cab837e1a27633dfe504d0e57727f5ccc4c33bcdea445e5b8ccc71fcd5e60eab78196fedeb7ec4797648c833</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","more":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","origin":"<p>前面我们提到和人类进化史一样，大型互联网站都不是一蹴而就的，没有天选之子从一诞生就拥有庞大的用户，高并发的访问，海量的数据。它们都是建立在业务不断发展的基础上，在不断遇到问题并解决问题的过程中，自然演化出来的。那么一个大型网站到底是如何从一个小鸡仔变成哥斯拉的呢？</p>\n<h4 id=\"1-初始阶段\"><a href=\"#1-初始阶段\" class=\"headerlink\" title=\"1.初始阶段\"></a>1.<strong>初始阶段</strong></h4><p>起初你们的网站只是一个小网站，根本没有几个用户，这个时候只需要一台服务器就绰绰有余，把应用程序，文件系统，数据库等所有的资源都在一台服务器上。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%841.png\" alt></p>\n<p>这个时候的网站其实是比较简单的。一般功能不太复杂，维护起来也很简单。只要你的团队不写出来太多的bug，一般是不会出现什么问题的。作为团队负责人的你喝喝茶、看看书的“闲暇之余”也能把工作干的很好。</p>\n<h4 id=\"2-应用服务和数据服务分离\"><a href=\"#2-应用服务和数据服务分离\" class=\"headerlink\" title=\"2.应用服务和数据服务分离\"></a>2.<strong>应用服务和数据服务分离</strong></h4><p>而随着网站业务的发展，你们的用户多了起来，访问量也变大了，慢慢你会发现一台服务器已经逐渐不能满足需求了：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足。这个时候你就意识到必须做出改变了，如果不改变，那么你的老板就会把你炒掉，如果你的老板不把你炒掉，那么越来越糟糕的用户体验，频繁爆发的问题，就会让你们的客户把你们炒掉。</p>\n<p>这时可以将应用和数据分离。应用和数据分离后，整个网站使用三台服务器：应用服务器、文件服务器和数据库服务器。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%842.png\" alt></p>\n<p>这么分绝不是瞎鸡儿分的，是有其道理的。应用程序更多的是逻辑计算，数据库需要快速磁盘检索和数据缓存，而文件系统则需要存储大量用户上传的文件。因此应用服务器需要更强大的CPU，数据服务器需要更大的硬盘和内存，而文件服务器需要更大的硬盘。</p>\n<p>应用和数据分离后，不同的特性的服务器各司其职，网站的并发处理能力和数据存储空间得到很大的改善，幸运的你发现经过这么改造之后，网站的性能又好了起来，用户的投诉没有了，又可以以支持网站业务进一步的发展了。你成功的保住了自己的工作！</p>\n<h4 id=\"3-使用缓存改善网站性能\"><a href=\"#3-使用缓存改善网站性能\" class=\"headerlink\" title=\"3.使用缓存改善网站性能\"></a>3.<strong>使用缓存改善网站性能</strong></h4><p>随着你们业务的进一步发展，用户量也逐渐增多。你会发现dan teng的事又来了。数据库的压力太大导致访问延迟，进而影响整个网站的性能，用户体验受到影响。这时，如果你不想再次被老板叫去喝茶，就需要对网站进一步优化。</p>\n<p>仔细分析你就会发现和现实世界的财富分配一样，网站数据的访问也遵循二八原则。80%的业务访问集中在20%的数据上。既然如此，就可以考虑将这20%的数据缓存下来，以避免更频繁的访问数据库，减少数据库的访问压力。</p>\n<p>起初你也许会考虑将数据在本地缓存，本地缓存访问速度很快，但是受应用服务器内存的限制，其缓存数据量有限，而且还会出现和应用程序争内存的情况。这时候你可以部署大内存的服务器作为专门的缓存服务器。如果内存还不够你还可以使用集群的方式，这样理论上就可以做到不受内存容量的限制。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%843.png\" alt></p>\n<h4 id=\"4-使用应用服务器集群改善网站的并发处理能力\"><a href=\"#4-使用应用服务器集群改善网站的并发处理能力\" class=\"headerlink\" title=\"4.使用应用服务器集群改善网站的并发处理能力\"></a>4.<strong>使用应用服务器集群改善网站的并发处理能力</strong></h4><p>好了，使用缓存后，数据访问压力得到有效缓解。你再一次保住了自己的饭碗。不过慢慢你又发现由于单一应用服务器能够处理的请求连接有限，处理能力也有限，在网站访问高峰期，应用服务器成为整个网站的瓶颈。于是越来越多的用户会502，会请求超时，甚至应用服务器直接崩溃。</p>\n<p>起初很多网站会采用更换性能更强大的服务器来解决问题，甚至不惜高价购买昂贵的小型机。但是慢慢会发现，不管多么强大的服务器，都满足不了网站持续增长的业务需求。</p>\n<p>这种情况下，更恰当的做法是增加一台服务器以分担原有服务器的访问及存储压力。对网站架构而言，只要能通过增加一台服务器的方式改善负载压力，就可以以同样的方式持续增加服务器不断改善系统性能，从而实现系统的可伸缩性。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%844.png\" alt></p>\n<p>在使用应用服务器集群的同时，可以增加负载均衡调度服务器，可以将来自用户浏览器的访问请求分发到应用服务器集群中的任何一套服务器上，如果有更多的用户就在集群中加入更多的应用服务器，使应用服务器的负载压力不再成为整个网站的瓶颈。</p>\n<h4 id=\"5-数据库读写分离\"><a href=\"#5-数据库读写分离\" class=\"headerlink\" title=\"5.数据库读写分离\"></a>5.<strong>数据库读写分离</strong></h4><p>没错，当你看到标题的时候就知道，令人dan teng的问题就又双叒叕来了。网站在使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作(缓存访问不命中、缓存过期)和全部的写操作需要访问数据库，在网站的用户达到一定的规模后，数据库因为负载压力过高而有成了网站的瓶颈。</p>\n<p>利用数据库主从热备的功能，配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。利用数据库的这一功能，可以实现数据库读写分离，从而改善数据库负载压力。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%845.png\" alt></p>\n<p>应用程序在写数据的时候，访问主数据库，主数据库通过主从复制将数据更新同步到从数据库，这样当应用服务器读数据的时候，就可以通过从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器使用专门的数据访问模块，使数据库读写分离对应用透明。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>其实以上五个阶段已经可以适应市场上大多数网站了。它们的业务决定了他们大都停留在上面某个阶段。那么对于更大的一些互联网站呢，显然以上几个阶段和方案是远远不够，那么它们在演化的道路上又会遇到哪些问题，又是怎么解决的呢？我们下篇文章接着讲吧！</p>\n","encrypt":true},{"title":"Redis对象——Redis对象系统简介","copyright":true,"date":"2019-11-24T06:38:45.000Z","keywords":"Redis","aside":"redis","_content":"### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;之前几篇文章,简单介绍 Redis用到的所有主要数据结构,简单动态字符串(SDS)、双端链表、字典、压缩列表、整数集合、跳跃表。\t\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis并没有直接使用这些数据结构来实现键值对数据库,而是基于这些数据结构创建了一个对象系统,这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象,而每种对象又通过不同的编码映射到不同的底层数据结构。\n\n<!--more-->\n\n### 一、Redis对象类型和编码\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis中的每个对象都由一个redisObject结构表示,该结构中和保存数据有关的三个属性分别是type属性、 encoding属性和ptr属性:\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis使用对象来表示数据库中的键和值,每次当我们在Redis的数据库中新创建一个键值对时,我们至少会创建两个对象,一个对象用作键值对的健(键对象),另一个对象用作键值对的值(值对象)。\n\n```\ntypedef struct redisObiect{\n\t//类型\n\tunsigned type:4;\n\t//编码\n\tunsigned encoding:4;\n\t//指向底层数据结构的指针\n\tvoid *ptr;\n}\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;其中Redis的键对象都是字符串对象，而Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种。其分别对应的内部编码和底层数据结构如下图所示：\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/object/Redis%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B.png)\n\n\n\n### 二、思考一个问题\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis中的对象，大都是通过多种数据结构来实现的，为什么会这样设计呢？用一种固定的数据结构来实现，不是更加简单吗？\n\nRedis这样设计有两个好处：\n\n1. 可以自由改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令，例如Redis3.2提供了quicklist，其结合了ziplist和linkedlist两者\n   的优势，为列表类型提供了一种更为优秀的内部编码实现，而对外部用户来说基本感知不到。 这一点比较像程序设计中的分层架构。\n2. 多种内部编码实现可以在不同场景下发挥各自的优势，从而优化对象在不同场景下的使用效率。例如ziplist比较节省内存，但是在列表元素比较多的情况下，性能会有所下降，这时候Redis会根据配置选项将列表类型的内部实现转换linkedlist。 (后续文章将根据具体对象介绍)\n\n### 本文重点\n\n* Redis基于底层的一些数据结构创建了一个对象系统以供用户使用\n* 这个系统主要包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象\n* Redis的键对象都是字符串对象\n* Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种\n* 为了可以自由改进内部编码，以及在不同场景下发挥其最大优势，Redis中的对象，大都是通过多种数据结构来实现\n\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n\n\n### -----END-----\n\n","source":"_posts/技术实践/redis/Redis对象——Redis对象系统简介.md","raw":"---\ntitle: Redis对象——Redis对象系统简介\ncopyright: true\ndate: 2019-11-24 14:38:45\ntags: \n- Redis\ncategories: Redis\nkeywords: Redis\naside: redis\n---\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;之前几篇文章,简单介绍 Redis用到的所有主要数据结构,简单动态字符串(SDS)、双端链表、字典、压缩列表、整数集合、跳跃表。\t\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis并没有直接使用这些数据结构来实现键值对数据库,而是基于这些数据结构创建了一个对象系统,这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象,而每种对象又通过不同的编码映射到不同的底层数据结构。\n\n<!--more-->\n\n### 一、Redis对象类型和编码\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis中的每个对象都由一个redisObject结构表示,该结构中和保存数据有关的三个属性分别是type属性、 encoding属性和ptr属性:\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis使用对象来表示数据库中的键和值,每次当我们在Redis的数据库中新创建一个键值对时,我们至少会创建两个对象,一个对象用作键值对的健(键对象),另一个对象用作键值对的值(值对象)。\n\n```\ntypedef struct redisObiect{\n\t//类型\n\tunsigned type:4;\n\t//编码\n\tunsigned encoding:4;\n\t//指向底层数据结构的指针\n\tvoid *ptr;\n}\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;其中Redis的键对象都是字符串对象，而Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种。其分别对应的内部编码和底层数据结构如下图所示：\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/object/Redis%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B.png)\n\n\n\n### 二、思考一个问题\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis中的对象，大都是通过多种数据结构来实现的，为什么会这样设计呢？用一种固定的数据结构来实现，不是更加简单吗？\n\nRedis这样设计有两个好处：\n\n1. 可以自由改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令，例如Redis3.2提供了quicklist，其结合了ziplist和linkedlist两者\n   的优势，为列表类型提供了一种更为优秀的内部编码实现，而对外部用户来说基本感知不到。 这一点比较像程序设计中的分层架构。\n2. 多种内部编码实现可以在不同场景下发挥各自的优势，从而优化对象在不同场景下的使用效率。例如ziplist比较节省内存，但是在列表元素比较多的情况下，性能会有所下降，这时候Redis会根据配置选项将列表类型的内部实现转换linkedlist。 (后续文章将根据具体对象介绍)\n\n### 本文重点\n\n* Redis基于底层的一些数据结构创建了一个对象系统以供用户使用\n* 这个系统主要包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象\n* Redis的键对象都是字符串对象\n* Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种\n* 为了可以自由改进内部编码，以及在不同场景下发挥其最大优势，Redis中的对象，大都是通过多种数据结构来实现\n\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n\n\n### -----END-----\n\n","slug":"技术实践/redis/Redis对象——Redis对象系统简介","published":1,"updated":"2021-03-14T03:04:50.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwj007phyjf4klx5fnp","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;之前几篇文章,简单介绍 Redis用到的所有主要数据结构,简单动态字符串(SDS)、双端链表、字典、压缩列表、整数集合、跳跃表。    </p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis并没有直接使用这些数据结构来实现键值对数据库,而是基于这些数据结构创建了一个对象系统,这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象,而每种对象又通过不同的编码映射到不同的底层数据结构。</p>\n<a id=\"more\"></a>\n<h3 id=\"一、Redis对象类型和编码\"><a href=\"#一、Redis对象类型和编码\" class=\"headerlink\" title=\"一、Redis对象类型和编码\"></a>一、Redis对象类型和编码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis中的每个对象都由一个redisObject结构表示,该结构中和保存数据有关的三个属性分别是type属性、 encoding属性和ptr属性:</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis使用对象来表示数据库中的键和值,每次当我们在Redis的数据库中新创建一个键值对时,我们至少会创建两个对象,一个对象用作键值对的健(键对象),另一个对象用作键值对的值(值对象)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct redisObiect&#123;</span><br><span class=\"line\">\t//类型</span><br><span class=\"line\">\tunsigned type:4;</span><br><span class=\"line\">\t//编码</span><br><span class=\"line\">\tunsigned encoding:4;</span><br><span class=\"line\">\t//指向底层数据结构的指针</span><br><span class=\"line\">\tvoid *ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;其中Redis的键对象都是字符串对象，而Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种。其分别对应的内部编码和底层数据结构如下图所示：</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/object/Redis%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B.png\" alt></p>\n<h3 id=\"二、思考一个问题\"><a href=\"#二、思考一个问题\" class=\"headerlink\" title=\"二、思考一个问题\"></a>二、思考一个问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis中的对象，大都是通过多种数据结构来实现的，为什么会这样设计呢？用一种固定的数据结构来实现，不是更加简单吗？</p>\n<p>Redis这样设计有两个好处：</p>\n<ol>\n<li>可以自由改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令，例如Redis3.2提供了quicklist，其结合了ziplist和linkedlist两者<br>的优势，为列表类型提供了一种更为优秀的内部编码实现，而对外部用户来说基本感知不到。 这一点比较像程序设计中的分层架构。</li>\n<li>多种内部编码实现可以在不同场景下发挥各自的优势，从而优化对象在不同场景下的使用效率。例如ziplist比较节省内存，但是在列表元素比较多的情况下，性能会有所下降，这时候Redis会根据配置选项将列表类型的内部实现转换linkedlist。 (后续文章将根据具体对象介绍)</li>\n</ol>\n<h3 id=\"本文重点\"><a href=\"#本文重点\" class=\"headerlink\" title=\"本文重点\"></a>本文重点</h3><ul>\n<li>Redis基于底层的一些数据结构创建了一个对象系统以供用户使用</li>\n<li>这个系统主要包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象</li>\n<li>Redis的键对象都是字符串对象</li>\n<li>Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种</li>\n<li>为了可以自由改进内部编码，以及在不同场景下发挥其最大优势，Redis中的对象，大都是通过多种数据结构来实现</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;之前几篇文章,简单介绍 Redis用到的所有主要数据结构,简单动态字符串(SDS)、双端链表、字典、压缩列表、整数集合、跳跃表。    </p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis并没有直接使用这些数据结构来实现键值对数据库,而是基于这些数据结构创建了一个对象系统,这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象,而每种对象又通过不同的编码映射到不同的底层数据结构。</p>","more":"<h3 id=\"一、Redis对象类型和编码\"><a href=\"#一、Redis对象类型和编码\" class=\"headerlink\" title=\"一、Redis对象类型和编码\"></a>一、Redis对象类型和编码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis中的每个对象都由一个redisObject结构表示,该结构中和保存数据有关的三个属性分别是type属性、 encoding属性和ptr属性:</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis使用对象来表示数据库中的键和值,每次当我们在Redis的数据库中新创建一个键值对时,我们至少会创建两个对象,一个对象用作键值对的健(键对象),另一个对象用作键值对的值(值对象)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct redisObiect&#123;</span><br><span class=\"line\">\t//类型</span><br><span class=\"line\">\tunsigned type:4;</span><br><span class=\"line\">\t//编码</span><br><span class=\"line\">\tunsigned encoding:4;</span><br><span class=\"line\">\t//指向底层数据结构的指针</span><br><span class=\"line\">\tvoid *ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;其中Redis的键对象都是字符串对象，而Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种。其分别对应的内部编码和底层数据结构如下图所示：</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/object/Redis%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B.png\" alt></p>\n<h3 id=\"二、思考一个问题\"><a href=\"#二、思考一个问题\" class=\"headerlink\" title=\"二、思考一个问题\"></a>二、思考一个问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis中的对象，大都是通过多种数据结构来实现的，为什么会这样设计呢？用一种固定的数据结构来实现，不是更加简单吗？</p>\n<p>Redis这样设计有两个好处：</p>\n<ol>\n<li>可以自由改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令，例如Redis3.2提供了quicklist，其结合了ziplist和linkedlist两者<br>的优势，为列表类型提供了一种更为优秀的内部编码实现，而对外部用户来说基本感知不到。 这一点比较像程序设计中的分层架构。</li>\n<li>多种内部编码实现可以在不同场景下发挥各自的优势，从而优化对象在不同场景下的使用效率。例如ziplist比较节省内存，但是在列表元素比较多的情况下，性能会有所下降，这时候Redis会根据配置选项将列表类型的内部实现转换linkedlist。 (后续文章将根据具体对象介绍)</li>\n</ol>\n<h3 id=\"本文重点\"><a href=\"#本文重点\" class=\"headerlink\" title=\"本文重点\"></a>本文重点</h3><ul>\n<li>Redis基于底层的一些数据结构创建了一个对象系统以供用户使用</li>\n<li>这个系统主要包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象</li>\n<li>Redis的键对象都是字符串对象</li>\n<li>Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种</li>\n<li>为了可以自由改进内部编码，以及在不同场景下发挥其最大优势，Redis中的对象，大都是通过多种数据结构来实现</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>"},{"title":"Redis对象——列表(List)","copyright":true,"date":"2020-03-30T02:45:38.000Z","keywords":"Redis,List","aside":"redis","_content":"&nbsp;&nbsp;&nbsp;&nbsp;列表（list）类型是用来存储多个有序的字符串，列表中的每个字符串称为元素(element)，一个列表最多可以存储232-1个元素。在Redis中，可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。\n\n<!--more-->\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/Redis%20List.png)\n\n列表类型有两个特点：\n\n1. 列表中的元素是有序的，这就意味着可以通过索引下标获取某个元素或者某个范围内的元素列表。\n2. 列表中的元素可以是重复的.\n\n### 一、内部实现\n\n在Redis3.2版本以前列表类型的内部编码有两种。\n\n* `ziplist（压缩列表）`：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。\n* `linkedlist（链表）`：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。\n\n而在Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.\n\n关于这三种底层数据结构可以查看我的另外三篇文章\n\n[Redis数据结构——链表](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/)\n\n[Redis数据结构——压缩列表](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/)\n\n[Redis数据结构——quicklist]([https://blog.laoyu.site/2020/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94quicklist/](https://blog.laoyu.site/2020/redis/Redis数据结构——quicklist/))\n\n### 二、常用命令\n\nRedis列表对象常用命令如下表(点击命令可查看命令详细说明)。\n\n\n| 命令 | 说明 | 时间复杂度 |\n| ---- | ---- | ---------- |\n| [BLPOP key [key ...] timeout](http://blog.laoyu.site/2020/redis_command/list/blpop/) | 删除，并获得该列表中的第一元素，或阻塞，直到有一个可用   | O(1)         |\n| [BRPOP key [key ...] timeout](http://blog.laoyu.site/2020/redis_command/list/brpop/) | 删除，并获得该列表中的最后一个元素，或阻塞，直到有一个可用   | O(1)         |\n| [BRPOPLPUSH source destination timeout](http://blog.laoyu.site/2020/redis_command/list/brpoplpush/) | 弹出一个列表的值，将它推到另一个列表，并返回它;或阻塞，直到有一个可用   | O(1)         |\n| [LINDEX key index](http://blog.laoyu.site/2020/redis_command/list/lindex/) | 获取一个元素，通过其索引列表   | O(N) |\n| [LINSERT key BEFORE](http://blog.laoyu.site/2020/redis_command/list/linsert/) |AFTER pivot value在列表中的另一个元素之前或之后插入一个元素 | O(N) |\n| [LLEN key](http://blog.laoyu.site/2020/redis_command/list/llen/) | 获得队列(List)的长度   | O(1)         |\n| [LPOP key](http://blog.laoyu.site/2020/redis_command/list/lpop/) | 从队列的左边出队一个元素   | O(1)         |\n| [LPUSH key value [value ...]](http://blog.laoyu.site/2020/redis_command/list/lpush/) | 从队列的左边入队一个或多个元素   | O(1)         |\n| [LPUSHX key value](http://blog.laoyu.site/2020/redis_command/list/lpushx/) | 当队列存在时，从队到左边入队一个元素   | O(1)         |\n| [LRANGE key start stop](http://blog.laoyu.site/2020/redis_command/list/lrange/) | 从列表中获取指定返回的元素   | O(S+N) |\n| [LREM key count value](http://blog.laoyu.site/2020/redis_command/list/lrem/) | 从列表中删除元素   | O(N)         |\n| [LSET key index value](http://blog.laoyu.site/2020/redis_command/list/lset/) | 设置队列里面一个元素的值   | O(N)         |\n| [LTRIM key start stop](http://blog.laoyu.site/2020/redis_command/list/ltrim/) | 修剪到指定范围内的清单   | O(N)         |\n| [RPOP key](http://blog.laoyu.site/2020/redis_command/list/rpop/) | 从队列的右边出队一个元   | O(1)         |\n| [RPOPLPUSH source destination](http://blog.laoyu.site/2020/redis_command/list/rpoplpush/) | 删除列表中的最后一个元素，将其追加到另一个列表   | O(1)         |\n| [RPUSH key value [value ...]](http://blog.laoyu.site/2020/redis_command/list/rpush/) | 从队列的右边入队一个元素   | O(1)         |\n| [RPUSHX key value](http://blog.laoyu.site/2020/redis_command/list/rpushx/) | 从队列的右边入队一个元素，仅队列存在时有效   | O(1)         |\n### 三、使用场景\n\n#### 3.1 消息队列\n\n列表类型可以使用 rpush 实现先进先出的功能，同时又可以使用 lpop 轻松的弹出（查询并删除）第一个元素，所以列表类型可以用来实现消息队列\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png)\n\n#### 3.2 文章(商品等)列表\n\n我们以博客站点为例，当用户和文章都越来越多时，为了加快程序的响应速度，我们可以把用户自己的文章存入到 List 中，因为 List 是有序的结构，所以这样又可以完美的实现分页功能，从而加速了程序的响应速度。\n\n1. 每篇文章我们使用**哈希**结构存储，例如每篇文章有3个属性title、timestamp、content\n\n   ```c\n   hmset acticle:1 title xx timestamp 1476536196 content xxxx\n   ...\n   hmset acticle:k title yy timestamp 1476512536 content yyyy\n   ...\n   ```\n\n2. 向用户文章列表添加文章，user：{id}：articles作为用户文章列表的键：\n\n   ```c\n   lpush user:1:acticles article:1 article3\n   ...\n   lpush\n   ...\n   ```\n\n3. 分页获取用户文章列表，例如下面伪代码获取用户id=1的前10篇文章\n\n   ```c\n   articles = lrange user:1:articles 0 9\n   for article in {articles}\n   {\n   \thgetall {article}\n   }\n   ```\n\n**注意:**使用列表类型保存和获取文章列表会存在两个问题。\n\n* 如果每次分页获取的文章个数较多，需要执行多次hgetall操作，此时可以考虑使用Pipeline批量获取，或者考虑将文章数据序列化为字符串类型，使用mget批量获取。\n* 分页获取文章列表时，lrange命令在列表两端性能较好，但是如果列表较大，获取列表中间范围的元素性能会变差，此时可以考虑将列表做二级拆分，或者使用Redis3.2的quicklist内部编码实现，它结合ziplist和linkedlist的特点，获取列表中间范围的元素时也可以高效完成。\n\n关于列表的使用场景可参考以下几个命令组合：\n\n* lpush+lpop=Stack（栈）\n* lpush+rpop=Queue（队列）\n* lpush+ltrim=Capped Collection（有限集合）\n* lpush+brpop=Message Queue（消息队列）\n\n### 小结\n\n本篇文章我们总结了Redis 列表对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis列表对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","source":"_posts/技术实践/redis/Redis对象——列表(List).md","raw":"---\ntitle: Redis对象——列表(List)\ncopyright: true\ndate: 2020-03-30 10:45:38\ntags: \n- Redis\ncategories: Redis\nkeywords: Redis,List\naside: redis\n---\n&nbsp;&nbsp;&nbsp;&nbsp;列表（list）类型是用来存储多个有序的字符串，列表中的每个字符串称为元素(element)，一个列表最多可以存储232-1个元素。在Redis中，可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。\n\n<!--more-->\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/Redis%20List.png)\n\n列表类型有两个特点：\n\n1. 列表中的元素是有序的，这就意味着可以通过索引下标获取某个元素或者某个范围内的元素列表。\n2. 列表中的元素可以是重复的.\n\n### 一、内部实现\n\n在Redis3.2版本以前列表类型的内部编码有两种。\n\n* `ziplist（压缩列表）`：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。\n* `linkedlist（链表）`：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。\n\n而在Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.\n\n关于这三种底层数据结构可以查看我的另外三篇文章\n\n[Redis数据结构——链表](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/)\n\n[Redis数据结构——压缩列表](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/)\n\n[Redis数据结构——quicklist]([https://blog.laoyu.site/2020/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94quicklist/](https://blog.laoyu.site/2020/redis/Redis数据结构——quicklist/))\n\n### 二、常用命令\n\nRedis列表对象常用命令如下表(点击命令可查看命令详细说明)。\n\n\n| 命令 | 说明 | 时间复杂度 |\n| ---- | ---- | ---------- |\n| [BLPOP key [key ...] timeout](http://blog.laoyu.site/2020/redis_command/list/blpop/) | 删除，并获得该列表中的第一元素，或阻塞，直到有一个可用   | O(1)         |\n| [BRPOP key [key ...] timeout](http://blog.laoyu.site/2020/redis_command/list/brpop/) | 删除，并获得该列表中的最后一个元素，或阻塞，直到有一个可用   | O(1)         |\n| [BRPOPLPUSH source destination timeout](http://blog.laoyu.site/2020/redis_command/list/brpoplpush/) | 弹出一个列表的值，将它推到另一个列表，并返回它;或阻塞，直到有一个可用   | O(1)         |\n| [LINDEX key index](http://blog.laoyu.site/2020/redis_command/list/lindex/) | 获取一个元素，通过其索引列表   | O(N) |\n| [LINSERT key BEFORE](http://blog.laoyu.site/2020/redis_command/list/linsert/) |AFTER pivot value在列表中的另一个元素之前或之后插入一个元素 | O(N) |\n| [LLEN key](http://blog.laoyu.site/2020/redis_command/list/llen/) | 获得队列(List)的长度   | O(1)         |\n| [LPOP key](http://blog.laoyu.site/2020/redis_command/list/lpop/) | 从队列的左边出队一个元素   | O(1)         |\n| [LPUSH key value [value ...]](http://blog.laoyu.site/2020/redis_command/list/lpush/) | 从队列的左边入队一个或多个元素   | O(1)         |\n| [LPUSHX key value](http://blog.laoyu.site/2020/redis_command/list/lpushx/) | 当队列存在时，从队到左边入队一个元素   | O(1)         |\n| [LRANGE key start stop](http://blog.laoyu.site/2020/redis_command/list/lrange/) | 从列表中获取指定返回的元素   | O(S+N) |\n| [LREM key count value](http://blog.laoyu.site/2020/redis_command/list/lrem/) | 从列表中删除元素   | O(N)         |\n| [LSET key index value](http://blog.laoyu.site/2020/redis_command/list/lset/) | 设置队列里面一个元素的值   | O(N)         |\n| [LTRIM key start stop](http://blog.laoyu.site/2020/redis_command/list/ltrim/) | 修剪到指定范围内的清单   | O(N)         |\n| [RPOP key](http://blog.laoyu.site/2020/redis_command/list/rpop/) | 从队列的右边出队一个元   | O(1)         |\n| [RPOPLPUSH source destination](http://blog.laoyu.site/2020/redis_command/list/rpoplpush/) | 删除列表中的最后一个元素，将其追加到另一个列表   | O(1)         |\n| [RPUSH key value [value ...]](http://blog.laoyu.site/2020/redis_command/list/rpush/) | 从队列的右边入队一个元素   | O(1)         |\n| [RPUSHX key value](http://blog.laoyu.site/2020/redis_command/list/rpushx/) | 从队列的右边入队一个元素，仅队列存在时有效   | O(1)         |\n### 三、使用场景\n\n#### 3.1 消息队列\n\n列表类型可以使用 rpush 实现先进先出的功能，同时又可以使用 lpop 轻松的弹出（查询并删除）第一个元素，所以列表类型可以用来实现消息队列\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png)\n\n#### 3.2 文章(商品等)列表\n\n我们以博客站点为例，当用户和文章都越来越多时，为了加快程序的响应速度，我们可以把用户自己的文章存入到 List 中，因为 List 是有序的结构，所以这样又可以完美的实现分页功能，从而加速了程序的响应速度。\n\n1. 每篇文章我们使用**哈希**结构存储，例如每篇文章有3个属性title、timestamp、content\n\n   ```c\n   hmset acticle:1 title xx timestamp 1476536196 content xxxx\n   ...\n   hmset acticle:k title yy timestamp 1476512536 content yyyy\n   ...\n   ```\n\n2. 向用户文章列表添加文章，user：{id}：articles作为用户文章列表的键：\n\n   ```c\n   lpush user:1:acticles article:1 article3\n   ...\n   lpush\n   ...\n   ```\n\n3. 分页获取用户文章列表，例如下面伪代码获取用户id=1的前10篇文章\n\n   ```c\n   articles = lrange user:1:articles 0 9\n   for article in {articles}\n   {\n   \thgetall {article}\n   }\n   ```\n\n**注意:**使用列表类型保存和获取文章列表会存在两个问题。\n\n* 如果每次分页获取的文章个数较多，需要执行多次hgetall操作，此时可以考虑使用Pipeline批量获取，或者考虑将文章数据序列化为字符串类型，使用mget批量获取。\n* 分页获取文章列表时，lrange命令在列表两端性能较好，但是如果列表较大，获取列表中间范围的元素性能会变差，此时可以考虑将列表做二级拆分，或者使用Redis3.2的quicklist内部编码实现，它结合ziplist和linkedlist的特点，获取列表中间范围的元素时也可以高效完成。\n\n关于列表的使用场景可参考以下几个命令组合：\n\n* lpush+lpop=Stack（栈）\n* lpush+rpop=Queue（队列）\n* lpush+ltrim=Capped Collection（有限集合）\n* lpush+brpop=Message Queue（消息队列）\n\n### 小结\n\n本篇文章我们总结了Redis 列表对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis列表对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","slug":"技术实践/redis/Redis对象——列表(List)","published":1,"updated":"2021-03-14T03:04:50.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwk007rhyjfs0k8myz9","content":"<p>&nbsp;&nbsp;&nbsp;&nbsp;列表（list）类型是用来存储多个有序的字符串，列表中的每个字符串称为元素(element)，一个列表最多可以存储232-1个元素。在Redis中，可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/Redis%20List.png\" alt></p>\n<p>列表类型有两个特点：</p>\n<ol>\n<li>列表中的元素是有序的，这就意味着可以通过索引下标获取某个元素或者某个范围内的元素列表。</li>\n<li>列表中的元素可以是重复的.</li>\n</ol>\n<h3 id=\"一、内部实现\"><a href=\"#一、内部实现\" class=\"headerlink\" title=\"一、内部实现\"></a>一、内部实现</h3><p>在Redis3.2版本以前列表类型的内部编码有两种。</p>\n<ul>\n<li><code>ziplist（压缩列表）</code>：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li>\n<li><code>linkedlist（链表）</code>：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</li>\n</ul>\n<p>而在Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.</p>\n<p>关于这三种底层数据结构可以查看我的另外三篇文章</p>\n<p><a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/\">Redis数据结构——链表</a></p>\n<p><a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">Redis数据结构——压缩列表</a></p>\n<p><a href=\"[https://blog.laoyu.site/2020/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94quicklist/](https://blog.laoyu.site/2020/redis/Redis数据结构——quicklist/\">Redis数据结构——quicklist</a>)</p>\n<h3 id=\"二、常用命令\"><a href=\"#二、常用命令\" class=\"headerlink\" title=\"二、常用命令\"></a>二、常用命令</h3><p>Redis列表对象常用命令如下表(点击命令可查看命令详细说明)。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/blpop/\">BLPOP key [key …] timeout</a></td>\n<td>删除，并获得该列表中的第一元素，或阻塞，直到有一个可用</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/brpop/\">BRPOP key [key …] timeout</a></td>\n<td>删除，并获得该列表中的最后一个元素，或阻塞，直到有一个可用</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/brpoplpush/\">BRPOPLPUSH source destination timeout</a></td>\n<td>弹出一个列表的值，将它推到另一个列表，并返回它;或阻塞，直到有一个可用</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lindex/\">LINDEX key index</a></td>\n<td>获取一个元素，通过其索引列表</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/linsert/\">LINSERT key BEFORE</a></td>\n<td>AFTER pivot value在列表中的另一个元素之前或之后插入一个元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/llen/\">LLEN key</a></td>\n<td>获得队列(List)的长度</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lpop/\">LPOP key</a></td>\n<td>从队列的左边出队一个元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lpush/\">LPUSH key value [value …]</a></td>\n<td>从队列的左边入队一个或多个元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lpushx/\">LPUSHX key value</a></td>\n<td>当队列存在时，从队到左边入队一个元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lrange/\">LRANGE key start stop</a></td>\n<td>从列表中获取指定返回的元素</td>\n<td>O(S+N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lrem/\">LREM key count value</a></td>\n<td>从列表中删除元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lset/\">LSET key index value</a></td>\n<td>设置队列里面一个元素的值</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/ltrim/\">LTRIM key start stop</a></td>\n<td>修剪到指定范围内的清单</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/rpop/\">RPOP key</a></td>\n<td>从队列的右边出队一个元</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/rpoplpush/\">RPOPLPUSH source destination</a></td>\n<td>删除列表中的最后一个元素，将其追加到另一个列表</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/rpush/\">RPUSH key value [value …]</a></td>\n<td>从队列的右边入队一个元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/rpushx/\">RPUSHX key value</a></td>\n<td>从队列的右边入队一个元素，仅队列存在时有效</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"三、使用场景\"><a href=\"#三、使用场景\" class=\"headerlink\" title=\"三、使用场景\"></a>三、使用场景</h3><h4 id=\"3-1-消息队列\"><a href=\"#3-1-消息队列\" class=\"headerlink\" title=\"3.1 消息队列\"></a>3.1 消息队列</h4><p>列表类型可以使用 rpush 实现先进先出的功能，同时又可以使用 lpop 轻松的弹出（查询并删除）第一个元素，所以列表类型可以用来实现消息队列</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png\" alt></p>\n<h4 id=\"3-2-文章-商品等-列表\"><a href=\"#3-2-文章-商品等-列表\" class=\"headerlink\" title=\"3.2 文章(商品等)列表\"></a>3.2 文章(商品等)列表</h4><p>我们以博客站点为例，当用户和文章都越来越多时，为了加快程序的响应速度，我们可以把用户自己的文章存入到 List 中，因为 List 是有序的结构，所以这样又可以完美的实现分页功能，从而加速了程序的响应速度。</p>\n<ol>\n<li><p>每篇文章我们使用<strong>哈希</strong>结构存储，例如每篇文章有3个属性title、timestamp、content</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hmset acticle:<span class=\"number\">1</span> title xx timestamp <span class=\"number\">1476536196</span> content xxxx</span><br><span class=\"line\">...</span><br><span class=\"line\">hmset acticle:k title yy timestamp <span class=\"number\">1476512536</span> content yyyy</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>向用户文章列表添加文章，user：{id}：articles作为用户文章列表的键：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lpush user:<span class=\"number\">1</span>:acticles article:<span class=\"number\">1</span> article3</span><br><span class=\"line\">...</span><br><span class=\"line\">lpush</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>分页获取用户文章列表，例如下面伪代码获取用户id=1的前10篇文章</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">articles = lrange user:<span class=\"number\">1</span>:articles <span class=\"number\">0</span> <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> article in &#123;articles&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\thgetall &#123;article&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>注意:</strong>使用列表类型保存和获取文章列表会存在两个问题。</p>\n<ul>\n<li>如果每次分页获取的文章个数较多，需要执行多次hgetall操作，此时可以考虑使用Pipeline批量获取，或者考虑将文章数据序列化为字符串类型，使用mget批量获取。</li>\n<li>分页获取文章列表时，lrange命令在列表两端性能较好，但是如果列表较大，获取列表中间范围的元素性能会变差，此时可以考虑将列表做二级拆分，或者使用Redis3.2的quicklist内部编码实现，它结合ziplist和linkedlist的特点，获取列表中间范围的元素时也可以高效完成。</li>\n</ul>\n<p>关于列表的使用场景可参考以下几个命令组合：</p>\n<ul>\n<li>lpush+lpop=Stack（栈）</li>\n<li>lpush+rpop=Queue（队列）</li>\n<li>lpush+ltrim=Capped Collection（有限集合）</li>\n<li>lpush+brpop=Message Queue（消息队列）</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本篇文章我们总结了Redis 列表对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis列表对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;&nbsp;&nbsp;列表（list）类型是用来存储多个有序的字符串，列表中的每个字符串称为元素(element)，一个列表最多可以存储232-1个元素。在Redis中，可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。</p>","more":"<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/Redis%20List.png\" alt></p>\n<p>列表类型有两个特点：</p>\n<ol>\n<li>列表中的元素是有序的，这就意味着可以通过索引下标获取某个元素或者某个范围内的元素列表。</li>\n<li>列表中的元素可以是重复的.</li>\n</ol>\n<h3 id=\"一、内部实现\"><a href=\"#一、内部实现\" class=\"headerlink\" title=\"一、内部实现\"></a>一、内部实现</h3><p>在Redis3.2版本以前列表类型的内部编码有两种。</p>\n<ul>\n<li><code>ziplist（压缩列表）</code>：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li>\n<li><code>linkedlist（链表）</code>：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</li>\n</ul>\n<p>而在Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.</p>\n<p>关于这三种底层数据结构可以查看我的另外三篇文章</p>\n<p><a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/\">Redis数据结构——链表</a></p>\n<p><a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">Redis数据结构——压缩列表</a></p>\n<p><a href=\"[https://blog.laoyu.site/2020/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94quicklist/](https://blog.laoyu.site/2020/redis/Redis数据结构——quicklist/\">Redis数据结构——quicklist</a>)</p>\n<h3 id=\"二、常用命令\"><a href=\"#二、常用命令\" class=\"headerlink\" title=\"二、常用命令\"></a>二、常用命令</h3><p>Redis列表对象常用命令如下表(点击命令可查看命令详细说明)。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/blpop/\">BLPOP key [key …] timeout</a></td>\n<td>删除，并获得该列表中的第一元素，或阻塞，直到有一个可用</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/brpop/\">BRPOP key [key …] timeout</a></td>\n<td>删除，并获得该列表中的最后一个元素，或阻塞，直到有一个可用</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/brpoplpush/\">BRPOPLPUSH source destination timeout</a></td>\n<td>弹出一个列表的值，将它推到另一个列表，并返回它;或阻塞，直到有一个可用</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lindex/\">LINDEX key index</a></td>\n<td>获取一个元素，通过其索引列表</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/linsert/\">LINSERT key BEFORE</a></td>\n<td>AFTER pivot value在列表中的另一个元素之前或之后插入一个元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/llen/\">LLEN key</a></td>\n<td>获得队列(List)的长度</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lpop/\">LPOP key</a></td>\n<td>从队列的左边出队一个元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lpush/\">LPUSH key value [value …]</a></td>\n<td>从队列的左边入队一个或多个元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lpushx/\">LPUSHX key value</a></td>\n<td>当队列存在时，从队到左边入队一个元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lrange/\">LRANGE key start stop</a></td>\n<td>从列表中获取指定返回的元素</td>\n<td>O(S+N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lrem/\">LREM key count value</a></td>\n<td>从列表中删除元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/lset/\">LSET key index value</a></td>\n<td>设置队列里面一个元素的值</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/ltrim/\">LTRIM key start stop</a></td>\n<td>修剪到指定范围内的清单</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/rpop/\">RPOP key</a></td>\n<td>从队列的右边出队一个元</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/rpoplpush/\">RPOPLPUSH source destination</a></td>\n<td>删除列表中的最后一个元素，将其追加到另一个列表</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/rpush/\">RPUSH key value [value …]</a></td>\n<td>从队列的右边入队一个元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/list/rpushx/\">RPUSHX key value</a></td>\n<td>从队列的右边入队一个元素，仅队列存在时有效</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"三、使用场景\"><a href=\"#三、使用场景\" class=\"headerlink\" title=\"三、使用场景\"></a>三、使用场景</h3><h4 id=\"3-1-消息队列\"><a href=\"#3-1-消息队列\" class=\"headerlink\" title=\"3.1 消息队列\"></a>3.1 消息队列</h4><p>列表类型可以使用 rpush 实现先进先出的功能，同时又可以使用 lpop 轻松的弹出（查询并删除）第一个元素，所以列表类型可以用来实现消息队列</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png\" alt></p>\n<h4 id=\"3-2-文章-商品等-列表\"><a href=\"#3-2-文章-商品等-列表\" class=\"headerlink\" title=\"3.2 文章(商品等)列表\"></a>3.2 文章(商品等)列表</h4><p>我们以博客站点为例，当用户和文章都越来越多时，为了加快程序的响应速度，我们可以把用户自己的文章存入到 List 中，因为 List 是有序的结构，所以这样又可以完美的实现分页功能，从而加速了程序的响应速度。</p>\n<ol>\n<li><p>每篇文章我们使用<strong>哈希</strong>结构存储，例如每篇文章有3个属性title、timestamp、content</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hmset acticle:<span class=\"number\">1</span> title xx timestamp <span class=\"number\">1476536196</span> content xxxx</span><br><span class=\"line\">...</span><br><span class=\"line\">hmset acticle:k title yy timestamp <span class=\"number\">1476512536</span> content yyyy</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>向用户文章列表添加文章，user：{id}：articles作为用户文章列表的键：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lpush user:<span class=\"number\">1</span>:acticles article:<span class=\"number\">1</span> article3</span><br><span class=\"line\">...</span><br><span class=\"line\">lpush</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>分页获取用户文章列表，例如下面伪代码获取用户id=1的前10篇文章</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">articles = lrange user:<span class=\"number\">1</span>:articles <span class=\"number\">0</span> <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> article in &#123;articles&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\thgetall &#123;article&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>注意:</strong>使用列表类型保存和获取文章列表会存在两个问题。</p>\n<ul>\n<li>如果每次分页获取的文章个数较多，需要执行多次hgetall操作，此时可以考虑使用Pipeline批量获取，或者考虑将文章数据序列化为字符串类型，使用mget批量获取。</li>\n<li>分页获取文章列表时，lrange命令在列表两端性能较好，但是如果列表较大，获取列表中间范围的元素性能会变差，此时可以考虑将列表做二级拆分，或者使用Redis3.2的quicklist内部编码实现，它结合ziplist和linkedlist的特点，获取列表中间范围的元素时也可以高效完成。</li>\n</ul>\n<p>关于列表的使用场景可参考以下几个命令组合：</p>\n<ul>\n<li>lpush+lpop=Stack（栈）</li>\n<li>lpush+rpop=Queue（队列）</li>\n<li>lpush+ltrim=Capped Collection（有限集合）</li>\n<li>lpush+brpop=Message Queue（消息队列）</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本篇文章我们总结了Redis 列表对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis列表对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>"},{"title":"Redis持久化——如何选择合适的持久化方式","copyright":true,"date":"2021-04-03T02:45:38.000Z","keywords":"Redis,持久化","aside":"redis","password":"1234qwer","_content":"\n我们知道`Redis`是基于内存的数据库，而所有基于内存的数据库，都有一个最大的问题，就是宕机数据丢失问题。持久化是`Redis `所提供的重要功能特性之一，它可以尽可能的保障宕机之后我们的数据能够不丢失，并且可以很快的进行恢复。\n\n之前两篇文章学习了`Redis`主要的两种持久化方式 内存快照(`RDB`)与`AOF`日志，但在真正业务使用中，对于如何选择合适的持久化方式，很多人却会犯了难。\n\n<!--more-->\n\n我们先来简单回顾一下两种持久化方式，并分析一下他们的优缺点。\n\n### 1 `RDB`持久化\n\n`RDB`持久化就是每隔一段时间把内存中的数据全量记录下来。`RDB`持久化并不能频繁的进行，因为`RDB`文件生成的过程虽然是由`fork`出来的子进程完成的，但是`fork`本身是有性能的开销的。\n\n\n#### `RDB`的优点:\n\n* 体积更小：相同的数据量`RDB`文件数据比`AOF`的小，因为`RDB`是紧凑型文件\n\n* 恢复更快：因为`RDB`是数据的快照，基本上就是数据的复制，不用重新读取再写入内存。\n\n* 性能更高:   父进程在保存`RDB`时候只需要`fork`一个子进程来干活，无需父进程，保证了`Redis`正常处理读写命令的性能。\n\n#### `RDB`的缺点：\n\n* 故障丢失：因为`RDB`是全量的，又不能频繁的执行`RDB`文件，因此越大的时间间隔数据丢失的也就越多\n\n* 耐久性差：相对`AOF`的异步策略来说，因为`RDB`的复制是全量的，即使是`fork`的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，`fork`的时间也会延长，导致`CPU`吃紧，耐久性相对较差。\n* 兼容性差：由于`Redis`更新换代的过程中`RDB`文件的格式一直在变化，老的版本`Redis` 可能无法恢复新版本的`RDB`文件。\n\n### 2 `AOF`持久化\n\n`AOF`持久化是通过保存`Redis`服务器所执行的写命令来记录数据库状态的。即`Redis`每执行一个命令的同时都会写入`AOF`缓冲区一份，并且可以通过设置回写策略来同步到磁盘文件，当文件过大时，会`fork`出一个子进程进行`AOF`重写操作。\n\n#### `AOF`的优点：\n\n* 数据保证：我们可以根据需要设置合适的回写策略，来保障数据尽可能少的丢失\n* 易于解析：相对于`RDB`文件，`AOF`文件更易于理解和解析，且没有兼容性问题。\n\n#### `AOF`的缺点:\n\n* 性能相对较差：它的操作模式决定了它会对`redis`的性能有所损耗\n\n* 体积相对更大：尽管是将`aof`文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。\n\n* 恢复速度较慢：由于恢复的时候要逐条解析命令并写入，相对于`RDB`文件的恢复比较慢。\n\n\n\n我们可以用一张表格来更清晰的对比一下两种持久化方式的优缺点\n\n| 持久化方式 | 对`Redis`性能的影响 | 文件大小 | 故障恢复速度 | 数据丢失 |\n| ---------- | ------------------- | -------- | ------------ | -------- |\n| `RDB`      | 小                  | 小       | 快           | 多       |\n| `AOF`      | 大                  | 大       | 慢           | 少       |\n\n### 3 混合持久化\n\n鱼我所欲也，熊掌亦我所欲也！如果我们既想要一个好的性能，又要尽量避免数据的丢失应该怎么办? 在`Redis` 4.0之后提供了混合持久化的方式，顾名思义就是把`RDB`持久化和`AOF`持久化结合起来的一种方式。\n\n混合持久化就是快照以一定的频率执行，而在两次快照之间，使用 `AOF` 日志记录这期间的所有命令操作。\n\n![Redis混合持久化](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/Redis%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96.png)\n\n如图所示，在第一次执行快照之后，将后续命令写入`AOF`文件，直到第二次执行快照。而在第二次执行快照的时候会清除`AOF`文件的内容，循环往复。\n\n这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，`AOF` 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作，也就不会出现文件过大的情况，同时可以避免`AOF`重写的开销。\n\n但世界上并没有完全两全其美的事情，即使鱼和熊掌兼得，一起吃的时候也容易串了味儿。`RDB`混合持久化固然兼顾了性能与数据完整性，但也有其缺点。\n\n* 兼顾了性能与数据的同时也牺牲了部分性能\n* `AOF` 文件中添加了` RDB` 格式的内容，使可读性变差，并且由于混合了`RDB`的内容，与`RDB`文件相同具有兼容性的问题\n\n那么，在真正使用的过程中，我们到底应该如何选择合适的持久化方式呢？\n\n### 4 如何选择合适的持久化方式\n\n技术决策不同于“今天中午吃什么”，可以拍脑袋或者抛硬币来决定。我们应该综合考虑很多因素，其中最重要的一点就是“平衡、取舍”的问题，因为没有最好的技术方案，只有适合的方案，在你想要得到一些东西的时候，必然要失去一些东西。\n\n下面几点可以在我们选择的时候提供一些帮助。\n\n* 如果你的业务场景需要很高的性能，或者宕机之后能够尽快的恢复，而对数据完整性的要求不是那么高，那么可以采用`RDB`持久化的方式。\n* 如果你的业务场景对数据完整性的要求很高，那么可以采用`AOF`的持久化方式，而至于采用那种回写策略，则取决于你对数据完整性的要求程度。\n* 如果你的业务场景既要兼顾性能，又注重数据完整性，那么可以采用混合持久化的方式。\n* 如果你对数据丢失无所谓，追求性能最大化的情况下，甚至可以禁用持久化。\n\n","source":"_posts/技术实践/redis/Redis持久化——如何选择合适的持久化方式.md","raw":"---\ntitle: Redis持久化——如何选择合适的持久化方式\ncopyright: true\ndate: 2021-04-03 10:45:38\ntags: \n- Redis\ncategories: Redis\nkeywords: Redis,持久化\naside: redis\npassword: 1234qwer\n---\n\n我们知道`Redis`是基于内存的数据库，而所有基于内存的数据库，都有一个最大的问题，就是宕机数据丢失问题。持久化是`Redis `所提供的重要功能特性之一，它可以尽可能的保障宕机之后我们的数据能够不丢失，并且可以很快的进行恢复。\n\n之前两篇文章学习了`Redis`主要的两种持久化方式 内存快照(`RDB`)与`AOF`日志，但在真正业务使用中，对于如何选择合适的持久化方式，很多人却会犯了难。\n\n<!--more-->\n\n我们先来简单回顾一下两种持久化方式，并分析一下他们的优缺点。\n\n### 1 `RDB`持久化\n\n`RDB`持久化就是每隔一段时间把内存中的数据全量记录下来。`RDB`持久化并不能频繁的进行，因为`RDB`文件生成的过程虽然是由`fork`出来的子进程完成的，但是`fork`本身是有性能的开销的。\n\n\n#### `RDB`的优点:\n\n* 体积更小：相同的数据量`RDB`文件数据比`AOF`的小，因为`RDB`是紧凑型文件\n\n* 恢复更快：因为`RDB`是数据的快照，基本上就是数据的复制，不用重新读取再写入内存。\n\n* 性能更高:   父进程在保存`RDB`时候只需要`fork`一个子进程来干活，无需父进程，保证了`Redis`正常处理读写命令的性能。\n\n#### `RDB`的缺点：\n\n* 故障丢失：因为`RDB`是全量的，又不能频繁的执行`RDB`文件，因此越大的时间间隔数据丢失的也就越多\n\n* 耐久性差：相对`AOF`的异步策略来说，因为`RDB`的复制是全量的，即使是`fork`的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，`fork`的时间也会延长，导致`CPU`吃紧，耐久性相对较差。\n* 兼容性差：由于`Redis`更新换代的过程中`RDB`文件的格式一直在变化，老的版本`Redis` 可能无法恢复新版本的`RDB`文件。\n\n### 2 `AOF`持久化\n\n`AOF`持久化是通过保存`Redis`服务器所执行的写命令来记录数据库状态的。即`Redis`每执行一个命令的同时都会写入`AOF`缓冲区一份，并且可以通过设置回写策略来同步到磁盘文件，当文件过大时，会`fork`出一个子进程进行`AOF`重写操作。\n\n#### `AOF`的优点：\n\n* 数据保证：我们可以根据需要设置合适的回写策略，来保障数据尽可能少的丢失\n* 易于解析：相对于`RDB`文件，`AOF`文件更易于理解和解析，且没有兼容性问题。\n\n#### `AOF`的缺点:\n\n* 性能相对较差：它的操作模式决定了它会对`redis`的性能有所损耗\n\n* 体积相对更大：尽管是将`aof`文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。\n\n* 恢复速度较慢：由于恢复的时候要逐条解析命令并写入，相对于`RDB`文件的恢复比较慢。\n\n\n\n我们可以用一张表格来更清晰的对比一下两种持久化方式的优缺点\n\n| 持久化方式 | 对`Redis`性能的影响 | 文件大小 | 故障恢复速度 | 数据丢失 |\n| ---------- | ------------------- | -------- | ------------ | -------- |\n| `RDB`      | 小                  | 小       | 快           | 多       |\n| `AOF`      | 大                  | 大       | 慢           | 少       |\n\n### 3 混合持久化\n\n鱼我所欲也，熊掌亦我所欲也！如果我们既想要一个好的性能，又要尽量避免数据的丢失应该怎么办? 在`Redis` 4.0之后提供了混合持久化的方式，顾名思义就是把`RDB`持久化和`AOF`持久化结合起来的一种方式。\n\n混合持久化就是快照以一定的频率执行，而在两次快照之间，使用 `AOF` 日志记录这期间的所有命令操作。\n\n![Redis混合持久化](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/Redis%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96.png)\n\n如图所示，在第一次执行快照之后，将后续命令写入`AOF`文件，直到第二次执行快照。而在第二次执行快照的时候会清除`AOF`文件的内容，循环往复。\n\n这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，`AOF` 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作，也就不会出现文件过大的情况，同时可以避免`AOF`重写的开销。\n\n但世界上并没有完全两全其美的事情，即使鱼和熊掌兼得，一起吃的时候也容易串了味儿。`RDB`混合持久化固然兼顾了性能与数据完整性，但也有其缺点。\n\n* 兼顾了性能与数据的同时也牺牲了部分性能\n* `AOF` 文件中添加了` RDB` 格式的内容，使可读性变差，并且由于混合了`RDB`的内容，与`RDB`文件相同具有兼容性的问题\n\n那么，在真正使用的过程中，我们到底应该如何选择合适的持久化方式呢？\n\n### 4 如何选择合适的持久化方式\n\n技术决策不同于“今天中午吃什么”，可以拍脑袋或者抛硬币来决定。我们应该综合考虑很多因素，其中最重要的一点就是“平衡、取舍”的问题，因为没有最好的技术方案，只有适合的方案，在你想要得到一些东西的时候，必然要失去一些东西。\n\n下面几点可以在我们选择的时候提供一些帮助。\n\n* 如果你的业务场景需要很高的性能，或者宕机之后能够尽快的恢复，而对数据完整性的要求不是那么高，那么可以采用`RDB`持久化的方式。\n* 如果你的业务场景对数据完整性的要求很高，那么可以采用`AOF`的持久化方式，而至于采用那种回写策略，则取决于你对数据完整性的要求程度。\n* 如果你的业务场景既要兼顾性能，又注重数据完整性，那么可以采用混合持久化的方式。\n* 如果你对数据丢失无所谓，追求性能最大化的情况下，甚至可以禁用持久化。\n\n","slug":"技术实践/redis/Redis持久化——如何选择合适的持久化方式","published":1,"updated":"2021-04-03T12:47:04.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwl007uhyjf5k70ypib","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以扫描下方二维码，关注公众号，回复“密码”，即可解锁本站所有文章。</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"9420d685454b6ebeb0bb24e3077197e35149f047fd3739ee5059b76bc9366cfb\">65b38762c41a7759ce3850fafc9a012addde412f2bdecaed75b23bb4db92e07993a82ca74675d95d1bdb33b410c3c2af8bee89be0e795db1534b17994ed961b4eb07ef790a6aa3b2cc5b332ca6214091631b7a521b21a793c139e1dc5170232e1fac1e2249c76bdf2d95a97b91e93c1887b6ea1d26933e57159086634e1bf0d81fdd55261d606802a3d4c90fe61b036eb1d628435a99e583a3f148e3f480b7dcecac62846e0e42731a7ce9518363ad8b5299456517975f0e97b7c262871da85a082cc39e5e549b1299489defaf946b015cb93fb6b0f406a89173e9975242952b15a1105b28d55c91f41994ab064f7dd7ebaba7a781a1530954ef3e3cd8d52bc3c60d3d2ca5018b6a2895e8bc9d6eea0048846f8c05c5489e3d5dbbf52eac3298ed15c7760eeeed198a259541a6c2f25e2170c908b2e15089e54b3b72571e7509a723b9b6135579c2fc682b1cf280ac4ffbfa7eeccff9c3d627bbb20dea8996977e33b19957f6bb1f521c63fc61ef0cb684fc1de90a5551464d78da1c29125e59f15894a63643513dc9073572e8f7ad5ab9a3aab05b63ac2daeeacbabc1b3346eefb84259d36238189902acc2e8d32e6455c65a63bd6965a8d8abe42a53ae9456964d17de3eb9211f11c8ac76e39ddb3435369b4d4f3988656f05860d2385462105b9c45e55050fd265c4591f42ae15e00935c17395e33f555364453fcfe23970d566ce3f7489235b46f5f1b1a24dafdb69b0ba76f9f91065ca5058ea18961a8cfb4722d67039e68f3ef3d10d57abee48657f12ff758446954b5a111f5a683f09de33cb756b423031d40acca17ec0fbdbff33f980143f915ece03cf1dd3d540576c7905821a8279dee7476e9ad094fea930b14155bb05246d6e403343bd05d8661a2ae2cb018308a7abab8ba1f495de0a532e99e85052958456c43e18fe4ae4a8b9712b8f37edfc54579e9e4b0772854313ac552f9c7491b13fbd378da7086bea4874652fad2b38b0ef7a929efb2811932eaf6d9f2cf7f0729354b44a0df9a09bd983c3bd0efc0f5428229e1ede3ae574d42b228faea11d1a98241bd5b82ed803cbb5188996e1007a7091f087ac31ee587b546e42495cc29996f149e6f482fd7cb320b49db59be9f2a33aa2e6b0bdf49afbf1e7b26349173545519f70a6e82bdec8c56d9d76e61cfcc4d5ac5c3997220f8d97e2b71d6dc976bf32a7bfdfcd6575c9abd522446aa8338d32f855b58c361dbd2696e9e734f3e428eba76b516acb4bc1b3b3a97407daf8d16bb7e3030f4a46eb2462ed96f90fe1a99872c3cb9d4ea0d688462b85977d0c70375f95d9ecdf8a2d806f4582d4e02e4963403d3f4d93ef3e787a99ccb9c533a20137d58e07065d867c4b2972e39163a52f49e8ea82a873b6a1304970ac5aeba13f5843bef446427c86b1f392bdebbbc1de5480f57cd7d055791809cd47534ff3b1b6a40e616d7c4e8ae320f4a0b5b815689d067d64f7c0013adb7421612416bcbecab94abdf843d165037b925aa4e80eb0cab4971f86a382d0d8dcf0c504e2e51d0213a0e7c7eb795bdbb5df6f92e493ab0c4a7458ec6117ea38ae0920ae89bbfba6b7736fcfa1613fd1a0715fb6a872c11d55826ed509181e4c6eb8953ae0913016f123bf111f48c0872f8b8baf1e7a9261e068c28ee01ebafc7f599879f4bfef9a901eb87c1becde209c26f0fe7f2865e1335cf5460966af7c8b34db01054ac15e591ecebfce3495dab6b44103f1c5ba86770b442eb5fd2b74fea515f68023347beb1a41fb9f99ff683cd925b43bbce67c921f061ce381a91cacff0cc7f038de71372e92652a4b1aa39264e35bd1d0b3536b839608beb8b92fc2ca22086ba26d11bc12156423a7557fd3f818c812a077887d5c1b18b33b82afce8deddf43ab786883acf5ef24f38299f3041bca069f63ecb3ae17795fe137efe6a07a12a30f7b0e977543a23335ca212e79dbf1a47eb91b5e0bf8d2f14f18b35d60b57f3bc78c88a1d3f1eab80bb8c9dbd4a64f00b98ee0f9914904cc69fb33dea6116e4544170e837bdb400bffe3f2eec3350d2db2776360dd5c77fb7292363c2993ebb19303508c80e7ded69fd29b1debf3d5644f96ce4be383a983ef78056d13377bd5169f434a2ff83b3140c3e8877fa3761d1a59ed94bc353752ef875938abac2d6d88523a8e3c26bc62852482e77aad1c196c1f6d1a0e355bec66d78292589e0be0633ed5c7a049efc79a9d0632c05fb2aef20ee376dbfa9a4200ae93d3cef4dadc969170a1d66a2f7df02939dee4a6025e91498a1e1e2ee6be30b4eedff6fe56480365c97c9040caa327d626d09a4459fc494d593299b3c9542d01791aacc066269a755a1105fdffdcec46ff50799e85a3de687e3abf5b5f523ed59abdcffcd5f32a766322362de9972ffad185efdced2d40c1fd442920bceb96d572afbd9593266d138b0e73c9d5d9ed11379a10c735f958f7fcc4d42532b32ad0f06cc63278b0d97a787e8639679ce6c38338962e791347c3ae4eec65a1b55d022064eef0bf2361cd3f5f3561910bfa15c6702a0a0be717766736265b6a2c0a6020b39a95cb371c645f682fefe0dfe669c1c9aef52aa33e2960e45b2359f8944033b55676b7f857e6f7a9870c3527e7a494b2dcbc872f84f7253e8e909657eb0e491b0e0f17147809e9be06590ea0b9b28ee68895841e2640955b5537a6b00a4622743084770cbd264664457a0bb01a9bf2c531c653a364b5e14035213ecda199a80e932d4898500644c8fd8ab691760c02dc9af396b782abe9ee63191ee15ea3aa076c9c6cb02127ebe4ec9c181fe603224d2545689927e56e327b9dd0bbce5ac3f4185cc3e558c584ca3f82787b9e107bd22d2024f96d5093081fbe1adb9aebd1ada48c40a7fe7bdd6c58a913423ff2022b118299c4db870c6aa09bd20d77c9c736cac557c58ac507d5ae26a8e24c8f989075043b5051aa156414a50e6dd843784eea93ab5f08f33e0917c90c3cedbec16518ecbc83fefd14e3c35cb4dcd9ddcf0cbe661e69f06f9bc9c41143aa2cbfd9cf6aaee6b0827b3940153be434a86c9483a196fac28a239a05b1f0c06f2adb09496b42ba37b47634381cb004b38cfea16cdcd7327c57cee5d4289603745a36c9dc379893b7103439c35084985600590cf1b875e5bd893ae61ef9f064f346cea8095aab728ff35c24eae53889db73cf5f796dfdc2304246f6684c27024dbe28d63a03e6423763d87fedc39fcbfe97da29776e735b81ffe83d1d80e09dc8283921d0bbf3365a1668c3cb06fe7e56687bc78b6d58d7360ebaa4fa0a90fdf7926136b52866239a08ba0817f7bc1aeffb5cc5101473b22f7da3c732110c5d45f57c7ab47ac709d2bc539ac641ae82d32fea03957186ad4c951a2a9f387554ad578af4fbd304421765bdbedc773428a5268ba559d2408a83b13e5e3c1ffe74f881c45a0a486061662a2e6e4362b46d8ceee25d47bd83255d3de2df34d4f72ab9778e17fe3f4f2f085634e587ec7a621e5e3936ea0b20c92e177cc7a1b67a809b6e06482a9a1fa06c2ac4696b8d292ccb62e243255758a1ea51049e98cddcfa325e0ecb7dc8dea09f49626c0f1a39a89e85db35f18ee679fa95cc40436735d50e8ac1a05a2f39ac5d157211c956327f674836b499b925819d4636da5679cf6e52b2b567e7649dbcffe77fea7047b54623e7196e29efcb92f991ce8c34b72052095336bbb57f790ceb58dbad3cba6b68d78ab8b64ed37c0e3ad5e7bf9dc3c2d72e21e940c42f2009f2f9928f8b49d02e5289d75807c3c01b04026a403367388fe6070a59ec3586581bc405c72c1fdc161c7a74a652ff300171b9ee500116392b733936afd4dac3dbca43e851f365d4fd6c6fffe62a6ea826c04ad8e6e26851fa56bdfae4cad5791a6ee5019b1442bdfe3752b10a408b55d9fde9e7646db61bec581f4d36761b4c21e2551b327bec52d4bab63dd7a44f5542a08e5f1371a630e00e58588b20b54589c817410887db5d934483c56fa9b55d578302af4f80a582882c40af3aa5872420ecc79c9bf4959e6e02402c8467526e1b5f4560d218f7fafe09d7047fd8eee7ca45691e147878ec849fbe46ff5b2b3ce7682e7950fb90b264da3674bf30f34dd9271d2b184d83ce910ff43c4d1e21cfb62a132be0f4fb90417a102b47da96d81918fcd50131e00e102e1e48836e60eb204082eab3c42f3f604a133ca803c2c56e9f997a4f2c33671257b18d30038ee67371e18c6eff0282aa781daed5894907a9c2d366e624a16690189d23d87d328b0a13c2854d781586d131fe98894464823f980c7396debab602d18c025e0f809e0f2b3a80944853e9b2faad9879ce44c428060b0db11371d6f125d7a9ab8675cd2b62fa041edfb5c465ec6d793275b5b0469b4b903667e44c5e0ee387cfd893a6acb65c0bb85a1036c81abcb6018d071fcb72a4e3070c4d19b780f06aff44d1c6e94b83d6d6855d30e9368fe0f224e0d2d6e46b04f9f42ce62c2b375a2342819b8efb4795851c43da15380844dc6ba066890f49c9384358025bd1eaa6c1c6ab1ce260019d6d6395d177f192871bf2006ece754afe0c106afe26ff965e1e8235203f094923fbea8b40baba3e38fa6a081d68e13e299d11aa825842e757f554ccc0e2ff2f598a5738f39cf367c529f355977fa07852f50659176579479525c858cc30241edec48373bd74b88d269c7417df47ab5612f3fee779ef69caeb0dc558e5ee5b7c495df87ea0d8adb2a820cfe8a2d77055732f4727256043786c1f983c4895ab27a34aaec7f44429d154c5b49d5b48bc3760476d754b7da93c0dd3ac25f00b6db3d1192bd9de16fb5685642310546988753218b2712065c3a179c007937f5b5d5ed011d8be91ec45884d6ae8f24a79bea17f8de3d91b3b62440777383b6ab28e0c82bf5b340660e4cd282c87ad676d546429c3875c708764cfe829c348409581932e5f7f7de66137c382d346249338c3dc66753616ccc204fefc6ed12ac0d18a4a08738c9ded4c8de4e81ebd84d9fb1db2b9f115ffe1e0c736e12baf8a4420c16039d0b2833ec93481280050b9b397f49777991afb6e39539ce04de87963791a3f99f7d3106303c8b53264ade212a308f62740fd93e170ce5d4151d07b9cfc4fca2c08ea294f5af3da91ed4070ad58be852702b1a0adedd526bebd9ab418169b521d11f0f6a1c82800a354e22bbb58fcf9853b34d412c3f1dfd9f85d505be40f27d17c0e8d5d1f3b8560760ba63d2cd8d1641dac6dfff67f370a629d6220d31784fefba2b7852e8f1665b504d903e1f487143e77a0a261aefde665ef40a1ce2d12a96dfe8908711432d9f17c3e84e6ca7720c0aea843a24a513413ddcc07d7d69467980b19b001681248906aa0b54ddbbbde28aff59c67a29cdacc11b730f99c25c9f9f36bb263326c39d31c0f03648e40c2c68521f3280c2fe760bd822ffc85f5c4aa1fed40033dc5e3ad6f98f0bd0af7e12076f01235f2108c126c9f3be056d9e9c48e175e240d127b942b6fe208b7e90e6901bbff1923b75becbb5ecfaae645c5905df21147012454c76d9d0f9d558896413716b63aac1dd4023f65ec81b11adae7ba60007b2eaf944fff635916ccd0338840578ed34f052ab03b7e80fe45ae17d08065346ab91684dc2f2f8c83981d088b58c56594b5a0f45d5c4f164e4dcfec57f22eda917158fd2045bdff408afbc8f41ec86d84fe9e713f1f6c6823bb90f7e2ee4aedff61357ca7a6372b47ac1806b4b6699493a303e93374bc9a0e9eee3abc32dbb286bee16ac255ca47b0861abf3c2233486f9c2a338e878c88cd6ff9d1e516bf461e9453c323e28520426053366f4c2a3ebc4b88ce40152082d6b9e229976d4e98197559facc0c7050665f1671c3255251418363db4abf9e53498075f1cc54c519465876832a9509ed9cfef064ae38a9b7492d0d70135f49b8984cd081ad498a4c52447a7572e9ed413e7178761d97f23f7f32551b4d13b41f7a215b4cbf8b67f7e9a386357a309c88f54905461417ee3b7e93cbbb9ae1577b0de4d36f3faea2713de64c4eb908f2ee1dd35cc4a0481b3417d8d6c39452ec840534c7aff69e831340a16bcb0e17df73e2fad730487576537f1e09bfb9f1969f0885dc5413882e8ce45e00bc93c791640eae0154dab7041e943876cc107a2af5d063bbee664ba6e7a01e7d3b67ef0c9da978f3eee88eda411aa0cb324b056311f2cac47b5f6f9124805ec8ef68dda8ade8463865eebbb3f08df8f1d80c2a22f961231d9614c772f2be43bd1f6e5a104b40e386229e3c8b3fd785b41163892dfc4cf36448b32f7f1971cea2ca534974650fad66e3c5ce4041cdd038df9a525fd850b6603722fdb6f9fbbe46b9df1088f3c20515394cacadb122e193ab9cb4b73d5685b0ee67971113093303c0696c9e8ede3294b228181ec7807a6c7ec7d3e67db0b01da6c9426799f326767c80cad5d749603be88242fadae9fe86a5853e4331dae5b6b2628686aeabd085cd6d4d79b4efa1f001c260dd76aa292ab762aa5d1b21e31e188f2e55a475a94a974cc77919c9d0a909170388701fc73be8423925e275d3f58f22b17e95c82d4b5cf9ccbaca7f5179100be21710cb18ca32e4c808ceded35de3f463bbc97ee72fa38250d41ca0a4a55ff000ddee3c84ba27444d0c153df721aa8d6245b5d7f688a05719098ab259150d1ca7cf4342c59d91cab15996406c470376988637788c0b6cea2b955b55d13d0f0c1271f49c5ddb0981be91d803ada607fcfb459215ad19adce3ea92b2dc0882d9fbbe9aa6ca36e39c355fa54f1067ff996fb5d5ac272bb7489108990f86017855e78fa425af2506e15ea9cbef89c80b57dead539adf31866648f83db584ffb1d2edd3e9fde75e31d759d8a79a9b32fbecde8c211f16072383527e3ea86c4f9196fcdc11624ffed83077ba4470f416b5aab788bb8dd811f9e1bb0205705aa4d542bbc9945b0a1da369043db8733407a4f4b1a32211e08fbca3bcfd7465b1ab0fbf7abe8027c13d62b7d6ecb3a818158a434c925564ef333289fffaa61b600fe403ae4722c00d320902a2079c334db1bfe496ba224d394c72dbee06b9116d89d2a3dc535aed063e58714dcdbfbea3713f1e9dff78abf5911cd1de48c48e841d24d27b264f0a9fdb748b717084e14fb3f2911675a5bc4b2bf8ded7a5f71b82f95a71675f64149e45945cd0f53482c26baf96ed38f96a159a966e74fa12016078a8191ab65fc29622518c128c8275de3391145a2de02dc0ec88c08f58a57f836cf63fe257f2baffdf6fac35202ac96825470cf9c10facae694e1999c22c266e263f14169e0b2162d44af6387d474e5c1cc7840df8b9f747712308ccd2d22353503bca65066175f5c097d374a4af6f53b4b21251fc63c2936c9abbd7dd02014e3e01500576c65a7e656fbaaacdd7967fe64e312a553d4dbca6fbc9e2af663aa27342f5bf51cfb1c6cb94fe7432b1d45c0e2c36b9f3642bc6ea81b3f046d1490642ef2e4b718a72f315d8a0ddb35259287b97e22f82d193789634e977f99066469f0341a0e2ef15cc8ce3f60968f09342e58c4b6c3b251ee85a3674b61c723e0ab926f4c58967c155f20966caf7b68dc4062161f9379fd6f742316eadcfdea715604c90df796ef927e5690a502d82c02c20bb35e9af175d0fa2318f013c1baccbe4ccbf9be58fb8c0cf73d6cca8ec276517368df1c1ab255a315abe6a819d68f61fd90d126db960be17d5061425d446490a1231498674133881d2bf354bd1b456917642dace898e94b4c58748e6168792d1e2fbecd39ff1cb0661a9068bc4270cf5b743b97d0534c689d3205533dd94d95f01e297ce829ae9958f93ccf47ae89df0bf09151620acfed38e69ad82cd99b7a387cf76f5ed17ef73c8dee3546598e3719ab50ef82d6aa2281f1b5d4c6f69a05384d6475434e9a47f02345384d8a1e6ae544cdfe07aed8b28e2d10b4230a810308724c1454074bb19dd7d78708877c712c57c12d8d709a1e38297e2ebd00979b8d5bd3021edb78617a10dfd1d9584694536781cf23ca1df05153406a07c528132b662e3198cbc593d4d17170d77ddb53e1071103929aef9ce0e687865821675d731696449be025be3559d42617d8d660d8ea0a28f2c8cc7f4e3c092ec760f17bb78ffdb162e64e45740d5c5f66d066be1de55e0f51b3814798a535edc64980dfaac5249496b280d1f47065743f9a8397506b02c643ec62e15a3712eb11975d9e3ca799e3ed22840650b156fbe10ecea6a6db07e466ce34d9f794deea33099e93245b64e29ec4db77ac64aeca84786af739587fd062a12bab21f990068b9c906e03df4dca264c6e81be206b49f2c0b1fec79e6cead3df7e519b4af19b4a423ef0e56eca8a4cf0e7f011a2a7077b25e36cd6bdd06e09a8a1dfa3db4a537d13601ec15759f2dab102de7f09fa71eabfab88f2b43f42dc77a540cd48ffbc44e31c41138af08bf356481ff7949615f01260e5b10c36d501eac91fdf5165a046bbab18eed5aabe918be7a47083db661bf7b531ad2c64b488b08c041cb3886dab33c99d18c731afd656a0b31974a91c5b0c9fc1418254a3729aab3fe747d321bac13ea08338125e5612db3705d05afaf6b4795c5b29ca69fefe785586f92b355c85b4b9df7004087e58dbca838ed63e28fca8ad6a0dd633e7dfd768457eac2a4ddbb328a4d363cc742372215548f1e90d35305b4db52a23f99407fc99fbb52e7fe05c663dbc6bb478f832d8a579b6c3ce12dee0b1befe752f3eda3d1f4247f5c731f570d3f80e309c5ab5987b48781973641fafe1d3d8af544aad911a28428ec31edb9bfab3419b0d5a7e32cdbcf47a9a15055b45e00f3f46e87d52a23a9e5c67c19501f5486b8ebd9262f3c24a801afc410e3a523f4b73bc7340fb3110495dcd3f77ed9a293ca140ac34bb7e410f5543e7042dd5b2c9877f68c5b7f2adfcbf70134f2db2695ff01672c5b1c3865b22b3c40e3387ad51fef3cc25f08a1f16e14a4f7a6fd5a449d091b2f28a9fbdfb64e4069367836cfc98d8072e987a5b5e396f33271208604524dbe26095ab6360b731ec90329898403bd3449402e6bb204378fc8415ca530342de1a4724d005da20e8f2fdfd5f1c98a96db36a5337e0e152833319520fb466e4b6ada85945733af03e51ec9d419401dd41e885c5b1632cfaac64e7b42c7bab684670cf3f3814d71e0b9fddc1ad3a696bb0274a59bbba135d2ad265a45ab0bd2b347c3eeb7a3f2324a879804929d056b55eea3132f6e52567ef01b289a32920d88ac4eecba4bc9dc6bde8509462b337432988ba1da23afab74477ddc71bf8f50c64276603205d204677e1ba495053d4901f27894efd28f8769aef2f33035f252b28749d1c8eccc5bfb075746f646fe2023fa775cbd22561b5dfcd33cef7c45dc4f320b990bddfcbbdde3ad7b14a4301d35ee1f37bb339eea37b1f3af8b592f40eb54bcf3f1ad4935d4c6b1d520978d4773b64ee65644cff877e23f9a4d487c63f04cd0ed185e93d69e6a661fb0fd57ead7eb2bb257e32d711c74baa196ffec78b0b4b83f9883dfd4948082a9a378bc08990070c25d2075e31da8403b04da3e6554fdd9f4987eff44f0c7dfca69379e597844660252890b00f54c32e37337a4936b7a50bec59f1333b2039590488a4e5ffb6d48223941ec65a4a093be9347a171d0fa551fe76f6baba1e717add7733f978fa55afd72db82b26c622ad4947b0bf750712257cc911efffc659c238e3f9597cd3342211ee887ca6c9c189f64123acdcfc713aae1a7f40855f653fcd399c37979f624814c54e9eb3375306a4ee7ac733bdbc90d1b938aaa19c48fb17f2571c62687252a2d79c17b3323456c12a34b4cd1ba0d1da19cd849af709a1752fa11f4d5f06bf2de1a9f668a6a8ce1ca30a18e190971ac8a99b7d40d772ff492d6d55e4bc194ce9bdd21cbc361844d0e042549988cde551f017fbb3b0f1ed6dd90954b34c9aa8c8afcbb76550b9a37d51f636e22e47d91d81a2a56b4f242ddfe9158716ac11839ce16b717a11f7d183a9d927d151f32402848a36fe4094cd2bfdd4e759ae41120d7d88cd2d14d0e1f540d1a670f18f77a000432c11135f1315352df28b2c34a71a0e6baf32414cd36c37d7297adcf63059998ccda45b586028b37d0153016e7653a24b636e28802c4043f6d939a8bd15f9371259a4bae7b3d6a45beb6f167c6bb109f1088d36e6f99b22cbbaffa8998e846ce516bfec4599f91c471d71b670ba87d3ccb06d6b34af555536380de6d0eb8d10f79915226b232053622d6105104379c5391090a93794ac454e488e02b83cd14233d2144669c01de08f3e2f503e277df14e7514238cdeff12a46b27a3d09102527ff4528caa016a34d8227bedd996d77269e65dbd06f6c1aff08db232f9db16f1779559ededf70f7939af0afe5efa30674e7312d720c67389b7920630ae0e531674cfd8ce6225ba2eb66d57f9ff4bf1e8db9c75f1fc8c5a8657f10c83ea9c54a0168585956e0205f5d4791e4c92284f5b102818c578bc79835a31638e9ca9552569079dcb2cea53e4f678c862cffbdf29646109b6c257e947e6602be82b66bd499c6f1ffe42b40eff27b4ac19135b3e1ab40aecbfef66ab41d3ee69816f9b789b0c2565ca75102dc79acde9a30621f6297be28755990dd5ce9f4b6047315f8721a6afca523e0d0c0c2b9ebf12186296619c03ee456c1f62ea5bbb4b673748dd7ab53ed5be2b437650f08c96cc920526882d3574d947f05d5bc7cbe571b4d650e6a33c6138e6a4453dfcbddace446926a7cb0f273d56d4a9caaa8f14d792a231961849105a0f5378f965f813ae07deaa00a4e7f387364ab86bbb08bf2c4ee319014b46b1b0d2ef2c34cb6b49a7039aae97425f5ff85f22586cba85bb8b2ebd2a807310b6534d24e477afefdbda59e7d729d8bd774d168f828c3a960a91c741b5670dc22a57481039cff97e953ec88a59aa9a9ace29f7f5cdfd9bf3d85b2f4001eccf4139a85bdddcaf8b7fe03bbdf10687e966d7fec23c5cf8e1d32b9211752223e0fd59d923f2d6fe4dc186681d6d80e9265fc460fd93abcaae5fc1a8ed6d4a</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","more":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","origin":"<p>我们知道<code>Redis</code>是基于内存的数据库，而所有基于内存的数据库，都有一个最大的问题，就是宕机数据丢失问题。持久化是<code>Redis</code>所提供的重要功能特性之一，它可以尽可能的保障宕机之后我们的数据能够不丢失，并且可以很快的进行恢复。</p>\n<p>之前两篇文章学习了<code>Redis</code>主要的两种持久化方式 内存快照(<code>RDB</code>)与<code>AOF</code>日志，但在真正业务使用中，对于如何选择合适的持久化方式，很多人却会犯了难。</p>\n<a id=\"more\"></a>\n<p>我们先来简单回顾一下两种持久化方式，并分析一下他们的优缺点。</p>\n<h3 id=\"1-RDB持久化\"><a href=\"#1-RDB持久化\" class=\"headerlink\" title=\"1 RDB持久化\"></a>1 <code>RDB</code>持久化</h3><p><code>RDB</code>持久化就是每隔一段时间把内存中的数据全量记录下来。<code>RDB</code>持久化并不能频繁的进行，因为<code>RDB</code>文件生成的过程虽然是由<code>fork</code>出来的子进程完成的，但是<code>fork</code>本身是有性能的开销的。</p>\n<h4 id=\"RDB的优点\"><a href=\"#RDB的优点\" class=\"headerlink\" title=\"RDB的优点:\"></a><code>RDB</code>的优点:</h4><ul>\n<li><p>体积更小：相同的数据量<code>RDB</code>文件数据比<code>AOF</code>的小，因为<code>RDB</code>是紧凑型文件</p>\n</li>\n<li><p>恢复更快：因为<code>RDB</code>是数据的快照，基本上就是数据的复制，不用重新读取再写入内存。</p>\n</li>\n<li><p>性能更高:   父进程在保存<code>RDB</code>时候只需要<code>fork</code>一个子进程来干活，无需父进程，保证了<code>Redis</code>正常处理读写命令的性能。</p>\n</li>\n</ul>\n<h4 id=\"RDB的缺点：\"><a href=\"#RDB的缺点：\" class=\"headerlink\" title=\"RDB的缺点：\"></a><code>RDB</code>的缺点：</h4><ul>\n<li><p>故障丢失：因为<code>RDB</code>是全量的，又不能频繁的执行<code>RDB</code>文件，因此越大的时间间隔数据丢失的也就越多</p>\n</li>\n<li><p>耐久性差：相对<code>AOF</code>的异步策略来说，因为<code>RDB</code>的复制是全量的，即使是<code>fork</code>的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，<code>fork</code>的时间也会延长，导致<code>CPU</code>吃紧，耐久性相对较差。</p>\n</li>\n<li>兼容性差：由于<code>Redis</code>更新换代的过程中<code>RDB</code>文件的格式一直在变化，老的版本<code>Redis</code> 可能无法恢复新版本的<code>RDB</code>文件。</li>\n</ul>\n<h3 id=\"2-AOF持久化\"><a href=\"#2-AOF持久化\" class=\"headerlink\" title=\"2 AOF持久化\"></a>2 <code>AOF</code>持久化</h3><p><code>AOF</code>持久化是通过保存<code>Redis</code>服务器所执行的写命令来记录数据库状态的。即<code>Redis</code>每执行一个命令的同时都会写入<code>AOF</code>缓冲区一份，并且可以通过设置回写策略来同步到磁盘文件，当文件过大时，会<code>fork</code>出一个子进程进行<code>AOF</code>重写操作。</p>\n<h4 id=\"AOF的优点：\"><a href=\"#AOF的优点：\" class=\"headerlink\" title=\"AOF的优点：\"></a><code>AOF</code>的优点：</h4><ul>\n<li>数据保证：我们可以根据需要设置合适的回写策略，来保障数据尽可能少的丢失</li>\n<li>易于解析：相对于<code>RDB</code>文件，<code>AOF</code>文件更易于理解和解析，且没有兼容性问题。</li>\n</ul>\n<h4 id=\"AOF的缺点\"><a href=\"#AOF的缺点\" class=\"headerlink\" title=\"AOF的缺点:\"></a><code>AOF</code>的缺点:</h4><ul>\n<li><p>性能相对较差：它的操作模式决定了它会对<code>redis</code>的性能有所损耗</p>\n</li>\n<li><p>体积相对更大：尽管是将<code>aof</code>文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。</p>\n</li>\n<li><p>恢复速度较慢：由于恢复的时候要逐条解析命令并写入，相对于<code>RDB</code>文件的恢复比较慢。</p>\n</li>\n</ul>\n<p>我们可以用一张表格来更清晰的对比一下两种持久化方式的优缺点</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>持久化方式</th>\n<th>对<code>Redis</code>性能的影响</th>\n<th>文件大小</th>\n<th>故障恢复速度</th>\n<th>数据丢失</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>RDB</code></td>\n<td>小</td>\n<td>小</td>\n<td>快</td>\n<td>多</td>\n</tr>\n<tr>\n<td><code>AOF</code></td>\n<td>大</td>\n<td>大</td>\n<td>慢</td>\n<td>少</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"3-混合持久化\"><a href=\"#3-混合持久化\" class=\"headerlink\" title=\"3 混合持久化\"></a>3 混合持久化</h3><p>鱼我所欲也，熊掌亦我所欲也！如果我们既想要一个好的性能，又要尽量避免数据的丢失应该怎么办? 在<code>Redis</code> 4.0之后提供了混合持久化的方式，顾名思义就是把<code>RDB</code>持久化和<code>AOF</code>持久化结合起来的一种方式。</p>\n<p>混合持久化就是快照以一定的频率执行，而在两次快照之间，使用 <code>AOF</code> 日志记录这期间的所有命令操作。</p>\n<p><img src=\"https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/Redis%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96.png\" alt=\"Redis混合持久化\"></p>\n<p>如图所示，在第一次执行快照之后，将后续命令写入<code>AOF</code>文件，直到第二次执行快照。而在第二次执行快照的时候会清除<code>AOF</code>文件的内容，循环往复。</p>\n<p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，<code>AOF</code> 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作，也就不会出现文件过大的情况，同时可以避免<code>AOF</code>重写的开销。</p>\n<p>但世界上并没有完全两全其美的事情，即使鱼和熊掌兼得，一起吃的时候也容易串了味儿。<code>RDB</code>混合持久化固然兼顾了性能与数据完整性，但也有其缺点。</p>\n<ul>\n<li>兼顾了性能与数据的同时也牺牲了部分性能</li>\n<li><code>AOF</code> 文件中添加了<code>RDB</code> 格式的内容，使可读性变差，并且由于混合了<code>RDB</code>的内容，与<code>RDB</code>文件相同具有兼容性的问题</li>\n</ul>\n<p>那么，在真正使用的过程中，我们到底应该如何选择合适的持久化方式呢？</p>\n<h3 id=\"4-如何选择合适的持久化方式\"><a href=\"#4-如何选择合适的持久化方式\" class=\"headerlink\" title=\"4 如何选择合适的持久化方式\"></a>4 如何选择合适的持久化方式</h3><p>技术决策不同于“今天中午吃什么”，可以拍脑袋或者抛硬币来决定。我们应该综合考虑很多因素，其中最重要的一点就是“平衡、取舍”的问题，因为没有最好的技术方案，只有适合的方案，在你想要得到一些东西的时候，必然要失去一些东西。</p>\n<p>下面几点可以在我们选择的时候提供一些帮助。</p>\n<ul>\n<li>如果你的业务场景需要很高的性能，或者宕机之后能够尽快的恢复，而对数据完整性的要求不是那么高，那么可以采用<code>RDB</code>持久化的方式。</li>\n<li>如果你的业务场景对数据完整性的要求很高，那么可以采用<code>AOF</code>的持久化方式，而至于采用那种回写策略，则取决于你对数据完整性的要求程度。</li>\n<li>如果你的业务场景既要兼顾性能，又注重数据完整性，那么可以采用混合持久化的方式。</li>\n<li>如果你对数据丢失无所谓，追求性能最大化的情况下，甚至可以禁用持久化。</li>\n</ul>\n","encrypt":true},{"title":"Redis数据结构——整数集合","copyright":true,"date":"2019-07-30T01:38:45.000Z","keywords":"Redis,数据结构,整数集合","aside":"redis","_content":"\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;整数集合(intset)并不是一个基础的数据结构，而是Redis自己设计的一种存储结构，是集合键的底层实现之一,当一个集合只包含整数值元素,并且这个集合的元素数量不多时, Redis i就会使用整数集合作为集合键的底层实现。\t\n\n<!--more-->\n\n### 一、整数集合实现\n\n&nbsp;&nbsp;&nbsp;&nbsp;整数集合(intset)是Redis用于保存整数值的集合抽象数据结构,它可以保存类型为int16_t、int32_t或者int64_t的整数值,并且保证集合中不会出现重复元素。\t\n\n```c\n//每个intset结构表示一个整数集合\ntypedef struct intset{\n    //编码方式\n    uint32_t encoding;\n    //集合中包含的元素数量\n    uint32_t length;\n    //保存元素的数组\n    int8_t contents[];\n} intset;\n```\n\n* contents数组是整数集合的底层实现，整数集合的每个元素都是 contents数组的个数组项(item),各个项在数组中按值的大小从小到大有序地排列,并且数组中不包含任何重复项。\n* length属性记录了数组的长度。 \n* intset结构将contents属性声明为int8_t类型的数组,但实际上 contents数组并不保存任何int8t类型的值, contents数组的真正类型取决于encoding属性的值。encoding属性的值为INTSET_ENC_INT16则数组就是uint16_t类型，数组中的每一个元素都是int16_t类型的整数值(-32768——32767)，encoding属性的值为INTSET_ENC_INT32则数组就是uint32_t类型，数组中的每一个元素都是int16_t类型的整数值(-2147483648——2147483647)。\n\n![int16_t](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/intset/int16_t%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上图，为一int16_t类型的整数集合，我们可以看到数组中存储了5个int16_t类型的整数，它们按照从小到大的顺序依次排列。这个时候我们思考一个问题。如果这个时候存入一个int32_t类型的整数会怎么样？内存溢出？这个时候就要提到整数集合的升级。\t\n\n### 二、整数集合的升级\n\n#### 2.1 整数集合升级过程\n\n&nbsp;&nbsp;&nbsp;&nbsp;正如上面所提到的问题，每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有所有元素的类型都要长时,整数集合需要先进行升级,然后才能将新元素添加到整数集合里面。升级整数集合并添加新元素主要分三步来进行。\n\n1. 根据新元素的类型,扩展整数集合底层数组的空间大小,并为新元素分配空间。\n2. 将底层数组现有的所有元素都转换成与新元素相同的类型,并将类型转换后的元素放置到正确的位上,而且在放置元素的过程中,需要继续维持底层数组的有序性质不变。\n3. 将新元素添加到底层数组里面。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/intset/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%9A%84%E5%8D%87%E7%BA%A7%20.png)\n\n#### 2.2 整数集合升级的优点\n\n1. 提升灵活性\n\n&nbsp;&nbsp;&nbsp;&nbsp;因为C语言是静态类型语言,为了避免类型错误,我们通常不会将两种不同类型的值放在同一个数据结构里面。\n\n&nbsp;&nbsp;&nbsp;&nbsp;例如,我们一般只使用int16_t类型的数组来保存int16_t类型的值,只使用int32_t类型的数组来保存int32_t类型的值,诸如此类。但是,因为整数集合可以通过自动升级底层数组来适应新元素,所以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合中,而不必担心出现类型错误,这种做法非常灵活。\n\n2. 节约内存\n\n&nbsp;&nbsp;&nbsp;&nbsp;要让一个数组可以同时保存int16_t、int32_t、int64_t三种类型的值,最简单的做法就是直接使用int64t类型的数组作为整数集合的底层实现。不过这样一来,即使添加到整数集合里面的都是int16_t类型或者int32_t类型的值,数组都需要使用int64_t类型的空间去保存它们,从而出现浪费内存的情况。\n\n而整数集合现在的做法既可以让集合能同时保存三种不同类型的值,又可以确保升级操作只会在有需要的时候进行,这可以尽量节省内存。如果我们一直只向整数集合添加int16_t类型的值,那么整数集合的底层实现就会一直是int16_t类型的数组,只有在我们要将int32_t类型或者int64_t类型的值添加到集合时,程序才会对数组进行升级。\n\n#### 2.3 降级\n\n&nbsp;&nbsp;&nbsp;&nbsp;整数集合不支持降级操作,一旦对数组进行了升级,编码就会一直保持升级后的状态。也就是说一旦我们向一个int16_t的整数集合内添加了一个int32_t的元素后，整数集合将升级到int32_t类型。即使后续的操作中我们删除了这个元素，整数集合还是会保持int32_t类型的状态。\n\n### 三、整数集合常用操作时间复杂度\n\n| 操作                     | 时间复杂度 |\n| ------------------------ | ---------- |\n| 创建一个新的整数集合     | O(1)       |\n| 添加指定元素到集合       | O(N)       |\n| 移除指定元素             | O(N)       |\n| 判断指定元素是否在集合中 | O(logN)    |\n| 随机返回一个元素         | O(1)       |\n| 取出在指定索引上的元素   | O(1)       |\n| 返回集合包含的元素个数   | O(1)       |\n| 返回集合占用的内存字节数 | O(1)       |\n\n### 本文重点\n\n* 整数集合是Redis自己设计的一种存储结构,集合键的底层实现之一。\n* 整数集合的底层实现为数组,这个数组以有序、无重复的方式保存集合元素,在有需要时,程序会根据新添加元素的类型,改变这个数组的类型。\n* 升级操作为整数集合带来了操作上的灵活性,并且尽可能地节约了内存。\n* 整数集合只支持升级操作,不支持降级操作。\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n\n\n### -----END-----","source":"_posts/技术实践/redis/Redis数据结构——整数集合.md","raw":"---\ntitle: Redis数据结构——整数集合\ncopyright: true\ndate: 2019-07-30 09:38:45\ntags: \n- Redis\n- 数据结构\ncategories: Redis\nkeywords: Redis,数据结构,整数集合\naside: redis\n---\n\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;整数集合(intset)并不是一个基础的数据结构，而是Redis自己设计的一种存储结构，是集合键的底层实现之一,当一个集合只包含整数值元素,并且这个集合的元素数量不多时, Redis i就会使用整数集合作为集合键的底层实现。\t\n\n<!--more-->\n\n### 一、整数集合实现\n\n&nbsp;&nbsp;&nbsp;&nbsp;整数集合(intset)是Redis用于保存整数值的集合抽象数据结构,它可以保存类型为int16_t、int32_t或者int64_t的整数值,并且保证集合中不会出现重复元素。\t\n\n```c\n//每个intset结构表示一个整数集合\ntypedef struct intset{\n    //编码方式\n    uint32_t encoding;\n    //集合中包含的元素数量\n    uint32_t length;\n    //保存元素的数组\n    int8_t contents[];\n} intset;\n```\n\n* contents数组是整数集合的底层实现，整数集合的每个元素都是 contents数组的个数组项(item),各个项在数组中按值的大小从小到大有序地排列,并且数组中不包含任何重复项。\n* length属性记录了数组的长度。 \n* intset结构将contents属性声明为int8_t类型的数组,但实际上 contents数组并不保存任何int8t类型的值, contents数组的真正类型取决于encoding属性的值。encoding属性的值为INTSET_ENC_INT16则数组就是uint16_t类型，数组中的每一个元素都是int16_t类型的整数值(-32768——32767)，encoding属性的值为INTSET_ENC_INT32则数组就是uint32_t类型，数组中的每一个元素都是int16_t类型的整数值(-2147483648——2147483647)。\n\n![int16_t](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/intset/int16_t%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上图，为一int16_t类型的整数集合，我们可以看到数组中存储了5个int16_t类型的整数，它们按照从小到大的顺序依次排列。这个时候我们思考一个问题。如果这个时候存入一个int32_t类型的整数会怎么样？内存溢出？这个时候就要提到整数集合的升级。\t\n\n### 二、整数集合的升级\n\n#### 2.1 整数集合升级过程\n\n&nbsp;&nbsp;&nbsp;&nbsp;正如上面所提到的问题，每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有所有元素的类型都要长时,整数集合需要先进行升级,然后才能将新元素添加到整数集合里面。升级整数集合并添加新元素主要分三步来进行。\n\n1. 根据新元素的类型,扩展整数集合底层数组的空间大小,并为新元素分配空间。\n2. 将底层数组现有的所有元素都转换成与新元素相同的类型,并将类型转换后的元素放置到正确的位上,而且在放置元素的过程中,需要继续维持底层数组的有序性质不变。\n3. 将新元素添加到底层数组里面。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/intset/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%9A%84%E5%8D%87%E7%BA%A7%20.png)\n\n#### 2.2 整数集合升级的优点\n\n1. 提升灵活性\n\n&nbsp;&nbsp;&nbsp;&nbsp;因为C语言是静态类型语言,为了避免类型错误,我们通常不会将两种不同类型的值放在同一个数据结构里面。\n\n&nbsp;&nbsp;&nbsp;&nbsp;例如,我们一般只使用int16_t类型的数组来保存int16_t类型的值,只使用int32_t类型的数组来保存int32_t类型的值,诸如此类。但是,因为整数集合可以通过自动升级底层数组来适应新元素,所以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合中,而不必担心出现类型错误,这种做法非常灵活。\n\n2. 节约内存\n\n&nbsp;&nbsp;&nbsp;&nbsp;要让一个数组可以同时保存int16_t、int32_t、int64_t三种类型的值,最简单的做法就是直接使用int64t类型的数组作为整数集合的底层实现。不过这样一来,即使添加到整数集合里面的都是int16_t类型或者int32_t类型的值,数组都需要使用int64_t类型的空间去保存它们,从而出现浪费内存的情况。\n\n而整数集合现在的做法既可以让集合能同时保存三种不同类型的值,又可以确保升级操作只会在有需要的时候进行,这可以尽量节省内存。如果我们一直只向整数集合添加int16_t类型的值,那么整数集合的底层实现就会一直是int16_t类型的数组,只有在我们要将int32_t类型或者int64_t类型的值添加到集合时,程序才会对数组进行升级。\n\n#### 2.3 降级\n\n&nbsp;&nbsp;&nbsp;&nbsp;整数集合不支持降级操作,一旦对数组进行了升级,编码就会一直保持升级后的状态。也就是说一旦我们向一个int16_t的整数集合内添加了一个int32_t的元素后，整数集合将升级到int32_t类型。即使后续的操作中我们删除了这个元素，整数集合还是会保持int32_t类型的状态。\n\n### 三、整数集合常用操作时间复杂度\n\n| 操作                     | 时间复杂度 |\n| ------------------------ | ---------- |\n| 创建一个新的整数集合     | O(1)       |\n| 添加指定元素到集合       | O(N)       |\n| 移除指定元素             | O(N)       |\n| 判断指定元素是否在集合中 | O(logN)    |\n| 随机返回一个元素         | O(1)       |\n| 取出在指定索引上的元素   | O(1)       |\n| 返回集合包含的元素个数   | O(1)       |\n| 返回集合占用的内存字节数 | O(1)       |\n\n### 本文重点\n\n* 整数集合是Redis自己设计的一种存储结构,集合键的底层实现之一。\n* 整数集合的底层实现为数组,这个数组以有序、无重复的方式保存集合元素,在有需要时,程序会根据新添加元素的类型,改变这个数组的类型。\n* 升级操作为整数集合带来了操作上的灵活性,并且尽可能地节约了内存。\n* 整数集合只支持升级操作,不支持降级操作。\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n\n\n### -----END-----","slug":"技术实践/redis/Redis数据结构——整数集合","published":1,"updated":"2021-03-14T03:04:50.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwl007xhyjft2uwyqe6","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;整数集合(intset)并不是一个基础的数据结构，而是Redis自己设计的一种存储结构，是集合键的底层实现之一,当一个集合只包含整数值元素,并且这个集合的元素数量不多时, Redis i就会使用整数集合作为集合键的底层实现。    </p>\n<a id=\"more\"></a>\n<h3 id=\"一、整数集合实现\"><a href=\"#一、整数集合实现\" class=\"headerlink\" title=\"一、整数集合实现\"></a>一、整数集合实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;整数集合(intset)是Redis用于保存整数值的集合抽象数据结构,它可以保存类型为int16_t、int32_t或者int64_t的整数值,并且保证集合中不会出现重复元素。    </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//每个intset结构表示一个整数集合</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//编码方式</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> encoding;</span><br><span class=\"line\">    <span class=\"comment\">//集合中包含的元素数量</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;</span><br><span class=\"line\">    <span class=\"comment\">//保存元素的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];</span><br><span class=\"line\">&#125; intset;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>contents数组是整数集合的底层实现，整数集合的每个元素都是 contents数组的个数组项(item),各个项在数组中按值的大小从小到大有序地排列,并且数组中不包含任何重复项。</li>\n<li>length属性记录了数组的长度。 </li>\n<li>intset结构将contents属性声明为int8_t类型的数组,但实际上 contents数组并不保存任何int8t类型的值, contents数组的真正类型取决于encoding属性的值。encoding属性的值为INTSET_ENC_INT16则数组就是uint16_t类型，数组中的每一个元素都是int16_t类型的整数值(-32768——32767)，encoding属性的值为INTSET_ENC_INT32则数组就是uint32_t类型，数组中的每一个元素都是int16_t类型的整数值(-2147483648——2147483647)。</li>\n</ul>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/intset/int16_t%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88.png\" alt=\"int16_t\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上图，为一int16_t类型的整数集合，我们可以看到数组中存储了5个int16_t类型的整数，它们按照从小到大的顺序依次排列。这个时候我们思考一个问题。如果这个时候存入一个int32_t类型的整数会怎么样？内存溢出？这个时候就要提到整数集合的升级。    </p>\n<h3 id=\"二、整数集合的升级\"><a href=\"#二、整数集合的升级\" class=\"headerlink\" title=\"二、整数集合的升级\"></a>二、整数集合的升级</h3><h4 id=\"2-1-整数集合升级过程\"><a href=\"#2-1-整数集合升级过程\" class=\"headerlink\" title=\"2.1 整数集合升级过程\"></a>2.1 整数集合升级过程</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;正如上面所提到的问题，每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有所有元素的类型都要长时,整数集合需要先进行升级,然后才能将新元素添加到整数集合里面。升级整数集合并添加新元素主要分三步来进行。</p>\n<ol>\n<li>根据新元素的类型,扩展整数集合底层数组的空间大小,并为新元素分配空间。</li>\n<li>将底层数组现有的所有元素都转换成与新元素相同的类型,并将类型转换后的元素放置到正确的位上,而且在放置元素的过程中,需要继续维持底层数组的有序性质不变。</li>\n<li>将新元素添加到底层数组里面。</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/intset/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%9A%84%E5%8D%87%E7%BA%A7%20.png\" alt></p>\n<h4 id=\"2-2-整数集合升级的优点\"><a href=\"#2-2-整数集合升级的优点\" class=\"headerlink\" title=\"2.2 整数集合升级的优点\"></a>2.2 整数集合升级的优点</h4><ol>\n<li>提升灵活性</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;因为C语言是静态类型语言,为了避免类型错误,我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;例如,我们一般只使用int16_t类型的数组来保存int16_t类型的值,只使用int32_t类型的数组来保存int32_t类型的值,诸如此类。但是,因为整数集合可以通过自动升级底层数组来适应新元素,所以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合中,而不必担心出现类型错误,这种做法非常灵活。</p>\n<ol>\n<li>节约内存</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;要让一个数组可以同时保存int16_t、int32_t、int64_t三种类型的值,最简单的做法就是直接使用int64t类型的数组作为整数集合的底层实现。不过这样一来,即使添加到整数集合里面的都是int16_t类型或者int32_t类型的值,数组都需要使用int64_t类型的空间去保存它们,从而出现浪费内存的情况。</p>\n<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值,又可以确保升级操作只会在有需要的时候进行,这可以尽量节省内存。如果我们一直只向整数集合添加int16_t类型的值,那么整数集合的底层实现就会一直是int16_t类型的数组,只有在我们要将int32_t类型或者int64_t类型的值添加到集合时,程序才会对数组进行升级。</p>\n<h4 id=\"2-3-降级\"><a href=\"#2-3-降级\" class=\"headerlink\" title=\"2.3 降级\"></a>2.3 降级</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;整数集合不支持降级操作,一旦对数组进行了升级,编码就会一直保持升级后的状态。也就是说一旦我们向一个int16_t的整数集合内添加了一个int32_t的元素后，整数集合将升级到int32_t类型。即使后续的操作中我们删除了这个元素，整数集合还是会保持int32_t类型的状态。</p>\n<h3 id=\"三、整数集合常用操作时间复杂度\"><a href=\"#三、整数集合常用操作时间复杂度\" class=\"headerlink\" title=\"三、整数集合常用操作时间复杂度\"></a>三、整数集合常用操作时间复杂度</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建一个新的整数集合</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>添加指定元素到集合</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>移除指定元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>判断指定元素是否在集合中</td>\n<td>O(logN)</td>\n</tr>\n<tr>\n<td>随机返回一个元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>取出在指定索引上的元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>返回集合包含的元素个数</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>返回集合占用的内存字节数</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"本文重点\"><a href=\"#本文重点\" class=\"headerlink\" title=\"本文重点\"></a>本文重点</h3><ul>\n<li>整数集合是Redis自己设计的一种存储结构,集合键的底层实现之一。</li>\n<li>整数集合的底层实现为数组,这个数组以有序、无重复的方式保存集合元素,在有需要时,程序会根据新添加元素的类型,改变这个数组的类型。</li>\n<li>升级操作为整数集合带来了操作上的灵活性,并且尽可能地节约了内存。</li>\n<li>整数集合只支持升级操作,不支持降级操作。</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;整数集合(intset)并不是一个基础的数据结构，而是Redis自己设计的一种存储结构，是集合键的底层实现之一,当一个集合只包含整数值元素,并且这个集合的元素数量不多时, Redis i就会使用整数集合作为集合键的底层实现。    </p>","more":"<h3 id=\"一、整数集合实现\"><a href=\"#一、整数集合实现\" class=\"headerlink\" title=\"一、整数集合实现\"></a>一、整数集合实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;整数集合(intset)是Redis用于保存整数值的集合抽象数据结构,它可以保存类型为int16_t、int32_t或者int64_t的整数值,并且保证集合中不会出现重复元素。    </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//每个intset结构表示一个整数集合</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">intset</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//编码方式</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> encoding;</span><br><span class=\"line\">    <span class=\"comment\">//集合中包含的元素数量</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> length;</span><br><span class=\"line\">    <span class=\"comment\">//保存元素的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int8_t</span> contents[];</span><br><span class=\"line\">&#125; intset;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>contents数组是整数集合的底层实现，整数集合的每个元素都是 contents数组的个数组项(item),各个项在数组中按值的大小从小到大有序地排列,并且数组中不包含任何重复项。</li>\n<li>length属性记录了数组的长度。 </li>\n<li>intset结构将contents属性声明为int8_t类型的数组,但实际上 contents数组并不保存任何int8t类型的值, contents数组的真正类型取决于encoding属性的值。encoding属性的值为INTSET_ENC_INT16则数组就是uint16_t类型，数组中的每一个元素都是int16_t类型的整数值(-32768——32767)，encoding属性的值为INTSET_ENC_INT32则数组就是uint32_t类型，数组中的每一个元素都是int16_t类型的整数值(-2147483648——2147483647)。</li>\n</ul>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/intset/int16_t%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88.png\" alt=\"int16_t\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上图，为一int16_t类型的整数集合，我们可以看到数组中存储了5个int16_t类型的整数，它们按照从小到大的顺序依次排列。这个时候我们思考一个问题。如果这个时候存入一个int32_t类型的整数会怎么样？内存溢出？这个时候就要提到整数集合的升级。    </p>\n<h3 id=\"二、整数集合的升级\"><a href=\"#二、整数集合的升级\" class=\"headerlink\" title=\"二、整数集合的升级\"></a>二、整数集合的升级</h3><h4 id=\"2-1-整数集合升级过程\"><a href=\"#2-1-整数集合升级过程\" class=\"headerlink\" title=\"2.1 整数集合升级过程\"></a>2.1 整数集合升级过程</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;正如上面所提到的问题，每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有所有元素的类型都要长时,整数集合需要先进行升级,然后才能将新元素添加到整数集合里面。升级整数集合并添加新元素主要分三步来进行。</p>\n<ol>\n<li>根据新元素的类型,扩展整数集合底层数组的空间大小,并为新元素分配空间。</li>\n<li>将底层数组现有的所有元素都转换成与新元素相同的类型,并将类型转换后的元素放置到正确的位上,而且在放置元素的过程中,需要继续维持底层数组的有序性质不变。</li>\n<li>将新元素添加到底层数组里面。</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/intset/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%9A%84%E5%8D%87%E7%BA%A7%20.png\" alt></p>\n<h4 id=\"2-2-整数集合升级的优点\"><a href=\"#2-2-整数集合升级的优点\" class=\"headerlink\" title=\"2.2 整数集合升级的优点\"></a>2.2 整数集合升级的优点</h4><ol>\n<li>提升灵活性</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;因为C语言是静态类型语言,为了避免类型错误,我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;例如,我们一般只使用int16_t类型的数组来保存int16_t类型的值,只使用int32_t类型的数组来保存int32_t类型的值,诸如此类。但是,因为整数集合可以通过自动升级底层数组来适应新元素,所以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合中,而不必担心出现类型错误,这种做法非常灵活。</p>\n<ol>\n<li>节约内存</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;要让一个数组可以同时保存int16_t、int32_t、int64_t三种类型的值,最简单的做法就是直接使用int64t类型的数组作为整数集合的底层实现。不过这样一来,即使添加到整数集合里面的都是int16_t类型或者int32_t类型的值,数组都需要使用int64_t类型的空间去保存它们,从而出现浪费内存的情况。</p>\n<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值,又可以确保升级操作只会在有需要的时候进行,这可以尽量节省内存。如果我们一直只向整数集合添加int16_t类型的值,那么整数集合的底层实现就会一直是int16_t类型的数组,只有在我们要将int32_t类型或者int64_t类型的值添加到集合时,程序才会对数组进行升级。</p>\n<h4 id=\"2-3-降级\"><a href=\"#2-3-降级\" class=\"headerlink\" title=\"2.3 降级\"></a>2.3 降级</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;整数集合不支持降级操作,一旦对数组进行了升级,编码就会一直保持升级后的状态。也就是说一旦我们向一个int16_t的整数集合内添加了一个int32_t的元素后，整数集合将升级到int32_t类型。即使后续的操作中我们删除了这个元素，整数集合还是会保持int32_t类型的状态。</p>\n<h3 id=\"三、整数集合常用操作时间复杂度\"><a href=\"#三、整数集合常用操作时间复杂度\" class=\"headerlink\" title=\"三、整数集合常用操作时间复杂度\"></a>三、整数集合常用操作时间复杂度</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建一个新的整数集合</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>添加指定元素到集合</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>移除指定元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>判断指定元素是否在集合中</td>\n<td>O(logN)</td>\n</tr>\n<tr>\n<td>随机返回一个元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>取出在指定索引上的元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>返回集合包含的元素个数</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>返回集合占用的内存字节数</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"本文重点\"><a href=\"#本文重点\" class=\"headerlink\" title=\"本文重点\"></a>本文重点</h3><ul>\n<li>整数集合是Redis自己设计的一种存储结构,集合键的底层实现之一。</li>\n<li>整数集合的底层实现为数组,这个数组以有序、无重复的方式保存集合元素,在有需要时,程序会根据新添加元素的类型,改变这个数组的类型。</li>\n<li>升级操作为整数集合带来了操作上的灵活性,并且尽可能地节约了内存。</li>\n<li>整数集合只支持升级操作,不支持降级操作。</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>"},{"title":"Spring Boot(一) Hello World","copyright":true,"date":"2020-03-19T05:23:18.000Z","keywords":"Spring Boot","aside":"SpringBoot","_content":"### 一、Spring Boot之我见\n\n&nbsp;&nbsp;&nbsp;&nbsp;*Spring Boot*是由Pivotal团队提供的全新框架，其设计目的是用来简化新*Spring*应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。\n\n<!--more-->\n\n&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件\n\n&nbsp;&nbsp;&nbsp;&nbsp;这是百科上对Spring Boot的说明。实际上在我看来Spring Boot就是Spring等一系列的java技术栈框架的组合加上约定大于配置的思想。它并不是一项新的技术也不是一个新的框架，而是各种技术的一个组合，它默认配置了很多框架的使用方式。它的出现，极大的提高了java应用的开发效率。其特性就是轻量级、可插拔、微服务。同时idea和spring boot的出现也颠覆了我一个.net程序员曾经对java的认知（我是.net出身的程序员，对于java最大的印象就是“配置”、“配置”、“配置”和难用的一笔的IDE）。原来Java项目开发也可以变得优雅起来！\n\n### 二、项目搭建\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在还是SSM(SSH)的时代搭建一个Web项目大概需要以下几步\n\n 1. 新建项目\n\n 2. 配置Web.xml，加载Spring和Spring Mvc\n\n 3. 配置数据库连接、配置Spring事务，配置mybatis\n\n 4. 配置加载配置文件的读取，开启注解\n\n 5. 配置日志文件\n\n 6. 配置完成后部署Tomcat调试\n\n    ...\n\n    一堆的配置，看得人头大，也让很多初学者望而却步。\n\n    而有了Spring Boot，一切将会简单而优雅。\n\n    本文将从Hello World做起，搭建一个简单的Spring Boot Web项目。\n\n1. File——New——Project（Moudle）\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/1.png)\n\n*注意*: 图中的https://start.spring.io/，也可以直接打开，在网站上直接生成项目下载，用idea打开也是一样的。\n\n2. Next将看到以下界面\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/2.png)\n\n3. 继续下一步，选择Web->Spring Boot，在这里我们可以选择Spring Boot版本\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/3.png)\n\n4. 继续下一步\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/4.png)\n\n5. 点击完成将看到如下目录结构\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/5.png)\n\n至此，一个Spring Boot项目就创建完成。\n\n### 三、项目结构说明\n\n1. 项目结构中主要目录说明大致如下\n\n```\n->spring-boot-web\t\t\t\t\t\t (项目或模块)\n---> src\n----->main\n------->java\t\t\t\t\t\t\t (Java代码目录)\n--------->spring.boot.web\t\t\t\t  (包spring.boot.web)\n----------->SpringBootWebApplication\t   (Spring Boot启动类)\n------->resources\n--------->static\t\t\t\t\t\t (静态资源目录)\n--------->templates\t\t\t\t\t\t (视图模板目录)\n--------->application.properties\t\t  (项目配置文件)\n------->test\t\t\t\t\t\t\t(测试)\n--------->java\t\t\t\t\t\t\n----------->spring.boot.web\n----------->SpringBootWebApplicationTests  (Spring Boot测试启动类)\n--->pom.xml\t\t\t\t\t\t\t\t(maven pom配置文件)\n```\n\n2. pom文件说明\n\n*&nbsp;&nbsp;&nbsp;&nbsp;pom.xml*，它是maven来管理各种jar包依赖的一个配置文件，maven相当于.net中的nuget，是一个包管理工具。我们可以看到项目搭建好之后，就默认为我们加上了下面这些配置。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <!--父节点配置了Spring Boot的一些信息，父节点代表子节点可以继承父节点的一些配置，如版本号，在这里配置了就不用在子节点配置了-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.8.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <!--项目信息-->\n    <groupId>spring.boot.examples</groupId>\n    <artifactId>spring-boot-web</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>spring-boot-web</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <!--依赖的包配置在下面这个节点-->\n    <dependencies>\n        <!--引入Spring Boot Web模块-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\t\t<!--引入Spring Boot 测试模块-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <!--Spring Boot Maven 插件-->\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n```\n\n3. Spring Boot启动类\n\n```java\npackage spring.boot.web;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringBootWebApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootWebApplication.class, args);\n    }\n\n}\n\n```\n\n启动类是Spring Boot程序的入口。\n\n### 四、Hello World\n\n1. 新建控制器\n\n   我们在spring.boot.web下建一个controller包，包内新建HelloWorld类\n\n   ```java\n   package spring.boot.web.controller;\n   \n   import org.springframework.web.bind.annotation.RequestMapping;\n   import org.springframework.web.bind.annotation.RestController;\n   \n   @RestController\n   public class HelloWorld {\n   \n       @RequestMapping(\"/helloWorld\")\n       public String Hello() {\n           return \"Hello World!\";\n       }\n   }\n   \n   ```\n\n   这里有两个注解：\n\n   `@RestController`的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！\n\n   `@RequestMapping`配置Url映射\n\n2. 启动Spring Boot项目\n\n   由于Spring Boot项目内置Tomcat服务器，我们不需要在部署到Tomcat。只需要要在配置文件application.properties里配置一下端口号，然后idea->run->run。\n\n```java\n  server.port=8888\n```\n\n如下图，代表启动成功！\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/6.png)\n\n打开浏览器输入：http://localhost:8888/helloWorld\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/7.png)\n\n**至此，Hello World项目完成。于Java上，再次体验到了简洁优雅的开发！**\n\n\n\n**[示例代码](https://github.com/hunter-droid/spring-boot-examples)**\n\n","source":"_posts/技术实践/spring-boot/Spring Boot(一) Hello World.md","raw":"---\ntitle: Spring Boot(一) Hello World\ncopyright: true\ndate: 2020-03-19 13:23:18\ncategories: \n- Spring Boot\nkeywords: Spring Boot\naside: SpringBoot\n---\n### 一、Spring Boot之我见\n\n&nbsp;&nbsp;&nbsp;&nbsp;*Spring Boot*是由Pivotal团队提供的全新框架，其设计目的是用来简化新*Spring*应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。\n\n<!--more-->\n\n&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件\n\n&nbsp;&nbsp;&nbsp;&nbsp;这是百科上对Spring Boot的说明。实际上在我看来Spring Boot就是Spring等一系列的java技术栈框架的组合加上约定大于配置的思想。它并不是一项新的技术也不是一个新的框架，而是各种技术的一个组合，它默认配置了很多框架的使用方式。它的出现，极大的提高了java应用的开发效率。其特性就是轻量级、可插拔、微服务。同时idea和spring boot的出现也颠覆了我一个.net程序员曾经对java的认知（我是.net出身的程序员，对于java最大的印象就是“配置”、“配置”、“配置”和难用的一笔的IDE）。原来Java项目开发也可以变得优雅起来！\n\n### 二、项目搭建\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在还是SSM(SSH)的时代搭建一个Web项目大概需要以下几步\n\n 1. 新建项目\n\n 2. 配置Web.xml，加载Spring和Spring Mvc\n\n 3. 配置数据库连接、配置Spring事务，配置mybatis\n\n 4. 配置加载配置文件的读取，开启注解\n\n 5. 配置日志文件\n\n 6. 配置完成后部署Tomcat调试\n\n    ...\n\n    一堆的配置，看得人头大，也让很多初学者望而却步。\n\n    而有了Spring Boot，一切将会简单而优雅。\n\n    本文将从Hello World做起，搭建一个简单的Spring Boot Web项目。\n\n1. File——New——Project（Moudle）\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/1.png)\n\n*注意*: 图中的https://start.spring.io/，也可以直接打开，在网站上直接生成项目下载，用idea打开也是一样的。\n\n2. Next将看到以下界面\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/2.png)\n\n3. 继续下一步，选择Web->Spring Boot，在这里我们可以选择Spring Boot版本\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/3.png)\n\n4. 继续下一步\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/4.png)\n\n5. 点击完成将看到如下目录结构\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/5.png)\n\n至此，一个Spring Boot项目就创建完成。\n\n### 三、项目结构说明\n\n1. 项目结构中主要目录说明大致如下\n\n```\n->spring-boot-web\t\t\t\t\t\t (项目或模块)\n---> src\n----->main\n------->java\t\t\t\t\t\t\t (Java代码目录)\n--------->spring.boot.web\t\t\t\t  (包spring.boot.web)\n----------->SpringBootWebApplication\t   (Spring Boot启动类)\n------->resources\n--------->static\t\t\t\t\t\t (静态资源目录)\n--------->templates\t\t\t\t\t\t (视图模板目录)\n--------->application.properties\t\t  (项目配置文件)\n------->test\t\t\t\t\t\t\t(测试)\n--------->java\t\t\t\t\t\t\n----------->spring.boot.web\n----------->SpringBootWebApplicationTests  (Spring Boot测试启动类)\n--->pom.xml\t\t\t\t\t\t\t\t(maven pom配置文件)\n```\n\n2. pom文件说明\n\n*&nbsp;&nbsp;&nbsp;&nbsp;pom.xml*，它是maven来管理各种jar包依赖的一个配置文件，maven相当于.net中的nuget，是一个包管理工具。我们可以看到项目搭建好之后，就默认为我们加上了下面这些配置。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <!--父节点配置了Spring Boot的一些信息，父节点代表子节点可以继承父节点的一些配置，如版本号，在这里配置了就不用在子节点配置了-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.8.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <!--项目信息-->\n    <groupId>spring.boot.examples</groupId>\n    <artifactId>spring-boot-web</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>spring-boot-web</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <!--依赖的包配置在下面这个节点-->\n    <dependencies>\n        <!--引入Spring Boot Web模块-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\t\t<!--引入Spring Boot 测试模块-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <!--Spring Boot Maven 插件-->\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n```\n\n3. Spring Boot启动类\n\n```java\npackage spring.boot.web;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringBootWebApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootWebApplication.class, args);\n    }\n\n}\n\n```\n\n启动类是Spring Boot程序的入口。\n\n### 四、Hello World\n\n1. 新建控制器\n\n   我们在spring.boot.web下建一个controller包，包内新建HelloWorld类\n\n   ```java\n   package spring.boot.web.controller;\n   \n   import org.springframework.web.bind.annotation.RequestMapping;\n   import org.springframework.web.bind.annotation.RestController;\n   \n   @RestController\n   public class HelloWorld {\n   \n       @RequestMapping(\"/helloWorld\")\n       public String Hello() {\n           return \"Hello World!\";\n       }\n   }\n   \n   ```\n\n   这里有两个注解：\n\n   `@RestController`的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！\n\n   `@RequestMapping`配置Url映射\n\n2. 启动Spring Boot项目\n\n   由于Spring Boot项目内置Tomcat服务器，我们不需要在部署到Tomcat。只需要要在配置文件application.properties里配置一下端口号，然后idea->run->run。\n\n```java\n  server.port=8888\n```\n\n如下图，代表启动成功！\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/6.png)\n\n打开浏览器输入：http://localhost:8888/helloWorld\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/7.png)\n\n**至此，Hello World项目完成。于Java上，再次体验到了简洁优雅的开发！**\n\n\n\n**[示例代码](https://github.com/hunter-droid/spring-boot-examples)**\n\n","slug":"技术实践/spring-boot/Spring Boot(一) Hello World","published":1,"updated":"2021-03-14T03:04:50.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwm0080hyjf78fxnp5q","content":"<h3 id=\"一、Spring-Boot之我见\"><a href=\"#一、Spring-Boot之我见\" class=\"headerlink\" title=\"一、Spring Boot之我见\"></a>一、Spring Boot之我见</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<em>Spring Boot</em>是由Pivotal团队提供的全新框架，其设计目的是用来简化新<em>Spring</em>应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p>\n<a id=\"more\"></a>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;这是百科上对Spring Boot的说明。实际上在我看来Spring Boot就是Spring等一系列的java技术栈框架的组合加上约定大于配置的思想。它并不是一项新的技术也不是一个新的框架，而是各种技术的一个组合，它默认配置了很多框架的使用方式。它的出现，极大的提高了java应用的开发效率。其特性就是轻量级、可插拔、微服务。同时idea和spring boot的出现也颠覆了我一个.net程序员曾经对java的认知（我是.net出身的程序员，对于java最大的印象就是“配置”、“配置”、“配置”和难用的一笔的IDE）。原来Java项目开发也可以变得优雅起来！</p>\n<h3 id=\"二、项目搭建\"><a href=\"#二、项目搭建\" class=\"headerlink\" title=\"二、项目搭建\"></a>二、项目搭建</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在还是SSM(SSH)的时代搭建一个Web项目大概需要以下几步</p>\n<ol>\n<li><p>新建项目</p>\n</li>\n<li><p>配置Web.xml，加载Spring和Spring Mvc</p>\n</li>\n<li><p>配置数据库连接、配置Spring事务，配置mybatis</p>\n</li>\n<li><p>配置加载配置文件的读取，开启注解</p>\n</li>\n<li><p>配置日志文件</p>\n</li>\n<li><p>配置完成后部署Tomcat调试</p>\n<p>…</p>\n<p>一堆的配置，看得人头大，也让很多初学者望而却步。</p>\n<p>而有了Spring Boot，一切将会简单而优雅。</p>\n<p>本文将从Hello World做起，搭建一个简单的Spring Boot Web项目。</p>\n</li>\n</ol>\n<ol>\n<li>File——New——Project（Moudle）</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/1.png\" alt></p>\n<p><em>注意</em>: 图中的<a href=\"https://start.spring.io/，也可以直接打开，在网站上直接生成项目下载，用idea打开也是一样的。\" target=\"_blank\" rel=\"noopener\">https://start.spring.io/，也可以直接打开，在网站上直接生成项目下载，用idea打开也是一样的。</a></p>\n<ol>\n<li>Next将看到以下界面</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/2.png\" alt></p>\n<ol>\n<li>继续下一步，选择Web-&gt;Spring Boot，在这里我们可以选择Spring Boot版本</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/3.png\" alt></p>\n<ol>\n<li>继续下一步</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/4.png\" alt></p>\n<ol>\n<li>点击完成将看到如下目录结构</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/5.png\" alt></p>\n<p>至此，一个Spring Boot项目就创建完成。</p>\n<h3 id=\"三、项目结构说明\"><a href=\"#三、项目结构说明\" class=\"headerlink\" title=\"三、项目结构说明\"></a>三、项目结构说明</h3><ol>\n<li>项目结构中主要目录说明大致如下</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt;spring-boot-web\t\t\t\t\t\t (项目或模块)</span><br><span class=\"line\">---&gt; src</span><br><span class=\"line\">-----&gt;main</span><br><span class=\"line\">-------&gt;java\t\t\t\t\t\t\t (Java代码目录)</span><br><span class=\"line\">---------&gt;spring.boot.web\t\t\t\t  (包spring.boot.web)</span><br><span class=\"line\">-----------&gt;SpringBootWebApplication\t   (Spring Boot启动类)</span><br><span class=\"line\">-------&gt;resources</span><br><span class=\"line\">---------&gt;static\t\t\t\t\t\t (静态资源目录)</span><br><span class=\"line\">---------&gt;templates\t\t\t\t\t\t (视图模板目录)</span><br><span class=\"line\">---------&gt;application.properties\t\t  (项目配置文件)</span><br><span class=\"line\">-------&gt;test\t\t\t\t\t\t\t(测试)</span><br><span class=\"line\">---------&gt;java\t\t\t\t\t\t</span><br><span class=\"line\">-----------&gt;spring.boot.web</span><br><span class=\"line\">-----------&gt;SpringBootWebApplicationTests  (Spring Boot测试启动类)</span><br><span class=\"line\">---&gt;pom.xml\t\t\t\t\t\t\t\t(maven pom配置文件)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>pom文件说明</li>\n</ol>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;pom.xml</em>，它是maven来管理各种jar包依赖的一个配置文件，maven相当于.net中的nuget，是一个包管理工具。我们可以看到项目搭建好之后，就默认为我们加上了下面这些配置。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--父节点配置了Spring Boot的一些信息，父节点代表子节点可以继承父节点的一些配置，如版本号，在这里配置了就不用在子节点配置了--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.1.8.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">relativePath</span>/&gt;</span> <span class=\"comment\">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--项目信息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>spring.boot.examples<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>spring-boot-web<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Demo project for Spring Boot<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--依赖的包配置在下面这个节点--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--引入Spring Boot Web模块--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--引入Spring Boot 测试模块--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--Spring Boot Maven 插件--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>Spring Boot启动类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.web;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringBootWebApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(SpringBootWebApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动类是Spring Boot程序的入口。</p>\n<h3 id=\"四、Hello-World\"><a href=\"#四、Hello-World\" class=\"headerlink\" title=\"四、Hello World\"></a>四、Hello World</h3><ol>\n<li><p>新建控制器</p>\n<p>我们在spring.boot.web下建一个controller包，包内新建HelloWorld类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.web.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/helloWorld\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">Hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有两个注解：</p>\n<p><code>@RestController</code>的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！</p>\n<p><code>@RequestMapping</code>配置Url映射</p>\n</li>\n<li><p>启动Spring Boot项目</p>\n<p>由于Spring Boot项目内置Tomcat服务器，我们不需要在部署到Tomcat。只需要要在配置文件application.properties里配置一下端口号，然后idea-&gt;run-&gt;run。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">8888</span></span><br></pre></td></tr></table></figure>\n<p>如下图，代表启动成功！</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/6.png\" alt></p>\n<p>打开浏览器输入：<a href=\"http://localhost:8888/helloWorld\" target=\"_blank\" rel=\"noopener\">http://localhost:8888/helloWorld</a></p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/7.png\" alt></p>\n<p><strong>至此，Hello World项目完成。于Java上，再次体验到了简洁优雅的开发！</strong></p>\n<p><strong><a href=\"https://github.com/hunter-droid/spring-boot-examples\" target=\"_blank\" rel=\"noopener\">示例代码</a></strong></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、Spring-Boot之我见\"><a href=\"#一、Spring-Boot之我见\" class=\"headerlink\" title=\"一、Spring Boot之我见\"></a>一、Spring Boot之我见</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<em>Spring Boot</em>是由Pivotal团队提供的全新框架，其设计目的是用来简化新<em>Spring</em>应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p>","more":"<p>&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;这是百科上对Spring Boot的说明。实际上在我看来Spring Boot就是Spring等一系列的java技术栈框架的组合加上约定大于配置的思想。它并不是一项新的技术也不是一个新的框架，而是各种技术的一个组合，它默认配置了很多框架的使用方式。它的出现，极大的提高了java应用的开发效率。其特性就是轻量级、可插拔、微服务。同时idea和spring boot的出现也颠覆了我一个.net程序员曾经对java的认知（我是.net出身的程序员，对于java最大的印象就是“配置”、“配置”、“配置”和难用的一笔的IDE）。原来Java项目开发也可以变得优雅起来！</p>\n<h3 id=\"二、项目搭建\"><a href=\"#二、项目搭建\" class=\"headerlink\" title=\"二、项目搭建\"></a>二、项目搭建</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在还是SSM(SSH)的时代搭建一个Web项目大概需要以下几步</p>\n<ol>\n<li><p>新建项目</p>\n</li>\n<li><p>配置Web.xml，加载Spring和Spring Mvc</p>\n</li>\n<li><p>配置数据库连接、配置Spring事务，配置mybatis</p>\n</li>\n<li><p>配置加载配置文件的读取，开启注解</p>\n</li>\n<li><p>配置日志文件</p>\n</li>\n<li><p>配置完成后部署Tomcat调试</p>\n<p>…</p>\n<p>一堆的配置，看得人头大，也让很多初学者望而却步。</p>\n<p>而有了Spring Boot，一切将会简单而优雅。</p>\n<p>本文将从Hello World做起，搭建一个简单的Spring Boot Web项目。</p>\n</li>\n</ol>\n<ol>\n<li>File——New——Project（Moudle）</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/1.png\" alt></p>\n<p><em>注意</em>: 图中的<a href=\"https://start.spring.io/，也可以直接打开，在网站上直接生成项目下载，用idea打开也是一样的。\" target=\"_blank\" rel=\"noopener\">https://start.spring.io/，也可以直接打开，在网站上直接生成项目下载，用idea打开也是一样的。</a></p>\n<ol>\n<li>Next将看到以下界面</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/2.png\" alt></p>\n<ol>\n<li>继续下一步，选择Web-&gt;Spring Boot，在这里我们可以选择Spring Boot版本</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/3.png\" alt></p>\n<ol>\n<li>继续下一步</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/4.png\" alt></p>\n<ol>\n<li>点击完成将看到如下目录结构</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/5.png\" alt></p>\n<p>至此，一个Spring Boot项目就创建完成。</p>\n<h3 id=\"三、项目结构说明\"><a href=\"#三、项目结构说明\" class=\"headerlink\" title=\"三、项目结构说明\"></a>三、项目结构说明</h3><ol>\n<li>项目结构中主要目录说明大致如下</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt;spring-boot-web\t\t\t\t\t\t (项目或模块)</span><br><span class=\"line\">---&gt; src</span><br><span class=\"line\">-----&gt;main</span><br><span class=\"line\">-------&gt;java\t\t\t\t\t\t\t (Java代码目录)</span><br><span class=\"line\">---------&gt;spring.boot.web\t\t\t\t  (包spring.boot.web)</span><br><span class=\"line\">-----------&gt;SpringBootWebApplication\t   (Spring Boot启动类)</span><br><span class=\"line\">-------&gt;resources</span><br><span class=\"line\">---------&gt;static\t\t\t\t\t\t (静态资源目录)</span><br><span class=\"line\">---------&gt;templates\t\t\t\t\t\t (视图模板目录)</span><br><span class=\"line\">---------&gt;application.properties\t\t  (项目配置文件)</span><br><span class=\"line\">-------&gt;test\t\t\t\t\t\t\t(测试)</span><br><span class=\"line\">---------&gt;java\t\t\t\t\t\t</span><br><span class=\"line\">-----------&gt;spring.boot.web</span><br><span class=\"line\">-----------&gt;SpringBootWebApplicationTests  (Spring Boot测试启动类)</span><br><span class=\"line\">---&gt;pom.xml\t\t\t\t\t\t\t\t(maven pom配置文件)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>pom文件说明</li>\n</ol>\n<p><em>&nbsp;&nbsp;&nbsp;&nbsp;pom.xml</em>，它是maven来管理各种jar包依赖的一个配置文件，maven相当于.net中的nuget，是一个包管理工具。我们可以看到项目搭建好之后，就默认为我们加上了下面这些配置。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--父节点配置了Spring Boot的一些信息，父节点代表子节点可以继承父节点的一些配置，如版本号，在这里配置了就不用在子节点配置了--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.1.8.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">relativePath</span>/&gt;</span> <span class=\"comment\">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--项目信息--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>spring.boot.examples<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>spring-boot-web<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Demo project for Spring Boot<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--依赖的包配置在下面这个节点--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--引入Spring Boot Web模块--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--引入Spring Boot 测试模块--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--Spring Boot Maven 插件--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>Spring Boot启动类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.web;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringBootWebApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(SpringBootWebApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动类是Spring Boot程序的入口。</p>\n<h3 id=\"四、Hello-World\"><a href=\"#四、Hello-World\" class=\"headerlink\" title=\"四、Hello World\"></a>四、Hello World</h3><ol>\n<li><p>新建控制器</p>\n<p>我们在spring.boot.web下建一个controller包，包内新建HelloWorld类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.web.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/helloWorld\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">Hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有两个注解：</p>\n<p><code>@RestController</code>的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！</p>\n<p><code>@RequestMapping</code>配置Url映射</p>\n</li>\n<li><p>启动Spring Boot项目</p>\n<p>由于Spring Boot项目内置Tomcat服务器，我们不需要在部署到Tomcat。只需要要在配置文件application.properties里配置一下端口号，然后idea-&gt;run-&gt;run。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">8888</span></span><br></pre></td></tr></table></figure>\n<p>如下图，代表启动成功！</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/6.png\" alt></p>\n<p>打开浏览器输入：<a href=\"http://localhost:8888/helloWorld\" target=\"_blank\" rel=\"noopener\">http://localhost:8888/helloWorld</a></p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/HelloWorld/7.png\" alt></p>\n<p><strong>至此，Hello World项目完成。于Java上，再次体验到了简洁优雅的开发！</strong></p>\n<p><strong><a href=\"https://github.com/hunter-droid/spring-boot-examples\" target=\"_blank\" rel=\"noopener\">示例代码</a></strong></p>"},{"title":"Spring Boot(三) 使用Lombok","copyright":true,"date":"2020-03-19T10:23:18.000Z","keywords":"Spring Boot","aside":"SpringBoot","_content":"&nbsp;&nbsp;&nbsp;&nbsp;C#写的多了用习惯了众多的语法糖，再写起来Java总会有一些非常不舒服的地方。比如用惯了C#的属性在用起来Java的属性，写起来就会感觉不够优雅。\n\n<!--more-->\n\n如:定义一个`Person`类\n\n```c#\n    public class Person\n    {\n        public string Name { get; set; }\n\n        public int Age { get; set; }  \n\n        public string Describe { get; set; }\n\n    }\n```\n\n而同样的代码，java写起来就...\n\n```java\n\npublic class Person {\n\n    private String name;\n\n    private Integer age;\n\n    private String escribe;\n\n    public Person() {\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public String getEscribe() {\n        return escribe;\n    }\n\n    public void setEscribe(String escribe) {\n        this.escribe = escribe;\n    }\n\n}\n```\n\n为了能够更优雅的编码，我们可以使用Lombok\n\n### 一、Lombok介绍\n\n&nbsp;&nbsp;&nbsp;&nbsp;Lombok是一个Java库，能自动插入编辑器并构建工具，简化Java开发。通过添加注解的方式，不需要为类编写getter或equals方法，同时可以自动化日志变量...[官网链接](https://www.projectlombok.org/)\n\n​\t简单来说，这玩意能以简单注解的方式简化Java代码，以提高开发效率\n\n### 二、 项目中引入Lombok\n\n1. 添加maven依赖\n\n```xml\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.10</version>\n    <scope>provided</scope>\n</dependency>\n```\n\n2. 创建一个`Person`类，并为其加上`@Data`注解\n\n```java\npackage spring.boot.lombok.model;\n\nimport lombok.Data;\n\n@Data\npublic class Person_Lombok {\n\n    private String name;\n\n    private Integer age;\n\n    private String describe;\n}\n```\n\n3. 安装idea插件\n\n使用Lombok还需要插件的配合，打开idea的设置，点击**Plugins**，点击**Browse repositories**，在弹出的窗口中搜索**lombok**，然后安装即可。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/1.png)\n\n编译时出错，可能是没有enable注解处理器。`Annotation Processors > Enable annotation processing`。设置完成之后程序正常运行。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/2.png)\n\n4. 测试运行\n\n```java\npackage spring.boot.lombok;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\nimport spring.boot.lombok.model.Person_Lombok;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Person_LombokTests {\n\n    @Autowired\n    public Person_Lombok person;\n\n    @Test\n    public void Test() {\n        person.setName(\"王小二\");\n        person.setAge(19);\n        person.setDescribe(\"豆蔻年华，正青春！\");\n        Assert.assertTrue(person.getAge() == 19);\n    }\n}\n\n```\n\n\n\n### 三、Lombok常用注解\n\n- `@Setter` 注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。\n- `@Getter` 使用方法同上，区别在于生成的是getter方法。\n- `@ToString` 注解在类，添加toString方法。\n- `@EqualsAndHashCode` 注解在类，生成hashCode和equals方法。\n- `@NoArgsConstructor` 注解在类，生成无参的构造方法。\n- `@RequiredArgsConstructor` 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。\n- `@AllArgsConstructor` 注解在类，生成包含类中所有字段的构造方法。\n- `@Data` 注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。\n- `@Slf4j` 注解在类，生成log变量，严格意义来说是常量。private static final Logger log = LoggerFactory.getLogger(UserController.class);\n- `@NonNull`给方法参数增加这个注解会自动在方法内对该参数进行是否为空的校验，如果为空，则抛出NPE（NullPointerException）\n- `@Cleanup`自动管理资源，用在局部变量之前，在当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成try-finally这样的代码来关闭流\n- `@Synchronized`用在方法上，将方法声明为同步的，并自动加锁，而锁对象是一个私有的属性$lock或$LOCK，而java中的synchronized关键字锁对象是this，锁在this或者自己的类对象上存在副作用，就是你不能阻止非受控代码去锁this或者类对象，这可能会导致竞争条件或者其它线程错误\n- `@SneakyThrows`自动抛受检异常，而无需显式在方法上使用throws语句\n\n### 四、Lombok原理解析\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们可以反编译一下，idea为我们生成的.class文件，\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/3.png)\n\n可以看到虽然使用了lombok后我们没有写get,set等方法，但是是因为idea安装了lombok的插件，在编译的时候帮我们生成了这些方法。\n\n在Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。\n\n- 运行时解析\n\n运行时能够解析的注解，必须将`@Retention`设置为`RUNTIME`，这样就可以通过反射拿到该注解。`java.lang.reflect`反射包中提供了一个接口`AnnotatedElement`，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口。\n\n- 编译时解析\n\n编译时解析有两种机制，分别简单描述下：\n\n1）Annotation Processing Tool\n\napt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因：\n\n- api都在com.sun.mirror非标准包下\n- 没有集成到javac中，需要额外运行\n\n2）Pluggable Annotation Processing API\n\n`JSR 269`自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，javac执行的过程如下：\n\n\n\n![img](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/4.png)\n\n`Lombok`本质上就是一个实现了`JSR 269 API`的程序。在使用javac的过程中，它产生作用的具体流程如下：\n\n1. `javac`对源代码进行分析，生成了一棵抽象语法树（AST）\n2. 运行过程中调用实现了`JSR 269 API`的`Lombok`程序\n3. 此时`Lombok`就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树AST，然后修改该语法树AST，增加getter和setter方法定义的相应树节点\n4. `javac`使用修改后的抽象语法树AST生成字节码文件，即给class增加新的节点（代码块）\n\n### 五、Lombok优缺点\n\n**优点：**\n\n* 能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率\n\n* 让代码变得简洁，不用过多的去关注相应的方法\n\n* 属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等\n\n**缺点：**\n\n* 不支持多种参数构造器的重载\n\n* 虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性。\n\n\n\n**[示例代码](https://github.com/hunter-droid/spring-boot-examples)**\n\n","source":"_posts/技术实践/spring-boot/Spring Boot(三) 使用Lombok.md","raw":"---\ntitle: Spring Boot(三) 使用Lombok\ncopyright: true\ndate: 2020-03-19 18:23:18\ncategories: \n- Spring Boot\nkeywords: Spring Boot\naside: SpringBoot\n---\n&nbsp;&nbsp;&nbsp;&nbsp;C#写的多了用习惯了众多的语法糖，再写起来Java总会有一些非常不舒服的地方。比如用惯了C#的属性在用起来Java的属性，写起来就会感觉不够优雅。\n\n<!--more-->\n\n如:定义一个`Person`类\n\n```c#\n    public class Person\n    {\n        public string Name { get; set; }\n\n        public int Age { get; set; }  \n\n        public string Describe { get; set; }\n\n    }\n```\n\n而同样的代码，java写起来就...\n\n```java\n\npublic class Person {\n\n    private String name;\n\n    private Integer age;\n\n    private String escribe;\n\n    public Person() {\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public String getEscribe() {\n        return escribe;\n    }\n\n    public void setEscribe(String escribe) {\n        this.escribe = escribe;\n    }\n\n}\n```\n\n为了能够更优雅的编码，我们可以使用Lombok\n\n### 一、Lombok介绍\n\n&nbsp;&nbsp;&nbsp;&nbsp;Lombok是一个Java库，能自动插入编辑器并构建工具，简化Java开发。通过添加注解的方式，不需要为类编写getter或equals方法，同时可以自动化日志变量...[官网链接](https://www.projectlombok.org/)\n\n​\t简单来说，这玩意能以简单注解的方式简化Java代码，以提高开发效率\n\n### 二、 项目中引入Lombok\n\n1. 添加maven依赖\n\n```xml\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.10</version>\n    <scope>provided</scope>\n</dependency>\n```\n\n2. 创建一个`Person`类，并为其加上`@Data`注解\n\n```java\npackage spring.boot.lombok.model;\n\nimport lombok.Data;\n\n@Data\npublic class Person_Lombok {\n\n    private String name;\n\n    private Integer age;\n\n    private String describe;\n}\n```\n\n3. 安装idea插件\n\n使用Lombok还需要插件的配合，打开idea的设置，点击**Plugins**，点击**Browse repositories**，在弹出的窗口中搜索**lombok**，然后安装即可。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/1.png)\n\n编译时出错，可能是没有enable注解处理器。`Annotation Processors > Enable annotation processing`。设置完成之后程序正常运行。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/2.png)\n\n4. 测试运行\n\n```java\npackage spring.boot.lombok;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\nimport spring.boot.lombok.model.Person_Lombok;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Person_LombokTests {\n\n    @Autowired\n    public Person_Lombok person;\n\n    @Test\n    public void Test() {\n        person.setName(\"王小二\");\n        person.setAge(19);\n        person.setDescribe(\"豆蔻年华，正青春！\");\n        Assert.assertTrue(person.getAge() == 19);\n    }\n}\n\n```\n\n\n\n### 三、Lombok常用注解\n\n- `@Setter` 注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。\n- `@Getter` 使用方法同上，区别在于生成的是getter方法。\n- `@ToString` 注解在类，添加toString方法。\n- `@EqualsAndHashCode` 注解在类，生成hashCode和equals方法。\n- `@NoArgsConstructor` 注解在类，生成无参的构造方法。\n- `@RequiredArgsConstructor` 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。\n- `@AllArgsConstructor` 注解在类，生成包含类中所有字段的构造方法。\n- `@Data` 注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。\n- `@Slf4j` 注解在类，生成log变量，严格意义来说是常量。private static final Logger log = LoggerFactory.getLogger(UserController.class);\n- `@NonNull`给方法参数增加这个注解会自动在方法内对该参数进行是否为空的校验，如果为空，则抛出NPE（NullPointerException）\n- `@Cleanup`自动管理资源，用在局部变量之前，在当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成try-finally这样的代码来关闭流\n- `@Synchronized`用在方法上，将方法声明为同步的，并自动加锁，而锁对象是一个私有的属性$lock或$LOCK，而java中的synchronized关键字锁对象是this，锁在this或者自己的类对象上存在副作用，就是你不能阻止非受控代码去锁this或者类对象，这可能会导致竞争条件或者其它线程错误\n- `@SneakyThrows`自动抛受检异常，而无需显式在方法上使用throws语句\n\n### 四、Lombok原理解析\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们可以反编译一下，idea为我们生成的.class文件，\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/3.png)\n\n可以看到虽然使用了lombok后我们没有写get,set等方法，但是是因为idea安装了lombok的插件，在编译的时候帮我们生成了这些方法。\n\n在Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。\n\n- 运行时解析\n\n运行时能够解析的注解，必须将`@Retention`设置为`RUNTIME`，这样就可以通过反射拿到该注解。`java.lang.reflect`反射包中提供了一个接口`AnnotatedElement`，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口。\n\n- 编译时解析\n\n编译时解析有两种机制，分别简单描述下：\n\n1）Annotation Processing Tool\n\napt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因：\n\n- api都在com.sun.mirror非标准包下\n- 没有集成到javac中，需要额外运行\n\n2）Pluggable Annotation Processing API\n\n`JSR 269`自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，javac执行的过程如下：\n\n\n\n![img](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/4.png)\n\n`Lombok`本质上就是一个实现了`JSR 269 API`的程序。在使用javac的过程中，它产生作用的具体流程如下：\n\n1. `javac`对源代码进行分析，生成了一棵抽象语法树（AST）\n2. 运行过程中调用实现了`JSR 269 API`的`Lombok`程序\n3. 此时`Lombok`就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树AST，然后修改该语法树AST，增加getter和setter方法定义的相应树节点\n4. `javac`使用修改后的抽象语法树AST生成字节码文件，即给class增加新的节点（代码块）\n\n### 五、Lombok优缺点\n\n**优点：**\n\n* 能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率\n\n* 让代码变得简洁，不用过多的去关注相应的方法\n\n* 属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等\n\n**缺点：**\n\n* 不支持多种参数构造器的重载\n\n* 虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性。\n\n\n\n**[示例代码](https://github.com/hunter-droid/spring-boot-examples)**\n\n","slug":"技术实践/spring-boot/Spring Boot(三) 使用Lombok","published":1,"updated":"2021-03-14T03:04:50.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwn0083hyjfflo969po","content":"<p>&nbsp;&nbsp;&nbsp;&nbsp;C#写的多了用习惯了众多的语法糖，再写起来Java总会有一些非常不舒服的地方。比如用惯了C#的属性在用起来Java的属性，写起来就会感觉不够优雅。</p>\n<a id=\"more\"></a>\n<p>如:定义一个<code>Person</code>类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int Age &#123; get; set; &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    public string Describe &#123; get; set; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而同样的代码，java写起来就…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String escribe;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(Integer age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getEscribe</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> escribe;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEscribe</span><span class=\"params\">(String escribe)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.escribe = escribe;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能够更优雅的编码，我们可以使用Lombok</p>\n<h3 id=\"一、Lombok介绍\"><a href=\"#一、Lombok介绍\" class=\"headerlink\" title=\"一、Lombok介绍\"></a>一、Lombok介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Lombok是一个Java库，能自动插入编辑器并构建工具，简化Java开发。通过添加注解的方式，不需要为类编写getter或equals方法，同时可以自动化日志变量…<a href=\"https://www.projectlombok.org/\" target=\"_blank\" rel=\"noopener\">官网链接</a></p>\n<p>​    简单来说，这玩意能以简单注解的方式简化Java代码，以提高开发效率</p>\n<h3 id=\"二、-项目中引入Lombok\"><a href=\"#二、-项目中引入Lombok\" class=\"headerlink\" title=\"二、 项目中引入Lombok\"></a>二、 项目中引入Lombok</h3><ol>\n<li>添加maven依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.projectlombok<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lombok<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.18.10<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>创建一个<code>Person</code>类，并为其加上<code>@Data</code>注解</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.lombok.model;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person_Lombok</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String describe;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>安装idea插件</li>\n</ol>\n<p>使用Lombok还需要插件的配合，打开idea的设置，点击<strong>Plugins</strong>，点击<strong>Browse repositories</strong>，在弹出的窗口中搜索<strong>lombok</strong>，然后安装即可。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/1.png\" alt></p>\n<p>编译时出错，可能是没有enable注解处理器。<code>Annotation Processors &gt; Enable annotation processing</code>。设置完成之后程序正常运行。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/2.png\" alt></p>\n<ol>\n<li>测试运行</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.lombok;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Assert;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> spring.boot.lombok.model.Person_Lombok;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person_LombokTests</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Person_Lombok person;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        person.setName(<span class=\"string\">\"王小二\"</span>);</span><br><span class=\"line\">        person.setAge(<span class=\"number\">19</span>);</span><br><span class=\"line\">        person.setDescribe(<span class=\"string\">\"豆蔻年华，正青春！\"</span>);</span><br><span class=\"line\">        Assert.assertTrue(person.getAge() == <span class=\"number\">19</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、Lombok常用注解\"><a href=\"#三、Lombok常用注解\" class=\"headerlink\" title=\"三、Lombok常用注解\"></a>三、Lombok常用注解</h3><ul>\n<li><code>@Setter</code> 注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。</li>\n<li><code>@Getter</code> 使用方法同上，区别在于生成的是getter方法。</li>\n<li><code>@ToString</code> 注解在类，添加toString方法。</li>\n<li><code>@EqualsAndHashCode</code> 注解在类，生成hashCode和equals方法。</li>\n<li><code>@NoArgsConstructor</code> 注解在类，生成无参的构造方法。</li>\n<li><code>@RequiredArgsConstructor</code> 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。</li>\n<li><code>@AllArgsConstructor</code> 注解在类，生成包含类中所有字段的构造方法。</li>\n<li><code>@Data</code> 注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</li>\n<li><code>@Slf4j</code> 注解在类，生成log变量，严格意义来说是常量。private static final Logger log = LoggerFactory.getLogger(UserController.class);</li>\n<li><code>@NonNull</code>给方法参数增加这个注解会自动在方法内对该参数进行是否为空的校验，如果为空，则抛出NPE（NullPointerException）</li>\n<li><code>@Cleanup</code>自动管理资源，用在局部变量之前，在当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成try-finally这样的代码来关闭流</li>\n<li><code>@Synchronized</code>用在方法上，将方法声明为同步的，并自动加锁，而锁对象是一个私有的属性$lock或$LOCK，而java中的synchronized关键字锁对象是this，锁在this或者自己的类对象上存在副作用，就是你不能阻止非受控代码去锁this或者类对象，这可能会导致竞争条件或者其它线程错误</li>\n<li><code>@SneakyThrows</code>自动抛受检异常，而无需显式在方法上使用throws语句</li>\n</ul>\n<h3 id=\"四、Lombok原理解析\"><a href=\"#四、Lombok原理解析\" class=\"headerlink\" title=\"四、Lombok原理解析\"></a>四、Lombok原理解析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以反编译一下，idea为我们生成的.class文件，</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/3.png\" alt></p>\n<p>可以看到虽然使用了lombok后我们没有写get,set等方法，但是是因为idea安装了lombok的插件，在编译的时候帮我们生成了这些方法。</p>\n<p>在Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。</p>\n<ul>\n<li>运行时解析</li>\n</ul>\n<p>运行时能够解析的注解，必须将<code>@Retention</code>设置为<code>RUNTIME</code>，这样就可以通过反射拿到该注解。<code>java.lang.reflect</code>反射包中提供了一个接口<code>AnnotatedElement</code>，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口。</p>\n<ul>\n<li>编译时解析</li>\n</ul>\n<p>编译时解析有两种机制，分别简单描述下：</p>\n<p>1）Annotation Processing Tool</p>\n<p>apt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因：</p>\n<ul>\n<li>api都在com.sun.mirror非标准包下</li>\n<li>没有集成到javac中，需要额外运行</li>\n</ul>\n<p>2）Pluggable Annotation Processing API</p>\n<p><code>JSR 269</code>自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，javac执行的过程如下：</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/4.png\" alt=\"img\"></p>\n<p><code>Lombok</code>本质上就是一个实现了<code>JSR 269 API</code>的程序。在使用javac的过程中，它产生作用的具体流程如下：</p>\n<ol>\n<li><code>javac</code>对源代码进行分析，生成了一棵抽象语法树（AST）</li>\n<li>运行过程中调用实现了<code>JSR 269 API</code>的<code>Lombok</code>程序</li>\n<li>此时<code>Lombok</code>就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树AST，然后修改该语法树AST，增加getter和setter方法定义的相应树节点</li>\n<li><code>javac</code>使用修改后的抽象语法树AST生成字节码文件，即给class增加新的节点（代码块）</li>\n</ol>\n<h3 id=\"五、Lombok优缺点\"><a href=\"#五、Lombok优缺点\" class=\"headerlink\" title=\"五、Lombok优缺点\"></a>五、Lombok优缺点</h3><p><strong>优点：</strong></p>\n<ul>\n<li><p>能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率</p>\n</li>\n<li><p>让代码变得简洁，不用过多的去关注相应的方法</p>\n</li>\n<li><p>属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等</p>\n</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><p>不支持多种参数构造器的重载</p>\n</li>\n<li><p>虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性。</p>\n</li>\n</ul>\n<p><strong><a href=\"https://github.com/hunter-droid/spring-boot-examples\" target=\"_blank\" rel=\"noopener\">示例代码</a></strong></p>\n","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;&nbsp;&nbsp;C#写的多了用习惯了众多的语法糖，再写起来Java总会有一些非常不舒服的地方。比如用惯了C#的属性在用起来Java的属性，写起来就会感觉不够优雅。</p>","more":"<p>如:定义一个<code>Person</code>类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public string Name &#123; get; set; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int Age &#123; get; set; &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    public string Describe &#123; get; set; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而同样的代码，java写起来就…</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String escribe;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(Integer age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getEscribe</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> escribe;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEscribe</span><span class=\"params\">(String escribe)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.escribe = escribe;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能够更优雅的编码，我们可以使用Lombok</p>\n<h3 id=\"一、Lombok介绍\"><a href=\"#一、Lombok介绍\" class=\"headerlink\" title=\"一、Lombok介绍\"></a>一、Lombok介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Lombok是一个Java库，能自动插入编辑器并构建工具，简化Java开发。通过添加注解的方式，不需要为类编写getter或equals方法，同时可以自动化日志变量…<a href=\"https://www.projectlombok.org/\" target=\"_blank\" rel=\"noopener\">官网链接</a></p>\n<p>​    简单来说，这玩意能以简单注解的方式简化Java代码，以提高开发效率</p>\n<h3 id=\"二、-项目中引入Lombok\"><a href=\"#二、-项目中引入Lombok\" class=\"headerlink\" title=\"二、 项目中引入Lombok\"></a>二、 项目中引入Lombok</h3><ol>\n<li>添加maven依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.projectlombok<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lombok<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.18.10<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>创建一个<code>Person</code>类，并为其加上<code>@Data</code>注解</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.lombok.model;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person_Lombok</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String describe;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>安装idea插件</li>\n</ol>\n<p>使用Lombok还需要插件的配合，打开idea的设置，点击<strong>Plugins</strong>，点击<strong>Browse repositories</strong>，在弹出的窗口中搜索<strong>lombok</strong>，然后安装即可。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/1.png\" alt></p>\n<p>编译时出错，可能是没有enable注解处理器。<code>Annotation Processors &gt; Enable annotation processing</code>。设置完成之后程序正常运行。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/2.png\" alt></p>\n<ol>\n<li>测试运行</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.lombok;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Assert;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> spring.boot.lombok.model.Person_Lombok;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person_LombokTests</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Person_Lombok person;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        person.setName(<span class=\"string\">\"王小二\"</span>);</span><br><span class=\"line\">        person.setAge(<span class=\"number\">19</span>);</span><br><span class=\"line\">        person.setDescribe(<span class=\"string\">\"豆蔻年华，正青春！\"</span>);</span><br><span class=\"line\">        Assert.assertTrue(person.getAge() == <span class=\"number\">19</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、Lombok常用注解\"><a href=\"#三、Lombok常用注解\" class=\"headerlink\" title=\"三、Lombok常用注解\"></a>三、Lombok常用注解</h3><ul>\n<li><code>@Setter</code> 注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。</li>\n<li><code>@Getter</code> 使用方法同上，区别在于生成的是getter方法。</li>\n<li><code>@ToString</code> 注解在类，添加toString方法。</li>\n<li><code>@EqualsAndHashCode</code> 注解在类，生成hashCode和equals方法。</li>\n<li><code>@NoArgsConstructor</code> 注解在类，生成无参的构造方法。</li>\n<li><code>@RequiredArgsConstructor</code> 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。</li>\n<li><code>@AllArgsConstructor</code> 注解在类，生成包含类中所有字段的构造方法。</li>\n<li><code>@Data</code> 注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</li>\n<li><code>@Slf4j</code> 注解在类，生成log变量，严格意义来说是常量。private static final Logger log = LoggerFactory.getLogger(UserController.class);</li>\n<li><code>@NonNull</code>给方法参数增加这个注解会自动在方法内对该参数进行是否为空的校验，如果为空，则抛出NPE（NullPointerException）</li>\n<li><code>@Cleanup</code>自动管理资源，用在局部变量之前，在当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成try-finally这样的代码来关闭流</li>\n<li><code>@Synchronized</code>用在方法上，将方法声明为同步的，并自动加锁，而锁对象是一个私有的属性$lock或$LOCK，而java中的synchronized关键字锁对象是this，锁在this或者自己的类对象上存在副作用，就是你不能阻止非受控代码去锁this或者类对象，这可能会导致竞争条件或者其它线程错误</li>\n<li><code>@SneakyThrows</code>自动抛受检异常，而无需显式在方法上使用throws语句</li>\n</ul>\n<h3 id=\"四、Lombok原理解析\"><a href=\"#四、Lombok原理解析\" class=\"headerlink\" title=\"四、Lombok原理解析\"></a>四、Lombok原理解析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以反编译一下，idea为我们生成的.class文件，</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/3.png\" alt></p>\n<p>可以看到虽然使用了lombok后我们没有写get,set等方法，但是是因为idea安装了lombok的插件，在编译的时候帮我们生成了这些方法。</p>\n<p>在Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。</p>\n<ul>\n<li>运行时解析</li>\n</ul>\n<p>运行时能够解析的注解，必须将<code>@Retention</code>设置为<code>RUNTIME</code>，这样就可以通过反射拿到该注解。<code>java.lang.reflect</code>反射包中提供了一个接口<code>AnnotatedElement</code>，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口。</p>\n<ul>\n<li>编译时解析</li>\n</ul>\n<p>编译时解析有两种机制，分别简单描述下：</p>\n<p>1）Annotation Processing Tool</p>\n<p>apt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因：</p>\n<ul>\n<li>api都在com.sun.mirror非标准包下</li>\n<li>没有集成到javac中，需要额外运行</li>\n</ul>\n<p>2）Pluggable Annotation Processing API</p>\n<p><code>JSR 269</code>自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，javac执行的过程如下：</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%B8%89%29%20%E4%BD%BF%E7%94%A8Lombok/4.png\" alt=\"img\"></p>\n<p><code>Lombok</code>本质上就是一个实现了<code>JSR 269 API</code>的程序。在使用javac的过程中，它产生作用的具体流程如下：</p>\n<ol>\n<li><code>javac</code>对源代码进行分析，生成了一棵抽象语法树（AST）</li>\n<li>运行过程中调用实现了<code>JSR 269 API</code>的<code>Lombok</code>程序</li>\n<li>此时<code>Lombok</code>就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树AST，然后修改该语法树AST，增加getter和setter方法定义的相应树节点</li>\n<li><code>javac</code>使用修改后的抽象语法树AST生成字节码文件，即给class增加新的节点（代码块）</li>\n</ol>\n<h3 id=\"五、Lombok优缺点\"><a href=\"#五、Lombok优缺点\" class=\"headerlink\" title=\"五、Lombok优缺点\"></a>五、Lombok优缺点</h3><p><strong>优点：</strong></p>\n<ul>\n<li><p>能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率</p>\n</li>\n<li><p>让代码变得简洁，不用过多的去关注相应的方法</p>\n</li>\n<li><p>属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等</p>\n</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><p>不支持多种参数构造器的重载</p>\n</li>\n<li><p>虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性。</p>\n</li>\n</ul>\n<p><strong><a href=\"https://github.com/hunter-droid/spring-boot-examples\" target=\"_blank\" rel=\"noopener\">示例代码</a></strong></p>"},{"title":"Spring Boot(二) 配置文件","copyright":true,"date":"2020-03-19T07:23:18.000Z","keywords":"Spring Boot","aside":"SpringBoot","_content":"### 一、配置Spring Boot热部署\n\n&nbsp;&nbsp;&nbsp;&nbsp;技术的发展总是因为人们想偷懒的心理，如果我们不想每次修改了代码，都必须重启一下服务器，并重新运行代码。那么可以配置一下热部署。有了它之后，修改了代码只需要重新build一下，就可以看到效果了，不需要重启服务器。\n\n<!--more-->\n\n#### 1.配置热部署\n\n1. pom.xml文件中添加如下依赖：\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>            \t\t                     <optional>true</optional>\n        </dependency>\n```\n\n2. 修改pom.xml文件\n\n```xml\n <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                \t<!--开启热部署-->\n                    <fork>true</fork>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n```\n\n修改pom.xml文件后，idea会弹出一个让你自动导入包的文件，点击`Import Changes`。就会自动将jar包下载到依赖库中。\n\n如此，就实现了Spring Boot的热部署，此时修改我们的代码，只需重新Build一下就可以了。\n\n#### 2. 配置自动build\n\n当然，如果你更懒的话，练build都不想做，也可以在Idea中配置自动Build(自动Build仅支持Spring Boot项目)。\n\n1. 打开Idea->File->Settings...可以看到如下界面\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/1.png)\n\n选中上图中的`Build Project automatical`\n\n2. 按组合键`Shift+ALT+Ctrl+/`选择`Registry`可以看到如下界面\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2.png)\n\n选中上图中的`complier.automake.allow.when.app.running`\n\n如此，修改我们的代码后，无需重新build也无需重新重启。\n\n### 二、Spring Boot读取配置文件\n\n1. 修改我们的配置文件`application.properties`\n\n```xml\nserver.port=8888\n\n<!--网站配置-->\nwebsite.name=Loading\nwebsite.domin=www.loading.ink\nwebsite.title=我的博客网站\nwebsite.description=分享我的生活和技术\n```\n\n2. 新建配置文件类`WebSiteConfig`\n\n```java\npackage spring.boot.web.config;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.PropertySource;\n\nimport java.text.MessageFormat;\n\n@Configuration\n//@ConfigurationProperties(prefix = \"website\")\n//要读取的配置文件地址\n@PropertySource(value = \"classpath:application.properties\")\npublic class WebSiteConfig {\n    @Value(\"${website.title}\")\n    private String title;\n    @Value(\"${website.domain}\")\n    private String domain;\n    @Value(\"${website.description}\")\n    private String description;\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getDomain() {\n        return domain;\n    }\n\n    public void setDomain(String domain) {\n        this.domain = domain;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    @Override\n    public String toString() {\n        return MessageFormat.format(\"Title:{0} Domin:{1} Description:{2}\", title, domain, description);\n    }\n}\n\n```\n\n读取配置文件中的配置有两种方式\n\n1.`@ConfigurationProperties(prefix = \"website\")`用于绑定属性，其中prefix表示所绑定的属性的前缀。如果配置文件中的配置和属性名一致可以用此种方式\n\n2.`@Value(\"${website.title}\")` 绑定配置文件中的属性\n\n注意：\n\n注解`@Configuration`用于定义配置类\n\n注解`@PropertySource(value = \"classpath:application.properties\")`代表要读取配置文件的路径当配置文件是`application.properties`时，这个注解可以省略不写\n\n3. 新建`WebSiteController`\n\n```java\npackage spring.boot.web.controller;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\nimport spring.boot.web.config.WebSiteConfig;\n\n@RequestMapping(\"/website\")\n@RestController\npublic class WebSiteController {\n\n    //通过@Autowired注解注入bean\n    @Autowired\n    private WebSiteConfig webSiteConfig;\n\n    @RequestMapping(method = RequestMethod.GET)\n    public String get() {\n        return webSiteConfig.toString();\n    }\n}\n\n```\n\n4. 测试运行\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/4.png)\n\n5. 注意,如果第一次运行时遇到读取配置文件里的中文乱码的问题。其主要原因可能是因为配置文件的格式并不是utf-8的格式。此时可在idea中进行设置。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/3.png)\n\n如上图所示更改为`uft-8`，注意后面的一定要勾选上。\n\n通过上面配置后如果还不行，可以将配置文件删除后重新建一个，问题就可以解决！\n\n### 三、Spring Boot Profile\n\n&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 使用一个全局的配置文件 `application.properties` ，Spring Boot 的全局配置文件的作用是对一些默认配置的配置值进行修改。\n\n&nbsp;&nbsp;&nbsp;&nbsp;在日常开发中，我们常常会遇到一个问题。就是在不同的环境使用不同的配置。比如生产、开发、测试三个不同的环境，我们的配置肯定不一样。这时，我们就要用到Profile。\n\n&nbsp;&nbsp;&nbsp;&nbsp;`Profile` 是 Spring 用来针对不同的环境对不同的配置提供支持的，全局 `Profile` 配置使用 `application-{profile}.properties `（如 `application-dev.properties`）。通过在 `application.properties` 中设置 `spring.profiles.active = dev` 来指定活动的 `Profile`。\n\n1. 依次再目录下面新建三个配置文件，`application-dev.properties`、`application-test.properties`、`application-prod.properties`。它们分别代表开发环境、测试环境、生产环境的配置文件。\n\n```java\nserver.port=8887\n\nwebsite.title=我的博客网站--Dev\nwebsite.domain=www.loading.ink\nwebsite.description=分享我的技术与生活\n```\n\n```java\nserver.port=8886\n\nwebsite.title=我的博客网站--test\nwebsite.domain=www.loading.ink\nwebsite.description=分享我的技术与生活\n```\n\n```java\nserver.port=8885\n\nwebsite.title=我的博客网站--prod\nwebsite.domain=www.loading.ink\nwebsite.description=分享我的技术与生活\n```\n\n2. 接下来修改`application.properties`：表示，将采用application-dev.properties这个配置文件。\n\n```java\nspring.profiles.active=dev\n```\n\n测试运行我们可以看到会启动开发环境配置文件的端口8887\n\n**注意：配置文件会优先获取`Profile`中的配置，如果`Profile`中没有的配置项， 那么会直接取`application.properties中`的配置**\n\n\n\n**[示例代码](https://github.com/hunter-droid/spring-boot-examples)**\n\n","source":"_posts/技术实践/spring-boot/Spring Boot(二) 读取配置文件.md","raw":"---\ntitle: Spring Boot(二) 配置文件\ncopyright: true\ndate: 2020-03-19 15:23:18\ncategories: \n- Spring Boot\nkeywords: Spring Boot\naside: SpringBoot\n---\n### 一、配置Spring Boot热部署\n\n&nbsp;&nbsp;&nbsp;&nbsp;技术的发展总是因为人们想偷懒的心理，如果我们不想每次修改了代码，都必须重启一下服务器，并重新运行代码。那么可以配置一下热部署。有了它之后，修改了代码只需要重新build一下，就可以看到效果了，不需要重启服务器。\n\n<!--more-->\n\n#### 1.配置热部署\n\n1. pom.xml文件中添加如下依赖：\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>            \t\t                     <optional>true</optional>\n        </dependency>\n```\n\n2. 修改pom.xml文件\n\n```xml\n <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <configuration>\n                \t<!--开启热部署-->\n                    <fork>true</fork>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n```\n\n修改pom.xml文件后，idea会弹出一个让你自动导入包的文件，点击`Import Changes`。就会自动将jar包下载到依赖库中。\n\n如此，就实现了Spring Boot的热部署，此时修改我们的代码，只需重新Build一下就可以了。\n\n#### 2. 配置自动build\n\n当然，如果你更懒的话，练build都不想做，也可以在Idea中配置自动Build(自动Build仅支持Spring Boot项目)。\n\n1. 打开Idea->File->Settings...可以看到如下界面\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/1.png)\n\n选中上图中的`Build Project automatical`\n\n2. 按组合键`Shift+ALT+Ctrl+/`选择`Registry`可以看到如下界面\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2.png)\n\n选中上图中的`complier.automake.allow.when.app.running`\n\n如此，修改我们的代码后，无需重新build也无需重新重启。\n\n### 二、Spring Boot读取配置文件\n\n1. 修改我们的配置文件`application.properties`\n\n```xml\nserver.port=8888\n\n<!--网站配置-->\nwebsite.name=Loading\nwebsite.domin=www.loading.ink\nwebsite.title=我的博客网站\nwebsite.description=分享我的生活和技术\n```\n\n2. 新建配置文件类`WebSiteConfig`\n\n```java\npackage spring.boot.web.config;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.PropertySource;\n\nimport java.text.MessageFormat;\n\n@Configuration\n//@ConfigurationProperties(prefix = \"website\")\n//要读取的配置文件地址\n@PropertySource(value = \"classpath:application.properties\")\npublic class WebSiteConfig {\n    @Value(\"${website.title}\")\n    private String title;\n    @Value(\"${website.domain}\")\n    private String domain;\n    @Value(\"${website.description}\")\n    private String description;\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getDomain() {\n        return domain;\n    }\n\n    public void setDomain(String domain) {\n        this.domain = domain;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    @Override\n    public String toString() {\n        return MessageFormat.format(\"Title:{0} Domin:{1} Description:{2}\", title, domain, description);\n    }\n}\n\n```\n\n读取配置文件中的配置有两种方式\n\n1.`@ConfigurationProperties(prefix = \"website\")`用于绑定属性，其中prefix表示所绑定的属性的前缀。如果配置文件中的配置和属性名一致可以用此种方式\n\n2.`@Value(\"${website.title}\")` 绑定配置文件中的属性\n\n注意：\n\n注解`@Configuration`用于定义配置类\n\n注解`@PropertySource(value = \"classpath:application.properties\")`代表要读取配置文件的路径当配置文件是`application.properties`时，这个注解可以省略不写\n\n3. 新建`WebSiteController`\n\n```java\npackage spring.boot.web.controller;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\nimport spring.boot.web.config.WebSiteConfig;\n\n@RequestMapping(\"/website\")\n@RestController\npublic class WebSiteController {\n\n    //通过@Autowired注解注入bean\n    @Autowired\n    private WebSiteConfig webSiteConfig;\n\n    @RequestMapping(method = RequestMethod.GET)\n    public String get() {\n        return webSiteConfig.toString();\n    }\n}\n\n```\n\n4. 测试运行\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/4.png)\n\n5. 注意,如果第一次运行时遇到读取配置文件里的中文乱码的问题。其主要原因可能是因为配置文件的格式并不是utf-8的格式。此时可在idea中进行设置。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/3.png)\n\n如上图所示更改为`uft-8`，注意后面的一定要勾选上。\n\n通过上面配置后如果还不行，可以将配置文件删除后重新建一个，问题就可以解决！\n\n### 三、Spring Boot Profile\n\n&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 使用一个全局的配置文件 `application.properties` ，Spring Boot 的全局配置文件的作用是对一些默认配置的配置值进行修改。\n\n&nbsp;&nbsp;&nbsp;&nbsp;在日常开发中，我们常常会遇到一个问题。就是在不同的环境使用不同的配置。比如生产、开发、测试三个不同的环境，我们的配置肯定不一样。这时，我们就要用到Profile。\n\n&nbsp;&nbsp;&nbsp;&nbsp;`Profile` 是 Spring 用来针对不同的环境对不同的配置提供支持的，全局 `Profile` 配置使用 `application-{profile}.properties `（如 `application-dev.properties`）。通过在 `application.properties` 中设置 `spring.profiles.active = dev` 来指定活动的 `Profile`。\n\n1. 依次再目录下面新建三个配置文件，`application-dev.properties`、`application-test.properties`、`application-prod.properties`。它们分别代表开发环境、测试环境、生产环境的配置文件。\n\n```java\nserver.port=8887\n\nwebsite.title=我的博客网站--Dev\nwebsite.domain=www.loading.ink\nwebsite.description=分享我的技术与生活\n```\n\n```java\nserver.port=8886\n\nwebsite.title=我的博客网站--test\nwebsite.domain=www.loading.ink\nwebsite.description=分享我的技术与生活\n```\n\n```java\nserver.port=8885\n\nwebsite.title=我的博客网站--prod\nwebsite.domain=www.loading.ink\nwebsite.description=分享我的技术与生活\n```\n\n2. 接下来修改`application.properties`：表示，将采用application-dev.properties这个配置文件。\n\n```java\nspring.profiles.active=dev\n```\n\n测试运行我们可以看到会启动开发环境配置文件的端口8887\n\n**注意：配置文件会优先获取`Profile`中的配置，如果`Profile`中没有的配置项， 那么会直接取`application.properties中`的配置**\n\n\n\n**[示例代码](https://github.com/hunter-droid/spring-boot-examples)**\n\n","slug":"技术实践/spring-boot/Spring Boot(二) 读取配置文件","published":1,"updated":"2021-03-14T03:04:50.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwo0087hyjf1fasz2bt","content":"<h3 id=\"一、配置Spring-Boot热部署\"><a href=\"#一、配置Spring-Boot热部署\" class=\"headerlink\" title=\"一、配置Spring Boot热部署\"></a>一、配置Spring Boot热部署</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;技术的发展总是因为人们想偷懒的心理，如果我们不想每次修改了代码，都必须重启一下服务器，并重新运行代码。那么可以配置一下热部署。有了它之后，修改了代码只需要重新build一下，就可以看到效果了，不需要重启服务器。</p>\n<a id=\"more\"></a>\n<h4 id=\"1-配置热部署\"><a href=\"#1-配置热部署\" class=\"headerlink\" title=\"1.配置热部署\"></a>1.配置热部署</h4><ol>\n<li>pom.xml文件中添加如下依赖：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-devtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span>            \t\t                     <span class=\"tag\">&lt;<span class=\"name\">optional</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">optional</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>修改pom.xml文件</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">               \t<span class=\"comment\">&lt;!--开启热部署--&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">fork</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">fork</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>修改pom.xml文件后，idea会弹出一个让你自动导入包的文件，点击<code>Import Changes</code>。就会自动将jar包下载到依赖库中。</p>\n<p>如此，就实现了Spring Boot的热部署，此时修改我们的代码，只需重新Build一下就可以了。</p>\n<h4 id=\"2-配置自动build\"><a href=\"#2-配置自动build\" class=\"headerlink\" title=\"2. 配置自动build\"></a>2. 配置自动build</h4><p>当然，如果你更懒的话，练build都不想做，也可以在Idea中配置自动Build(自动Build仅支持Spring Boot项目)。</p>\n<ol>\n<li>打开Idea-&gt;File-&gt;Settings…可以看到如下界面</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/1.png\" alt></p>\n<p>选中上图中的<code>Build Project automatical</code></p>\n<ol>\n<li>按组合键<code>Shift+ALT+Ctrl+/</code>选择<code>Registry</code>可以看到如下界面</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2.png\" alt></p>\n<p>选中上图中的<code>complier.automake.allow.when.app.running</code></p>\n<p>如此，修改我们的代码后，无需重新build也无需重新重启。</p>\n<h3 id=\"二、Spring-Boot读取配置文件\"><a href=\"#二、Spring-Boot读取配置文件\" class=\"headerlink\" title=\"二、Spring Boot读取配置文件\"></a>二、Spring Boot读取配置文件</h3><ol>\n<li>修改我们的配置文件<code>application.properties</code></li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=8888</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--网站配置--&gt;</span></span><br><span class=\"line\">website.name=Loading</span><br><span class=\"line\">website.domin=www.loading.ink</span><br><span class=\"line\">website.title=我的博客网站</span><br><span class=\"line\">website.description=分享我的生活和技术</span><br></pre></td></tr></table></figure>\n<ol>\n<li>新建配置文件类<code>WebSiteConfig</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.web.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.MessageFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"comment\">//@ConfigurationProperties(prefix = \"website\")</span></span><br><span class=\"line\"><span class=\"comment\">//要读取的配置文件地址</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource</span>(value = <span class=\"string\">\"classpath:application.properties\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSiteConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;website.title&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;website.domain&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String domain;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;website.description&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String description;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTitle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTitle</span><span class=\"params\">(String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDomain</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> domain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDomain</span><span class=\"params\">(String domain)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.domain = domain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDescription</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> description;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDescription</span><span class=\"params\">(String description)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.description = description;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MessageFormat.format(<span class=\"string\">\"Title:&#123;0&#125; Domin:&#123;1&#125; Description:&#123;2&#125;\"</span>, title, domain, description);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>读取配置文件中的配置有两种方式</p>\n<p>1.<code>@ConfigurationProperties(prefix = &quot;website&quot;)</code>用于绑定属性，其中prefix表示所绑定的属性的前缀。如果配置文件中的配置和属性名一致可以用此种方式</p>\n<p>2.<code>@Value(&quot;${website.title}&quot;)</code> 绑定配置文件中的属性</p>\n<p>注意：</p>\n<p>注解<code>@Configuration</code>用于定义配置类</p>\n<p>注解<code>@PropertySource(value = &quot;classpath:application.properties&quot;)</code>代表要读取配置文件的路径当配置文件是<code>application.properties</code>时，这个注解可以省略不写</p>\n<ol>\n<li>新建<code>WebSiteController</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.web.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"><span class=\"keyword\">import</span> spring.boot.web.config.WebSiteConfig;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/website\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSiteController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//通过@Autowired注解注入bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WebSiteConfig webSiteConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> webSiteConfig.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>测试运行</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/4.png\" alt></p>\n<ol>\n<li>注意,如果第一次运行时遇到读取配置文件里的中文乱码的问题。其主要原因可能是因为配置文件的格式并不是utf-8的格式。此时可在idea中进行设置。</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/3.png\" alt></p>\n<p>如上图所示更改为<code>uft-8</code>，注意后面的一定要勾选上。</p>\n<p>通过上面配置后如果还不行，可以将配置文件删除后重新建一个，问题就可以解决！</p>\n<h3 id=\"三、Spring-Boot-Profile\"><a href=\"#三、Spring-Boot-Profile\" class=\"headerlink\" title=\"三、Spring Boot Profile\"></a>三、Spring Boot Profile</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 使用一个全局的配置文件 <code>application.properties</code> ，Spring Boot 的全局配置文件的作用是对一些默认配置的配置值进行修改。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;在日常开发中，我们常常会遇到一个问题。就是在不同的环境使用不同的配置。比如生产、开发、测试三个不同的环境，我们的配置肯定不一样。这时，我们就要用到Profile。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>Profile</code> 是 Spring 用来针对不同的环境对不同的配置提供支持的，全局 <code>Profile</code> 配置使用 <code>application-{profile}.properties</code>（如 <code>application-dev.properties</code>）。通过在 <code>application.properties</code> 中设置 <code>spring.profiles.active = dev</code> 来指定活动的 <code>Profile</code>。</p>\n<ol>\n<li>依次再目录下面新建三个配置文件，<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code>。它们分别代表开发环境、测试环境、生产环境的配置文件。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">8887</span></span><br><span class=\"line\"></span><br><span class=\"line\">website.title=我的博客网站--Dev</span><br><span class=\"line\">website.domain=www.loading.ink</span><br><span class=\"line\">website.description=分享我的技术与生活</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">8886</span></span><br><span class=\"line\"></span><br><span class=\"line\">website.title=我的博客网站--test</span><br><span class=\"line\">website.domain=www.loading.ink</span><br><span class=\"line\">website.description=分享我的技术与生活</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">8885</span></span><br><span class=\"line\"></span><br><span class=\"line\">website.title=我的博客网站--prod</span><br><span class=\"line\">website.domain=www.loading.ink</span><br><span class=\"line\">website.description=分享我的技术与生活</span><br></pre></td></tr></table></figure>\n<ol>\n<li>接下来修改<code>application.properties</code>：表示，将采用application-dev.properties这个配置文件。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.profiles.active=dev</span><br></pre></td></tr></table></figure>\n<p>测试运行我们可以看到会启动开发环境配置文件的端口8887</p>\n<p><strong>注意：配置文件会优先获取<code>Profile</code>中的配置，如果<code>Profile</code>中没有的配置项， 那么会直接取<code>application.properties中</code>的配置</strong></p>\n<p><strong><a href=\"https://github.com/hunter-droid/spring-boot-examples\" target=\"_blank\" rel=\"noopener\">示例代码</a></strong></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、配置Spring-Boot热部署\"><a href=\"#一、配置Spring-Boot热部署\" class=\"headerlink\" title=\"一、配置Spring Boot热部署\"></a>一、配置Spring Boot热部署</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;技术的发展总是因为人们想偷懒的心理，如果我们不想每次修改了代码，都必须重启一下服务器，并重新运行代码。那么可以配置一下热部署。有了它之后，修改了代码只需要重新build一下，就可以看到效果了，不需要重启服务器。</p>","more":"<h4 id=\"1-配置热部署\"><a href=\"#1-配置热部署\" class=\"headerlink\" title=\"1.配置热部署\"></a>1.配置热部署</h4><ol>\n<li>pom.xml文件中添加如下依赖：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-devtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span>            \t\t                     <span class=\"tag\">&lt;<span class=\"name\">optional</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">optional</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>修改pom.xml文件</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">               \t<span class=\"comment\">&lt;!--开启热部署--&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">fork</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">fork</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>修改pom.xml文件后，idea会弹出一个让你自动导入包的文件，点击<code>Import Changes</code>。就会自动将jar包下载到依赖库中。</p>\n<p>如此，就实现了Spring Boot的热部署，此时修改我们的代码，只需重新Build一下就可以了。</p>\n<h4 id=\"2-配置自动build\"><a href=\"#2-配置自动build\" class=\"headerlink\" title=\"2. 配置自动build\"></a>2. 配置自动build</h4><p>当然，如果你更懒的话，练build都不想做，也可以在Idea中配置自动Build(自动Build仅支持Spring Boot项目)。</p>\n<ol>\n<li>打开Idea-&gt;File-&gt;Settings…可以看到如下界面</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/1.png\" alt></p>\n<p>选中上图中的<code>Build Project automatical</code></p>\n<ol>\n<li>按组合键<code>Shift+ALT+Ctrl+/</code>选择<code>Registry</code>可以看到如下界面</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2.png\" alt></p>\n<p>选中上图中的<code>complier.automake.allow.when.app.running</code></p>\n<p>如此，修改我们的代码后，无需重新build也无需重新重启。</p>\n<h3 id=\"二、Spring-Boot读取配置文件\"><a href=\"#二、Spring-Boot读取配置文件\" class=\"headerlink\" title=\"二、Spring Boot读取配置文件\"></a>二、Spring Boot读取配置文件</h3><ol>\n<li>修改我们的配置文件<code>application.properties</code></li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=8888</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--网站配置--&gt;</span></span><br><span class=\"line\">website.name=Loading</span><br><span class=\"line\">website.domin=www.loading.ink</span><br><span class=\"line\">website.title=我的博客网站</span><br><span class=\"line\">website.description=分享我的生活和技术</span><br></pre></td></tr></table></figure>\n<ol>\n<li>新建配置文件类<code>WebSiteConfig</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.web.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.MessageFormat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"comment\">//@ConfigurationProperties(prefix = \"website\")</span></span><br><span class=\"line\"><span class=\"comment\">//要读取的配置文件地址</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource</span>(value = <span class=\"string\">\"classpath:application.properties\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSiteConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;website.title&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;website.domain&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String domain;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;website.description&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String description;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTitle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTitle</span><span class=\"params\">(String title)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDomain</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> domain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDomain</span><span class=\"params\">(String domain)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.domain = domain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getDescription</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> description;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDescription</span><span class=\"params\">(String description)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.description = description;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MessageFormat.format(<span class=\"string\">\"Title:&#123;0&#125; Domin:&#123;1&#125; Description:&#123;2&#125;\"</span>, title, domain, description);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>读取配置文件中的配置有两种方式</p>\n<p>1.<code>@ConfigurationProperties(prefix = &quot;website&quot;)</code>用于绑定属性，其中prefix表示所绑定的属性的前缀。如果配置文件中的配置和属性名一致可以用此种方式</p>\n<p>2.<code>@Value(&quot;${website.title}&quot;)</code> 绑定配置文件中的属性</p>\n<p>注意：</p>\n<p>注解<code>@Configuration</code>用于定义配置类</p>\n<p>注解<code>@PropertySource(value = &quot;classpath:application.properties&quot;)</code>代表要读取配置文件的路径当配置文件是<code>application.properties</code>时，这个注解可以省略不写</p>\n<ol>\n<li>新建<code>WebSiteController</code></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.web.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"><span class=\"keyword\">import</span> spring.boot.web.config.WebSiteConfig;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/website\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSiteController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//通过@Autowired注解注入bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WebSiteConfig webSiteConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> webSiteConfig.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>测试运行</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/4.png\" alt></p>\n<ol>\n<li>注意,如果第一次运行时遇到读取配置文件里的中文乱码的问题。其主要原因可能是因为配置文件的格式并不是utf-8的格式。此时可在idea中进行设置。</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E4%BA%8C%29%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/3.png\" alt></p>\n<p>如上图所示更改为<code>uft-8</code>，注意后面的一定要勾选上。</p>\n<p>通过上面配置后如果还不行，可以将配置文件删除后重新建一个，问题就可以解决！</p>\n<h3 id=\"三、Spring-Boot-Profile\"><a href=\"#三、Spring-Boot-Profile\" class=\"headerlink\" title=\"三、Spring Boot Profile\"></a>三、Spring Boot Profile</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 使用一个全局的配置文件 <code>application.properties</code> ，Spring Boot 的全局配置文件的作用是对一些默认配置的配置值进行修改。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;在日常开发中，我们常常会遇到一个问题。就是在不同的环境使用不同的配置。比如生产、开发、测试三个不同的环境，我们的配置肯定不一样。这时，我们就要用到Profile。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>Profile</code> 是 Spring 用来针对不同的环境对不同的配置提供支持的，全局 <code>Profile</code> 配置使用 <code>application-{profile}.properties</code>（如 <code>application-dev.properties</code>）。通过在 <code>application.properties</code> 中设置 <code>spring.profiles.active = dev</code> 来指定活动的 <code>Profile</code>。</p>\n<ol>\n<li>依次再目录下面新建三个配置文件，<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code>。它们分别代表开发环境、测试环境、生产环境的配置文件。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">8887</span></span><br><span class=\"line\"></span><br><span class=\"line\">website.title=我的博客网站--Dev</span><br><span class=\"line\">website.domain=www.loading.ink</span><br><span class=\"line\">website.description=分享我的技术与生活</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">8886</span></span><br><span class=\"line\"></span><br><span class=\"line\">website.title=我的博客网站--test</span><br><span class=\"line\">website.domain=www.loading.ink</span><br><span class=\"line\">website.description=分享我的技术与生活</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">8885</span></span><br><span class=\"line\"></span><br><span class=\"line\">website.title=我的博客网站--prod</span><br><span class=\"line\">website.domain=www.loading.ink</span><br><span class=\"line\">website.description=分享我的技术与生活</span><br></pre></td></tr></table></figure>\n<ol>\n<li>接下来修改<code>application.properties</code>：表示，将采用application-dev.properties这个配置文件。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.profiles.active=dev</span><br></pre></td></tr></table></figure>\n<p>测试运行我们可以看到会启动开发环境配置文件的端口8887</p>\n<p><strong>注意：配置文件会优先获取<code>Profile</code>中的配置，如果<code>Profile</code>中没有的配置项， 那么会直接取<code>application.properties中</code>的配置</strong></p>\n<p><strong><a href=\"https://github.com/hunter-droid/spring-boot-examples\" target=\"_blank\" rel=\"noopener\">示例代码</a></strong></p>"},{"title":"设计原则-单一职责(SRP)","copyright":true,"date":"2021-01-07T06:29:26.000Z","keywords":"设计原则单一职责(SRP)","password":"1234qwer","aside":"Notes-LargeSite","_content":"# 设计原则:单一职责(SRP)\n\n### 1 什么是单一职责(SRP)原则\n单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP。翻译过来就是：一个类或者模块只负责完成一个职责（或者功能）。\n<!--more-->\n所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。\n很多人认为这个原则是针对一个类进行描述，在我看来这里使用模块这个更加抽象的名词更为合适。在设计中，小到一个方法，大到一个模块我们都应该尽量取遵循单一职责原则。\n### 2 为什么要遵循单一职责\n相信在我们日常开发中，每个人都遇到过改了一个问题经常会引起另一个问题。其原因大多都是因为在设计上违背了单一职责原则。\n如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性，**是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。。**\n\n\n如下图，就是一个非常明显的不满足单一职责的类。我们的业务类UserService中包含了add、log、persistence三个方法，同时也包含了三个职责业务添加、日志记录、持久化。而实际上我们的业务规则可能是经常变化的，但是我们的持久化方法和日志记录是不常变化的。由于耦合在一个类中我们频繁改动的业务方法，很有可能影响到日志记录与持久化。又或者是我们日志记录和持久化方法这与业务无关的变动也很有可能影响到我们的正常的也业务逻辑。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1609808860860-d20a331d-234b-4f72-8543-56a49bc79c7c.png#align=left&display=inline&height=231&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=515&size=9132&status=done&style=none&width=515)\n正确的做法是将他们分离开来。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1609809232344-ec2f7737-b68d-4997-962b-d87c8cf0b25f.png#align=left&display=inline&height=386&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=717&size=20394&status=done&style=none&width=717)\n### 3 如何判断职责是否足够单一\n对于单一职责这一原则的定义和描述，相信每一个程序员都能张口就来。它理解起来也并不难，即我们不要设计大而全的类或模块，要尽量设计粒度小、功能单一的模块。但实际应用过程中确是非常困难的，也是一个非常有争议性的原则，原因就在于如何去判断职责是否足够单一。就像做菜一样，“放盐少许”，那么这个少许到底是多少？你与专业大厨的区别就在于对这个度的把握。\n程序设计也是如此，上面那个例子是非常简单的一眼就能区分职责。但实际开发中往往有很多场景会让你对职责是否单一的判定难以拿捏。\n如下面这个用户类是否满足单一职责呢？\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1609892468009-16965915-59de-43c4-8ef0-3e3e7a58169c.png#align=left&display=inline&height=397&margin=%5Bobject%20Object%5D&name=image.png&originHeight=397&originWidth=523&size=14504&status=done&style=none&width=523)\n我们可以看到，省市区地址信息在用户信息类里面，这种情况下你说它满足不满足似乎都有道理。这时就要根据具体的业务场景来看，如果你的业务场景中地址信息仅仅作为用户信息的一部分展示来看，这么设计就是合理的。而如果你的地址信息有一些单独的逻辑，那么就是不符合单一职责的。比如电商系统。\n此时我们就要把地址信息拆分出来\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1609892795708-6e461120-68a1-43b0-bed3-c6868a26f942.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=589&size=16056&status=done&style=none&width=589)\n再如社交系统中，也许起初地址信息只是用于用户信息的一部分来展示，但是随着业务的发展多了一些根据地址信息推荐好友等特殊的需求。那么我们就要在业务演进的过程中把类进行拆分。\n综上所述,我们可以总结出\n\n1. 不同的应用场景，对同一个类的职责是否单一的判定，是不一样的。我们需要具体场景具体分析\n1. 一个类的设计可能已经满足单一职责原则了，但可能随着需求的迭代在未来的某个时候就不再满足单一职责原则了，此时我们没必要过于未雨绸缪，过度设计。可以先满足业务需求。随着业务的发展，如果类变得越来越庞大，代码越来越多，不再满足单一职责，这个时候，再把这个类持续进行重构拆分。\n\n### 4 职责设计是否越单一越好\n我们再来思考一个问题，为了满足单一职责原则，是不是把类拆得越细就越好呢？\n比如我们常用与接口通信的类与序列化操作类\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1609893460734-9763e42c-60dd-4227-9c8b-c3ae954c7a3a.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=581&size=10746&status=done&style=none&width=581)\n这时如果我们进一步把Get、 Post, Serialize,Derialize进行拆分到两个类里面，看似更好的遵循了单一职责原则，但实际上如果我们的协议格式发生改变或者序列化方式发生改变，那么就要去更改两个类的代码，如果我们漏掉了一个，后果可想而知。\n\n### 5 不满足单一职责的坏味道\n随着开发经验的积累，我们是很容易嗅到一些不满足单一职责的坏味道的\n\n1. 类的代码行数过多\n1. 类依赖的其他类过多\n1. 过长的方法\n1. 私有方法过多\n1. 不容易给类起名字，类名中包含两个或以上的名词\n### 小结\n单一职责原则是开发中最基础，最简单，确是最难把握的一个原则，我们需要不断地学习以及大量经验的积累，才能更好的掌握它。此外没有最好的设计，只有合适的设计，我们需要结合真实的业务场景。记住：无论任何的思想与原则的最终目的是让我们的代码具有更好的可读性、可维护性、可扩展性......\n","source":"_posts/技术实践/代码的艺术/设计原则_单一职责(SRP).md","raw":"---\ntitle: 设计原则-单一职责(SRP)\ncopyright: true\ndate: 2021-01-07 14:29:26\ntags: \n- 代码的艺术\n- 设计原则\ncategories: 代码的艺术\nkeywords: 设计原则单一职责(SRP)\npassword: 1234qwer\naside: Notes-LargeSite\n---\n# 设计原则:单一职责(SRP)\n\n### 1 什么是单一职责(SRP)原则\n单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP。翻译过来就是：一个类或者模块只负责完成一个职责（或者功能）。\n<!--more-->\n所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。\n很多人认为这个原则是针对一个类进行描述，在我看来这里使用模块这个更加抽象的名词更为合适。在设计中，小到一个方法，大到一个模块我们都应该尽量取遵循单一职责原则。\n### 2 为什么要遵循单一职责\n相信在我们日常开发中，每个人都遇到过改了一个问题经常会引起另一个问题。其原因大多都是因为在设计上违背了单一职责原则。\n如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性，**是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。。**\n\n\n如下图，就是一个非常明显的不满足单一职责的类。我们的业务类UserService中包含了add、log、persistence三个方法，同时也包含了三个职责业务添加、日志记录、持久化。而实际上我们的业务规则可能是经常变化的，但是我们的持久化方法和日志记录是不常变化的。由于耦合在一个类中我们频繁改动的业务方法，很有可能影响到日志记录与持久化。又或者是我们日志记录和持久化方法这与业务无关的变动也很有可能影响到我们的正常的也业务逻辑。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1609808860860-d20a331d-234b-4f72-8543-56a49bc79c7c.png#align=left&display=inline&height=231&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=515&size=9132&status=done&style=none&width=515)\n正确的做法是将他们分离开来。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1609809232344-ec2f7737-b68d-4997-962b-d87c8cf0b25f.png#align=left&display=inline&height=386&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=717&size=20394&status=done&style=none&width=717)\n### 3 如何判断职责是否足够单一\n对于单一职责这一原则的定义和描述，相信每一个程序员都能张口就来。它理解起来也并不难，即我们不要设计大而全的类或模块，要尽量设计粒度小、功能单一的模块。但实际应用过程中确是非常困难的，也是一个非常有争议性的原则，原因就在于如何去判断职责是否足够单一。就像做菜一样，“放盐少许”，那么这个少许到底是多少？你与专业大厨的区别就在于对这个度的把握。\n程序设计也是如此，上面那个例子是非常简单的一眼就能区分职责。但实际开发中往往有很多场景会让你对职责是否单一的判定难以拿捏。\n如下面这个用户类是否满足单一职责呢？\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1609892468009-16965915-59de-43c4-8ef0-3e3e7a58169c.png#align=left&display=inline&height=397&margin=%5Bobject%20Object%5D&name=image.png&originHeight=397&originWidth=523&size=14504&status=done&style=none&width=523)\n我们可以看到，省市区地址信息在用户信息类里面，这种情况下你说它满足不满足似乎都有道理。这时就要根据具体的业务场景来看，如果你的业务场景中地址信息仅仅作为用户信息的一部分展示来看，这么设计就是合理的。而如果你的地址信息有一些单独的逻辑，那么就是不符合单一职责的。比如电商系统。\n此时我们就要把地址信息拆分出来\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1609892795708-6e461120-68a1-43b0-bed3-c6868a26f942.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=589&size=16056&status=done&style=none&width=589)\n再如社交系统中，也许起初地址信息只是用于用户信息的一部分来展示，但是随着业务的发展多了一些根据地址信息推荐好友等特殊的需求。那么我们就要在业务演进的过程中把类进行拆分。\n综上所述,我们可以总结出\n\n1. 不同的应用场景，对同一个类的职责是否单一的判定，是不一样的。我们需要具体场景具体分析\n1. 一个类的设计可能已经满足单一职责原则了，但可能随着需求的迭代在未来的某个时候就不再满足单一职责原则了，此时我们没必要过于未雨绸缪，过度设计。可以先满足业务需求。随着业务的发展，如果类变得越来越庞大，代码越来越多，不再满足单一职责，这个时候，再把这个类持续进行重构拆分。\n\n### 4 职责设计是否越单一越好\n我们再来思考一个问题，为了满足单一职责原则，是不是把类拆得越细就越好呢？\n比如我们常用与接口通信的类与序列化操作类\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1609893460734-9763e42c-60dd-4227-9c8b-c3ae954c7a3a.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=581&size=10746&status=done&style=none&width=581)\n这时如果我们进一步把Get、 Post, Serialize,Derialize进行拆分到两个类里面，看似更好的遵循了单一职责原则，但实际上如果我们的协议格式发生改变或者序列化方式发生改变，那么就要去更改两个类的代码，如果我们漏掉了一个，后果可想而知。\n\n### 5 不满足单一职责的坏味道\n随着开发经验的积累，我们是很容易嗅到一些不满足单一职责的坏味道的\n\n1. 类的代码行数过多\n1. 类依赖的其他类过多\n1. 过长的方法\n1. 私有方法过多\n1. 不容易给类起名字，类名中包含两个或以上的名词\n### 小结\n单一职责原则是开发中最基础，最简单，确是最难把握的一个原则，我们需要不断地学习以及大量经验的积累，才能更好的掌握它。此外没有最好的设计，只有合适的设计，我们需要结合真实的业务场景。记住：无论任何的思想与原则的最终目的是让我们的代码具有更好的可读性、可维护性、可扩展性......\n","slug":"技术实践/代码的艺术/设计原则_单一职责(SRP)","published":1,"updated":"2021-03-14T03:04:50.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpwr008bhyjfhe3zb4gr","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以扫描下方二维码，关注公众号，回复“密码”，即可解锁本站所有文章。</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"c95ba2d84ef2b4c25be81c3a36c1a16dcb3e15a1fbdf5ed464d644564c9b4c07\">b7643d9c41d0d9ba3a929c90d205da71374ea94563cdb37cd834982e5d5cfec80987eaf7f6d01c9ff87e1d312963ef788c442527a19cad4f0d1c99769f256f7725458e9d3b198d77ffbc205a18df0c35c95cbab55222c569c78f46d9c8964fd769913b635a23448fbbe181a282882c9f51aef718b0a2947aee02b0a3f85f527cabac01f6e93ee5c24a8ec62cf7fe460abcc9763cd2a6104d1a12a9524289fb2256f7352c72a1201e87fb40ad37f270323752e4085a1d57013340321e5fd0e0214e5d192b08a8b2fc85d2508c901a4449ccababe1164d8b530ece9b596f0307981a704dad919852033279285c422b7616c8bc981bc9ff5e60888ea738971dace2f1b842a13536e8337a26225f4340f7930944ca53be3f0682449757c5c8cbe48e57037188c3df94213fffe1d1efe5ed1a728e3d70e26dc0d5f6eb8b94aeb304986937344f98d2351cdd76ba8c2f07d4f41afab79fbea5e602c7d03d894bbcb2cf8f2fab7175d31cee947eaeb89569c7558836ac963a64f17d6323c5bc130b6fb26a6d2ccb682ae374d703c593f8187dfc7eb921f0bb29804aa55e8980c1c3b7efedcd690c78f073aa8b43959f0a2049e04c391743d6acd4a7caf094886b9a9bb431a21e3ad224b2f2f7d247607f83732553edf08a07d9f84cd21d97d92fd207ad00c8ced503936de1c4dd1c5f2e415cfa67333692a510d6cf862913e24fbb30a66a97f4705ba8f1a8d847b43b29e89d0e004531b7fe6e19f606a823349733442df7e969ff61b247d19065dff403a610b458984497d9a6d4aa1f68356acaca6d2398cd09e0c3fbc2919a03dc462cedeeb75a48fed6c12eb34b5f921ea61b018d6b3a13ce05ce044ebd26735e9037d80fa536d690119fa422222c1423242ab6c0c2de1aa48179a660ce14011220c7b237bb26dbbf2bbd05ae840ec256f144877d3e674e3db2df713faff45f14593de507f2c0d9f9916ad58a794485afbd6612ca523aa184e4a4b7b993ce518da8b7aef549e6b525d64c824a938a5d8122abc99b3083ac417e809b91d6a846bdf6c24b0e816724eaada5edda2939c74ecc0c4686fc3e7fdbc9a08ee3196e9e09dba5d49f91afa6679d5a82353025c977cd6322c1fde756bd98a9277d3c6437352da6c74eabfc78aa688933c97740634e666dc865c5d54a8e179a5de694f005ba08c786d7de8da92acbbbeeb4dbe44b0038e00b593087be3d212e032ab2a48d9192fdee976560147bf4266c9eb31bec576753c4d7d976e2e592878eefa3dd96e0bbbf0c32fe30d335a04bd2ff6d4a3017605d8db0420d41bde129adcd2ace1d750a3ae91b5c548fc69714fd39e5905dc44ffed68fef27e76c887e0e7ea2c3eeb218cbbcba56f2d4f3be87f4b93f97efd74d5009c2473490e83212ecae2d5f140095799732123cfc30f417d4925310522e04db2f09e39a25aafe83608105b7ffaa45ad082ea72614a2ce18678e57643851a9cf44e927b1c67183024ea6d9975392c3e029a81c1a821fa7c8750797dcaed3e156d73d55c6bc37657f489840841bf599d0101405c25883dd5f1b1ec89455002d16e4638d6f48a82933c1a2608e4e311ad77da9db566816f2c94a5f4fa69f87c759729a5eb517d161ea1ae0cf0ceb3e71cb95f636a9969dabe61fbe8d8e82b13cbaccd739228d9b7104b2be7388e7a9996f41deae8fdc44a1f8764dfb338a3c082f8e9ac2cad9ba1f46f87707165eb1890024b34947c00f5e81ee46753c61a710c0f2122d9b810f0c7b665b4b3ee11d853a4d1896688a765ee8273fe106345d13c7c062db3e2d25cfe5b983672d3f2d98e9b545b38f109eb3a7e42f87ffb9b102ce887e47a87e4834195543fb9c4a9bfd3143c0c0f63c6b81569549ef2c12b3f4b6aeb5e52e464ba65079f58c4e4eb3a19a9c293a10564d3944230d2a08171b64db3fd84a1bf87c7501cec159b5e15ce731fe731532dfe86d10e59501c165053e1cb105bc428bcadab9b949805356383022ffc3afeb637660a7c54702ad3b7c7a41bffa1056d40ac9d63095ff8f5af4b313488720899f0242d52cc0bf2fa7d866a2b9d79a8ae58cd19e7763f578a3a90a661a48f5782de340da21587b3ab68d038be8e5c91f5c64919624b4475e5aa28c5feb71e3a70b19a963c47da499960286ee461f997592d02717df4e7c88ef4861b943ab71a5770fb175050356bff50c6a720871355071672f895b9206f491f7de7412977f8f634974617fd694a95b7f557ba628ea20a858a38812331b5aa2271a1ab44bd504ae8a30957562b27453f7a6599968ddf35550370f0cffbf608e74eb5b6b13629cbb5302628c3ea6ea14a3e9353726dbbf427f0d3a6a95b63326dbca720e59427afc44f684856b38d793b94c071a2053cb7232c3d3e36963dbc3d63fa306f8e5f1a4e4f6c50be021ea6457e584407d4241623b05718871dfc012bda844d21ed0013e1d43277d154aa9dc122e2241797f924d746b5a51d5b93c1a909876cf7d18429b1ec7449151f3a9cb49fa9c8667b55ed74332ae83f319c09dffab85391e52fc120fe88439616bfb63409b1e5eb1bd610b5ba3b7696883b6267d5fa0a7a337fccae4b4b376d683b225a82458b05f67de96ee97be54c51916010293ca521bb20871b953377889bafbc113380130b949a6587928be894bf4f19ce3181fc0d71e7127e9c06d06019406166d03d1c9a27cfd9ff5e484ecd791b7be5616a40f2af310b81a55652c7f89cd3f70a1cb43f94f76f33b1c09a57252c1f068b1d0a0579073a55f6d6f5ab68a86384808455f7bfc8ab0ebb0ea56cc10359d98ca0c9ee61020beb17ad9ba325176d1f369bf5d6daafbcf226acff8ea233aaa0f757aafa2388790df90c431ee61edbb98551834ca88c255fc9882a427ef306223df5678e91e5a11deb00740c855d50825a1a0c1a475973b0fb373e30822a61ef0ac097045e0b4e726d8cad9ebefa9dcb0a06535d784054193348d5117015f7c34c671ef5c1a393e1a2f35a3ee9c4c5ed6e74db6c9a0f9cd9d5f4d09600b95afaa9d9540b34ba8e39d5b30928ba3ff8406d5b07d00eff4d399367d15081c778fcfe7c67dd2ba3db2bb7d665b63b287cd38966de8319ef10af14ad9e27c3158aa19401d69cd87981c93bc6f49d38fd4631b36988517a78b9ff2acea76fa0e089ecddf985ddf8ec7cc4f5b16f5fd014c99e936ba405ee9746754028fbbce8b80a60e36703ae3ea89a351da534c950bbca5ebcbedd9bcc1705bfe29bb2783a8c14713e7e21c6f43dc5802b9d56d3e556d8e0c9cc9418cabb622abe941e5570ebb3d0a76e8d9215811afd1c552791c5fbaafb264d5bb6b1520c1c60122e3f1ffcfd5dd11bb45953ea2959218129995849fb34b1fb4e48d4f0c4fd512ca5b7ac76a53ca59732184bdc2346c0aa00f0f34af8aa49b632cd86e0b6830125cf1edc25ad0f50e96cb89481eb7ec8aaf5d445f2e67c15afa92d2d6dc2bad4f52fcd50de5c08df3b3cbbaae7066bc2e35c84ecdc5eaeb63bc13d5cb48b85959ef48cb513539cd3fd8affd7bcef5349d8797edfa0654709a2d88150e5c5eb7cbfe184ed92146c408e6b30f727bb20faf9cdf141eb769dddf7daa4a17f50c9ffe472e393d8eb03aebad4703cfaf775ce6f4d55ef02cab74d60aa3b58dcb3db38aec6ceec354202ab241ab7c66da7c7537df1c26fbd73d2502f3de636ff2c14bafddf2d546b3ecda8848852e218f9cfb779d5a7a5eb20c3c859c6374755c47f9c1f5ae45f5ca37a16e3d10384001c06d3b10cc8524e96ff8b66dec5693af5f5ef6af88fc72b9bcfb5ef75a8b8379fc0706bd593191d4ca24298aa798e4e95e551dc82c2483076beb5385114431cdd54d1040196244e3fcbfbd53cc8ebfa85dc4bd092f81ef0d302f39b7fa42edd7a530bc64e656a9789d6f6ba2ab0ee3e64e29300d1acc19ea407e1dbe5bd68050ca195671b7b58b69ef229d2d3086825def5afde8b97e34454ccb7eb0fa602f2a8ef00c3903262667b987b727a1eca9fcd05ce9f53ec0c018f62f503f182388bc9bbb753dc03c2eed504cb03cfa01f90568fa7a293c153299c092568a9603264a2a697adcbb4f17e6a61004bf0defb3a94bc9794a0e84ea2795cfc2b953da573728c1e7a74b090675336260d8519281cb5f2e7804e7ce5506b04f05b7561f65d99f9b09a81c11a54c35e70d6539f0ff7205b1fcbdd5aab514f1c985f281cba2950314b40055c02224d526ff785fe4b5adcedbade06888824c1e3a0d28b93625553b464af66010b81d4904ab3d3a7358f3fd89d85507a2cb408b42b93ea654e614264281a224abe1158c124183017739cf21519306bb6fd9bb23ed64c573092cedc3483ec91efbd5a99b7f9a8e379d7756d946ac9b5741947d06492f67aa0e65c44f4958159b322d8817e6b949b8e9f5e866cb4ee4252d17767bef7355e9feeb0e86bcfbb52beb78c17c94b3021fb4ca77cf55745f1de68a7a80712cdd9e1e27a8b5e7be2426fc83204b06e0c463560be85eb7d5a3d2db4ee9820817e57cdecf9d3f7c4351c5e5d3fb19da531754ae17585fa2c86d9a9a6d10c3c0562a89c8d494cfe2cddbf0aff002c95916a8e1835c318e458cbd34d288bd5ba33bd6e86cf93efd3a25501b2d867f11aeb582d1866353efdf5b7a02636f4b539dae6d7e87646470dd77bc4b5ac3dfbbbebda73596c1b31770ed025ef1eeee583b58302dc60a149eb3b4b27084eb291bad57d3d584c42e86db241c4b639ae72de9505893c7ccd47c554189c1e7b657343b38a25c3f1c8455fa3cbf4824a11174473b5f8075df5405e3af1e053bd1fdffbfd3c4f7f1ec2adc6f7c42109a2f5df675f99cbce9409a3150e54eaec6b6e4c138452e35e259f6f5c3b36ff7c0f53a0ed74b0b1294b6845874d0237afde0acea0999e53f1523e1638214cf0b52bcb50d1be9470389dd31404c85aa2a7b626cc731a79737a8d609463a4dc1f3d135cf25409b9bbe496777f937cff553ccdac04c7459915aa7c5156a74e10a353e4f9986ccaf475588ae076a18e7a562c5f592b12e049c0d1be484f65a91708ee43c2af031fd21148d5c8f7818f7678ebb3c0a0b073adbad114cdd1d0a596db042970a6b68e4e82778f464af784b564496e5147f7f4d47f7fbf48e1f0970eb9a2907ceb148f8efe0a72bbedf890c8d867a8ccdfb7b27d36e04ac115a637177e9f0564f9d8f54f254ae3c8c311ffa316d40d99493cf5953531aa6d358546682dd87c365d06f253b175840de15d89ef692468ca3be945c57331ec3e2348ad35d321700a88ce9644080f0af64bce6c179086f05ca07f537b042f11a52eaed297ff58169da493c53d70eb46b5406ef36ab380c96135cd03f8ad4fd537b6c5d1163d0e20e9204731fa5b3647a61fb7a408ce3bd6f65d0c202f00cd356a829960107d3215fe69c3dc0315674f06ccce18767c0e9f1c3b16dc86b5016402fadf091446ecafe9984e2b5208de186059b4274f032381339f66eb2192c51597c9f1109dcbbc3a825b37006cc5151f85681d46c341dfca6619a7a7702ecd90d2322703913ea3394c072487dd30ccf95a0684a55883fbbd618838bba01d7b9dae2c918ce682c703be8d50e6464a9beb96237429563a44b6e495d5d4f43cead0e38d5d452b2aaf020e040d807742f1f4b37fbc56e13adda7f259b4e2984e112baab99a6b79876ce8c24663d9aad37ad715ea3f9162b8a7d3de3e60ffe51d7315beb52e365e4dd4741f3737e2873e078da19d7de5c2aa2230ef9613cded6ed33874c6c4b3bc109d7b616f35c6d7d3022e4714c348b9e21dc9f099aa455025a0b7efd39e7726ffbb4864319c315d79860b41a53345bb6ae9e7c28949d4d6dd6f33cb8e78252c119cc8e0908afef37393ce726ef8514a8f98ac774555af4ca62ce7b9752341c0510224f9efb18c51fbd484836d1e891be67efa2933d7f9a9788ec4dc118a9e9858f36e456391c090f4bceba46e8ceefc04755e3cbe3f2efc6416d5aeb2709abf2b07806dc509346186ff7d5f19241447be04c7f57c895393bf9b8a066c8fff0787a38a1b897abcc3a38d348ec55655bf2cd09c1e2c7937a067ecc1089b0afd0d03f97e3e085160986264d31595e6d8c60fd8e47372c1080ef54c48657cb95a670e72295afb1816b227f49d88dd82c5980cf12c59572b34b9082a689c620216dd59b4454b91cff41ef1f36d9c4e173a64363923c851b3165694eb9edbe7c10bcf7335cea298c7845aab445c4cdf238d3aa7e7a689ad169769351c11b2538fb8a74c0a8791596d83dab9f8190d8ec585b30e84bfb24f2b24f0f780287cc33154f9a2a2dcd77a5aa8489270acebdfc249c4dce6e107b247df70afd1cdacf5fed095cce13fc0f1e248aff2a591e7730da9ab5159609e8689b33b7c942c6b416253a76d046acc71f234c5eb2d59fbe610b6c781976f96c44dc533a864f7b8de81232e4f691b469f77ce57b7e37958ec9db87b73e0b24f6540f283d53fb981c633ca461c91ba0d121edec382238bdf51942dd8809cb453f25b5c56cf5caf532f82065d648535f7f3476eeebd4d581f282a5970443ce2efc1166f856676ec15a603a97761804be99365d9a26a855511a983611b96e5851d519fd9c2525b45f4928ad3f6fbab574584c921856141b6d1cf3e70c0c83e0971095283a89fd5b3be960a6fc4c35be9506badd0777c952819a56ab7fd03654a2f2b03f8e36b882e2f239fc50cf6b35aec93561157371f3cf6aa9e570cb6fde30aff9a7aeb1427798116d78367b516a80c00ec0c14ba71d40b12785930b7f501511ca01121a9f226d816722b098b62a039877c88aadebf259ec4cebdf81c126e507a3ec968d1900d17c1a01400873611dca0fe453e329936b81716eec8d6ea400cce19d167176d4ed3c38db46a19948e5b06af96a9ab149b101daec43efd9fbf6deabd28bbbb8cde5491a31876bb2b1384c94e60ce698afe8863111caf700cdcebece1ad82112acb00acf8570c7bdf9fb2f460e969fc02b4965e4dbad7e892d730dde18bb010b7dff2dd1dc7334e2a5d086650b2da43b94e50efbd0dc3c6a2638a7813e82a36f1418bbd24408eff5600871ccee7b80afa1c05afa50426a47bafb2d5b6bf00590ac1beaed7f3496d03d7f0e09fe651e6ba6d4fd6251abf7bdf26ace448dc0efd3c165d79166a66f3de995ced9576ec2a3012cadbb2d26133d1ef378948aa7c462f27755de0dc0d8328b8bcb2ed48e4b2db7d180c1c49ea4d909d8150fec3616cf20a2f06f95b8dac56efd8fb424f529ef838686ee91f401a1d3bcb4501bc3c01c6e315a53c0416d8fb975f83945460f7d41cb712212227b50e9d4bdf485fd024e0ea848568147f23c402c449f27bc4f87dadb21ae293a4cbac801249a61598ff0e383e0dbee9db093e22deb7f2a2aa4cc87ee8eee1fbe7bba57f1b91e6284c67c501a6500fe6d7815fc2a7c0a773bd62db109b3c2202f1428fad1f6aa2cea2c17a9cf5d94d6633e9c42f38beb09ad03e2d426ebb1f4cfba90c729b0fa7178bca92865ba7224115461df149900d238e940d8494074bd59fd5715bb1a103149bb8efda35af151194ae4abaa01427c712abd3d78a1cece8ae134728ad74c50611af73346b93c6f0e5a354e33fefac1d2bec5169c8997eda8d457978641c935a604392ed3b7ec03e6cfef14f540560026c1bd49f20394d5fc950ad34f21592eb16a37953c499ee00d305019d8070bdfeb3293c53f2df44fe1308925d617b854f0ac3d34776ed93369d6f33c3685b301ab05fa0937c7fba084f9670ff2b942453dbcbb4bb2d75074fc6c0e19f26e1deb00fd29c604861a64716a834d391a91e8303373875cdb61d799ef760a17f974b116738bc3d1b64c3ec147c72c1b680fdbebed9b7bd3d6df241da6443c76d61322ec9873f7a7662f24461213454993595c948d1100871782b2d3a554fd0974d815f7f5f84e4d2b1a4261ae14360e5c26e5fbd0d2ad117e41623bc2401d7c0248f90b2e3cfb9662f68cecbdc5196eac93588e12c12fc4b74b50818de9ca45447e79516056bfd0819c658342d558ab17f7ad2091cb6f5304d65de0e6ae37b86f8d0148d682db29ab76310e8f4b102e29b75a32e78f55491e458dea7d45f02f9d5dbab87e9db6b0bd4d62131f74f60acc890e6c0201d653d3116c6050c9d067519e32862b24337470afb27c1874c6a751f9bbdaa7963aa333ee6f09a7af1cbe22421083e2ab3cc402b64e51c133bb05ecda752fb6f4020248645e9a5c63d918c5f3c492ad6510dfec55489c119aecd149e1397d68770cb0583d14147b752017d1046f713939a371926bf05b66af1f238a1583de438b109e7e88cf27fee9fb31ccc4451db24c615fc716fbd92b955c4ba5861f94aaee8f36565757ae2d2d4f661b2965705ebbd3b644d2d1d7d1a5ffa58e81c117b3b8c4f1722963b853937d7dc1aa5492577c169a541d710d4b937c69088b55b5b335338f466b76ff83a1ae221d12eec1f8bd16954320b0284ed62b844c93de0df08b9d4781726be652f99efd5d858b767905f1cfa9df64e0f0f2adf7d7c185cdf91b905929dc6d96c280d8541e77a36069a43fec92da68a41c37521b14a11286f2598f78554a35c7b81b1b5615e181163abde1f989e556f3daa5f45ab4bb6db49677be03d6f6b9006d0146dcbb60b8bd30320e6dc3610e41fec977c2c616fe62a0561c91c2be84d7cd53008d55ea463b22e4a213989e53d3dc1cf03439f46bc73e09750a70f921e7dc76d5cd8f34d91c92bf8d169e346048b4dd09fab28af59f3be7a477d662f753243273431917afdf0eaff3c2876f4e9679b3b2b84220c58abf7925b7105fcdaf891a868ec696ff1ba9daa3179b20fc9737fdd16d05ceace75f2e75c307d9ba6d79be52683b521dc365cd9b106a647ccdacc99f686710e47c3718a6cd7d433051b70771479e599a30ab324e45efc959be00cba2b2d66ae21ca44ea8f1bb2c0309c4d7ea28745539f60e5a3365d1c0f8a8bd70bd0eaf089cf7965a6760237dfe2dd0db07de3cef65babd11ca1819ca7ba836cc9f733197203498ef266e251f010e86ec0afe50031dbfa543f96b308035d8dc46ee242d3c9f3344f891f2f3ddcecd7b81624c7ac37df1118a18719ba7a73a4bf7c7f34407431d625fed8bbd85deb062c82ab2e8f04369fce1be317517698149100c27f57b08b8e34532541e3e73766150bd34080f426702e30c4513ce77dc78ea83144fb627dd0e9b08eda0eb5d7e07761cbb15dc03bdcd3bbbd82f88acd4df3d5ad48045a17c95c734aa53ac8dff0f373e385b4c63cdf4ba6d1bca059066e81d4ef0afac4a826fc6a05a2c121bb37b5b66e4419b6cb310aada54b4c6a66a0e913c5b18985ef2400f1cc5da77a10bbbf577a5d8f1f2f7e2c8accce05e5c42b9cab869f9d336175deda4aab404cf1e34b08d4793b97d7860e312e7a8221043c0cda5a5f0c170a474a33fed5a471da1cffab8252ee8e9033de83dd18ca33012e153274d99385574b1401d7c26c098663a3e8365df8086beefcb20c81db84e26c94e2ab92297921ade90f91e4dcf8b6b658385fa321f36990345ec0899557cc8e98282b2aea1aaa023a0324ea1eb5339cdf11cfcebaba7c02e875fd4f0d20b0d84d51c48bd48efb75843694a8a3989510042904695f1857cf0cf162ee7bd1764996d8fd988d1295b02d89a6490a4dd48a38ec8d28f444dc460921c57a923ec16aa5aeca3edb913d09efedf13f61c3347a23a37110daa2114710d009c5e7af4d4ea5929c801c809cb07a5524e786c20b94866651ccb06ea3e2025513e3051a5998c37bf9bf0e8f82b2cdab16ee2c60f94a6d048fab57b86d7a901af5aca72c2ce5dfb393a86732eac9a3c39e1892ddc934bf50bfab4b92f8ccd7c225c85e3234c76785dd9b592fd4627665f8efee453eb22311110efc597b5008435dfdf77a482d490f0cd2fddfd416ab471173df42d8b62f66faed52632c0b05b08f208a560df0acb2953e1e5a1e0c085ce318bdcdc571572c44723ee50fb48c79cbacea85d3dd5a4cd4988db4815a8022d44b9410e62d63e1d11fad2422e5001a89413b46e2b85d16bdf87b7013d1119f185771f9ad296f019705d2b97801371a5cabb6db0bb1656ba480300da976420a931d236baecdfb5004c3102099a8d056755f8611e51c4280a76aff0b37e53f44a8eb34bcf5287a9e0ac3ac3c0a8db435bf238cbb235703343f1b73ca814ad6810d66b48adae13965be0b0350bffe4e424b8b9f07b113fee46a3dc553e8ca65c81883c705a210c22557bfca9dd387e1866793dc5481dc093beb56bd1bbc7e05233f3e01558e5f0ca2d8d93f4b017da3bb518d4ece0dbdc1488adabf5dc264d1bf72060431fc77c1d562c9c409879c76dfefee362b02ef48cb48b1e1c3e5dae77ad1eecaa0aaa0f843846431636b266d06d2cdbf5f0cde53d9cf564fb0e64d8964a6a1f4de36e08a977c6d1c04325594712013d6818499136ba621789be70bb9ffac98f8c87103936a9d8a06b1960e8f8cb8f3874743d89cca70af0e94bbb14f33578fe1d13ccdf861df56382d38a376900b17d1f825c39d0099360e9296544a375b207a745c3d4e2807311138edd9fe5464a86b9605c2fb3e01c71bef23b47af9a90477430042de4712c9648d1b11a9906c2acb1aa69cda4ea1aa13d725841a48eed67b989b24abc9d08e52a379adf4ddb6ff2d5bcfb0fb49b71e17011a7f3445b3cca6d0f495af8e99299569344844c0bc1905b7af90c8be699d4c4501d2bd9c8df4993151efc91dedc08efd4c8f46ba5f2c25c87c00b563aad3a3354c825053c12444166c3c5430478e8a18cd6d6c14a39a2bdf6351c3d80ec23003497a44e953c187539056417008855900ef578a176e7c4c14e33e55d2087c7b7f0b6db4e1585a161f57197a538ce4ea129226161b1ee6341713f2126feae1e7aabc749e1ee210e376995754cb770cf040ab005658a85676c497e9077033287c9a4058b4c40825eb7ab847910bf2c859b8f192a4d326490007207b8f322a1aa70bb85960fe739fa1691298311c5c32274814fe348fe47a6651c347d4fb45ec582d021d109d7b191cc98069d760cae1ca0a038eae900f796438cfcdce1f5e49aca7b83075096dfdbfce33bac0b83b8e3b1a1b56197eeb2f727cd7a45904fdb7b068d8577df6f5df11455f4b280d9b8168eaf9060cfa8a20b448261edfcf108ee310fe1a824504378b905bf78e8cc5f8bde79923dab36848f0b85aca348e52faa1e6d5c972d2cdd6977ee6648f0d715e90dac6fb5383b466b1c3ebbe00c86eb529d592613268c4e7e143b13a2b198f55b0d2b8e1121626948c6887dcbd2939e3f57375d96ef24669066ab5c6be5815e04313628eb5e2899a97c3f3756a68a567e82fc56fc836c6bbdfc90c8f0252d61d2977dbc193e91210eb2868743f5a8ca33395188eb153e102bcf596dacd4bc5e6d1335fec41d8d30696ef2c18928d37e0dc779a94d1ce5a354a67cc13735d0f6291944da334e5ef884142dc25f9a6f674e2df22df64a3b9044a13079133e140b75bfdbae9dbc9bbca4c58c2421d43b8b5b4f9842cc218c6683afc5ba868c98c92aa4fd3dd33016c84e5734e8b77b7faa129dc5db576a3948</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","more":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","origin":"<h1 id=\"设计原则-单一职责-SRP\"><a href=\"#设计原则-单一职责-SRP\" class=\"headerlink\" title=\"设计原则:单一职责(SRP)\"></a>设计原则:单一职责(SRP)</h1><h3 id=\"1-什么是单一职责-SRP-原则\"><a href=\"#1-什么是单一职责-SRP-原则\" class=\"headerlink\" title=\"1 什么是单一职责(SRP)原则\"></a>1 什么是单一职责(SRP)原则</h3><p>单一职责原则的英文是 Single Responsibility Principle，缩写为 SRP。翻译过来就是：一个类或者模块只负责完成一个职责（或者功能）。<br><a id=\"more\"></a><br>所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。<br>很多人认为这个原则是针对一个类进行描述，在我看来这里使用模块这个更加抽象的名词更为合适。在设计中，小到一个方法，大到一个模块我们都应该尽量取遵循单一职责原则。</p>\n<h3 id=\"2-为什么要遵循单一职责\"><a href=\"#2-为什么要遵循单一职责\" class=\"headerlink\" title=\"2 为什么要遵循单一职责\"></a>2 为什么要遵循单一职责</h3><p>相信在我们日常开发中，每个人都遇到过改了一个问题经常会引起另一个问题。其原因大多都是因为在设计上违背了单一职责原则。<br>如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性，<strong>是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。。</strong></p>\n<p>如下图，就是一个非常明显的不满足单一职责的类。我们的业务类UserService中包含了add、log、persistence三个方法，同时也包含了三个职责业务添加、日志记录、持久化。而实际上我们的业务规则可能是经常变化的，但是我们的持久化方法和日志记录是不常变化的。由于耦合在一个类中我们频繁改动的业务方法，很有可能影响到日志记录与持久化。又或者是我们日志记录和持久化方法这与业务无关的变动也很有可能影响到我们的正常的也业务逻辑。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1609808860860-d20a331d-234b-4f72-8543-56a49bc79c7c.png#align=left&amp;display=inline&amp;height=231&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=231&amp;originWidth=515&amp;size=9132&amp;status=done&amp;style=none&amp;width=515\" alt=\"image.png\"><br>正确的做法是将他们分离开来。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1609809232344-ec2f7737-b68d-4997-962b-d87c8cf0b25f.png#align=left&amp;display=inline&amp;height=386&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=386&amp;originWidth=717&amp;size=20394&amp;status=done&amp;style=none&amp;width=717\" alt=\"image.png\"></p>\n<h3 id=\"3-如何判断职责是否足够单一\"><a href=\"#3-如何判断职责是否足够单一\" class=\"headerlink\" title=\"3 如何判断职责是否足够单一\"></a>3 如何判断职责是否足够单一</h3><p>对于单一职责这一原则的定义和描述，相信每一个程序员都能张口就来。它理解起来也并不难，即我们不要设计大而全的类或模块，要尽量设计粒度小、功能单一的模块。但实际应用过程中确是非常困难的，也是一个非常有争议性的原则，原因就在于如何去判断职责是否足够单一。就像做菜一样，“放盐少许”，那么这个少许到底是多少？你与专业大厨的区别就在于对这个度的把握。<br>程序设计也是如此，上面那个例子是非常简单的一眼就能区分职责。但实际开发中往往有很多场景会让你对职责是否单一的判定难以拿捏。<br>如下面这个用户类是否满足单一职责呢？<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1609892468009-16965915-59de-43c4-8ef0-3e3e7a58169c.png#align=left&amp;display=inline&amp;height=397&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=397&amp;originWidth=523&amp;size=14504&amp;status=done&amp;style=none&amp;width=523\" alt=\"image.png\"><br>我们可以看到，省市区地址信息在用户信息类里面，这种情况下你说它满足不满足似乎都有道理。这时就要根据具体的业务场景来看，如果你的业务场景中地址信息仅仅作为用户信息的一部分展示来看，这么设计就是合理的。而如果你的地址信息有一些单独的逻辑，那么就是不符合单一职责的。比如电商系统。<br>此时我们就要把地址信息拆分出来<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1609892795708-6e461120-68a1-43b0-bed3-c6868a26f942.png#align=left&amp;display=inline&amp;height=299&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=299&amp;originWidth=589&amp;size=16056&amp;status=done&amp;style=none&amp;width=589\" alt=\"image.png\"><br>再如社交系统中，也许起初地址信息只是用于用户信息的一部分来展示，但是随着业务的发展多了一些根据地址信息推荐好友等特殊的需求。那么我们就要在业务演进的过程中把类进行拆分。<br>综上所述,我们可以总结出</p>\n<ol>\n<li>不同的应用场景，对同一个类的职责是否单一的判定，是不一样的。我们需要具体场景具体分析</li>\n<li>一个类的设计可能已经满足单一职责原则了，但可能随着需求的迭代在未来的某个时候就不再满足单一职责原则了，此时我们没必要过于未雨绸缪，过度设计。可以先满足业务需求。随着业务的发展，如果类变得越来越庞大，代码越来越多，不再满足单一职责，这个时候，再把这个类持续进行重构拆分。</li>\n</ol>\n<h3 id=\"4-职责设计是否越单一越好\"><a href=\"#4-职责设计是否越单一越好\" class=\"headerlink\" title=\"4 职责设计是否越单一越好\"></a>4 职责设计是否越单一越好</h3><p>我们再来思考一个问题，为了满足单一职责原则，是不是把类拆得越细就越好呢？<br>比如我们常用与接口通信的类与序列化操作类<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1609893460734-9763e42c-60dd-4227-9c8b-c3ae954c7a3a.png#align=left&amp;display=inline&amp;height=228&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=228&amp;originWidth=581&amp;size=10746&amp;status=done&amp;style=none&amp;width=581\" alt=\"image.png\"><br>这时如果我们进一步把Get、 Post, Serialize,Derialize进行拆分到两个类里面，看似更好的遵循了单一职责原则，但实际上如果我们的协议格式发生改变或者序列化方式发生改变，那么就要去更改两个类的代码，如果我们漏掉了一个，后果可想而知。</p>\n<h3 id=\"5-不满足单一职责的坏味道\"><a href=\"#5-不满足单一职责的坏味道\" class=\"headerlink\" title=\"5 不满足单一职责的坏味道\"></a>5 不满足单一职责的坏味道</h3><p>随着开发经验的积累，我们是很容易嗅到一些不满足单一职责的坏味道的</p>\n<ol>\n<li>类的代码行数过多</li>\n<li>类依赖的其他类过多</li>\n<li>过长的方法</li>\n<li>私有方法过多</li>\n<li>不容易给类起名字，类名中包含两个或以上的名词<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3>单一职责原则是开发中最基础，最简单，确是最难把握的一个原则，我们需要不断地学习以及大量经验的积累，才能更好的掌握它。此外没有最好的设计，只有合适的设计，我们需要结合真实的业务场景。记住：无论任何的思想与原则的最终目的是让我们的代码具有更好的可读性、可维护性、可扩展性……</li>\n</ol>\n","encrypt":true},{"title":"如何提高代码的可测试性","copyright":true,"date":"2021-01-06T03:29:26.000Z","keywords":"单元测试","_content":"\n### 1 为什么要关心可测试性\n很多公司很多人在实践单元测试中总觉的很困难的一个很重要的原因就是其代码本身不具有可测试性。他们往往会走入一个误区。面对一个几千行、逻辑混乱的方法而抓耳挠腮的想着用十八般武艺，各种框架去写这个方法的单元测试，而最终不得不以失败而告终，耗费了大量的时间却徒劳而无功。其实是他们忽略了这个方法的本身是不具有可测试性的。\n<!--more-->\n因此我们在要对一个方法进行单测之前，一定要先看一下它是不是具有可测试性，如果不具有，那么我们应该先对其进行重构以提高其可测试性。\n在可测试的设计中,你应该很容易为代码的每一段逻辑(循环、i语句和 switchi等)快速编写一个单元测试,这些单元测试具有如下属性\n\n- 运行速度快\n- 相互隔离,即每个测试可以独立运行,或者作为一组测试的一部分运行,可以按任何顺\n- 不需要进行外部配置\n- 产生稳定的通过或失败结果。这些就是FCC属性:快速、隔离、无需配置和稳定(Fast, Isolated, Configuration-fre,andConsistent)。\n\n如果编写这样的测试很困难,或者需要很长时间,那这个系统就不是一个可测试的，如果把测试看做系统的一个用户,可测试性设计就成为一种思维方式。\n### 2 可测试性设计技巧\n如果你要测试的方法真的有几百行上千行，那么我建议先用重构一书中的方法去解决它。其次关于可测试性在实践过程中是有一些技巧的。\n2.1 方法可重写\n在Java中,方法默认就是虚拟方法，可重写的。而在NET中,如果想要替换一个方法的行为,你需要明确地把方法设置为虚拟方法,才能进行重写。因此我们可以在设计之初就尽量把方法用关键字virtual标记。\n#### 2.2 面向接口设计\n如果我们的代码都能够保持面向接口设计的原则，意味着我们的依赖都是很容易被替换的，可以让我们在测试中年很容易取创造真实对象的伪对象。\n#### 2.3 避免密封类\n密封类就是将一个类封闭起来，断其子孙的一种方式。\n密封方法则不是为了防止继承而是防止重写，而且它是为了重写基类的虚方法并提供具体的实现，同时防止其后继类（派生类）再次重写该虚方法\n无论是我们的被测方法还是其依赖的方法属于一个密封类，那么意味着这个方法是不能被重写的，在测试中也就不能去替换它。因此应该尽量避免使用密封类\n#### 2.4 避免在方法内初始化对象\n很多人在写代码的时候习惯于在一个方法内部初始化对象，如下面这样\n```csharp\npublic void GetName(int userId){\n    //方法内部初始化类\n\treturn new User(userId).GetName();\n}\n```\n这样的设计其实是违背了代码的低耦合原则的，也不具有可测试性，因此我们在开发中应该尽量避免在方法中初始化另一个对象。对于外部依赖的对象可以使用依赖注入的方式。\n#### 2.5 避免直接调用静态方法\n要在测试中替换一个静态方法的行为,是非常困难的。\n要处理这种情况,我们可以使用抽取和重写的方法进行重构,把这个静态方法抽象出去。\n一个更为极端的做法是:避免使用任何的静态方法。这样的话,每一段逻辑都是一个类实例的一部分,使得这段逻辑更容易替换。有些进行单元测试或者测试驱动开发的人不喜欢使用单例,原因之一就是单例缺少可替换性。单例是静态的公共共享资源,很难重写它们。\n要完全避免使用静态方法可能会过于困难,但是你可以尝试在应用程序中尽量少使用单例或者静态方法,这样在测试时会变得容易一些。\n#### 2.6 避免在构造函数和静态构造函数中包含逻辑代码\n无论是构造函数还是静态构造函数内的逻辑同样是我们无法在测试中重写控制它的，因此我们需要避免在构造函数和静态构造函数中包含逻辑代码。\n\n关于可测试性设计虽然是有着许多技巧，但如果你掌握了代码编写的内容心法\"SOLID原则\"，并且熟练应用于编码中，其实你的代码绝大多数都是具有良好的可测试性的。\n### 3 可测试性设计的缺点\n可测试性固然可以更加方便的让我们对代码进行单元测试，但有些时候也会给我们带来一些“麻烦”。因此它也是一个颇有争议的话题。有些人认为可测试性是好的设计应该具有的特征之一。也有些认为可测试性会破坏原有的设计带来一些副作用。\n那么可测试性设计会带来哪些“麻烦”呢\n#### 3.1 工作量\n大多数情况下,设计时以可测试性为目标会增加工作量,因为比起不考虑可测试性的设计比起可测试性设计需要编写更多的代码。\n#### 3.2 复杂度\n可测试性设计有时会让人觉得,它把简单的事情过于复杂化了。有些接口的使用让你感觉很别扭或者设计公开了你未曾考虑过的类行为语义。而且,当使用了很多接口把东西进行抽象之后,如果你要浏览基础代码找到一个方法的真正实现代码,会更加困难和麻烦。\n\n#### 3.3 破坏更好的设计封装\n从一些可测试性的技巧我们可以知道有些时候为了让代码更具有可测试性，会破坏一些原有的设计原则。\n\n\n正如人月神话一书中所说，在软件开发这一行业中没有银弹。一门技术或者方法论在给我们提供了一些帮助的同时也会带来一些问题。这就**需要我们在具体使用的过程中****case by case，根据可测试性设计所带来的优缺点找到一个平衡点！**\n","source":"_posts/技术实践/单元测试/如何提高代码的可测试性.md","raw":"---\ntitle: 如何提高代码的可测试性\ncopyright: true\ndate: 2021-01-06 11:29:26\ntags: \n- 单元测试\ncategories: \n- 单元测试\nkeywords:  单元测试\n---\n\n### 1 为什么要关心可测试性\n很多公司很多人在实践单元测试中总觉的很困难的一个很重要的原因就是其代码本身不具有可测试性。他们往往会走入一个误区。面对一个几千行、逻辑混乱的方法而抓耳挠腮的想着用十八般武艺，各种框架去写这个方法的单元测试，而最终不得不以失败而告终，耗费了大量的时间却徒劳而无功。其实是他们忽略了这个方法的本身是不具有可测试性的。\n<!--more-->\n因此我们在要对一个方法进行单测之前，一定要先看一下它是不是具有可测试性，如果不具有，那么我们应该先对其进行重构以提高其可测试性。\n在可测试的设计中,你应该很容易为代码的每一段逻辑(循环、i语句和 switchi等)快速编写一个单元测试,这些单元测试具有如下属性\n\n- 运行速度快\n- 相互隔离,即每个测试可以独立运行,或者作为一组测试的一部分运行,可以按任何顺\n- 不需要进行外部配置\n- 产生稳定的通过或失败结果。这些就是FCC属性:快速、隔离、无需配置和稳定(Fast, Isolated, Configuration-fre,andConsistent)。\n\n如果编写这样的测试很困难,或者需要很长时间,那这个系统就不是一个可测试的，如果把测试看做系统的一个用户,可测试性设计就成为一种思维方式。\n### 2 可测试性设计技巧\n如果你要测试的方法真的有几百行上千行，那么我建议先用重构一书中的方法去解决它。其次关于可测试性在实践过程中是有一些技巧的。\n2.1 方法可重写\n在Java中,方法默认就是虚拟方法，可重写的。而在NET中,如果想要替换一个方法的行为,你需要明确地把方法设置为虚拟方法,才能进行重写。因此我们可以在设计之初就尽量把方法用关键字virtual标记。\n#### 2.2 面向接口设计\n如果我们的代码都能够保持面向接口设计的原则，意味着我们的依赖都是很容易被替换的，可以让我们在测试中年很容易取创造真实对象的伪对象。\n#### 2.3 避免密封类\n密封类就是将一个类封闭起来，断其子孙的一种方式。\n密封方法则不是为了防止继承而是防止重写，而且它是为了重写基类的虚方法并提供具体的实现，同时防止其后继类（派生类）再次重写该虚方法\n无论是我们的被测方法还是其依赖的方法属于一个密封类，那么意味着这个方法是不能被重写的，在测试中也就不能去替换它。因此应该尽量避免使用密封类\n#### 2.4 避免在方法内初始化对象\n很多人在写代码的时候习惯于在一个方法内部初始化对象，如下面这样\n```csharp\npublic void GetName(int userId){\n    //方法内部初始化类\n\treturn new User(userId).GetName();\n}\n```\n这样的设计其实是违背了代码的低耦合原则的，也不具有可测试性，因此我们在开发中应该尽量避免在方法中初始化另一个对象。对于外部依赖的对象可以使用依赖注入的方式。\n#### 2.5 避免直接调用静态方法\n要在测试中替换一个静态方法的行为,是非常困难的。\n要处理这种情况,我们可以使用抽取和重写的方法进行重构,把这个静态方法抽象出去。\n一个更为极端的做法是:避免使用任何的静态方法。这样的话,每一段逻辑都是一个类实例的一部分,使得这段逻辑更容易替换。有些进行单元测试或者测试驱动开发的人不喜欢使用单例,原因之一就是单例缺少可替换性。单例是静态的公共共享资源,很难重写它们。\n要完全避免使用静态方法可能会过于困难,但是你可以尝试在应用程序中尽量少使用单例或者静态方法,这样在测试时会变得容易一些。\n#### 2.6 避免在构造函数和静态构造函数中包含逻辑代码\n无论是构造函数还是静态构造函数内的逻辑同样是我们无法在测试中重写控制它的，因此我们需要避免在构造函数和静态构造函数中包含逻辑代码。\n\n关于可测试性设计虽然是有着许多技巧，但如果你掌握了代码编写的内容心法\"SOLID原则\"，并且熟练应用于编码中，其实你的代码绝大多数都是具有良好的可测试性的。\n### 3 可测试性设计的缺点\n可测试性固然可以更加方便的让我们对代码进行单元测试，但有些时候也会给我们带来一些“麻烦”。因此它也是一个颇有争议的话题。有些人认为可测试性是好的设计应该具有的特征之一。也有些认为可测试性会破坏原有的设计带来一些副作用。\n那么可测试性设计会带来哪些“麻烦”呢\n#### 3.1 工作量\n大多数情况下,设计时以可测试性为目标会增加工作量,因为比起不考虑可测试性的设计比起可测试性设计需要编写更多的代码。\n#### 3.2 复杂度\n可测试性设计有时会让人觉得,它把简单的事情过于复杂化了。有些接口的使用让你感觉很别扭或者设计公开了你未曾考虑过的类行为语义。而且,当使用了很多接口把东西进行抽象之后,如果你要浏览基础代码找到一个方法的真正实现代码,会更加困难和麻烦。\n\n#### 3.3 破坏更好的设计封装\n从一些可测试性的技巧我们可以知道有些时候为了让代码更具有可测试性，会破坏一些原有的设计原则。\n\n\n正如人月神话一书中所说，在软件开发这一行业中没有银弹。一门技术或者方法论在给我们提供了一些帮助的同时也会带来一些问题。这就**需要我们在具体使用的过程中****case by case，根据可测试性设计所带来的优缺点找到一个平衡点！**\n","slug":"技术实践/单元测试/如何提高代码的可测试性","published":1,"updated":"2021-03-21T08:32:36.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpws008ehyjffgo2a3ef","content":"<h3 id=\"1-为什么要关心可测试性\"><a href=\"#1-为什么要关心可测试性\" class=\"headerlink\" title=\"1 为什么要关心可测试性\"></a>1 为什么要关心可测试性</h3><p>很多公司很多人在实践单元测试中总觉的很困难的一个很重要的原因就是其代码本身不具有可测试性。他们往往会走入一个误区。面对一个几千行、逻辑混乱的方法而抓耳挠腮的想着用十八般武艺，各种框架去写这个方法的单元测试，而最终不得不以失败而告终，耗费了大量的时间却徒劳而无功。其实是他们忽略了这个方法的本身是不具有可测试性的。<br><a id=\"more\"></a><br>因此我们在要对一个方法进行单测之前，一定要先看一下它是不是具有可测试性，如果不具有，那么我们应该先对其进行重构以提高其可测试性。<br>在可测试的设计中,你应该很容易为代码的每一段逻辑(循环、i语句和 switchi等)快速编写一个单元测试,这些单元测试具有如下属性</p>\n<ul>\n<li>运行速度快</li>\n<li>相互隔离,即每个测试可以独立运行,或者作为一组测试的一部分运行,可以按任何顺</li>\n<li>不需要进行外部配置</li>\n<li>产生稳定的通过或失败结果。这些就是FCC属性:快速、隔离、无需配置和稳定(Fast, Isolated, Configuration-fre,andConsistent)。</li>\n</ul>\n<p>如果编写这样的测试很困难,或者需要很长时间,那这个系统就不是一个可测试的，如果把测试看做系统的一个用户,可测试性设计就成为一种思维方式。</p>\n<h3 id=\"2-可测试性设计技巧\"><a href=\"#2-可测试性设计技巧\" class=\"headerlink\" title=\"2 可测试性设计技巧\"></a>2 可测试性设计技巧</h3><p>如果你要测试的方法真的有几百行上千行，那么我建议先用重构一书中的方法去解决它。其次关于可测试性在实践过程中是有一些技巧的。<br>2.1 方法可重写<br>在Java中,方法默认就是虚拟方法，可重写的。而在NET中,如果想要替换一个方法的行为,你需要明确地把方法设置为虚拟方法,才能进行重写。因此我们可以在设计之初就尽量把方法用关键字virtual标记。</p>\n<h4 id=\"2-2-面向接口设计\"><a href=\"#2-2-面向接口设计\" class=\"headerlink\" title=\"2.2 面向接口设计\"></a>2.2 面向接口设计</h4><p>如果我们的代码都能够保持面向接口设计的原则，意味着我们的依赖都是很容易被替换的，可以让我们在测试中年很容易取创造真实对象的伪对象。</p>\n<h4 id=\"2-3-避免密封类\"><a href=\"#2-3-避免密封类\" class=\"headerlink\" title=\"2.3 避免密封类\"></a>2.3 避免密封类</h4><p>密封类就是将一个类封闭起来，断其子孙的一种方式。<br>密封方法则不是为了防止继承而是防止重写，而且它是为了重写基类的虚方法并提供具体的实现，同时防止其后继类（派生类）再次重写该虚方法<br>无论是我们的被测方法还是其依赖的方法属于一个密封类，那么意味着这个方法是不能被重写的，在测试中也就不能去替换它。因此应该尽量避免使用密封类</p>\n<h4 id=\"2-4-避免在方法内初始化对象\"><a href=\"#2-4-避免在方法内初始化对象\" class=\"headerlink\" title=\"2.4 避免在方法内初始化对象\"></a>2.4 避免在方法内初始化对象</h4><p>很多人在写代码的时候习惯于在一个方法内部初始化对象，如下面这样<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">GetName</span>(<span class=\"params\"><span class=\"keyword\">int</span> userId</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//方法内部初始化类</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(userId).GetName();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样的设计其实是违背了代码的低耦合原则的，也不具有可测试性，因此我们在开发中应该尽量避免在方法中初始化另一个对象。对于外部依赖的对象可以使用依赖注入的方式。</p>\n<h4 id=\"2-5-避免直接调用静态方法\"><a href=\"#2-5-避免直接调用静态方法\" class=\"headerlink\" title=\"2.5 避免直接调用静态方法\"></a>2.5 避免直接调用静态方法</h4><p>要在测试中替换一个静态方法的行为,是非常困难的。<br>要处理这种情况,我们可以使用抽取和重写的方法进行重构,把这个静态方法抽象出去。<br>一个更为极端的做法是:避免使用任何的静态方法。这样的话,每一段逻辑都是一个类实例的一部分,使得这段逻辑更容易替换。有些进行单元测试或者测试驱动开发的人不喜欢使用单例,原因之一就是单例缺少可替换性。单例是静态的公共共享资源,很难重写它们。<br>要完全避免使用静态方法可能会过于困难,但是你可以尝试在应用程序中尽量少使用单例或者静态方法,这样在测试时会变得容易一些。</p>\n<h4 id=\"2-6-避免在构造函数和静态构造函数中包含逻辑代码\"><a href=\"#2-6-避免在构造函数和静态构造函数中包含逻辑代码\" class=\"headerlink\" title=\"2.6 避免在构造函数和静态构造函数中包含逻辑代码\"></a>2.6 避免在构造函数和静态构造函数中包含逻辑代码</h4><p>无论是构造函数还是静态构造函数内的逻辑同样是我们无法在测试中重写控制它的，因此我们需要避免在构造函数和静态构造函数中包含逻辑代码。</p>\n<p>关于可测试性设计虽然是有着许多技巧，但如果你掌握了代码编写的内容心法”SOLID原则”，并且熟练应用于编码中，其实你的代码绝大多数都是具有良好的可测试性的。</p>\n<h3 id=\"3-可测试性设计的缺点\"><a href=\"#3-可测试性设计的缺点\" class=\"headerlink\" title=\"3 可测试性设计的缺点\"></a>3 可测试性设计的缺点</h3><p>可测试性固然可以更加方便的让我们对代码进行单元测试，但有些时候也会给我们带来一些“麻烦”。因此它也是一个颇有争议的话题。有些人认为可测试性是好的设计应该具有的特征之一。也有些认为可测试性会破坏原有的设计带来一些副作用。<br>那么可测试性设计会带来哪些“麻烦”呢</p>\n<h4 id=\"3-1-工作量\"><a href=\"#3-1-工作量\" class=\"headerlink\" title=\"3.1 工作量\"></a>3.1 工作量</h4><p>大多数情况下,设计时以可测试性为目标会增加工作量,因为比起不考虑可测试性的设计比起可测试性设计需要编写更多的代码。</p>\n<h4 id=\"3-2-复杂度\"><a href=\"#3-2-复杂度\" class=\"headerlink\" title=\"3.2 复杂度\"></a>3.2 复杂度</h4><p>可测试性设计有时会让人觉得,它把简单的事情过于复杂化了。有些接口的使用让你感觉很别扭或者设计公开了你未曾考虑过的类行为语义。而且,当使用了很多接口把东西进行抽象之后,如果你要浏览基础代码找到一个方法的真正实现代码,会更加困难和麻烦。</p>\n<h4 id=\"3-3-破坏更好的设计封装\"><a href=\"#3-3-破坏更好的设计封装\" class=\"headerlink\" title=\"3.3 破坏更好的设计封装\"></a>3.3 破坏更好的设计封装</h4><p>从一些可测试性的技巧我们可以知道有些时候为了让代码更具有可测试性，会破坏一些原有的设计原则。</p>\n<p>正如人月神话一书中所说，在软件开发这一行业中没有银弹。一门技术或者方法论在给我们提供了一些帮助的同时也会带来一些问题。这就<strong>需要我们在具体使用的过程中**</strong>case by case，根据可测试性设计所带来的优缺点找到一个平衡点！**</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-为什么要关心可测试性\"><a href=\"#1-为什么要关心可测试性\" class=\"headerlink\" title=\"1 为什么要关心可测试性\"></a>1 为什么要关心可测试性</h3><p>很多公司很多人在实践单元测试中总觉的很困难的一个很重要的原因就是其代码本身不具有可测试性。他们往往会走入一个误区。面对一个几千行、逻辑混乱的方法而抓耳挠腮的想着用十八般武艺，各种框架去写这个方法的单元测试，而最终不得不以失败而告终，耗费了大量的时间却徒劳而无功。其实是他们忽略了这个方法的本身是不具有可测试性的。<br>","more":"<br>因此我们在要对一个方法进行单测之前，一定要先看一下它是不是具有可测试性，如果不具有，那么我们应该先对其进行重构以提高其可测试性。<br>在可测试的设计中,你应该很容易为代码的每一段逻辑(循环、i语句和 switchi等)快速编写一个单元测试,这些单元测试具有如下属性</p>\n<ul>\n<li>运行速度快</li>\n<li>相互隔离,即每个测试可以独立运行,或者作为一组测试的一部分运行,可以按任何顺</li>\n<li>不需要进行外部配置</li>\n<li>产生稳定的通过或失败结果。这些就是FCC属性:快速、隔离、无需配置和稳定(Fast, Isolated, Configuration-fre,andConsistent)。</li>\n</ul>\n<p>如果编写这样的测试很困难,或者需要很长时间,那这个系统就不是一个可测试的，如果把测试看做系统的一个用户,可测试性设计就成为一种思维方式。</p>\n<h3 id=\"2-可测试性设计技巧\"><a href=\"#2-可测试性设计技巧\" class=\"headerlink\" title=\"2 可测试性设计技巧\"></a>2 可测试性设计技巧</h3><p>如果你要测试的方法真的有几百行上千行，那么我建议先用重构一书中的方法去解决它。其次关于可测试性在实践过程中是有一些技巧的。<br>2.1 方法可重写<br>在Java中,方法默认就是虚拟方法，可重写的。而在NET中,如果想要替换一个方法的行为,你需要明确地把方法设置为虚拟方法,才能进行重写。因此我们可以在设计之初就尽量把方法用关键字virtual标记。</p>\n<h4 id=\"2-2-面向接口设计\"><a href=\"#2-2-面向接口设计\" class=\"headerlink\" title=\"2.2 面向接口设计\"></a>2.2 面向接口设计</h4><p>如果我们的代码都能够保持面向接口设计的原则，意味着我们的依赖都是很容易被替换的，可以让我们在测试中年很容易取创造真实对象的伪对象。</p>\n<h4 id=\"2-3-避免密封类\"><a href=\"#2-3-避免密封类\" class=\"headerlink\" title=\"2.3 避免密封类\"></a>2.3 避免密封类</h4><p>密封类就是将一个类封闭起来，断其子孙的一种方式。<br>密封方法则不是为了防止继承而是防止重写，而且它是为了重写基类的虚方法并提供具体的实现，同时防止其后继类（派生类）再次重写该虚方法<br>无论是我们的被测方法还是其依赖的方法属于一个密封类，那么意味着这个方法是不能被重写的，在测试中也就不能去替换它。因此应该尽量避免使用密封类</p>\n<h4 id=\"2-4-避免在方法内初始化对象\"><a href=\"#2-4-避免在方法内初始化对象\" class=\"headerlink\" title=\"2.4 避免在方法内初始化对象\"></a>2.4 避免在方法内初始化对象</h4><p>很多人在写代码的时候习惯于在一个方法内部初始化对象，如下面这样<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">GetName</span>(<span class=\"params\"><span class=\"keyword\">int</span> userId</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//方法内部初始化类</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(userId).GetName();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样的设计其实是违背了代码的低耦合原则的，也不具有可测试性，因此我们在开发中应该尽量避免在方法中初始化另一个对象。对于外部依赖的对象可以使用依赖注入的方式。</p>\n<h4 id=\"2-5-避免直接调用静态方法\"><a href=\"#2-5-避免直接调用静态方法\" class=\"headerlink\" title=\"2.5 避免直接调用静态方法\"></a>2.5 避免直接调用静态方法</h4><p>要在测试中替换一个静态方法的行为,是非常困难的。<br>要处理这种情况,我们可以使用抽取和重写的方法进行重构,把这个静态方法抽象出去。<br>一个更为极端的做法是:避免使用任何的静态方法。这样的话,每一段逻辑都是一个类实例的一部分,使得这段逻辑更容易替换。有些进行单元测试或者测试驱动开发的人不喜欢使用单例,原因之一就是单例缺少可替换性。单例是静态的公共共享资源,很难重写它们。<br>要完全避免使用静态方法可能会过于困难,但是你可以尝试在应用程序中尽量少使用单例或者静态方法,这样在测试时会变得容易一些。</p>\n<h4 id=\"2-6-避免在构造函数和静态构造函数中包含逻辑代码\"><a href=\"#2-6-避免在构造函数和静态构造函数中包含逻辑代码\" class=\"headerlink\" title=\"2.6 避免在构造函数和静态构造函数中包含逻辑代码\"></a>2.6 避免在构造函数和静态构造函数中包含逻辑代码</h4><p>无论是构造函数还是静态构造函数内的逻辑同样是我们无法在测试中重写控制它的，因此我们需要避免在构造函数和静态构造函数中包含逻辑代码。</p>\n<p>关于可测试性设计虽然是有着许多技巧，但如果你掌握了代码编写的内容心法”SOLID原则”，并且熟练应用于编码中，其实你的代码绝大多数都是具有良好的可测试性的。</p>\n<h3 id=\"3-可测试性设计的缺点\"><a href=\"#3-可测试性设计的缺点\" class=\"headerlink\" title=\"3 可测试性设计的缺点\"></a>3 可测试性设计的缺点</h3><p>可测试性固然可以更加方便的让我们对代码进行单元测试，但有些时候也会给我们带来一些“麻烦”。因此它也是一个颇有争议的话题。有些人认为可测试性是好的设计应该具有的特征之一。也有些认为可测试性会破坏原有的设计带来一些副作用。<br>那么可测试性设计会带来哪些“麻烦”呢</p>\n<h4 id=\"3-1-工作量\"><a href=\"#3-1-工作量\" class=\"headerlink\" title=\"3.1 工作量\"></a>3.1 工作量</h4><p>大多数情况下,设计时以可测试性为目标会增加工作量,因为比起不考虑可测试性的设计比起可测试性设计需要编写更多的代码。</p>\n<h4 id=\"3-2-复杂度\"><a href=\"#3-2-复杂度\" class=\"headerlink\" title=\"3.2 复杂度\"></a>3.2 复杂度</h4><p>可测试性设计有时会让人觉得,它把简单的事情过于复杂化了。有些接口的使用让你感觉很别扭或者设计公开了你未曾考虑过的类行为语义。而且,当使用了很多接口把东西进行抽象之后,如果你要浏览基础代码找到一个方法的真正实现代码,会更加困难和麻烦。</p>\n<h4 id=\"3-3-破坏更好的设计封装\"><a href=\"#3-3-破坏更好的设计封装\" class=\"headerlink\" title=\"3.3 破坏更好的设计封装\"></a>3.3 破坏更好的设计封装</h4><p>从一些可测试性的技巧我们可以知道有些时候为了让代码更具有可测试性，会破坏一些原有的设计原则。</p>\n<p>正如人月神话一书中所说，在软件开发这一行业中没有银弹。一门技术或者方法论在给我们提供了一些帮助的同时也会带来一些问题。这就<strong>需要我们在具体使用的过程中**</strong>case by case，根据可测试性设计所带来的优缺点找到一个平衡点！**</p>"},{"title":"大型网站技术架构(三)大型网站的演化下","copyright":true,"date":"2020-04-27T03:29:26.000Z","keywords":"大型网站技术架构","password":"1234qwer","aside":"Notes-LargeSite","_content":"\n前面我们提到大型网站架构演化过程中的五个阶段。这篇文章我们接着来看在演化的过程中还会遇到什么问题，又是如何解决的？\n\n#### 6.**使用反向代理和CDN加速网站响应**\n\n随着你们网站业务的发展越来越快，用户的规模也越来越大，已经不仅仅局限于某一地区了。你们的用户可能已经遍及全国各个地区，甚至走向了世界。由于不同地区的复杂的网络环境，各个地方用户的访问速度差距也越来越大。这个时候你会发现有些像我一样的用户由于缺乏耐心。忍受不了较长的访问时间而离开，进而投入到你们竞争对手怀抱中。随着用户流失率的越来越高，看似镇定的你，内心其实慌得一批。为了提供更好的用户体验，留住用户，你必须要想办法加速网站访问速度。\n\n这个时候，主要手段有使用CDN和反向代理。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%846.png)\n\nCDN和反向代理的基本原理都是缓存，区别在于CDN部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。\n\n使用CDN和反向代理的目的都是尽早返回数据给用户，一方面加快用户访问速度，另一方面也减轻后端服务器的压力。\n\n#### 7.**使用分布式文件系统和分布式数据库系统**\n\n上一篇文章我们说到，任何强大的单一服务器都满足不了大型网站持续增长的业务需求。数据库和文件系统也是如此。即使数据库经过读写分离后，从一台服务器拆分成两台服务器，仍然不够。这时你应该考虑分库分表、分布式数据库和分布式文件系统。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%847.png)\n\n注意：分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同的业务的数据库部署在不同的物理服务器上。\n\n#### 8.**使用NoSQL和搜索引擎**\n\n随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，网站需要采用一些非关系型数据库技术如NoSQL和非数据库查询技术如搜索引擎。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%848.png)\n\nNoSQL和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。\n\n#### 9.**业务拆分**\n\n相信你们的网站如果经过上面这些阶段的发展，你们的网站已然成为一个“庞然大物”。你们的业务范围会越来越广，业务场景也日益复杂。研发团队必然也越来越大。此时不得不使用分而治之的手段将整个网站业务分成不同的产品线，如大型购物交易网站就会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责。\n\n具体到技术上，也会根据产品线划分，将一个网站拆分成许多不同的应用，每个应用独立部署维护。应用之间可以通过一个超链接建立关系(在首页上的导航链接每个都指向不同的应用地址)，也可以通过接口通讯或者消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%849.png)\n\n#### 10.**分布式服务**\n\n随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方，导致数据库连接资源不足，拒绝服务。\n\n既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用业务服务完成具体操作。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%8410.png)\n\n大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如数据中心的实时数据同步和具体网站业务相关的问题也都可以通过组合改进现有技术架构来解决。\n\n但事物发展到一定阶段，作者认为，就会拥有其自发展性，向着更强大的方向发展。也会衍生出更多的业务，既然大型网站架构解决了海量数据的管理和高并发事务的处理，那么就可以把这些解决方案应用到网站自身以外的业务上去，可以出售问题的解决方案，也可以将计算作为一种基础资源出售，中小网站不需要再关心技术架构问题，只需要按需付费，就可以使网站随着业务的增长逐渐获得更大的存储空间和更多的计算资源。再者，网站的访问并非是均匀的，有其高峰期，也有低谷期。比如双十一的时候，假设淘宝需要使用10000台服务器，而平时可能只需要3000台就够了。那么平时的时候这7000台服务器怎么办呢？\n\n这个时候就可以把他们租借出去。于是越来越多的大型网站都开始建设云计算平台，提供大型网站的解决方案，计算资源，服务器资源等。\n\n#### 总结\n\n大型网站架构技术的核心价值不是从无到有搭建一个大型网站，而是能够伴随小型网站业务的逐步发展，慢慢地演化成一个大型网站。所以网站还很小的时候就去追求网站的架构是舍本逐末，得不偿失的。小型网站最需要做的就是为用户提供好的服务来创造价值，得到用户的认可，活下去，野蛮生长。\n\n看似漫长而惊心动魄的演化过程，实则是随着业务的发展而水到聚成的一件事。没有必要去刻意的追求大型网站的解决方案。由于大公司巨大成功的光环效应，再加上有些所谓“大公司技术高手”的影响，网站在讨论架构决策时，最有说服力的一句话就成了“淘宝就是这么搞的”或者“Facebook就是这么搞的”。\n\n大公司的经验和成功模式固然重要，值得学习借鉴，但如果因此而变得盲从，就失去了坚持自我的勇气，在架构演化的道路上迟早会迷路。\n\n网站技术是为了业务而存在的，除此毫无意义，在技术选型和架构设计中，脱离网站业务发展的实际，一味追求时髦的新技术，可能会将网站技术发展引入歧途。技术是用来解决业务问题的，而业务的问题，也可以通过业务的手段去解决。\n\n我也曾经陷入过这样的误区，我的第一家公司是一家传统公司，想要转型互联网电商。而我们的团队也是一群热爱技术的人，于是我们借鉴了许多京东淘宝的解决方案。但是由于技术发展的脚步过快，技术团队也变得越来越大，远远超过了业务发展的脚步，最终也只能是失败收场了！\n\n\n\n","source":"_posts/notes/大型网站技术架构/大型网站架构(三)大型网站的演化下.md","raw":"---\ntitle: 大型网站技术架构(三)大型网站的演化下\ncopyright: true\ndate: 2020-04-27 11:29:26\ntags: \n- 读书笔记\n- 大型网站技术架构\ncategories: \n- 读书笔记\n- 大型网站技术架构\nkeywords: 大型网站技术架构\npassword: 1234qwer\naside: Notes-LargeSite\n---\n\n前面我们提到大型网站架构演化过程中的五个阶段。这篇文章我们接着来看在演化的过程中还会遇到什么问题，又是如何解决的？\n\n#### 6.**使用反向代理和CDN加速网站响应**\n\n随着你们网站业务的发展越来越快，用户的规模也越来越大，已经不仅仅局限于某一地区了。你们的用户可能已经遍及全国各个地区，甚至走向了世界。由于不同地区的复杂的网络环境，各个地方用户的访问速度差距也越来越大。这个时候你会发现有些像我一样的用户由于缺乏耐心。忍受不了较长的访问时间而离开，进而投入到你们竞争对手怀抱中。随着用户流失率的越来越高，看似镇定的你，内心其实慌得一批。为了提供更好的用户体验，留住用户，你必须要想办法加速网站访问速度。\n\n这个时候，主要手段有使用CDN和反向代理。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%846.png)\n\nCDN和反向代理的基本原理都是缓存，区别在于CDN部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。\n\n使用CDN和反向代理的目的都是尽早返回数据给用户，一方面加快用户访问速度，另一方面也减轻后端服务器的压力。\n\n#### 7.**使用分布式文件系统和分布式数据库系统**\n\n上一篇文章我们说到，任何强大的单一服务器都满足不了大型网站持续增长的业务需求。数据库和文件系统也是如此。即使数据库经过读写分离后，从一台服务器拆分成两台服务器，仍然不够。这时你应该考虑分库分表、分布式数据库和分布式文件系统。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%847.png)\n\n注意：分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同的业务的数据库部署在不同的物理服务器上。\n\n#### 8.**使用NoSQL和搜索引擎**\n\n随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，网站需要采用一些非关系型数据库技术如NoSQL和非数据库查询技术如搜索引擎。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%848.png)\n\nNoSQL和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。\n\n#### 9.**业务拆分**\n\n相信你们的网站如果经过上面这些阶段的发展，你们的网站已然成为一个“庞然大物”。你们的业务范围会越来越广，业务场景也日益复杂。研发团队必然也越来越大。此时不得不使用分而治之的手段将整个网站业务分成不同的产品线，如大型购物交易网站就会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责。\n\n具体到技术上，也会根据产品线划分，将一个网站拆分成许多不同的应用，每个应用独立部署维护。应用之间可以通过一个超链接建立关系(在首页上的导航链接每个都指向不同的应用地址)，也可以通过接口通讯或者消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%849.png)\n\n#### 10.**分布式服务**\n\n随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方，导致数据库连接资源不足，拒绝服务。\n\n既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用业务服务完成具体操作。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%8410.png)\n\n大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如数据中心的实时数据同步和具体网站业务相关的问题也都可以通过组合改进现有技术架构来解决。\n\n但事物发展到一定阶段，作者认为，就会拥有其自发展性，向着更强大的方向发展。也会衍生出更多的业务，既然大型网站架构解决了海量数据的管理和高并发事务的处理，那么就可以把这些解决方案应用到网站自身以外的业务上去，可以出售问题的解决方案，也可以将计算作为一种基础资源出售，中小网站不需要再关心技术架构问题，只需要按需付费，就可以使网站随着业务的增长逐渐获得更大的存储空间和更多的计算资源。再者，网站的访问并非是均匀的，有其高峰期，也有低谷期。比如双十一的时候，假设淘宝需要使用10000台服务器，而平时可能只需要3000台就够了。那么平时的时候这7000台服务器怎么办呢？\n\n这个时候就可以把他们租借出去。于是越来越多的大型网站都开始建设云计算平台，提供大型网站的解决方案，计算资源，服务器资源等。\n\n#### 总结\n\n大型网站架构技术的核心价值不是从无到有搭建一个大型网站，而是能够伴随小型网站业务的逐步发展，慢慢地演化成一个大型网站。所以网站还很小的时候就去追求网站的架构是舍本逐末，得不偿失的。小型网站最需要做的就是为用户提供好的服务来创造价值，得到用户的认可，活下去，野蛮生长。\n\n看似漫长而惊心动魄的演化过程，实则是随着业务的发展而水到聚成的一件事。没有必要去刻意的追求大型网站的解决方案。由于大公司巨大成功的光环效应，再加上有些所谓“大公司技术高手”的影响，网站在讨论架构决策时，最有说服力的一句话就成了“淘宝就是这么搞的”或者“Facebook就是这么搞的”。\n\n大公司的经验和成功模式固然重要，值得学习借鉴，但如果因此而变得盲从，就失去了坚持自我的勇气，在架构演化的道路上迟早会迷路。\n\n网站技术是为了业务而存在的，除此毫无意义，在技术选型和架构设计中，脱离网站业务发展的实际，一味追求时髦的新技术，可能会将网站技术发展引入歧途。技术是用来解决业务问题的，而业务的问题，也可以通过业务的手段去解决。\n\n我也曾经陷入过这样的误区，我的第一家公司是一家传统公司，想要转型互联网电商。而我们的团队也是一群热爱技术的人，于是我们借鉴了许多京东淘宝的解决方案。但是由于技术发展的脚步过快，技术团队也变得越来越大，远远超过了业务发展的脚步，最终也只能是失败收场了！\n\n\n\n","slug":"notes/大型网站技术架构/大型网站架构(三)大型网站的演化下","published":1,"updated":"2021-03-14T03:04:50.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzd00dghyjfp40ho080","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以扫描下方二维码，关注公众号，回复“密码”，即可解锁本站所有文章。</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"651b14c6bea64a0e8a68b4e121a2fb056f4f7bb50f61798896e16c436cc3b6c5\">38cabacd4dc4203e3d9e0b841f17afc9794ff6c6451d1c95aa0d4453e07c30a1344edeb43663afbd31373f819d3e52ee6da67ce7e863447185b6f3cec674d6146020c96c2361ba113e4bdd00c722e28c67f442f9b158764223a67ded55189ae505f6410c36ec01a083cba4a33cd64fec4c963d3f59b79615bd3523fac18bf75216dddf5b4945829b8bf3c6a9a06b89152bdc16ad8d2056a8bfc817994d37abe28e1a4e69f00b6bf6ec95cb12eff60485f435096c928b8466ab13932f2eb0823957a75af24f00fcefc931cb7467229770228c4e0f138a14ed5fff986ef6512d985b57c68c0716455b4d3a61a5ac45bcb9ea5e2f7273b28c43419460e1f8c727ce24deddeaffdb710593c4d045b629bf98acebeb6388e400446176b075b070de472b57980ed3f47e2478f609a81fa40d645de81d5a6d2e4b784119fbacd1b42ce8071f7bf61f47eb3da6a8b921d46ae231c6a09a0026cfb522d8a91d5a52424f871b115a1f367b05dd545bfa3abaff4bb5d2168a871354cc39e23cf746afe8841a16e10b1dc7bfa23f579e4fc5677d3363bcf5d9ab320498886bc121a6d4711701c1fd3ae3030cf69249e06659a7dd3afc09ebef8dec7642c1b2aff1acd910647ba8b0fd273ef74e9d555a6d19bc04b46ae6d14d98c9b9b2efe3984dea8828653f09a780e33987149a22e6827cc56e0004db361e6c5762134ee91e925499c8e01fa7d3ef8143ad38897514204bd1f1c68d1d49e3ea247e8ac3181770b31d9f1e8e88f535d86feba791836694dd62f8063d3d15ecbeaf7164a99881805de78c28fede3da2fe880270d0cf5f6250a19688392d95f49a952e251dda32c100acaec133baacba5424c095179e030719627182c8aeb08658baf0150e046a2e03576ea1a86badcbf44109e1fee2da256075e509808ae31a696d8482062c9e99867788bf7acca97beaefdd12c357543abfd22338409ae4008343fb4b17b0c926400b0d985b1c9d401444b2e540a924c9301fe8e1ad5c5c053f388d07bdc97705032568f634c1c93609ac4222872e3e4024ae136f2e6d1d3bd50ffc1d994fa428239666bdeb4cf5e36849b0110567bc387a08d2223424148107560bf5281118d845c5eb13707cefe3d5374acc96daab9f2a689690261ffe5810b27188eea575f60f708093315d11d18219db0c013120e6bbd4242d3a7fbcabd1b362183ffecea47ee313ea10b0c565d8681c8de0c857a8198bb5b35b45de2816f884f19640d95ad1a1202bd0f85fb2f83227f8847db856a7673b39a332c77066c9ddeb396a82ad60bfeb3895be1d4342e2c82a5c8e673d0b43ed7692daff492fad46ad7b30335b0b5db9eb7b1e54a3280dd0145f9304c6fc036e66240673a54bcc068aa3cd4f33d0bed2c5e62a53824c488448023ac65b393837304780eca3a56387fc6127fca08291aa8e5e925122e2864ad214b8d82fc719de048810e32f3bdeb67b76f0b8d353cc9e599fcb5847e1f3f16aba28477fc600a331dc6248386eb78bb91485dd5d0b979322c2a5f4fe4aed264d2d64b6a122d0b6593d39e0452c315da7dbf1300573fef5542dd24a5040aa6a899b65ff11854f4c793611a3237c3232dc42ce35d6c259e9a562838a047692b371e44f1563af06f6c7e68fcbcf4cdd9d451f89858ec6f86bc1d4b359c3ea33acb2327ab9aa9879ab041d563b9a1a50a9d83c05916595b37f7a69e4a685aafc0d3b6d5f757374299f52dff67f35745783d07edd3cdb4b53a66dc0bbefb010696d9723abd6dae707dd67655f628743f11531edfbcde987d298aff776c264a8ab65a88a5b2c122cdcc3db8c07d69c432d874d1b1ccb46a6da3bdf7395c0e9426b9107a361e90c0a24d5518bc7d15d9e54d4783985cdcaf75e61cdddaf3ddc7e37fb3a2cb9d362c36360d95dc0654671755c86ad61b8e5ecc5abcf47d4426d4f308c89dc8bb48b10f1f631d3899ecb735078ffd1d65b84c60cddcf7fd45b6d3472549c95c7a81fe81e64ebe778816207f87a0522c59344ce68fdd3cf996795398b542b3bc43585d8dba466fb275e78cdd3b7113dd495129c6ad8d6f48f49529f75b745a7ee30589e1b300edf1cce945f09760dfad8ccf84cbd228b307240abf94297687fc7be273040d1c7b6748c26dc2ce5f85c37de6e8607027a7689390c8d37e5b57598b6b21d6ca216b8196728ba217c24144c8f0133dbfe687c8df81ceb6559c72b022bdbfe069a533f3003d17aacf338362d9aabbfd7b7ff4c5a1087c05a1b5e36736b87900fcd4c7753e46aa3b49ba418886ca012fd8aaa6b26e5e72390a82f8d4c8e5748254852ed5b65a9f1ebd0a2f08ea91d112582545bbe5b895c4c7c288da3021757034b4dacaee8dde5047e714801de2dcc5f26518fcb8a7a4242cd794986cc1a00eb0b88b5ab2f1dc61a9a8c42d20da937b0ab0e42be34c2f8e615a90485e219623436b39a01ff7f23a19683aa3741fc8d11b051aa0e2a937a91d9fb3e736e494fcd2448e424c346338ed8c6ae0788da4d857de58d15c7c74f05cf179ddf32a61caa2c99ea25d1403d8f8269ae3550ee78ba9450dda6d5c38f7f6091b6c38daafeb006ed158fc65c58f2869e9243ff0f720d331154e81eaf2ae59c0c4dd094fc65af873673732c37838beb744229e1c6eab5eba3fa8d9be165630bf36fbb9cf02eeb9e71e5939077c96a5bab88e2ef318d9981119bc822632e7da05e6f91a701f349cf813a1187c941a632fbbc1239471b6b0c34f6a1963e81b76f60dbc917fffb535820f15d4bd11b926e982c70b26ab0ca02ec63a915aa8c6beb7e6ef3aa31d02063db03a666b0c36ed09264298ed43891336a53a3086e37ad1e43389882807d2124c3d6169df48987942e6ed7d5ebcbad70feb095735617513b1ed0da492691a5adf71bfb74fd9c4fd3c9f02e33002e419f3d059d3b3c05bcd50c54098581ace9880bbf4a3cf139edec112f3957e6b249a8f46982f55b4099f911d8e7ce03a1d1ab2873a0400040c3be0b8eb6f8b6b605e4320487588da945914159e2024844787bea01cc81735da234f3ec2b07f82a45c771c691155ab21323f4a41beb47966c931019e620284d53557d543e72e5142468d7bd81873d35d9dd1bb40751b0c3af6d052a0defc2a505a01495787af0889c1f843353c8120326c5dd361b9b469462961f8f7093c8b3d1938dd054966c78afec8794a8bc1f1c2c2fb47c9bbe4e9a65d9a6ae72956cfdf761cca569386ed6528fd2591a2e76275d88ad4de566e6115b6fbee59676fa06ce3aa677f144f99a73046217bba070b6447a4e8d0f974df5c55bdd0b79d37de87a5c1df82a6108979f0be8d881d9d15feabb57527bf3a68cd7c4f5b83dd88794b71c917164cb1a9413c4eb17c72673e45aa7cde02feb44362c298fd210c4932ef2edacf9d58457a9f0da3519b8b06d26be0b741ebd62301bc9107d85cb9200388951936ea8bb68f46a0b30be6b7a882d4f7ad90ee889f9cd62aea35799e5216be4f98c73e30a6fa9ff8877484aba933142393bbc5e7a0e3cd68be9fed98f42d1112981afd42d2210b74cc598007ce8641d3197dfc7f1fefd05d1be198a122160349141366d3a1df08f037c77119fcb7160f99c8b62e778b3897f567c743d6f33ed5a1ea37c3f05fefbb092970d181a7ea7ddd869c0156d838509579cbd076181a59af330a4261c0ca124b0085bc7565456f6df6a0485cfdfe4c53c0b53b2657860cd9927a7e80d4df7b83bcf16d71372208e59d0c27b43f6558598f6ef17e21df996ed67c6286d56d0fa15c1edc1ca79eff119b37a4d1f299920c62783075ede1e21400126ef5b344dbceb8134261eb573b507e426bb6e494dba4482fb54e565f1cc3e9dbae9ac609e14a56801b17f5d2236e85acaecd5bb5e29961212d5e94f03e755ec00b741b1411d7608923a3d58417635b5351ed027c65a1e0b5b4cd618850c17d364923718de24bfa7d6d17231b74042c6c4ec66aa3ea3fa003e1bedba4a7dc7b156ef0d856f1a8c281cdfdf7e0c1a17e6a974b980db3fbeb4942c517245f1fea1ae0e3de4f83b51f30f84c0310ce1156e7e314018c29661d9f50bf4a3f1ea71eb641cda4a0d28eead8c2cbd7efed5e8d4d4425f8f9d61877c989beaf715e3896f1941e2af47f672a45d1501585b5a5bb0756bd35974eb25f3d055857f92d7af21658c81e483d7d3726a8e90f88f727ad6504e2c070d1f0360b9c9d4a300717d9790b7d6704cacfcb70e9d7131cacf351be7896df683fa521b2880fef3129a2dd150c01b2c00f79139cdef78215c1d3297eff2a489aa284712d0af0f8d81f1f190b99e9a1d561e08d47ef17c78913172e86c40b7b754f4a897b267cd253b72b97e78ba110b71cf8100c4b058ad39a11454bcce26d12620449c3950523822e983b18e6eeaf1200e35b2cba7004a415bfe407bb0032f7e48186bd6a0da53a47972b50b0999a70d014d4e48ee85fda23f04f7c24630a67621de9e29dc05372cd0f55b0b4c257532cd3728a8f7d6bfe08cad237a24aff9368df721067bb60413e1c001056b53ce3faff4f18f5f6bc800d7cb0128be635e083462763277ea81de12cd891f35f0c64c1c0cd17907628ebfb9ac73a0af8cb266666abdeb7ca785d79229616bbc7047fdb8e4a2292ed2e395e11d066e8f892bd0220b0fac9cc66ead82f64651cb542df016cc646f1a0ff4db40a765d2e99b95bb4e62963954017cc5b6d8f92336d7753531ee1cb1e27411c9dc1ccc8c887d117f470b459694b73bf789252610aa1985ef837fd507cb56d877fd040e39466192c3c09609127db54a460c47128890266f8f974fa847ff96167dbce19d02b010e6549f3816c0ca54648b7cea7a811f54e24f9da62d47ba4fb843693e713fb62706e6581a6458f1dc0dc8a47c1f80ccb581ffc4389ebfd31754aa55a71b8017944b3d90c51aacf9c6732103b15bcc81020a860dec7303b7c7fd2268ce4762308df3ddc711d35fbb97e5acdb4677a7ac81ab9a06c9d69b3ebeac3793275fa24f8685bf073f3713081f58baa76c3f3ceef3276c99c294cf87b93fbe2976cbb05d6e6bf1f5c5d1b18ab5951a405de71b20abc9579c9814b689466d9ba2597507130be144cc93d4ed7ba10c33b2d70e20c804675e9d08904e86a01dd8f237496397c9ea761407b95b87e86588987cd8f8f0a88c8173a171308c494cc5e24b01b0683fe94354c1c3182ecc7069a9539299f2b8e575cfd1e738663c31ecf82f1ee41d229881d2577940d977658c5e9f46abc0723aa9deeb2bd2df8ddfab18c3ef4c88bc9f8e6c7ed48ebf13e9e59a3c639178521be73dab35c09059ddf5ded53bb314c8aa92239834bd1d1d19f63be081242746171e614e1071be10f45a28e69c6503f7e7c502056c06ad0695d025df82f6ebc1a83025dd11827273ee2380c40594d515058be8ace43d2b2173035967e9c1ac3e7797fb4d10325fe413ef2fd5ecf62364784b278964f04ad985b6040c5c82ff11c41624128a999596117354e1e490d6b9adbe6897075e7314e7d92ee0265110cd75091253cd933235c781e787062a04f1c0b8be3ffba4663556e7401d4a0b0e49a5381a959a2898b0174b4aeb76517dd8254a29a039e7b7a0f68ece25c392025f86fc0ea090dfac1c04b66417ab4a18a3bdd3ce1e469918cbaafd30d74b28f3fa97d278dd6323de9f35333ff2613b3338e38e060a0113bd4e74a38c0df0e25107861508f50fcf05c7d7f9feda24582781833536499c0d1bf90742a7c2c7ede773866c646ebc110ebc9b8c8704639e4f35b34c82c40976d42b197fba4b6e0da5cb0fb5c1b48b36d9c127bcd5651888dfc9bfca6dd43d090ad0ec4eeec2f2113a108993c5df5261167804e00d3df0ca0a608a3a643bcea7ecfb5ae361095909d4fa8895292ceddbcf054bf34960737cabe11ede85248db44471961b2db16ec48a713f95d49d755df523a3ee5d0ec9456132d98fc1709ef2f8ad8e3d08ba628db4a95c98b62ed4c0afde484f82e58dc5fb97a405f6af8a529bd3091db24ac55feeb420d464c7d947ce69840cefcd88649c4fe802d8f2b9a8e0c57db835f68d17aec479243b3025c6dd18f7d8fb1a2ff2513edc51a4741f34f81872239f1dd24dad845b6100fcc6c30c749d6dfdeded49ea80b61816f601f762c0bf0383e4eb15e5be654f35aa28ba12f374b4b4fb24a7cd9953a3d00a232c1fb940ee171c99d64a5f0903bb4fabf7057369603126463886f2ad4e1a13d9345a0a606e7284cff73c8f8da3796fdbe337f7635f57d4a5aff9e27ca8e4abba4b12ce1ff05baffade76a340c7b5f8f94e358c7bb17d1c1b2400b26c8abf8a84f9bcb32b532ec466df22e80819bf753178b41aa79230fc48a41591c099a65f2ca6fd8967565bc6223106053a763ecb56c0406855aab5527915fa090c2e54ff04b6456456b0ac2ccfa5e8f25099911c192aac6a574a8c2606e498e98d8adb7d64044a0dae696be9bbcf42b9816817bda7516c7a6a58c1475df4432e2027b297e01f6f841fa3b46bf5a73bbd4b647c445aceef3ed70d38f5919098d94ca09d7527d54f98cf82ee499ef5010bcd67b1d90fe6b9a5fe0a919f69c27977bb7f4fc7c377d4a22730e5e88fec7c1a873fd771e1b63127e706d07d8e960c91bcc7b29b39ca34be0ba31da73c37af7f30d923fbdafa53c56b745e075cb654f8ddf66cc06a6857e43ffac88285fbcf5a3a1177387e30aed62c6a2eb7b54dad9e403dc8193af4c50caf79c0df2f5b9bfdde569d887a8cc72c6151cc99846063b1c3f09e3f5282d89edf0e0634e386b770480893ee23cc740cec4f3f398b1bd32bedb4a3d82cfb86f51642c9f88132cf320079a2fa9a146cdaa4d992528fd983173f1891c3d7cfd06926091a607129e7e848ce3ba06f8882ace6864cddfa85d2dbf2b7f84d12516f7c871ae325df4b12c80085289c3de66615c853530265d849224370ba605178a683e0822d1997f276a4a625cd808103c1fe82130527d00f4a68e0ea9ea2850038632488abe9b10b440a9bb15494f5c955ffe746ffeabb5f1995e589e2c8f72cb43e6e1fb6abbd1d026adffafc007620b6b762b0afcce2e086364f303a9505a6c564f4ca73b05e98762b02ab5eefabaa36b4e374901a437e70a847f35f938aef15f6b1a409a9c941014dc8c587b27f6721b5f4372adc16bb3140a5f9914da176ad7b81150083852b7a64a700636f73dab8e031c7a8a971c5a3dce33dcf4c6079311d69c5667e8689652f6c4dcc597b9610e40eb62ede888be0d45094b7ab414ccb6d571b41ef428e9db73211705338bc3e2d68d54a2bc76764c0b6ca5ab4637da3fd4dc2a64aa159d04f0a3aca510172996d05600c42ac1ef2ca60d7dbbcd9621f0c635a3f7a89adf7d4184e82fe2223ef2d6335c52ba4731c9501082c9027d7045c073d5be95d4d664b6dce147f42b50aa267b8d3b0ccf66ec8efe31b0de569643151b2c1d40f58facba8e45aca8c0fae7c936e321cf564e4f661c7c9302d40fee237197905e020938eadb6a116bbea1034366dbc4e80f5738590a6e4671337b10f0d0cfd0f7cd53c5de443ab1fb61829a3a167ad097631a5401ba81c54c08bd6aab0478827ba05cc378b1f04397c87d03a3aaa2f3292373ecb1cf1b94ebb91ff93666cff4d3dc9a89101c4a3383b9fbe419e0066e9d142222ef1a74b8d730d4f1a9eed5ee5133da5d9ce3ff5dbb76c3be48d01d6337eef287391de9c9aa0c77d04e1dc993f11e00f97aeb752a58d335946acf450540bcf2c52f48faa893ef8b48c1daf76abc2125691bccd3ef55eb7ca8feed3558b4bc894fd3efa22122e8d1cfae81d28b57811fb9652de2964534aa9b692213acc809c394b50dce2154f7b61b1c698aae1b4a77863618dff449a7c57f3002ca8f6b2f6d7a786f0314ae9fb44c98597fa77cee01416199e8bc1e87531220165ba855d892bd497c2fc0f2a879f0adf4f72e8e99a2bfaab569a103f7acd231866f65e4099c407a7ed8e8294a1170a2709ac5f322d47e2b18956b599e0e00ad4867b613a7a744c9bf27875f341567721a56b3ed87bda9111ef1a6d78158b8e1fcfcbbfe6b22679a3fa2af5343f478b310890383658a7b89844b11df7b0af7b22530ec3bb0ef26ec211fbbc18855113587b4461e17687dc442c08877a7a01d7955ba251510c2971f9bba5d03efd30e318d802ab24a756e66e1fc0774849baa02e6bc1d56b1d0d41a10f2f25e84dd3c542f977ef4dc69513c87c3791d5e2ac74c25454fb98add19df3109384e66a0ffc82e0b8702b174bde77c666311a5f2507439341ea66ff923204ba60d738141013a75742aba4b29ecd2eb58c04a489c6349e4e8ffb7a194a0872bddc39530b97ffeb245a00c8d941b57626d28273b975d4a81976767ea68bef6c23f3fde3acb329fc747191d794a5f090d36abb7df6c0ea3803131b858aa946cc68c598eaf376318f8baca6f1b25ad038dfa92213a040bfa37b3abe278b60eebe052ea76d244208ab9f4f96cbdcf3ca82586a1de0d523f2a517cfecbcf29569699c50ceae85fc8e77e27b5285f0fdefb76f9b0c5ad9871781c3997ca4740ef932d46789884f35a3cd8bde091c08d47a9afc8b4ea58770c3f55bcd5d24edb347e49ec1c76e19e84d308ddf5d11a589df2914e3ec46e890baec3a1a7352863604dc6ae335e1b115eebf5864a881d5cd4a536611029acf62c99d8d493e1535e3ab028ae61c23081a924e35ed9aed5f879e99228ca6069a4c5646d72b2153113b1296079d52e8477ad88a401d3d7acd31477691f9fca7fc29705dbf79fcd95c62bbf8466ff947233880342021004d1d96107aec691e5465d658ef5466fc52d153a83e8b89f9bc6c9ed02b11926b6984f4f35df4573ecc451638c5cf0bc8359e1031666f890d0fe0ea67b0ac4ef9514e58b9159384636a488543363ace01c8a86239122aedc7d4510174b8af3e76ca58b8a8b3b7a995b6d5ae316d6e6e76ccde403176185574dc665b29e140d6e66c08fad431d608710d9942c802a3475e820367d6581549cdd2df3ea6a6c412608135f93127b7f9ffaf1b6c4ac6be13150a6a5e2d338a7a1bfcd403748653f368b44c7743316ac59ecacdac1fc6ce916bb47642b2f4c314992768d91f913697efcc968a4b080ac3bf2eabd1b95f2bd7eb000d84c80269d8f99e0afa588ff928029d5706ccfbe54cc6c8ee4bdfed3fd267579c36303d9e49a124c830cf2bac06c6e44e116d2644bf465ffcccfd730080c5f76eab73a39d7865364e65be38442927925585ab2bf34fe039bd661480a06ae9fe63705206a586bc55d6d6fa19174aabbc4c312c80e1ffda17c351e0fbca33a1cd3434faf252ff61f8c99e083dcb37fce09bf67c0d10034246306b44cfc35b139ec55dd1e195c08175d543db762c5d2ebae6d7cb198802e4c93fe218d0f43ede961ad82868603a6185f12db759380a63066b82b16888899129110fb3b5a7f86a97efdbfd9b056f7130f245124bcba6ce225c698fa9dc8cbce066c5dcca7ca35af1c5ba33b3d6cfd8e455d0091068f7814b96adc0a04e22952b39e3ad50d28f916df79e281c2b6f57c43322abe8dd4c685a55c65f919e5f1f1404f353938b351f54f82fe4540158574b77b160c4cb51661edbd2681859fc7bc4243a75f1b605cbb2b0b526d49d05843d9b043c28aa0055d1612383edf8ffa782b23dd12100a1199ec96867e62abf3e7ca7d9245cefda54c3842bbf1124c29e08a2fe471f7b33862caa16ebf7a8f0e492cfe771664c6c521ca4c507c690ba9c07683ea90a65cad2f94befe64f01816f68b6178ea4cdc1a67619c25f43fce2805b5dc67d0b23d5433506366f3ae2fb5f1d65bd5929248302170319d2fced504b1b5da40a8539d9132b278dde580b6ac8760cfd5eceade9da20c12b4eee26fe941d77a19fa951f205bdad146d43e1398c28f042cfaa09502ab8ea31be64f252dc1906d3229cacf61831e0291c5f9e1d5be62ed50050e4fdfe6b02be860bdb510d5a335a8f304e112d0904ded0a851c074a54290fd3cefe6ce1a8632ccbdc679447104ae914a0f05b38968e5db73b930bcd301f0d13995c4730dd390bb8dc4cc6e28baf17d235e9a6cde8c9d4fcaad6bd703198dd49527f0b51c9305359d708cb0ef392e10b33ad00d689802ce82aa692f5a30ea24dd9feb648062aa4fbd28237ce02305efd3f915f5654d8690b3bc3fe5d06b57d7e4132aa8517575325359754cf543b36a6b5b90e2eb710f6aae77d1a6b2a3fc81e1fd1b159921a16321343749ee68cb3f692f7e96dc13cb4ec838b054530fed8ef1fd0e58bfee452102cef2eb936f1cf3145678beda83571897ddc69de45dc68b8e684e029a505e5e26717e0c82927b1ffa6bf5e830234e44f20df99eb2125070b02dde5cc88d9dadbf53deffc0d67101ad4f7beff0b0f4dbde1cd8f6d323c13823be8622c81847868e5e9f047c873d04d668807d08b3373637de0bb2df593abc6e210fa0b3557e9bc52df875e77f83d639ab70f6ca41b1eb6eb9d4398890ba6f63ea8a0ad128fa9b5acd29c2586d3e68d84512a0f7560f8d8d5c2c2f74fb88c8d2aa08d29abb574a30bc6113594a9910e46b340bef77ae51961e5cb512e0f173693cf47428a5b5b7963e9318ee203d9608f63786a32085ad14882b888d134864821a87e1d660f045537318e3b5ee18b62cebec67d251c5423dbb988696fe8f00cd7b7ff510b25f89ff6fc74034f06d195590e8e6d88a7712c14c6eb3c82cf830afcee5edeadf79f2395bb9192991a3d9f30322fecc3a3fe9e11f251abcf7af823c25d6e82685bdab24ed75de89a64a7345c585c407e11180f19c9b1ba27513bbed19a3792ebaac44aba1182397fd8247ea2665cffef2c3f607a847cda4d3c8049e9ee98f09ee263f376522a6f98f8a289db784732113d1997fa5057deb96004cf690b530e551606428833b2b686685addbdb2684a5b48e5f4b7f94d3f1683dde135b42544cda78b21648bc29fe538c7944d4ef4a7679d15c369242eb440dcf8177fe9ca86d59205c57febff3131a11fc56344d5ed71b3080d65090e147103c9feba21f5a6befa9c5ab887d9658dbbe0a782603403a3dcb6a3b9f9f018c5703a6950908e66919f6ee1a10ab17cac88bd916d5d18ccf5cc05968ae181ad37acbdde996392150136ac4e0caa6e86209cdd00ae39b1b6f38d384f378bf711407f3ef1bda839bb5b9d20c29ecc6243d9b1db9a53e9b397537807d41b07ab2d09ff428b09db8ed0ee74dad64692924969ec669732ab32d2a3e529caeba02c16fb0494629469e0cd9956f5ee01b7febbf55f4fd55d6930c7522852c1e59a941dd6fdb9cbbf034560b9b48d8b0799a1fc80df54ea83d577ae255c3095419cc3f1a46b5234c260e1419dd29970cbe6f28c4f532701d6dbb29d78f39831cdf8e51ad342313e6267f15a0b697950b824f642431b4710aba664ac9b10e87d587d3ccd663f10441c1792a7201255b8423c6dadc6750be3914d874bbc7bcefbe699698276ac5c41e455afc2441a2860df276f2d77a19534fb2d18e775405cc5ec966ed0196ef4007014252ed304ea63729f876509ea1f7897faba627154dbaa51d5858ec1fdd8327d9e16333aa69aed82fa3e4ad1d4ac0cd2d4645946a7c9398c44f61e0835f5bc9dc10ade121b79ed2c8f630dfd15d21681a7b028e6408e8cf7f8ccfd516ccbf781c1bb94788f03ffe95a8be6d74c7467e8272652a19d2b98cc08126c266ad7cedca3b9c6ad5febe84928c970272762b3ddd060481b571f1eab7d845b2a4793f40054a0af7689db185f83100dfd9546d1fcded11c122a2fc5417176d7d3860ce089f66692434f6ecc986486ae7d04a15fb868b8ccb4b9ce4a4cab7e15aaf954be1c285a0de8c58eea802473dbb58a949150eca92b4cd162637c1233bbc1a7d0f434fb63e2acd51a693fca37ffc98b38a2e521fea74912ce25b8e28e2eac67121da56b65d25fdfd2d3476c7a34943542b12854fa4fa043a8b5773d9f1c96ae78c07f4316011cd1d415bbe79a60d518a69361cfb9b12ca29ddc7ff5b20b695c38551450df867fbdcfac4ebd2c1bb518c1abc3dece76a8f2dbf9a3c9842322cd58fea6e5afa4ebfb87b5c453b62739784ab37ee614c33729082af47d7cdceeffe2cc017ef55fa1531ad25b2db60c8081395f886c1fcd9e80104f0a9340502cbf065ba7d6d647a3fe6fdfd5ee1759e714ff273fef7d003229e0c345c2e11bc3848d9ed3978b19f25be27d574f6be58c18853f0ae6c487047096795e471088f107615c9d6dbda5d2c71400342e751f687f3b42ef31a20bccc9e4a9a7698054ef567673766f0f99735a91263387a4373221a7e5c135b0fb0cc5e9c0c9b4248782d0ce6cf91379ffc54c1943d115090fabd84465098a9ea0282641042ba0bddb067286ea5379a62ccf5a9b08a1e2292e6dd4723867bee6355fd1f179db9c6a3f2399cc8d36940128a27e0fd61ba5e150f44162c49751da71258f68665b8a4a723cafb47163c077eb0f80ea5a27771f0a2148952429418eae9349488bbd4fe12b7142e2733929141e9c4d39be3d80f2225aff859ec6b3f3a5f3b1f59b665279e232925556ccef111eb316583f64ddbe457aca85cd52b5b0ed2065842533e3f2bdae5d1ac111ff8a6bcc1ba2ad5f82b47ac02654242e932e7d157d89d5a62becd9788874914410ea0d23451c66c06e16783f2493f78506f2cc1a7afdcfa5e3b3867580b487611872402e262a82794912433f7b34db3d12557d25c49c3a08494619ce57f68e5df1eaf296c846bfb8a5349f20a0b8d861a766335aa360f7c9dba2902c3441bbea8c6663daee2527c2f42e2fbf54b908dff134ef7d82506870d6601b9d7bb0dc3405c9382f9e4e600f983425d2f75b540620dafa2b0caf357ee1d9344e79b414563f79d565cb1b2e807e58759c3698592c8226a37fefd93e6c2c72e98b37a746c340d14aa9e4af38836ed8a51ea55125a7f184fedbe35361b8ee5a63782cb8390a49c75b31ac944a9e251a9a635db9b92566697d254c54e5f54eeb61234fb32c1f6a5b2b4d9ada1e00b9f293fc373b48fc80552c94207251cc9d073e3ca703bfb6bf0d43318735140251e234c6914f3ba5a822e73b3e0d3f31826eb2b5af0bf548be30e0be40cf4461549faec2b58cd312069d02206a00b6efade9f99b5d8a0c57a27ae06c410598474b5f759dac3185bca6f8b037b02a604acc27552ad771821938bd24e59970f63251a720ce9827a962ed64bf97e990ced95e1e631a83cb73d68802375c6351ebc2df4869810ec117c5711bd09d118d2576ba27708c6da57ead4da51339ce26101c74c63973a6ce58bae4908562694300ecba1a86e55cc783a7640afe17034a741f98dbdde386d290109f147d7c95cf2a6d0896645d6df85b29725668d8e3424b02fef7aeb721c7de10888df4a674c727c29ab7ab2be7cf4d1f29e5f950575e2e9b196e6fbd3229e05e20b8052d9e41b994e5fde16bbcaf952e0ed0650c3e647e4390f696744fe2d71cfa8e37fdeb72f0dd4d5310307ba97ad275eb38456b49e5e9837ca791ad9bd20d2a504d7f8c8b29143ba6beea8e3b3fd2f4e1fb9dfddf443c5931921</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","more":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","origin":"<p>前面我们提到大型网站架构演化过程中的五个阶段。这篇文章我们接着来看在演化的过程中还会遇到什么问题，又是如何解决的？</p>\n<h4 id=\"6-使用反向代理和CDN加速网站响应\"><a href=\"#6-使用反向代理和CDN加速网站响应\" class=\"headerlink\" title=\"6.使用反向代理和CDN加速网站响应\"></a>6.<strong>使用反向代理和CDN加速网站响应</strong></h4><p>随着你们网站业务的发展越来越快，用户的规模也越来越大，已经不仅仅局限于某一地区了。你们的用户可能已经遍及全国各个地区，甚至走向了世界。由于不同地区的复杂的网络环境，各个地方用户的访问速度差距也越来越大。这个时候你会发现有些像我一样的用户由于缺乏耐心。忍受不了较长的访问时间而离开，进而投入到你们竞争对手怀抱中。随着用户流失率的越来越高，看似镇定的你，内心其实慌得一批。为了提供更好的用户体验，留住用户，你必须要想办法加速网站访问速度。</p>\n<p>这个时候，主要手段有使用CDN和反向代理。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%846.png\" alt></p>\n<p>CDN和反向代理的基本原理都是缓存，区别在于CDN部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。</p>\n<p>使用CDN和反向代理的目的都是尽早返回数据给用户，一方面加快用户访问速度，另一方面也减轻后端服务器的压力。</p>\n<h4 id=\"7-使用分布式文件系统和分布式数据库系统\"><a href=\"#7-使用分布式文件系统和分布式数据库系统\" class=\"headerlink\" title=\"7.使用分布式文件系统和分布式数据库系统\"></a>7.<strong>使用分布式文件系统和分布式数据库系统</strong></h4><p>上一篇文章我们说到，任何强大的单一服务器都满足不了大型网站持续增长的业务需求。数据库和文件系统也是如此。即使数据库经过读写分离后，从一台服务器拆分成两台服务器，仍然不够。这时你应该考虑分库分表、分布式数据库和分布式文件系统。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%847.png\" alt></p>\n<p>注意：分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同的业务的数据库部署在不同的物理服务器上。</p>\n<h4 id=\"8-使用NoSQL和搜索引擎\"><a href=\"#8-使用NoSQL和搜索引擎\" class=\"headerlink\" title=\"8.使用NoSQL和搜索引擎\"></a>8.<strong>使用NoSQL和搜索引擎</strong></h4><p>随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，网站需要采用一些非关系型数据库技术如NoSQL和非数据库查询技术如搜索引擎。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%848.png\" alt></p>\n<p>NoSQL和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</p>\n<h4 id=\"9-业务拆分\"><a href=\"#9-业务拆分\" class=\"headerlink\" title=\"9.业务拆分\"></a>9.<strong>业务拆分</strong></h4><p>相信你们的网站如果经过上面这些阶段的发展，你们的网站已然成为一个“庞然大物”。你们的业务范围会越来越广，业务场景也日益复杂。研发团队必然也越来越大。此时不得不使用分而治之的手段将整个网站业务分成不同的产品线，如大型购物交易网站就会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责。</p>\n<p>具体到技术上，也会根据产品线划分，将一个网站拆分成许多不同的应用，每个应用独立部署维护。应用之间可以通过一个超链接建立关系(在首页上的导航链接每个都指向不同的应用地址)，也可以通过接口通讯或者消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%849.png\" alt></p>\n<h4 id=\"10-分布式服务\"><a href=\"#10-分布式服务\" class=\"headerlink\" title=\"10.分布式服务\"></a>10.<strong>分布式服务</strong></h4><p>随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方，导致数据库连接资源不足，拒绝服务。</p>\n<p>既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用业务服务完成具体操作。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%BC%94%E5%8C%96/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%8410.png\" alt></p>\n<p>大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如数据中心的实时数据同步和具体网站业务相关的问题也都可以通过组合改进现有技术架构来解决。</p>\n<p>但事物发展到一定阶段，作者认为，就会拥有其自发展性，向着更强大的方向发展。也会衍生出更多的业务，既然大型网站架构解决了海量数据的管理和高并发事务的处理，那么就可以把这些解决方案应用到网站自身以外的业务上去，可以出售问题的解决方案，也可以将计算作为一种基础资源出售，中小网站不需要再关心技术架构问题，只需要按需付费，就可以使网站随着业务的增长逐渐获得更大的存储空间和更多的计算资源。再者，网站的访问并非是均匀的，有其高峰期，也有低谷期。比如双十一的时候，假设淘宝需要使用10000台服务器，而平时可能只需要3000台就够了。那么平时的时候这7000台服务器怎么办呢？</p>\n<p>这个时候就可以把他们租借出去。于是越来越多的大型网站都开始建设云计算平台，提供大型网站的解决方案，计算资源，服务器资源等。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>大型网站架构技术的核心价值不是从无到有搭建一个大型网站，而是能够伴随小型网站业务的逐步发展，慢慢地演化成一个大型网站。所以网站还很小的时候就去追求网站的架构是舍本逐末，得不偿失的。小型网站最需要做的就是为用户提供好的服务来创造价值，得到用户的认可，活下去，野蛮生长。</p>\n<p>看似漫长而惊心动魄的演化过程，实则是随着业务的发展而水到聚成的一件事。没有必要去刻意的追求大型网站的解决方案。由于大公司巨大成功的光环效应，再加上有些所谓“大公司技术高手”的影响，网站在讨论架构决策时，最有说服力的一句话就成了“淘宝就是这么搞的”或者“Facebook就是这么搞的”。</p>\n<p>大公司的经验和成功模式固然重要，值得学习借鉴，但如果因此而变得盲从，就失去了坚持自我的勇气，在架构演化的道路上迟早会迷路。</p>\n<p>网站技术是为了业务而存在的，除此毫无意义，在技术选型和架构设计中，脱离网站业务发展的实际，一味追求时髦的新技术，可能会将网站技术发展引入歧途。技术是用来解决业务问题的，而业务的问题，也可以通过业务的手段去解决。</p>\n<p>我也曾经陷入过这样的误区，我的第一家公司是一家传统公司，想要转型互联网电商。而我们的团队也是一群热爱技术的人，于是我们借鉴了许多京东淘宝的解决方案。但是由于技术发展的脚步过快，技术团队也变得越来越大，远远超过了业务发展的脚步，最终也只能是失败收场了！</p>\n","encrypt":true},{"title":"软件(敏捷)开发中工作量工时评估方法","copyright":true,"date":"2018-11-14T00:58:01.000Z","keywords":"敏捷开发,项目管理","mathjax":true,"_content":"\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;软件开发中如何合理的预估项目的开发时间始终是一个难题。因为项目中不确定性的因素太多。这里我们根据日常项目中开发的规律总结出一种工作量预估的模型。该模型参考物理学中时间的计算方式:\n$$\n时间(T)=\\frac {距离(S)}{速度(V)}\n$$\n得到我们的软件开发时间计算公式:\n$$\n开发时间(T)=\\frac {工作量(S)}{开发速度(V)}\n$$\n\n<!--more-->\n\n### 一、工作量的确定\n\n&nbsp;&nbsp;&nbsp;&nbsp;工作量主要与三方面的因素有关系。任务的规模、任务的复杂度以及完成该任务的人员能力水平。这里我们先假设一个标准的人员水平(即：理想状态下人员水平都是一定的标准工程师)。那么此时工作量主要与任务的规模与任务的复杂度有关系。\n\n#### 1.1 任务规模(S)\n\n 关于任务的规模拆分出如下等级。(我们可以总结自己项目的规律来调整这个等级)：\n\n| 级别 | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| 5    | 任务规模极其之大，甚至不能估计，可以拆分成很多小任务，甚至子工程。 |\n| 4    | 任务规模较大，需要一周左右的时间来完成，可以拆分成很多小任务 |\n| 3    | 中等规模的任务，需要三到五天左右的工作量                     |\n| 2    | 任务小，需要两到三天左右的工作量                             |\n| 1    | 任务较小，需要一天左右的工作量                               |\n| 0.5  | 任务非常小，需要很少的工作量，需要几个小时的工作             |\n\n注意:这里的工作量只是完成任务本身所需的工作量，但软件开发往往不只是完成任务本身，更多时候任务还会涉及到其它相关的任务、系统。也有些任务可能涉及到团队技术的盲点，需要一定的时间研究分析等。因此，我们还需要结合任务的复杂度来进行工作量的评估。\n\n#### 1.2 任务复杂度(C)\n\n关于任务复杂度，同样可以拆分出以下几个等级。\n\n| 级别 | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| 5    | 极其复杂，更多依赖于其它任务、系统或子系统，含有团队中缺乏的技术，或者一些重要的经验，任务描述很不清晰，有许多未知因素，对外部任务、系统或子系统有很大的影响等 |\n| 4    | 非常复杂，依赖于其它任务、系统或子系统，其中所涉及到的一些技术点、经验在团队中不是强项，任务描述不清晰，有些未知因素，需要极高的一些技术能力才能完成，对外部任务、系统或子系统有一定的影响等 |\n| 3    | 中等程度复杂，有些依赖于其它任务、系统或子系统，完成任务很少或不需要研究，任务描述很清晰，未知因素基本没有，只需要一般的技术能力就可以完成，对外部任务、系统或子系统很少的影响等 |\n| 2    | 简单，很少依赖于其它任务、系统或子系统，其中所涉及到的一些技术点、经验在团队中曾经有过，任务描述基本清晰，未知因素较少，只需要一般的技术能力就可以完成，对外部任务、系统或子系统基本没有影响 |\n| 1    | 较简单，基本没有未知因素，所涉及的技术、经验都是团队非常熟练的。只需要基本的编程能力就可以完成，任务影响力仅涉及自身。 |\n\n#### 1.3 工作量(E)\n\n$$\n单个任务工作量(o)=SC\n$$\n\n\n$$\n项目的总工作量(E)=\\sum_{i=1}^n{(SC)}_i\n$$\n这里，我们定义工作量的最小工作单位为sp，单位时间一天的工作量。1sp即：我们的标准工程师一天的工作量为1sp(即:我们的标准工程师理想中的开发速度为1sp)；\n\n### 二、开发速度的评估\n\n#### 2.1 理想开发速度\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们的一个标准工程师理想中的开发速度就是一天可以完成1sp的工作量。前提是标准程序员，但显然我们团队中的程序员不可能都是标准工程师。因此理想中我们的团队开发速度为:\n$$\n团队理想开发速度(V_t)=标准工程师开发速度(V_s)*团队人员个数(R)\n$$\n\n#### 2.2 开发速度的影响因子\n\n&nbsp;&nbsp;&nbsp;&nbsp;项目开发速度是一个很复杂的概念，很难准确的对其进行定义。考虑到不同团队成员的能力不同，则开发速度也不相同，即使是同一团队，其开发速度也不是一成不变的，会受到各种因素的影响。理想开发速度仅仅是没有受到任何阻力影响时的速度。但在项目过程中，总会遇到一些影响。其影响因素主要包括两方面。确定性因素以及突发性因素，在项目开始前，项目经理对以下两种因素预估的越准确，那么对开发时间的评估也越准确。\n\n确定性因素一般是项目客观存在的，容易在开始前预测的。关于确定性因素大致参考如下:\n\n| 影响因子       | 影响因子分数(以下为示例分数，具体分数可根据情况自定义i>0,若稳定则为1) |\n| -------------- | ------------------------------------------------------------ |\n| 团队组成       | 0.95                                                         |\n| 开发过程       | 1                                                            |\n| 需求清晰完整度 | 0.96                                                         |\n| 技术因素       | 0.97                                                         |\n| 团队配合       | 1.05                                                         |\n| 其它因素       | 0.98                                                         |\n\n团队组成:考虑到团队成员不可能为标准工程师。因此团队人员的能力是影响团队开发速度的一个很大因素。我们可以在团队中找一个接近于标准工程师的人，得到他的能力系数(SF)为1sp(一天可以完成1sp的工作量)，则以他为基准可以得到团队所有人的能力系数。则团队组成的影响因子分数(TF)计算公式为:\n$$\nTF=\\frac{\\sum_{i=1}^N{(SF)}_i} {N}\n$$\n开发过程:考虑到改进开发过程(采用敏捷，优化测试方法等)会对开发速度有影响，因此开发过程是影响因素之一。其值可大于1也可以小于1，若稳定不变则为1\n\n需求清晰完成度:需求是否足够清晰、完整也会对开发速度有影响。\n\n技术因素:若完成该项目涉及到团队中未知、不具备的技术知识也是风险之一。当然也可能为正面因素。\n\n团队配合:一个配合好的团队和配合差的团队其开发速度也是明显不同的。\n\n**说明:以上因素具体项目团队可自行调整。**\n\n确定性因素(FF)的综合影响(FR)计算公式为:\n$$\nFR=\\prod_{i=0}^n(FF)_i\n$$\n突发性因素往往是项目开始前哪一预测的。关于突发性因素大致参考如下\n\n| 突发性因素\\影响因子分数 | 高(+) | 中(+) | 低(+) | 稳定 | 低(-) | 中(-) | 高(-) |\n| ----------------------- | ----- | ----- | ----- | ---- | ----- | ----- | ----- |\n| 团队变化                | 1.1   | 1.05  | 1.02  | 1    | 0.98  | 0.95  | 0.91  |\n| 需求变化                | -     | -     | -     | 1    | 0.99  | 0.98  | 0.97  |\n| 团队成员兼职            | -     | -     | -     | 1    | 0.98  | 0.96  | 0.94  |\n| 业务方失误              | -     | -     | -     | 1    | 0.97  | 0.95  | 0.92  |\n| 开发环境变化            | 1.1   | 1.05  | 1.02  | 1    | 0.98  | 0.95  | 0.92  |\n| 临时增加减少任务        | 1.1   | 1.05  | 1.02  | 1    | 0.97  | 0.95  | 0.91  |\n| 其它                    | 1.1   | 1.05  | 1.02  | 1    | 0.99  | 0.97  | 0.96  |\n\n团队变化:团队人员离职，新增成员等\n\n需求变化:开发过程中需求的变更\n\n团队成员兼职:团队成员身兼数职，在其他团队也有工作。\n\n业务方失误:业务方提出错误的要求等\n\n开发环境变化:项目开发过程中开发环境发生变化\n\n临时增加减少任务:项目过程中临时性的新增或减少需求。\n\n**说明:以上因素具体项目团队可自行调整。**\n\n突发性因素(VF)的综合影响(DF)计算公式为:\n$$\nDF=\\prod_{i=0}^n(VF)_i\n$$\n\n#### 2.3 实际开发速度\n\n&nbsp;&nbsp;&nbsp;&nbsp;实际开发速度需要在理想开发速度的基础上增加各种影响因子。其公式如下:\n$$\nV=V_t^{FR\\times DF}\n$$\n![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-17/79849907.jpg)\n\n如上图,由下往上分别为3-8人的开发团队开发速度与综合影响因子分数的函数图像(影响因子在0.8-1.2之间)。\n\n2.3 开发时间评估\n\n&nbsp;&nbsp;&nbsp;&nbsp;开发时间计算公式如下:\n$$\nT=\\frac {E}{V}=\\frac {\\sum_{i=1}^n{(SC)}_i}{V_t^{FR\\times DF}}(Days)\n$$\n\n### 三、模型举例\n\n输入:\n\n* 任务数:50\n* 团队人数:7\n* 固定性因素影响值:\n  * 团队组成  0.97  \n  * 开发过程  1  \n  * 需求清晰完整度  0.95  \n  * 技术因素  0.96  \n  * 团队配合  1.02  \n  * 其它因素  0.96\n* 突发性因素影响值:\n  * 团队变化   0.95\n  * 需求变化   0.98 \n  * 团队成员兼职  0.99  \n  * 业务方失误  1 \n  * 开发环境变化  1\n  * 临时增加减少任务   1 \n  * 其它   0.99 \n\n输出:\n\n* 总工作量:  150\n\n* 理想开发速度:  7\n\n* 理想开发时间:  21.4天\n\n* 固定性因素影响综合值:  0.87\n\n* 突发性因素影响值:  0.91\n\n* 实际开发速度: 4.65\n\n* 实际开发时间: 32.2天\n\n### 结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;以上仅个人针对我们公司项目所制定的一种工作量评估模型。其具体实用程度，使用中存在的问题等，还有待时间与大量数据的支撑。也希望道友们能提供一些宝贵的意见。你们的团队是如何进行工时与工作量的评估的。","source":"_posts/效能管理/团队方法论/软件-敏捷-开发中工作量工时评估方法.md","raw":"---\ntitle: 软件(敏捷)开发中工作量工时评估方法\ncopyright: true\ndate: 2018-11-14 08:58:01\ntags: \n- 项目管理\n- 敏捷开发\n- 工时评估\ncategories: 项目管理\nkeywords: 敏捷开发,项目管理\nmathjax: true\n---\n\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;软件开发中如何合理的预估项目的开发时间始终是一个难题。因为项目中不确定性的因素太多。这里我们根据日常项目中开发的规律总结出一种工作量预估的模型。该模型参考物理学中时间的计算方式:\n$$\n时间(T)=\\frac {距离(S)}{速度(V)}\n$$\n得到我们的软件开发时间计算公式:\n$$\n开发时间(T)=\\frac {工作量(S)}{开发速度(V)}\n$$\n\n<!--more-->\n\n### 一、工作量的确定\n\n&nbsp;&nbsp;&nbsp;&nbsp;工作量主要与三方面的因素有关系。任务的规模、任务的复杂度以及完成该任务的人员能力水平。这里我们先假设一个标准的人员水平(即：理想状态下人员水平都是一定的标准工程师)。那么此时工作量主要与任务的规模与任务的复杂度有关系。\n\n#### 1.1 任务规模(S)\n\n 关于任务的规模拆分出如下等级。(我们可以总结自己项目的规律来调整这个等级)：\n\n| 级别 | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| 5    | 任务规模极其之大，甚至不能估计，可以拆分成很多小任务，甚至子工程。 |\n| 4    | 任务规模较大，需要一周左右的时间来完成，可以拆分成很多小任务 |\n| 3    | 中等规模的任务，需要三到五天左右的工作量                     |\n| 2    | 任务小，需要两到三天左右的工作量                             |\n| 1    | 任务较小，需要一天左右的工作量                               |\n| 0.5  | 任务非常小，需要很少的工作量，需要几个小时的工作             |\n\n注意:这里的工作量只是完成任务本身所需的工作量，但软件开发往往不只是完成任务本身，更多时候任务还会涉及到其它相关的任务、系统。也有些任务可能涉及到团队技术的盲点，需要一定的时间研究分析等。因此，我们还需要结合任务的复杂度来进行工作量的评估。\n\n#### 1.2 任务复杂度(C)\n\n关于任务复杂度，同样可以拆分出以下几个等级。\n\n| 级别 | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| 5    | 极其复杂，更多依赖于其它任务、系统或子系统，含有团队中缺乏的技术，或者一些重要的经验，任务描述很不清晰，有许多未知因素，对外部任务、系统或子系统有很大的影响等 |\n| 4    | 非常复杂，依赖于其它任务、系统或子系统，其中所涉及到的一些技术点、经验在团队中不是强项，任务描述不清晰，有些未知因素，需要极高的一些技术能力才能完成，对外部任务、系统或子系统有一定的影响等 |\n| 3    | 中等程度复杂，有些依赖于其它任务、系统或子系统，完成任务很少或不需要研究，任务描述很清晰，未知因素基本没有，只需要一般的技术能力就可以完成，对外部任务、系统或子系统很少的影响等 |\n| 2    | 简单，很少依赖于其它任务、系统或子系统，其中所涉及到的一些技术点、经验在团队中曾经有过，任务描述基本清晰，未知因素较少，只需要一般的技术能力就可以完成，对外部任务、系统或子系统基本没有影响 |\n| 1    | 较简单，基本没有未知因素，所涉及的技术、经验都是团队非常熟练的。只需要基本的编程能力就可以完成，任务影响力仅涉及自身。 |\n\n#### 1.3 工作量(E)\n\n$$\n单个任务工作量(o)=SC\n$$\n\n\n$$\n项目的总工作量(E)=\\sum_{i=1}^n{(SC)}_i\n$$\n这里，我们定义工作量的最小工作单位为sp，单位时间一天的工作量。1sp即：我们的标准工程师一天的工作量为1sp(即:我们的标准工程师理想中的开发速度为1sp)；\n\n### 二、开发速度的评估\n\n#### 2.1 理想开发速度\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们的一个标准工程师理想中的开发速度就是一天可以完成1sp的工作量。前提是标准程序员，但显然我们团队中的程序员不可能都是标准工程师。因此理想中我们的团队开发速度为:\n$$\n团队理想开发速度(V_t)=标准工程师开发速度(V_s)*团队人员个数(R)\n$$\n\n#### 2.2 开发速度的影响因子\n\n&nbsp;&nbsp;&nbsp;&nbsp;项目开发速度是一个很复杂的概念，很难准确的对其进行定义。考虑到不同团队成员的能力不同，则开发速度也不相同，即使是同一团队，其开发速度也不是一成不变的，会受到各种因素的影响。理想开发速度仅仅是没有受到任何阻力影响时的速度。但在项目过程中，总会遇到一些影响。其影响因素主要包括两方面。确定性因素以及突发性因素，在项目开始前，项目经理对以下两种因素预估的越准确，那么对开发时间的评估也越准确。\n\n确定性因素一般是项目客观存在的，容易在开始前预测的。关于确定性因素大致参考如下:\n\n| 影响因子       | 影响因子分数(以下为示例分数，具体分数可根据情况自定义i>0,若稳定则为1) |\n| -------------- | ------------------------------------------------------------ |\n| 团队组成       | 0.95                                                         |\n| 开发过程       | 1                                                            |\n| 需求清晰完整度 | 0.96                                                         |\n| 技术因素       | 0.97                                                         |\n| 团队配合       | 1.05                                                         |\n| 其它因素       | 0.98                                                         |\n\n团队组成:考虑到团队成员不可能为标准工程师。因此团队人员的能力是影响团队开发速度的一个很大因素。我们可以在团队中找一个接近于标准工程师的人，得到他的能力系数(SF)为1sp(一天可以完成1sp的工作量)，则以他为基准可以得到团队所有人的能力系数。则团队组成的影响因子分数(TF)计算公式为:\n$$\nTF=\\frac{\\sum_{i=1}^N{(SF)}_i} {N}\n$$\n开发过程:考虑到改进开发过程(采用敏捷，优化测试方法等)会对开发速度有影响，因此开发过程是影响因素之一。其值可大于1也可以小于1，若稳定不变则为1\n\n需求清晰完成度:需求是否足够清晰、完整也会对开发速度有影响。\n\n技术因素:若完成该项目涉及到团队中未知、不具备的技术知识也是风险之一。当然也可能为正面因素。\n\n团队配合:一个配合好的团队和配合差的团队其开发速度也是明显不同的。\n\n**说明:以上因素具体项目团队可自行调整。**\n\n确定性因素(FF)的综合影响(FR)计算公式为:\n$$\nFR=\\prod_{i=0}^n(FF)_i\n$$\n突发性因素往往是项目开始前哪一预测的。关于突发性因素大致参考如下\n\n| 突发性因素\\影响因子分数 | 高(+) | 中(+) | 低(+) | 稳定 | 低(-) | 中(-) | 高(-) |\n| ----------------------- | ----- | ----- | ----- | ---- | ----- | ----- | ----- |\n| 团队变化                | 1.1   | 1.05  | 1.02  | 1    | 0.98  | 0.95  | 0.91  |\n| 需求变化                | -     | -     | -     | 1    | 0.99  | 0.98  | 0.97  |\n| 团队成员兼职            | -     | -     | -     | 1    | 0.98  | 0.96  | 0.94  |\n| 业务方失误              | -     | -     | -     | 1    | 0.97  | 0.95  | 0.92  |\n| 开发环境变化            | 1.1   | 1.05  | 1.02  | 1    | 0.98  | 0.95  | 0.92  |\n| 临时增加减少任务        | 1.1   | 1.05  | 1.02  | 1    | 0.97  | 0.95  | 0.91  |\n| 其它                    | 1.1   | 1.05  | 1.02  | 1    | 0.99  | 0.97  | 0.96  |\n\n团队变化:团队人员离职，新增成员等\n\n需求变化:开发过程中需求的变更\n\n团队成员兼职:团队成员身兼数职，在其他团队也有工作。\n\n业务方失误:业务方提出错误的要求等\n\n开发环境变化:项目开发过程中开发环境发生变化\n\n临时增加减少任务:项目过程中临时性的新增或减少需求。\n\n**说明:以上因素具体项目团队可自行调整。**\n\n突发性因素(VF)的综合影响(DF)计算公式为:\n$$\nDF=\\prod_{i=0}^n(VF)_i\n$$\n\n#### 2.3 实际开发速度\n\n&nbsp;&nbsp;&nbsp;&nbsp;实际开发速度需要在理想开发速度的基础上增加各种影响因子。其公式如下:\n$$\nV=V_t^{FR\\times DF}\n$$\n![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-17/79849907.jpg)\n\n如上图,由下往上分别为3-8人的开发团队开发速度与综合影响因子分数的函数图像(影响因子在0.8-1.2之间)。\n\n2.3 开发时间评估\n\n&nbsp;&nbsp;&nbsp;&nbsp;开发时间计算公式如下:\n$$\nT=\\frac {E}{V}=\\frac {\\sum_{i=1}^n{(SC)}_i}{V_t^{FR\\times DF}}(Days)\n$$\n\n### 三、模型举例\n\n输入:\n\n* 任务数:50\n* 团队人数:7\n* 固定性因素影响值:\n  * 团队组成  0.97  \n  * 开发过程  1  \n  * 需求清晰完整度  0.95  \n  * 技术因素  0.96  \n  * 团队配合  1.02  \n  * 其它因素  0.96\n* 突发性因素影响值:\n  * 团队变化   0.95\n  * 需求变化   0.98 \n  * 团队成员兼职  0.99  \n  * 业务方失误  1 \n  * 开发环境变化  1\n  * 临时增加减少任务   1 \n  * 其它   0.99 \n\n输出:\n\n* 总工作量:  150\n\n* 理想开发速度:  7\n\n* 理想开发时间:  21.4天\n\n* 固定性因素影响综合值:  0.87\n\n* 突发性因素影响值:  0.91\n\n* 实际开发速度: 4.65\n\n* 实际开发时间: 32.2天\n\n### 结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;以上仅个人针对我们公司项目所制定的一种工作量评估模型。其具体实用程度，使用中存在的问题等，还有待时间与大量数据的支撑。也希望道友们能提供一些宝贵的意见。你们的团队是如何进行工时与工作量的评估的。","slug":"效能管理/团队方法论/软件-敏捷-开发中工作量工时评估方法","published":1,"updated":"2021-03-14T03:04:50.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpze00dhhyjfup2rmqsh","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;软件开发中如何合理的预估项目的开发时间始终是一个难题。因为项目中不确定性的因素太多。这里我们根据日常项目中开发的规律总结出一种工作量预估的模型。该模型参考物理学中时间的计算方式:</p>\n<script type=\"math/tex; mode=display\">\n时间(T)=\\frac {距离(S)}{速度(V)}</script><p>得到我们的软件开发时间计算公式:</p>\n<script type=\"math/tex; mode=display\">\n开发时间(T)=\\frac {工作量(S)}{开发速度(V)}</script><a id=\"more\"></a>\n<h3 id=\"一、工作量的确定\"><a href=\"#一、工作量的确定\" class=\"headerlink\" title=\"一、工作量的确定\"></a>一、工作量的确定</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;工作量主要与三方面的因素有关系。任务的规模、任务的复杂度以及完成该任务的人员能力水平。这里我们先假设一个标准的人员水平(即：理想状态下人员水平都是一定的标准工程师)。那么此时工作量主要与任务的规模与任务的复杂度有关系。</p>\n<h4 id=\"1-1-任务规模-S\"><a href=\"#1-1-任务规模-S\" class=\"headerlink\" title=\"1.1 任务规模(S)\"></a>1.1 任务规模(S)</h4><p> 关于任务的规模拆分出如下等级。(我们可以总结自己项目的规律来调整这个等级)：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5</td>\n<td>任务规模极其之大，甚至不能估计，可以拆分成很多小任务，甚至子工程。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>任务规模较大，需要一周左右的时间来完成，可以拆分成很多小任务</td>\n</tr>\n<tr>\n<td>3</td>\n<td>中等规模的任务，需要三到五天左右的工作量</td>\n</tr>\n<tr>\n<td>2</td>\n<td>任务小，需要两到三天左右的工作量</td>\n</tr>\n<tr>\n<td>1</td>\n<td>任务较小，需要一天左右的工作量</td>\n</tr>\n<tr>\n<td>0.5</td>\n<td>任务非常小，需要很少的工作量，需要几个小时的工作</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>注意:这里的工作量只是完成任务本身所需的工作量，但软件开发往往不只是完成任务本身，更多时候任务还会涉及到其它相关的任务、系统。也有些任务可能涉及到团队技术的盲点，需要一定的时间研究分析等。因此，我们还需要结合任务的复杂度来进行工作量的评估。</p>\n<h4 id=\"1-2-任务复杂度-C\"><a href=\"#1-2-任务复杂度-C\" class=\"headerlink\" title=\"1.2 任务复杂度(C)\"></a>1.2 任务复杂度(C)</h4><p>关于任务复杂度，同样可以拆分出以下几个等级。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5</td>\n<td>极其复杂，更多依赖于其它任务、系统或子系统，含有团队中缺乏的技术，或者一些重要的经验，任务描述很不清晰，有许多未知因素，对外部任务、系统或子系统有很大的影响等</td>\n</tr>\n<tr>\n<td>4</td>\n<td>非常复杂，依赖于其它任务、系统或子系统，其中所涉及到的一些技术点、经验在团队中不是强项，任务描述不清晰，有些未知因素，需要极高的一些技术能力才能完成，对外部任务、系统或子系统有一定的影响等</td>\n</tr>\n<tr>\n<td>3</td>\n<td>中等程度复杂，有些依赖于其它任务、系统或子系统，完成任务很少或不需要研究，任务描述很清晰，未知因素基本没有，只需要一般的技术能力就可以完成，对外部任务、系统或子系统很少的影响等</td>\n</tr>\n<tr>\n<td>2</td>\n<td>简单，很少依赖于其它任务、系统或子系统，其中所涉及到的一些技术点、经验在团队中曾经有过，任务描述基本清晰，未知因素较少，只需要一般的技术能力就可以完成，对外部任务、系统或子系统基本没有影响</td>\n</tr>\n<tr>\n<td>1</td>\n<td>较简单，基本没有未知因素，所涉及的技术、经验都是团队非常熟练的。只需要基本的编程能力就可以完成，任务影响力仅涉及自身。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"1-3-工作量-E\"><a href=\"#1-3-工作量-E\" class=\"headerlink\" title=\"1.3 工作量(E)\"></a>1.3 工作量(E)</h4><script type=\"math/tex; mode=display\">\n单个任务工作量(o)=SC</script><script type=\"math/tex; mode=display\">\n项目的总工作量(E)=\\sum_{i=1}^n{(SC)}_i</script><p>这里，我们定义工作量的最小工作单位为sp，单位时间一天的工作量。1sp即：我们的标准工程师一天的工作量为1sp(即:我们的标准工程师理想中的开发速度为1sp)；</p>\n<h3 id=\"二、开发速度的评估\"><a href=\"#二、开发速度的评估\" class=\"headerlink\" title=\"二、开发速度的评估\"></a>二、开发速度的评估</h3><h4 id=\"2-1-理想开发速度\"><a href=\"#2-1-理想开发速度\" class=\"headerlink\" title=\"2.1 理想开发速度\"></a>2.1 理想开发速度</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;我们的一个标准工程师理想中的开发速度就是一天可以完成1sp的工作量。前提是标准程序员，但显然我们团队中的程序员不可能都是标准工程师。因此理想中我们的团队开发速度为:</p>\n<script type=\"math/tex; mode=display\">\n团队理想开发速度(V_t)=标准工程师开发速度(V_s)*团队人员个数(R)</script><h4 id=\"2-2-开发速度的影响因子\"><a href=\"#2-2-开发速度的影响因子\" class=\"headerlink\" title=\"2.2 开发速度的影响因子\"></a>2.2 开发速度的影响因子</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;项目开发速度是一个很复杂的概念，很难准确的对其进行定义。考虑到不同团队成员的能力不同，则开发速度也不相同，即使是同一团队，其开发速度也不是一成不变的，会受到各种因素的影响。理想开发速度仅仅是没有受到任何阻力影响时的速度。但在项目过程中，总会遇到一些影响。其影响因素主要包括两方面。确定性因素以及突发性因素，在项目开始前，项目经理对以下两种因素预估的越准确，那么对开发时间的评估也越准确。</p>\n<p>确定性因素一般是项目客观存在的，容易在开始前预测的。关于确定性因素大致参考如下:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>影响因子</th>\n<th>影响因子分数(以下为示例分数，具体分数可根据情况自定义i&gt;0,若稳定则为1)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>团队组成</td>\n<td>0.95</td>\n</tr>\n<tr>\n<td>开发过程</td>\n<td>1</td>\n</tr>\n<tr>\n<td>需求清晰完整度</td>\n<td>0.96</td>\n</tr>\n<tr>\n<td>技术因素</td>\n<td>0.97</td>\n</tr>\n<tr>\n<td>团队配合</td>\n<td>1.05</td>\n</tr>\n<tr>\n<td>其它因素</td>\n<td>0.98</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>团队组成:考虑到团队成员不可能为标准工程师。因此团队人员的能力是影响团队开发速度的一个很大因素。我们可以在团队中找一个接近于标准工程师的人，得到他的能力系数(SF)为1sp(一天可以完成1sp的工作量)，则以他为基准可以得到团队所有人的能力系数。则团队组成的影响因子分数(TF)计算公式为:</p>\n<script type=\"math/tex; mode=display\">\nTF=\\frac{\\sum_{i=1}^N{(SF)}_i} {N}</script><p>开发过程:考虑到改进开发过程(采用敏捷，优化测试方法等)会对开发速度有影响，因此开发过程是影响因素之一。其值可大于1也可以小于1，若稳定不变则为1</p>\n<p>需求清晰完成度:需求是否足够清晰、完整也会对开发速度有影响。</p>\n<p>技术因素:若完成该项目涉及到团队中未知、不具备的技术知识也是风险之一。当然也可能为正面因素。</p>\n<p>团队配合:一个配合好的团队和配合差的团队其开发速度也是明显不同的。</p>\n<p><strong>说明:以上因素具体项目团队可自行调整。</strong></p>\n<p>确定性因素(FF)的综合影响(FR)计算公式为:</p>\n<script type=\"math/tex; mode=display\">\nFR=\\prod_{i=0}^n(FF)_i</script><p>突发性因素往往是项目开始前哪一预测的。关于突发性因素大致参考如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>突发性因素\\影响因子分数</th>\n<th>高(+)</th>\n<th>中(+)</th>\n<th>低(+)</th>\n<th>稳定</th>\n<th>低(-)</th>\n<th>中(-)</th>\n<th>高(-)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>团队变化</td>\n<td>1.1</td>\n<td>1.05</td>\n<td>1.02</td>\n<td>1</td>\n<td>0.98</td>\n<td>0.95</td>\n<td>0.91</td>\n</tr>\n<tr>\n<td>需求变化</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>1</td>\n<td>0.99</td>\n<td>0.98</td>\n<td>0.97</td>\n</tr>\n<tr>\n<td>团队成员兼职</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>1</td>\n<td>0.98</td>\n<td>0.96</td>\n<td>0.94</td>\n</tr>\n<tr>\n<td>业务方失误</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>1</td>\n<td>0.97</td>\n<td>0.95</td>\n<td>0.92</td>\n</tr>\n<tr>\n<td>开发环境变化</td>\n<td>1.1</td>\n<td>1.05</td>\n<td>1.02</td>\n<td>1</td>\n<td>0.98</td>\n<td>0.95</td>\n<td>0.92</td>\n</tr>\n<tr>\n<td>临时增加减少任务</td>\n<td>1.1</td>\n<td>1.05</td>\n<td>1.02</td>\n<td>1</td>\n<td>0.97</td>\n<td>0.95</td>\n<td>0.91</td>\n</tr>\n<tr>\n<td>其它</td>\n<td>1.1</td>\n<td>1.05</td>\n<td>1.02</td>\n<td>1</td>\n<td>0.99</td>\n<td>0.97</td>\n<td>0.96</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>团队变化:团队人员离职，新增成员等</p>\n<p>需求变化:开发过程中需求的变更</p>\n<p>团队成员兼职:团队成员身兼数职，在其他团队也有工作。</p>\n<p>业务方失误:业务方提出错误的要求等</p>\n<p>开发环境变化:项目开发过程中开发环境发生变化</p>\n<p>临时增加减少任务:项目过程中临时性的新增或减少需求。</p>\n<p><strong>说明:以上因素具体项目团队可自行调整。</strong></p>\n<p>突发性因素(VF)的综合影响(DF)计算公式为:</p>\n<script type=\"math/tex; mode=display\">\nDF=\\prod_{i=0}^n(VF)_i</script><h4 id=\"2-3-实际开发速度\"><a href=\"#2-3-实际开发速度\" class=\"headerlink\" title=\"2.3 实际开发速度\"></a>2.3 实际开发速度</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;实际开发速度需要在理想开发速度的基础上增加各种影响因子。其公式如下:</p>\n<script type=\"math/tex; mode=display\">\nV=V_t^{FR\\times DF}</script><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-17/79849907.jpg\" alt></p>\n<p>如上图,由下往上分别为3-8人的开发团队开发速度与综合影响因子分数的函数图像(影响因子在0.8-1.2之间)。</p>\n<p>2.3 开发时间评估</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;开发时间计算公式如下:</p>\n<script type=\"math/tex; mode=display\">\nT=\\frac {E}{V}=\\frac {\\sum_{i=1}^n{(SC)}_i}{V_t^{FR\\times DF}}(Days)</script><h3 id=\"三、模型举例\"><a href=\"#三、模型举例\" class=\"headerlink\" title=\"三、模型举例\"></a>三、模型举例</h3><p>输入:</p>\n<ul>\n<li>任务数:50</li>\n<li>团队人数:7</li>\n<li>固定性因素影响值:<ul>\n<li>团队组成  0.97  </li>\n<li>开发过程  1  </li>\n<li>需求清晰完整度  0.95  </li>\n<li>技术因素  0.96  </li>\n<li>团队配合  1.02  </li>\n<li>其它因素  0.96</li>\n</ul>\n</li>\n<li>突发性因素影响值:<ul>\n<li>团队变化   0.95</li>\n<li>需求变化   0.98 </li>\n<li>团队成员兼职  0.99  </li>\n<li>业务方失误  1 </li>\n<li>开发环境变化  1</li>\n<li>临时增加减少任务   1 </li>\n<li>其它   0.99 </li>\n</ul>\n</li>\n</ul>\n<p>输出:</p>\n<ul>\n<li><p>总工作量:  150</p>\n</li>\n<li><p>理想开发速度:  7</p>\n</li>\n<li><p>理想开发时间:  21.4天</p>\n</li>\n<li><p>固定性因素影响综合值:  0.87</p>\n</li>\n<li><p>突发性因素影响值:  0.91</p>\n</li>\n<li><p>实际开发速度: 4.65</p>\n</li>\n<li><p>实际开发时间: 32.2天</p>\n</li>\n</ul>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;以上仅个人针对我们公司项目所制定的一种工作量评估模型。其具体实用程度，使用中存在的问题等，还有待时间与大量数据的支撑。也希望道友们能提供一些宝贵的意见。你们的团队是如何进行工时与工作量的评估的。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;软件开发中如何合理的预估项目的开发时间始终是一个难题。因为项目中不确定性的因素太多。这里我们根据日常项目中开发的规律总结出一种工作量预估的模型。该模型参考物理学中时间的计算方式:</p>\n<script type=\"math/tex; mode=display\">\n时间(T)=\\frac {距离(S)}{速度(V)}</script><p>得到我们的软件开发时间计算公式:</p>\n<script type=\"math/tex; mode=display\">\n开发时间(T)=\\frac {工作量(S)}{开发速度(V)}</script>","more":"<h3 id=\"一、工作量的确定\"><a href=\"#一、工作量的确定\" class=\"headerlink\" title=\"一、工作量的确定\"></a>一、工作量的确定</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;工作量主要与三方面的因素有关系。任务的规模、任务的复杂度以及完成该任务的人员能力水平。这里我们先假设一个标准的人员水平(即：理想状态下人员水平都是一定的标准工程师)。那么此时工作量主要与任务的规模与任务的复杂度有关系。</p>\n<h4 id=\"1-1-任务规模-S\"><a href=\"#1-1-任务规模-S\" class=\"headerlink\" title=\"1.1 任务规模(S)\"></a>1.1 任务规模(S)</h4><p> 关于任务的规模拆分出如下等级。(我们可以总结自己项目的规律来调整这个等级)：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5</td>\n<td>任务规模极其之大，甚至不能估计，可以拆分成很多小任务，甚至子工程。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>任务规模较大，需要一周左右的时间来完成，可以拆分成很多小任务</td>\n</tr>\n<tr>\n<td>3</td>\n<td>中等规模的任务，需要三到五天左右的工作量</td>\n</tr>\n<tr>\n<td>2</td>\n<td>任务小，需要两到三天左右的工作量</td>\n</tr>\n<tr>\n<td>1</td>\n<td>任务较小，需要一天左右的工作量</td>\n</tr>\n<tr>\n<td>0.5</td>\n<td>任务非常小，需要很少的工作量，需要几个小时的工作</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>注意:这里的工作量只是完成任务本身所需的工作量，但软件开发往往不只是完成任务本身，更多时候任务还会涉及到其它相关的任务、系统。也有些任务可能涉及到团队技术的盲点，需要一定的时间研究分析等。因此，我们还需要结合任务的复杂度来进行工作量的评估。</p>\n<h4 id=\"1-2-任务复杂度-C\"><a href=\"#1-2-任务复杂度-C\" class=\"headerlink\" title=\"1.2 任务复杂度(C)\"></a>1.2 任务复杂度(C)</h4><p>关于任务复杂度，同样可以拆分出以下几个等级。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>级别</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5</td>\n<td>极其复杂，更多依赖于其它任务、系统或子系统，含有团队中缺乏的技术，或者一些重要的经验，任务描述很不清晰，有许多未知因素，对外部任务、系统或子系统有很大的影响等</td>\n</tr>\n<tr>\n<td>4</td>\n<td>非常复杂，依赖于其它任务、系统或子系统，其中所涉及到的一些技术点、经验在团队中不是强项，任务描述不清晰，有些未知因素，需要极高的一些技术能力才能完成，对外部任务、系统或子系统有一定的影响等</td>\n</tr>\n<tr>\n<td>3</td>\n<td>中等程度复杂，有些依赖于其它任务、系统或子系统，完成任务很少或不需要研究，任务描述很清晰，未知因素基本没有，只需要一般的技术能力就可以完成，对外部任务、系统或子系统很少的影响等</td>\n</tr>\n<tr>\n<td>2</td>\n<td>简单，很少依赖于其它任务、系统或子系统，其中所涉及到的一些技术点、经验在团队中曾经有过，任务描述基本清晰，未知因素较少，只需要一般的技术能力就可以完成，对外部任务、系统或子系统基本没有影响</td>\n</tr>\n<tr>\n<td>1</td>\n<td>较简单，基本没有未知因素，所涉及的技术、经验都是团队非常熟练的。只需要基本的编程能力就可以完成，任务影响力仅涉及自身。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"1-3-工作量-E\"><a href=\"#1-3-工作量-E\" class=\"headerlink\" title=\"1.3 工作量(E)\"></a>1.3 工作量(E)</h4><script type=\"math/tex; mode=display\">\n单个任务工作量(o)=SC</script><script type=\"math/tex; mode=display\">\n项目的总工作量(E)=\\sum_{i=1}^n{(SC)}_i</script><p>这里，我们定义工作量的最小工作单位为sp，单位时间一天的工作量。1sp即：我们的标准工程师一天的工作量为1sp(即:我们的标准工程师理想中的开发速度为1sp)；</p>\n<h3 id=\"二、开发速度的评估\"><a href=\"#二、开发速度的评估\" class=\"headerlink\" title=\"二、开发速度的评估\"></a>二、开发速度的评估</h3><h4 id=\"2-1-理想开发速度\"><a href=\"#2-1-理想开发速度\" class=\"headerlink\" title=\"2.1 理想开发速度\"></a>2.1 理想开发速度</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;我们的一个标准工程师理想中的开发速度就是一天可以完成1sp的工作量。前提是标准程序员，但显然我们团队中的程序员不可能都是标准工程师。因此理想中我们的团队开发速度为:</p>\n<script type=\"math/tex; mode=display\">\n团队理想开发速度(V_t)=标准工程师开发速度(V_s)*团队人员个数(R)</script><h4 id=\"2-2-开发速度的影响因子\"><a href=\"#2-2-开发速度的影响因子\" class=\"headerlink\" title=\"2.2 开发速度的影响因子\"></a>2.2 开发速度的影响因子</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;项目开发速度是一个很复杂的概念，很难准确的对其进行定义。考虑到不同团队成员的能力不同，则开发速度也不相同，即使是同一团队，其开发速度也不是一成不变的，会受到各种因素的影响。理想开发速度仅仅是没有受到任何阻力影响时的速度。但在项目过程中，总会遇到一些影响。其影响因素主要包括两方面。确定性因素以及突发性因素，在项目开始前，项目经理对以下两种因素预估的越准确，那么对开发时间的评估也越准确。</p>\n<p>确定性因素一般是项目客观存在的，容易在开始前预测的。关于确定性因素大致参考如下:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>影响因子</th>\n<th>影响因子分数(以下为示例分数，具体分数可根据情况自定义i&gt;0,若稳定则为1)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>团队组成</td>\n<td>0.95</td>\n</tr>\n<tr>\n<td>开发过程</td>\n<td>1</td>\n</tr>\n<tr>\n<td>需求清晰完整度</td>\n<td>0.96</td>\n</tr>\n<tr>\n<td>技术因素</td>\n<td>0.97</td>\n</tr>\n<tr>\n<td>团队配合</td>\n<td>1.05</td>\n</tr>\n<tr>\n<td>其它因素</td>\n<td>0.98</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>团队组成:考虑到团队成员不可能为标准工程师。因此团队人员的能力是影响团队开发速度的一个很大因素。我们可以在团队中找一个接近于标准工程师的人，得到他的能力系数(SF)为1sp(一天可以完成1sp的工作量)，则以他为基准可以得到团队所有人的能力系数。则团队组成的影响因子分数(TF)计算公式为:</p>\n<script type=\"math/tex; mode=display\">\nTF=\\frac{\\sum_{i=1}^N{(SF)}_i} {N}</script><p>开发过程:考虑到改进开发过程(采用敏捷，优化测试方法等)会对开发速度有影响，因此开发过程是影响因素之一。其值可大于1也可以小于1，若稳定不变则为1</p>\n<p>需求清晰完成度:需求是否足够清晰、完整也会对开发速度有影响。</p>\n<p>技术因素:若完成该项目涉及到团队中未知、不具备的技术知识也是风险之一。当然也可能为正面因素。</p>\n<p>团队配合:一个配合好的团队和配合差的团队其开发速度也是明显不同的。</p>\n<p><strong>说明:以上因素具体项目团队可自行调整。</strong></p>\n<p>确定性因素(FF)的综合影响(FR)计算公式为:</p>\n<script type=\"math/tex; mode=display\">\nFR=\\prod_{i=0}^n(FF)_i</script><p>突发性因素往往是项目开始前哪一预测的。关于突发性因素大致参考如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>突发性因素\\影响因子分数</th>\n<th>高(+)</th>\n<th>中(+)</th>\n<th>低(+)</th>\n<th>稳定</th>\n<th>低(-)</th>\n<th>中(-)</th>\n<th>高(-)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>团队变化</td>\n<td>1.1</td>\n<td>1.05</td>\n<td>1.02</td>\n<td>1</td>\n<td>0.98</td>\n<td>0.95</td>\n<td>0.91</td>\n</tr>\n<tr>\n<td>需求变化</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>1</td>\n<td>0.99</td>\n<td>0.98</td>\n<td>0.97</td>\n</tr>\n<tr>\n<td>团队成员兼职</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>1</td>\n<td>0.98</td>\n<td>0.96</td>\n<td>0.94</td>\n</tr>\n<tr>\n<td>业务方失误</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>1</td>\n<td>0.97</td>\n<td>0.95</td>\n<td>0.92</td>\n</tr>\n<tr>\n<td>开发环境变化</td>\n<td>1.1</td>\n<td>1.05</td>\n<td>1.02</td>\n<td>1</td>\n<td>0.98</td>\n<td>0.95</td>\n<td>0.92</td>\n</tr>\n<tr>\n<td>临时增加减少任务</td>\n<td>1.1</td>\n<td>1.05</td>\n<td>1.02</td>\n<td>1</td>\n<td>0.97</td>\n<td>0.95</td>\n<td>0.91</td>\n</tr>\n<tr>\n<td>其它</td>\n<td>1.1</td>\n<td>1.05</td>\n<td>1.02</td>\n<td>1</td>\n<td>0.99</td>\n<td>0.97</td>\n<td>0.96</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>团队变化:团队人员离职，新增成员等</p>\n<p>需求变化:开发过程中需求的变更</p>\n<p>团队成员兼职:团队成员身兼数职，在其他团队也有工作。</p>\n<p>业务方失误:业务方提出错误的要求等</p>\n<p>开发环境变化:项目开发过程中开发环境发生变化</p>\n<p>临时增加减少任务:项目过程中临时性的新增或减少需求。</p>\n<p><strong>说明:以上因素具体项目团队可自行调整。</strong></p>\n<p>突发性因素(VF)的综合影响(DF)计算公式为:</p>\n<script type=\"math/tex; mode=display\">\nDF=\\prod_{i=0}^n(VF)_i</script><h4 id=\"2-3-实际开发速度\"><a href=\"#2-3-实际开发速度\" class=\"headerlink\" title=\"2.3 实际开发速度\"></a>2.3 实际开发速度</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;实际开发速度需要在理想开发速度的基础上增加各种影响因子。其公式如下:</p>\n<script type=\"math/tex; mode=display\">\nV=V_t^{FR\\times DF}</script><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-17/79849907.jpg\" alt></p>\n<p>如上图,由下往上分别为3-8人的开发团队开发速度与综合影响因子分数的函数图像(影响因子在0.8-1.2之间)。</p>\n<p>2.3 开发时间评估</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;开发时间计算公式如下:</p>\n<script type=\"math/tex; mode=display\">\nT=\\frac {E}{V}=\\frac {\\sum_{i=1}^n{(SC)}_i}{V_t^{FR\\times DF}}(Days)</script><h3 id=\"三、模型举例\"><a href=\"#三、模型举例\" class=\"headerlink\" title=\"三、模型举例\"></a>三、模型举例</h3><p>输入:</p>\n<ul>\n<li>任务数:50</li>\n<li>团队人数:7</li>\n<li>固定性因素影响值:<ul>\n<li>团队组成  0.97  </li>\n<li>开发过程  1  </li>\n<li>需求清晰完整度  0.95  </li>\n<li>技术因素  0.96  </li>\n<li>团队配合  1.02  </li>\n<li>其它因素  0.96</li>\n</ul>\n</li>\n<li>突发性因素影响值:<ul>\n<li>团队变化   0.95</li>\n<li>需求变化   0.98 </li>\n<li>团队成员兼职  0.99  </li>\n<li>业务方失误  1 </li>\n<li>开发环境变化  1</li>\n<li>临时增加减少任务   1 </li>\n<li>其它   0.99 </li>\n</ul>\n</li>\n</ul>\n<p>输出:</p>\n<ul>\n<li><p>总工作量:  150</p>\n</li>\n<li><p>理想开发速度:  7</p>\n</li>\n<li><p>理想开发时间:  21.4天</p>\n</li>\n<li><p>固定性因素影响综合值:  0.87</p>\n</li>\n<li><p>突发性因素影响值:  0.91</p>\n</li>\n<li><p>实际开发速度: 4.65</p>\n</li>\n<li><p>实际开发时间: 32.2天</p>\n</li>\n</ul>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;以上仅个人针对我们公司项目所制定的一种工作量评估模型。其具体实用程度，使用中存在的问题等，还有待时间与大量数据的支撑。也希望道友们能提供一些宝贵的意见。你们的团队是如何进行工时与工作量的评估的。</p>"},{"title":"蓝绿红黑灰|常用的发布方式","copyright":true,"date":"2021-01-08T03:29:26.000Z","keywords":"发布方式","aside":"Notes-LargeSite","_content":"\n## 1 发布之痛\n\n相信每个程序员都曾经经历过，或正在经历过发布的痛苦，每个发布日的夜晚通常是灯火通明。在现在互联网公司较高的发布频率之下更是放大了这种痛苦，多少正值青春年华的程序员为此白了发、秃了头！让程序员经历发布痛苦的原因有很多，其中之一就是发布方式。\n\n<!--more-->\n\n发布造成系统故障影响系统可用性的最大原因之一。因此大多数的公司会选择在用户量最小的深夜进行发布，这就造成了每到发布日就有一大堆黑眼圈的程序员熬夜坐等发布，但其实有了一些好的发布方式也许就不必如此。\n我曾经带过两家公司，这两家公司团队的对于发布时间的看法则孑然不同，第一家公司的总是担心发布会对用用户造成影响，因此每次发布都会选择深夜进行发布。而另一家公司则认为应该在用户流量最大的时候进行发布，这样系统问题则可以尽早的暴露出来。造成这两种的结果我分析有很多原因。开发人员信心、交付质量、资源工具、发布方式......我们今天就来看看一些常用的发布方式。\n\n## 2 常用的发布方式\n\n### 2.1 蛮力发布\n\n顾名思义，这种方式简单而粗暴！直接将新的版本覆盖掉老的版本。其优点就是简单而且成本较低，但缺点同样很明显，就是发布过程中通常会导致服务中断进而导致用户受到影响，这种方式比较适应于开发环境或者测试环境或者是公司内部系统这种对可用性要求不高的场景，有些小的公司资源稀缺(服务器资源，基础设施等)的时候也会采用这种方式。比如我的第一家公司一开始的规模较小的时候，通常会选择一个夜深人静、访问量小的时候，悄悄地发布。\n![蛮力发布](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E8%9B%AE%E5%8A%9B%E5%8F%91%E5%B8%83.png)\n\n### 2.2 金丝雀发布\n\n金丝雀发布是灰度发布的一种。灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。即在发布过程中一部分用户继续使用老版本，一部分用户使用新版本，不断地扩大新版本的访问流量。最终实现老版本到新版本的过度。由于金丝雀对瓦斯极其敏感，因此以前旷工开矿下矿洞前，先会放一只金丝雀进去探是否有有毒气体，看金丝雀能否活下来，金丝雀发布由此得名。\n![金丝雀发布](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E9%87%91%E4%B8%9D%E9%9B%80%E5%8F%91%E5%B8%83.png)\n发布过程中，先发一台或者一小部分比例的机器作为金丝雀，用于流量验证。如果金丝雀验证通过则把剩余机器全部发掉。如果金丝雀验证失败，则直接回退金丝雀。金丝雀发布的优势在于可以用少量用户来验证新版本功能，这样即使有问题所影响的也是很小的一部分客户。如果对新版本功能或性能缺乏足够信心那么就可以采用这种方式。这种方式也有其缺点，金丝雀发布本质上仍然是一次性的全量发布，发布过程中用户体验并不平滑，有些隐藏深处的bug少量用户可能并不能验证出来问题，需要逐步扩大流量才可以。\n\n### 2.3 滚动发布\n\n滚动发布是在金丝雀发布基础上进行改进的一种发布方式。相比于金丝雀发布，先发金丝雀，然后全发的方式，滚动发布则是整个发布过程中按批次进行发布。每个批次拉入后都可作为金丝雀进行验证，这样流量逐步放大直至结束。![滚动发布](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E6%BB%9A%E5%8A%A8%E5%8F%91%E5%B8%83.png)\n这种方式的优点就是对用户的影响小，体验平滑，但同样也有很多缺点，首先就是发布和回退时间慢，其次发布工具复杂，负载均衡设备需要具有平滑的拉入拉出能力，一般公司并没有资源投入研发这种复杂的发布工具。再者\n发布过程中新老版本同时运行，需要注意兼容性问题。\n\n### 2.4 蓝绿部署\n\n蓝绿部署，是采用两个分开的集群对软件版本进行升级的一种方式。它的部署模型中包括一个蓝色集群 Group1 和一个绿色集群 Group2，在没有新版本上线的情况下，两个集群上运行的版本是一致的，同时对外提供服务。![蓝绿部署](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E8%93%9D%E7%BB%BF%E9%83%A8%E7%BD%B2.png)\n系统升级时，蓝绿部署的流程是：\n\n- 从负载均衡器列表中删除集群Group1，让集群 Group2  单独提供服务。\n- 在集群 Group1 上部署新版本。\n- 集群 Group1 升级完毕后，把负载均衡列表全部指向 Group1，并删除集群 Group2  ，由 Group1 单独提供服务。\n- 在集群 Group2   上部署完新版本后，再把它添加回负载均衡列表中。\n\n这样，就完成了两个集群上所有机器的版本升级。\n蓝绿部署的优点是升级和回退速度非常快，缺点是全量升级，如果V2版本有问题，对用户影响大再者由于升级过程中会服务器资源会减少一半，有可能产生服务器过载问题，因此这种发布方式也不适用于在业务高峰期使用。\n\n### 2.5 红黑发布\n\n与蓝绿部署类似，红黑部署也是通过两个集群完成软件版本的升级。当前提供服务的所有机器都运行在红色集群 Group1 中，当需要发布新版本的时候，具体流程是这样的：\n\n- 先申请一个黑色集群 Group2  ，在 Group2   上部署新版本的服务；\n- 等到 Group2  升级完成后，我们一次性地把负载均衡全部指向 Group2  ；\n- 把 Group1 集群从负载均衡列表中删除，并释放集群 Group1 中所有机器。这\n\n这样就完成了一个版本的升级。可以看到，与蓝绿部署相比，红黑部署获得了两个收益：一是，简化了流程；二是，避免了在升级的过程中，由于只有一半的服务器提供服务，而可能导致的系统过载问题。但同样也存在全量升级对用户的影响问题，也带来了一个新的问题，就是发布过程中需要两倍的服务器资源。\n![红黑发布.png](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E7%BA%A2%E9%BB%91%E5%8F%91%E5%B8%83.png)\n\n### 2.6 功能开关\n\n这种发布方式是利用代码中的功能开关来控制发布逻辑，是一种相对比较低成本和简单的发布方式。研发人员可以灵活定制和自助完成的发布方式。这种方式通常依赖于一个配置中心系统，当然如果没有，可以使用简单的配置文件。\n\n![功能开关.png](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E5%8A%9F%E8%83%BD%E5%BC%80%E5%85%B3.png)\n应用上线后，开关先不打开，只待一声令下，可以全量打开开关，也可以按照某种维度(公司ID，用户ID等)分批打开开关进行流量验证，如果有问题，则随时关闭开关。\n这种方式的优势在于升级切换和回退速度非常快，而且相对于复杂的发布工具，成本较为低廉。但是也有很大的不足之处，就是开关本身也是代码，而且是与业务无关的代码，对代码的侵入性较高，也必须定期清理老版本的逻辑，使得维护成本增加。\n\n## 3 小结\n\n这篇文章介绍了目前常用的一些发布方式，每种发布方式各有其优缺点。但其实在真正实践过程中这些发布方式往往是根据具体的情况来结合使用的。主要可以通过升级回退速度、成本、对用户影响三个方面来考虑。\n比如在我最开始的小型公司里，公司业务小，服务器资源也不足，甚至连最基础的负载均衡服务器都没有，这个时候我们的发布通常是选择一个流量小的时候进行蛮力发布的，这个时候也许会对用户造成短暂的影响，但那个时候的我们是没有人力物力财力......去搞后面那些复杂的方式的。\n而后来的某厂里有着充足的资源，我们有着多服务器群组，各种强大的发布工具......，通常我们是结合具体场景来选择合适的发布方式的。最常用的其中就是金丝雀发布和滚动发布。而在有些时候由于集群中的请求是随机分发的你并不能保证同一个用户的上一个请求和下一个请求还在同一个服务器上，这时如果旧的版本不能兼容新的版本的时候，如果是在业务流量低的时候，我们会考虑采用蓝绿部署的方式，如果在流量高峰期则会采用红黑发布的方式来避免服务器过载。\n而针对一些特殊的功能也经常会采用滚动发布+功能功能开关的方式。新版本发上去之后，逐步打开开关验证。\n总之，各种发布方式的本质目的都是为了提高我们的发布效率，保持系统可用性，减少对用户的影响能够让用户平滑的过渡到新的版本。","source":"_posts/效能管理/团队方法论/蓝绿红黑灰常用的发布方式.md","raw":"---\ntitle: 蓝绿红黑灰|常用的发布方式\ncopyright: true\ndate: 2021-01-08 11:29:26\ntags: \n- 团队方法论\n- 监控告警体系\ncategories: \n- 团队方法论\n- 发布方式\nkeywords: 发布方式\naside: Notes-LargeSite\n---\n\n## 1 发布之痛\n\n相信每个程序员都曾经经历过，或正在经历过发布的痛苦，每个发布日的夜晚通常是灯火通明。在现在互联网公司较高的发布频率之下更是放大了这种痛苦，多少正值青春年华的程序员为此白了发、秃了头！让程序员经历发布痛苦的原因有很多，其中之一就是发布方式。\n\n<!--more-->\n\n发布造成系统故障影响系统可用性的最大原因之一。因此大多数的公司会选择在用户量最小的深夜进行发布，这就造成了每到发布日就有一大堆黑眼圈的程序员熬夜坐等发布，但其实有了一些好的发布方式也许就不必如此。\n我曾经带过两家公司，这两家公司团队的对于发布时间的看法则孑然不同，第一家公司的总是担心发布会对用用户造成影响，因此每次发布都会选择深夜进行发布。而另一家公司则认为应该在用户流量最大的时候进行发布，这样系统问题则可以尽早的暴露出来。造成这两种的结果我分析有很多原因。开发人员信心、交付质量、资源工具、发布方式......我们今天就来看看一些常用的发布方式。\n\n## 2 常用的发布方式\n\n### 2.1 蛮力发布\n\n顾名思义，这种方式简单而粗暴！直接将新的版本覆盖掉老的版本。其优点就是简单而且成本较低，但缺点同样很明显，就是发布过程中通常会导致服务中断进而导致用户受到影响，这种方式比较适应于开发环境或者测试环境或者是公司内部系统这种对可用性要求不高的场景，有些小的公司资源稀缺(服务器资源，基础设施等)的时候也会采用这种方式。比如我的第一家公司一开始的规模较小的时候，通常会选择一个夜深人静、访问量小的时候，悄悄地发布。\n![蛮力发布](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E8%9B%AE%E5%8A%9B%E5%8F%91%E5%B8%83.png)\n\n### 2.2 金丝雀发布\n\n金丝雀发布是灰度发布的一种。灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。即在发布过程中一部分用户继续使用老版本，一部分用户使用新版本，不断地扩大新版本的访问流量。最终实现老版本到新版本的过度。由于金丝雀对瓦斯极其敏感，因此以前旷工开矿下矿洞前，先会放一只金丝雀进去探是否有有毒气体，看金丝雀能否活下来，金丝雀发布由此得名。\n![金丝雀发布](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E9%87%91%E4%B8%9D%E9%9B%80%E5%8F%91%E5%B8%83.png)\n发布过程中，先发一台或者一小部分比例的机器作为金丝雀，用于流量验证。如果金丝雀验证通过则把剩余机器全部发掉。如果金丝雀验证失败，则直接回退金丝雀。金丝雀发布的优势在于可以用少量用户来验证新版本功能，这样即使有问题所影响的也是很小的一部分客户。如果对新版本功能或性能缺乏足够信心那么就可以采用这种方式。这种方式也有其缺点，金丝雀发布本质上仍然是一次性的全量发布，发布过程中用户体验并不平滑，有些隐藏深处的bug少量用户可能并不能验证出来问题，需要逐步扩大流量才可以。\n\n### 2.3 滚动发布\n\n滚动发布是在金丝雀发布基础上进行改进的一种发布方式。相比于金丝雀发布，先发金丝雀，然后全发的方式，滚动发布则是整个发布过程中按批次进行发布。每个批次拉入后都可作为金丝雀进行验证，这样流量逐步放大直至结束。![滚动发布](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E6%BB%9A%E5%8A%A8%E5%8F%91%E5%B8%83.png)\n这种方式的优点就是对用户的影响小，体验平滑，但同样也有很多缺点，首先就是发布和回退时间慢，其次发布工具复杂，负载均衡设备需要具有平滑的拉入拉出能力，一般公司并没有资源投入研发这种复杂的发布工具。再者\n发布过程中新老版本同时运行，需要注意兼容性问题。\n\n### 2.4 蓝绿部署\n\n蓝绿部署，是采用两个分开的集群对软件版本进行升级的一种方式。它的部署模型中包括一个蓝色集群 Group1 和一个绿色集群 Group2，在没有新版本上线的情况下，两个集群上运行的版本是一致的，同时对外提供服务。![蓝绿部署](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E8%93%9D%E7%BB%BF%E9%83%A8%E7%BD%B2.png)\n系统升级时，蓝绿部署的流程是：\n\n- 从负载均衡器列表中删除集群Group1，让集群 Group2  单独提供服务。\n- 在集群 Group1 上部署新版本。\n- 集群 Group1 升级完毕后，把负载均衡列表全部指向 Group1，并删除集群 Group2  ，由 Group1 单独提供服务。\n- 在集群 Group2   上部署完新版本后，再把它添加回负载均衡列表中。\n\n这样，就完成了两个集群上所有机器的版本升级。\n蓝绿部署的优点是升级和回退速度非常快，缺点是全量升级，如果V2版本有问题，对用户影响大再者由于升级过程中会服务器资源会减少一半，有可能产生服务器过载问题，因此这种发布方式也不适用于在业务高峰期使用。\n\n### 2.5 红黑发布\n\n与蓝绿部署类似，红黑部署也是通过两个集群完成软件版本的升级。当前提供服务的所有机器都运行在红色集群 Group1 中，当需要发布新版本的时候，具体流程是这样的：\n\n- 先申请一个黑色集群 Group2  ，在 Group2   上部署新版本的服务；\n- 等到 Group2  升级完成后，我们一次性地把负载均衡全部指向 Group2  ；\n- 把 Group1 集群从负载均衡列表中删除，并释放集群 Group1 中所有机器。这\n\n这样就完成了一个版本的升级。可以看到，与蓝绿部署相比，红黑部署获得了两个收益：一是，简化了流程；二是，避免了在升级的过程中，由于只有一半的服务器提供服务，而可能导致的系统过载问题。但同样也存在全量升级对用户的影响问题，也带来了一个新的问题，就是发布过程中需要两倍的服务器资源。\n![红黑发布.png](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E7%BA%A2%E9%BB%91%E5%8F%91%E5%B8%83.png)\n\n### 2.6 功能开关\n\n这种发布方式是利用代码中的功能开关来控制发布逻辑，是一种相对比较低成本和简单的发布方式。研发人员可以灵活定制和自助完成的发布方式。这种方式通常依赖于一个配置中心系统，当然如果没有，可以使用简单的配置文件。\n\n![功能开关.png](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E5%8A%9F%E8%83%BD%E5%BC%80%E5%85%B3.png)\n应用上线后，开关先不打开，只待一声令下，可以全量打开开关，也可以按照某种维度(公司ID，用户ID等)分批打开开关进行流量验证，如果有问题，则随时关闭开关。\n这种方式的优势在于升级切换和回退速度非常快，而且相对于复杂的发布工具，成本较为低廉。但是也有很大的不足之处，就是开关本身也是代码，而且是与业务无关的代码，对代码的侵入性较高，也必须定期清理老版本的逻辑，使得维护成本增加。\n\n## 3 小结\n\n这篇文章介绍了目前常用的一些发布方式，每种发布方式各有其优缺点。但其实在真正实践过程中这些发布方式往往是根据具体的情况来结合使用的。主要可以通过升级回退速度、成本、对用户影响三个方面来考虑。\n比如在我最开始的小型公司里，公司业务小，服务器资源也不足，甚至连最基础的负载均衡服务器都没有，这个时候我们的发布通常是选择一个流量小的时候进行蛮力发布的，这个时候也许会对用户造成短暂的影响，但那个时候的我们是没有人力物力财力......去搞后面那些复杂的方式的。\n而后来的某厂里有着充足的资源，我们有着多服务器群组，各种强大的发布工具......，通常我们是结合具体场景来选择合适的发布方式的。最常用的其中就是金丝雀发布和滚动发布。而在有些时候由于集群中的请求是随机分发的你并不能保证同一个用户的上一个请求和下一个请求还在同一个服务器上，这时如果旧的版本不能兼容新的版本的时候，如果是在业务流量低的时候，我们会考虑采用蓝绿部署的方式，如果在流量高峰期则会采用红黑发布的方式来避免服务器过载。\n而针对一些特殊的功能也经常会采用滚动发布+功能功能开关的方式。新版本发上去之后，逐步打开开关验证。\n总之，各种发布方式的本质目的都是为了提高我们的发布效率，保持系统可用性，减少对用户的影响能够让用户平滑的过渡到新的版本。","slug":"效能管理/团队方法论/蓝绿红黑灰常用的发布方式","published":1,"updated":"2021-03-14T03:04:50.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzf00djhyjfemer3slv","content":"<h2 id=\"1-发布之痛\"><a href=\"#1-发布之痛\" class=\"headerlink\" title=\"1 发布之痛\"></a>1 发布之痛</h2><p>相信每个程序员都曾经经历过，或正在经历过发布的痛苦，每个发布日的夜晚通常是灯火通明。在现在互联网公司较高的发布频率之下更是放大了这种痛苦，多少正值青春年华的程序员为此白了发、秃了头！让程序员经历发布痛苦的原因有很多，其中之一就是发布方式。</p>\n<a id=\"more\"></a>\n<p>发布造成系统故障影响系统可用性的最大原因之一。因此大多数的公司会选择在用户量最小的深夜进行发布，这就造成了每到发布日就有一大堆黑眼圈的程序员熬夜坐等发布，但其实有了一些好的发布方式也许就不必如此。<br>我曾经带过两家公司，这两家公司团队的对于发布时间的看法则孑然不同，第一家公司的总是担心发布会对用用户造成影响，因此每次发布都会选择深夜进行发布。而另一家公司则认为应该在用户流量最大的时候进行发布，这样系统问题则可以尽早的暴露出来。造成这两种的结果我分析有很多原因。开发人员信心、交付质量、资源工具、发布方式……我们今天就来看看一些常用的发布方式。</p>\n<h2 id=\"2-常用的发布方式\"><a href=\"#2-常用的发布方式\" class=\"headerlink\" title=\"2 常用的发布方式\"></a>2 常用的发布方式</h2><h3 id=\"2-1-蛮力发布\"><a href=\"#2-1-蛮力发布\" class=\"headerlink\" title=\"2.1 蛮力发布\"></a>2.1 蛮力发布</h3><p>顾名思义，这种方式简单而粗暴！直接将新的版本覆盖掉老的版本。其优点就是简单而且成本较低，但缺点同样很明显，就是发布过程中通常会导致服务中断进而导致用户受到影响，这种方式比较适应于开发环境或者测试环境或者是公司内部系统这种对可用性要求不高的场景，有些小的公司资源稀缺(服务器资源，基础设施等)的时候也会采用这种方式。比如我的第一家公司一开始的规模较小的时候，通常会选择一个夜深人静、访问量小的时候，悄悄地发布。<br><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E8%9B%AE%E5%8A%9B%E5%8F%91%E5%B8%83.png\" alt=\"蛮力发布\"></p>\n<h3 id=\"2-2-金丝雀发布\"><a href=\"#2-2-金丝雀发布\" class=\"headerlink\" title=\"2.2 金丝雀发布\"></a>2.2 金丝雀发布</h3><p>金丝雀发布是灰度发布的一种。灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。即在发布过程中一部分用户继续使用老版本，一部分用户使用新版本，不断地扩大新版本的访问流量。最终实现老版本到新版本的过度。由于金丝雀对瓦斯极其敏感，因此以前旷工开矿下矿洞前，先会放一只金丝雀进去探是否有有毒气体，看金丝雀能否活下来，金丝雀发布由此得名。<br><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E9%87%91%E4%B8%9D%E9%9B%80%E5%8F%91%E5%B8%83.png\" alt=\"金丝雀发布\"><br>发布过程中，先发一台或者一小部分比例的机器作为金丝雀，用于流量验证。如果金丝雀验证通过则把剩余机器全部发掉。如果金丝雀验证失败，则直接回退金丝雀。金丝雀发布的优势在于可以用少量用户来验证新版本功能，这样即使有问题所影响的也是很小的一部分客户。如果对新版本功能或性能缺乏足够信心那么就可以采用这种方式。这种方式也有其缺点，金丝雀发布本质上仍然是一次性的全量发布，发布过程中用户体验并不平滑，有些隐藏深处的bug少量用户可能并不能验证出来问题，需要逐步扩大流量才可以。</p>\n<h3 id=\"2-3-滚动发布\"><a href=\"#2-3-滚动发布\" class=\"headerlink\" title=\"2.3 滚动发布\"></a>2.3 滚动发布</h3><p>滚动发布是在金丝雀发布基础上进行改进的一种发布方式。相比于金丝雀发布，先发金丝雀，然后全发的方式，滚动发布则是整个发布过程中按批次进行发布。每个批次拉入后都可作为金丝雀进行验证，这样流量逐步放大直至结束。<img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E6%BB%9A%E5%8A%A8%E5%8F%91%E5%B8%83.png\" alt=\"滚动发布\"><br>这种方式的优点就是对用户的影响小，体验平滑，但同样也有很多缺点，首先就是发布和回退时间慢，其次发布工具复杂，负载均衡设备需要具有平滑的拉入拉出能力，一般公司并没有资源投入研发这种复杂的发布工具。再者<br>发布过程中新老版本同时运行，需要注意兼容性问题。</p>\n<h3 id=\"2-4-蓝绿部署\"><a href=\"#2-4-蓝绿部署\" class=\"headerlink\" title=\"2.4 蓝绿部署\"></a>2.4 蓝绿部署</h3><p>蓝绿部署，是采用两个分开的集群对软件版本进行升级的一种方式。它的部署模型中包括一个蓝色集群 Group1 和一个绿色集群 Group2，在没有新版本上线的情况下，两个集群上运行的版本是一致的，同时对外提供服务。<img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E8%93%9D%E7%BB%BF%E9%83%A8%E7%BD%B2.png\" alt=\"蓝绿部署\"><br>系统升级时，蓝绿部署的流程是：</p>\n<ul>\n<li>从负载均衡器列表中删除集群Group1，让集群 Group2  单独提供服务。</li>\n<li>在集群 Group1 上部署新版本。</li>\n<li>集群 Group1 升级完毕后，把负载均衡列表全部指向 Group1，并删除集群 Group2  ，由 Group1 单独提供服务。</li>\n<li>在集群 Group2   上部署完新版本后，再把它添加回负载均衡列表中。</li>\n</ul>\n<p>这样，就完成了两个集群上所有机器的版本升级。<br>蓝绿部署的优点是升级和回退速度非常快，缺点是全量升级，如果V2版本有问题，对用户影响大再者由于升级过程中会服务器资源会减少一半，有可能产生服务器过载问题，因此这种发布方式也不适用于在业务高峰期使用。</p>\n<h3 id=\"2-5-红黑发布\"><a href=\"#2-5-红黑发布\" class=\"headerlink\" title=\"2.5 红黑发布\"></a>2.5 红黑发布</h3><p>与蓝绿部署类似，红黑部署也是通过两个集群完成软件版本的升级。当前提供服务的所有机器都运行在红色集群 Group1 中，当需要发布新版本的时候，具体流程是这样的：</p>\n<ul>\n<li>先申请一个黑色集群 Group2  ，在 Group2   上部署新版本的服务；</li>\n<li>等到 Group2  升级完成后，我们一次性地把负载均衡全部指向 Group2  ；</li>\n<li>把 Group1 集群从负载均衡列表中删除，并释放集群 Group1 中所有机器。这</li>\n</ul>\n<p>这样就完成了一个版本的升级。可以看到，与蓝绿部署相比，红黑部署获得了两个收益：一是，简化了流程；二是，避免了在升级的过程中，由于只有一半的服务器提供服务，而可能导致的系统过载问题。但同样也存在全量升级对用户的影响问题，也带来了一个新的问题，就是发布过程中需要两倍的服务器资源。<br><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E7%BA%A2%E9%BB%91%E5%8F%91%E5%B8%83.png\" alt=\"红黑发布.png\"></p>\n<h3 id=\"2-6-功能开关\"><a href=\"#2-6-功能开关\" class=\"headerlink\" title=\"2.6 功能开关\"></a>2.6 功能开关</h3><p>这种发布方式是利用代码中的功能开关来控制发布逻辑，是一种相对比较低成本和简单的发布方式。研发人员可以灵活定制和自助完成的发布方式。这种方式通常依赖于一个配置中心系统，当然如果没有，可以使用简单的配置文件。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E5%8A%9F%E8%83%BD%E5%BC%80%E5%85%B3.png\" alt=\"功能开关.png\"><br>应用上线后，开关先不打开，只待一声令下，可以全量打开开关，也可以按照某种维度(公司ID，用户ID等)分批打开开关进行流量验证，如果有问题，则随时关闭开关。<br>这种方式的优势在于升级切换和回退速度非常快，而且相对于复杂的发布工具，成本较为低廉。但是也有很大的不足之处，就是开关本身也是代码，而且是与业务无关的代码，对代码的侵入性较高，也必须定期清理老版本的逻辑，使得维护成本增加。</p>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3 小结\"></a>3 小结</h2><p>这篇文章介绍了目前常用的一些发布方式，每种发布方式各有其优缺点。但其实在真正实践过程中这些发布方式往往是根据具体的情况来结合使用的。主要可以通过升级回退速度、成本、对用户影响三个方面来考虑。<br>比如在我最开始的小型公司里，公司业务小，服务器资源也不足，甚至连最基础的负载均衡服务器都没有，这个时候我们的发布通常是选择一个流量小的时候进行蛮力发布的，这个时候也许会对用户造成短暂的影响，但那个时候的我们是没有人力物力财力……去搞后面那些复杂的方式的。<br>而后来的某厂里有着充足的资源，我们有着多服务器群组，各种强大的发布工具……，通常我们是结合具体场景来选择合适的发布方式的。最常用的其中就是金丝雀发布和滚动发布。而在有些时候由于集群中的请求是随机分发的你并不能保证同一个用户的上一个请求和下一个请求还在同一个服务器上，这时如果旧的版本不能兼容新的版本的时候，如果是在业务流量低的时候，我们会考虑采用蓝绿部署的方式，如果在流量高峰期则会采用红黑发布的方式来避免服务器过载。<br>而针对一些特殊的功能也经常会采用滚动发布+功能功能开关的方式。新版本发上去之后，逐步打开开关验证。<br>总之，各种发布方式的本质目的都是为了提高我们的发布效率，保持系统可用性，减少对用户的影响能够让用户平滑的过渡到新的版本。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-发布之痛\"><a href=\"#1-发布之痛\" class=\"headerlink\" title=\"1 发布之痛\"></a>1 发布之痛</h2><p>相信每个程序员都曾经经历过，或正在经历过发布的痛苦，每个发布日的夜晚通常是灯火通明。在现在互联网公司较高的发布频率之下更是放大了这种痛苦，多少正值青春年华的程序员为此白了发、秃了头！让程序员经历发布痛苦的原因有很多，其中之一就是发布方式。</p>","more":"<p>发布造成系统故障影响系统可用性的最大原因之一。因此大多数的公司会选择在用户量最小的深夜进行发布，这就造成了每到发布日就有一大堆黑眼圈的程序员熬夜坐等发布，但其实有了一些好的发布方式也许就不必如此。<br>我曾经带过两家公司，这两家公司团队的对于发布时间的看法则孑然不同，第一家公司的总是担心发布会对用用户造成影响，因此每次发布都会选择深夜进行发布。而另一家公司则认为应该在用户流量最大的时候进行发布，这样系统问题则可以尽早的暴露出来。造成这两种的结果我分析有很多原因。开发人员信心、交付质量、资源工具、发布方式……我们今天就来看看一些常用的发布方式。</p>\n<h2 id=\"2-常用的发布方式\"><a href=\"#2-常用的发布方式\" class=\"headerlink\" title=\"2 常用的发布方式\"></a>2 常用的发布方式</h2><h3 id=\"2-1-蛮力发布\"><a href=\"#2-1-蛮力发布\" class=\"headerlink\" title=\"2.1 蛮力发布\"></a>2.1 蛮力发布</h3><p>顾名思义，这种方式简单而粗暴！直接将新的版本覆盖掉老的版本。其优点就是简单而且成本较低，但缺点同样很明显，就是发布过程中通常会导致服务中断进而导致用户受到影响，这种方式比较适应于开发环境或者测试环境或者是公司内部系统这种对可用性要求不高的场景，有些小的公司资源稀缺(服务器资源，基础设施等)的时候也会采用这种方式。比如我的第一家公司一开始的规模较小的时候，通常会选择一个夜深人静、访问量小的时候，悄悄地发布。<br><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E8%9B%AE%E5%8A%9B%E5%8F%91%E5%B8%83.png\" alt=\"蛮力发布\"></p>\n<h3 id=\"2-2-金丝雀发布\"><a href=\"#2-2-金丝雀发布\" class=\"headerlink\" title=\"2.2 金丝雀发布\"></a>2.2 金丝雀发布</h3><p>金丝雀发布是灰度发布的一种。灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。即在发布过程中一部分用户继续使用老版本，一部分用户使用新版本，不断地扩大新版本的访问流量。最终实现老版本到新版本的过度。由于金丝雀对瓦斯极其敏感，因此以前旷工开矿下矿洞前，先会放一只金丝雀进去探是否有有毒气体，看金丝雀能否活下来，金丝雀发布由此得名。<br><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E9%87%91%E4%B8%9D%E9%9B%80%E5%8F%91%E5%B8%83.png\" alt=\"金丝雀发布\"><br>发布过程中，先发一台或者一小部分比例的机器作为金丝雀，用于流量验证。如果金丝雀验证通过则把剩余机器全部发掉。如果金丝雀验证失败，则直接回退金丝雀。金丝雀发布的优势在于可以用少量用户来验证新版本功能，这样即使有问题所影响的也是很小的一部分客户。如果对新版本功能或性能缺乏足够信心那么就可以采用这种方式。这种方式也有其缺点，金丝雀发布本质上仍然是一次性的全量发布，发布过程中用户体验并不平滑，有些隐藏深处的bug少量用户可能并不能验证出来问题，需要逐步扩大流量才可以。</p>\n<h3 id=\"2-3-滚动发布\"><a href=\"#2-3-滚动发布\" class=\"headerlink\" title=\"2.3 滚动发布\"></a>2.3 滚动发布</h3><p>滚动发布是在金丝雀发布基础上进行改进的一种发布方式。相比于金丝雀发布，先发金丝雀，然后全发的方式，滚动发布则是整个发布过程中按批次进行发布。每个批次拉入后都可作为金丝雀进行验证，这样流量逐步放大直至结束。<img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E6%BB%9A%E5%8A%A8%E5%8F%91%E5%B8%83.png\" alt=\"滚动发布\"><br>这种方式的优点就是对用户的影响小，体验平滑，但同样也有很多缺点，首先就是发布和回退时间慢，其次发布工具复杂，负载均衡设备需要具有平滑的拉入拉出能力，一般公司并没有资源投入研发这种复杂的发布工具。再者<br>发布过程中新老版本同时运行，需要注意兼容性问题。</p>\n<h3 id=\"2-4-蓝绿部署\"><a href=\"#2-4-蓝绿部署\" class=\"headerlink\" title=\"2.4 蓝绿部署\"></a>2.4 蓝绿部署</h3><p>蓝绿部署，是采用两个分开的集群对软件版本进行升级的一种方式。它的部署模型中包括一个蓝色集群 Group1 和一个绿色集群 Group2，在没有新版本上线的情况下，两个集群上运行的版本是一致的，同时对外提供服务。<img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E8%93%9D%E7%BB%BF%E9%83%A8%E7%BD%B2.png\" alt=\"蓝绿部署\"><br>系统升级时，蓝绿部署的流程是：</p>\n<ul>\n<li>从负载均衡器列表中删除集群Group1，让集群 Group2  单独提供服务。</li>\n<li>在集群 Group1 上部署新版本。</li>\n<li>集群 Group1 升级完毕后，把负载均衡列表全部指向 Group1，并删除集群 Group2  ，由 Group1 单独提供服务。</li>\n<li>在集群 Group2   上部署完新版本后，再把它添加回负载均衡列表中。</li>\n</ul>\n<p>这样，就完成了两个集群上所有机器的版本升级。<br>蓝绿部署的优点是升级和回退速度非常快，缺点是全量升级，如果V2版本有问题，对用户影响大再者由于升级过程中会服务器资源会减少一半，有可能产生服务器过载问题，因此这种发布方式也不适用于在业务高峰期使用。</p>\n<h3 id=\"2-5-红黑发布\"><a href=\"#2-5-红黑发布\" class=\"headerlink\" title=\"2.5 红黑发布\"></a>2.5 红黑发布</h3><p>与蓝绿部署类似，红黑部署也是通过两个集群完成软件版本的升级。当前提供服务的所有机器都运行在红色集群 Group1 中，当需要发布新版本的时候，具体流程是这样的：</p>\n<ul>\n<li>先申请一个黑色集群 Group2  ，在 Group2   上部署新版本的服务；</li>\n<li>等到 Group2  升级完成后，我们一次性地把负载均衡全部指向 Group2  ；</li>\n<li>把 Group1 集群从负载均衡列表中删除，并释放集群 Group1 中所有机器。这</li>\n</ul>\n<p>这样就完成了一个版本的升级。可以看到，与蓝绿部署相比，红黑部署获得了两个收益：一是，简化了流程；二是，避免了在升级的过程中，由于只有一半的服务器提供服务，而可能导致的系统过载问题。但同样也存在全量升级对用户的影响问题，也带来了一个新的问题，就是发布过程中需要两倍的服务器资源。<br><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E7%BA%A2%E9%BB%91%E5%8F%91%E5%B8%83.png\" alt=\"红黑发布.png\"></p>\n<h3 id=\"2-6-功能开关\"><a href=\"#2-6-功能开关\" class=\"headerlink\" title=\"2.6 功能开关\"></a>2.6 功能开关</h3><p>这种发布方式是利用代码中的功能开关来控制发布逻辑，是一种相对比较低成本和简单的发布方式。研发人员可以灵活定制和自助完成的发布方式。这种方式通常依赖于一个配置中心系统，当然如果没有，可以使用简单的配置文件。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/%E5%8A%9F%E8%83%BD%E5%BC%80%E5%85%B3.png\" alt=\"功能开关.png\"><br>应用上线后，开关先不打开，只待一声令下，可以全量打开开关，也可以按照某种维度(公司ID，用户ID等)分批打开开关进行流量验证，如果有问题，则随时关闭开关。<br>这种方式的优势在于升级切换和回退速度非常快，而且相对于复杂的发布工具，成本较为低廉。但是也有很大的不足之处，就是开关本身也是代码，而且是与业务无关的代码，对代码的侵入性较高，也必须定期清理老版本的逻辑，使得维护成本增加。</p>\n<h2 id=\"3-小结\"><a href=\"#3-小结\" class=\"headerlink\" title=\"3 小结\"></a>3 小结</h2><p>这篇文章介绍了目前常用的一些发布方式，每种发布方式各有其优缺点。但其实在真正实践过程中这些发布方式往往是根据具体的情况来结合使用的。主要可以通过升级回退速度、成本、对用户影响三个方面来考虑。<br>比如在我最开始的小型公司里，公司业务小，服务器资源也不足，甚至连最基础的负载均衡服务器都没有，这个时候我们的发布通常是选择一个流量小的时候进行蛮力发布的，这个时候也许会对用户造成短暂的影响，但那个时候的我们是没有人力物力财力……去搞后面那些复杂的方式的。<br>而后来的某厂里有着充足的资源，我们有着多服务器群组，各种强大的发布工具……，通常我们是结合具体场景来选择合适的发布方式的。最常用的其中就是金丝雀发布和滚动发布。而在有些时候由于集群中的请求是随机分发的你并不能保证同一个用户的上一个请求和下一个请求还在同一个服务器上，这时如果旧的版本不能兼容新的版本的时候，如果是在业务流量低的时候，我们会考虑采用蓝绿部署的方式，如果在流量高峰期则会采用红黑发布的方式来避免服务器过载。<br>而针对一些特殊的功能也经常会采用滚动发布+功能功能开关的方式。新版本发上去之后，逐步打开开关验证。<br>总之，各种发布方式的本质目的都是为了提高我们的发布效率，保持系统可用性，减少对用户的影响能够让用户平滑的过渡到新的版本。</p>"},{"title":"说一说Web开发中两种常用的分层架构及其对应的代码模型","copyright":true,"date":"2020-04-21T03:29:26.000Z","keywords":"DDD 三层架构 领域驱动","password":"1234qwer","_content":"## \n\n昨天妹子让我帮她解决个问题，本以为可以轻松搞定，但是打开他们项目的一瞬间，我头皮发麻。本身功能不多的一个小项目，解决方案里竟然有几十个类库。仅仅搞明白各个类库的作用，代码层次之间的引用关系就花了一个多小时。<!--more-->\n\n显然可能他们项目结构的代码模型出了问题，设计混乱，不容易上手。\n\n项目中一个好的的代码模型一定是简单、清晰、明了、易于上手的。它总是会让人用起来很舒服，它可以让项目团队成员更好地理解代码，根据代码规范实现团队协作；它可以让各层的逻辑互不干扰、分工协作、各据其位、各司其职，避免不必要的代码混淆。它可以让我们的代码扩展性很好，可以让系统的可维护性更好......\n\n而代码模型的搭建跟项目的分层架构有关系，绝大多数项目开发中都会会采用分层开发，它有着分散关注、松散耦合、逻辑复用、标准定义、扩展性强等众多好处。而在分层架构中最常用的有两种:三层架构和DDD(领域驱动)分层架构。我们选择的分层方式也决定了我们的项目结构中的代码模型。\n\n### 1.三层架构\n\n三层架构是一种严格分层模式，而严格分层架构模式的特点是上层只能访问相邻的下层，其他层次间的调用都不允许。它把职责划分为界面展示、业务逻辑、数据访问三层，还有一个业务实体，前面三层都要依赖它，所以它并不构成一个层。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%20%281%29.png)\n\n三层架构是一种面向过程的编程思想，它有几个特点\n* 业务实体类中基本上只有属性没有方法。\n* 业务逻辑层的类基本上只有方法没有属性。\n\n在使用三层架构开发的时候我们通常会直接将数据表结构映射为业务实体类。这样的好处是只需要理解一套模型，以至于市场上也产生了一系列的代码生成工具可以一键生成实体和增删改查的代码。但对于复杂点的业务，这样做也会产生很多的问题。\n\n而当业务不再是简单的增删查改时，我们可以在三层架构的基础上有个简单的变形：提取一个服务层出来，用来组合模块间的交互，还为业务逻辑层提供了一个防腐层，可以把记录日志、验证权限、处理异常等职责分配给服务层。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E6%94%B9%E8%BF%9B%20%282%29.png)\n\n### 2. DDD分层架构\n\n三层架构有一个显著缺点就是它的内存模型不是基于业务模型而是是基于数据库模型建立的。而很多时候我们的业务模型并不能和我们的数据库模型完全吻合。\n\n例如：如果你的数据库模型的粒度很小。有些业务就需要连接多张数据库表才能实现。而如果数据库模型的粒度很大（这是大部分项目的选择），代码的质量（重用性、稳定性、扩展性）就很差。由于没有从业务的角度去仔细定义每一个对象，每个人会根据自己的需要建立各种QueryModel或ViewModel(相信三层架构用久了的同学都会遇到这个问题)。\n\n而且现在很多大型系统都会采用分布式的架构，如现在的微服务架构。服务内不仅仅是简单的增删查改，会有更多的与其它服务交互的内容，而服务的拆分也是以业务模型为导向的。\n\n这个时候DDD(领域驱动)分层架构就会更有优势。\n\n![依赖倒置的DDD分层架构](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/DDD.png)\n\nDDD分层架构主要包含四层:用户接口层、应用层、领域层、基础层。\n\n* 用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口适配相关的功能。\n* 应用层：位于领域层的上一层，理论上不应该有业务规则或逻辑。主要用来实现服务组合和编排，协作完成业务操作，负责处理业务用例的执行顺序以及结果的拼装，以粗粒度的服务通过 API 网关向前端发布提供安全认证、权限校验、事务控制、发送或订阅领域事件等功能。\n* 领域层：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和事件等领域对象，以及它们组合所形成的业务能力。\n* 基础层：贯穿所有层的，为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。基础层包含基础服务，它可以采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响。\n\n![DDD分层架构](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/DDD%E5%86%85%E5%AE%B9.png)\n\nDDD分层架构也分为严格分层架构和松散分层架构，在严格分层架构中，领域服务只能被应用服务调用，而应用服务只能被用户接口层调用，服务是逐层对外封装或组合的，依赖关系清晰。而在松散分层架构中，领域服务可以同时被应用层或用户接口层调用，服务的依赖关系比较复杂且难管理。因此我个人推荐使用严格的分层架构\n\n### 3.如何选择三层架构还是DDD分层架构\n\n对于项目开发中应该如何选择我们可以基于两点考虑：系统本身的业务复杂度和团队人员能力。\n\n#### 3.1 系统本身的业务复杂度\n\n如果你们的系统只是个简单的小系统有或者系统本身业务并不复杂，基本都是些增删改查。那么三层架构将是你良好的选择。它会让你的开发变得简单，会大大提高你的开发效率，而且这种分层架构的学习成本很低，新人简单熟悉就可以很容易的上手。对于简单的系统使用DDD分层，反而增加了系统的复杂度。\n\n而如果你们的系统很复杂或者对于一些成长性的网站系统(一开始很小，随着业务发展慢慢壮大的系统)，那么你可以考虑使用DDD分层架构，DDD的思想可以让你更好的对业务进行建模，这种分层架构会让你的系统扩展性很好，在网站壮大的过程中，单体系统必然会向分布式系统进行发展，而DDD的思想可以对服务进行很好的拆分，如当下的微服务架构，DDD的思想就可以帮助我们很好的定义服务的边界。\n\n#### 3.2 团队人员能力\n\n团队人员的能力仍然是选择要考虑的因素。因为DDD对于人员的能力要求相对于三层架构要高。它需要团队的人员要有一个良好的逻辑思想和建模能力，而且DDD的学习成本也要高一些。如果你的团队成员能力一般或者以入行不久的新人为主，或者你的团队人员流动性较大的话，也是不建议使用DDD的。这种情况下使用三层架构会更好一些。\n\n总有些人会觉得DDD的概念“高大上”，因此为了使用DDD而使用DDD,更有甚至，根本都没有真正弄明白DDD，就开始使用，最终搞的个四不像，不仅没有解决问题，反而徒增了系统复杂度，拉低性能和效率，其实真正项目中改如何选择，应该结合你的团队和系统来，权衡利弊综合考虑。简单、优雅、方便、快捷的解决问题岂不是更好?\n\n### 4.两种分层架构对应的代码模型\n\n一旦选定了分层架构，项目中所对应的代码模型也就确定了。我们以.net为例(java只需要把程序集当成jar包来看就可以了)，推荐下面这两种代码模型。\n\n#### 4.1 三层架构\n\n![简单的三层架构](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E7%AE%80%E5%8D%95%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png)\n\n这是最简单的三层架构代码模型，业务逻辑层,数据访问层，应用接口层(界面层，界面层可以是mvc，也可以是webapi。（因为现在很多项目都是前后端分离，服务端开发人员不需要写页面，所以就没有写MVC，界面层我也改叫用户接口层了)。。当然现在几乎是没有人这么用的。因为这样做的依赖性很高。不利于扩展。因此我们要引入依赖倒置的概念。因此我们的结构需要做如下变形\n\n![依赖倒置的三层架构](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png)\n\n这种结构在简单三层的基础上对业务逻辑层和数据访问层引入了其抽象层，这样就很好的将层与层之间的依赖关系进行了解耦。\n\n比如，我曾经遇到多个项目数据库从MSSQL转到MySql。在三层架构中，其实大量的逻辑都应该被封装在业务逻辑层。这个时候我们是需要把DAL换成MySql的DAL，业务逻辑不需要任何改动。如果是最简单的三层架构那种绝对依赖关系，我们必然要改动业务逻辑层以接入新的DAL。而这种依赖倒置的层次结构则不需要。\n\n由于三层架构中同层引用时应该避免的。业务逻辑也是基于数据库模型建立的，而有些业务则需要组合多个业务来实现，为了实现业务逻辑代码复用有些可以采用继承和多态的方式来实现。有些时候则需要再引入一个服务层(防腐层)来组合模块间的交互。也可以把记录日志、验证权限、处理异常等职责分配给这一层。\n\n![完整的三层架构](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E5%AE%8C%E5%96%84%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png)\n\n很多项目可能还要加个工具层，用来放一些常用的工具类。但是工具类这个东西，**与项目有关的可以放在这里，如果是多项目之间可以复用的，最好用更专业的做法：单独管理维护，打包成Nuget包(maven包)，由各个项目进行调用**。\n\n#### 4.2 DDD分层代码模型\n\n按照 DDD 分层架构模型设计出来的代码模型应该长什么样子呢？\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.png)\n\n如上图所示:\n\n1. 用户接口层\n* Controller:提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理\n   * DTO:数据传输的载体，内部不存在任何业务逻辑，我们通过 DTO 把内部的领域对象与外界隔离。\n   * Mapper: 实现 DTO 与领域对象之间的相互转换和数据交换。\n2. 应用层\n\n   * Event:存放事件相关代码，可以进行事件的发布和处理。事件发布和订阅放在应用层，事件相关的业务逻辑放在领域层。\n\n   * Service：对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是一段独立的业务逻辑。\n3. 领域层\n   * Aggregate：是Entity、Event、Service、Repository的根目录，聚合内实现高内聚的业务逻辑，可以根据实际项目中业务的聚合名称命名。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。如果我们的项目需要进行微服务的拆分，那么一个聚合里的内容可以拆分为一个单独的服务。\n   * Entity：用来存放聚合根、实体、值对象以及工厂模式（Factory）相关代码。实体类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现。跨实体的业务逻辑代码在领域服务中实现。\n   * Event：存放事件实体以及与事件活动相关的业务逻辑代码。\n   * Service：存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑。领域服务封装多个实体或方法后向上层提供应用服务调用。\n   * Repository：存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，最好一个聚合对应一个仓储。\n\n4. 基础设施层\n   * Config：主要存放一些配置相关代码。\n   * Util：其它诸如数据库、缓存、文件，第三方类库相关的代码可以在这个目录下建立子目录。\n\n在DDD的代码模型中需要注意的是:\n\n* 分层的概念一定要清晰，明确各层的职责。\n* 聚合的代码边界一定要清晰，聚合之间一定是松耦合低关联的。\n\n### 小结\n\n毫无疑问，项目中选择合适的分层架构并设计一个优秀的代码模型有着巨大的好处，但实际上无论是三层架构还是DDD分层架构都没有明确的规定其标准的代码模型。因此以上两种代码模型仅供大家参考。\n\n而经常会有些设计者在设计的时候总喜欢“炫技”，设计出来的代码模型“深奥复杂”、晦涩难懂，美其名曰“高大上”。熟不知大道至简，优秀的设计是用简单的方式解决复杂的问题，而不是把简单的问题复杂化，在解决问题的基础上，简单实用才是正途！\n\n同是天涯撸码人，码农何必为难码农，希望每个项目都能有一个好的设计人员，结合实际情况，设计出一个好的代码模型，利己利人！\n\n\n\n","source":"_posts/效能管理/团队方法论/两种Web开发中常用的分层架构及其代码模型.md","raw":"---\ntitle: 说一说Web开发中两种常用的分层架构及其对应的代码模型\ncopyright: true\ndate: 2020-04-21 11:29:26\ntags: \n- 分层架构、DDD\ncategories: 分层架构\nkeywords: DDD 三层架构 领域驱动\npassword: 1234qwer\n---\n## \n\n昨天妹子让我帮她解决个问题，本以为可以轻松搞定，但是打开他们项目的一瞬间，我头皮发麻。本身功能不多的一个小项目，解决方案里竟然有几十个类库。仅仅搞明白各个类库的作用，代码层次之间的引用关系就花了一个多小时。<!--more-->\n\n显然可能他们项目结构的代码模型出了问题，设计混乱，不容易上手。\n\n项目中一个好的的代码模型一定是简单、清晰、明了、易于上手的。它总是会让人用起来很舒服，它可以让项目团队成员更好地理解代码，根据代码规范实现团队协作；它可以让各层的逻辑互不干扰、分工协作、各据其位、各司其职，避免不必要的代码混淆。它可以让我们的代码扩展性很好，可以让系统的可维护性更好......\n\n而代码模型的搭建跟项目的分层架构有关系，绝大多数项目开发中都会会采用分层开发，它有着分散关注、松散耦合、逻辑复用、标准定义、扩展性强等众多好处。而在分层架构中最常用的有两种:三层架构和DDD(领域驱动)分层架构。我们选择的分层方式也决定了我们的项目结构中的代码模型。\n\n### 1.三层架构\n\n三层架构是一种严格分层模式，而严格分层架构模式的特点是上层只能访问相邻的下层，其他层次间的调用都不允许。它把职责划分为界面展示、业务逻辑、数据访问三层，还有一个业务实体，前面三层都要依赖它，所以它并不构成一个层。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%20%281%29.png)\n\n三层架构是一种面向过程的编程思想，它有几个特点\n* 业务实体类中基本上只有属性没有方法。\n* 业务逻辑层的类基本上只有方法没有属性。\n\n在使用三层架构开发的时候我们通常会直接将数据表结构映射为业务实体类。这样的好处是只需要理解一套模型，以至于市场上也产生了一系列的代码生成工具可以一键生成实体和增删改查的代码。但对于复杂点的业务，这样做也会产生很多的问题。\n\n而当业务不再是简单的增删查改时，我们可以在三层架构的基础上有个简单的变形：提取一个服务层出来，用来组合模块间的交互，还为业务逻辑层提供了一个防腐层，可以把记录日志、验证权限、处理异常等职责分配给服务层。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E6%94%B9%E8%BF%9B%20%282%29.png)\n\n### 2. DDD分层架构\n\n三层架构有一个显著缺点就是它的内存模型不是基于业务模型而是是基于数据库模型建立的。而很多时候我们的业务模型并不能和我们的数据库模型完全吻合。\n\n例如：如果你的数据库模型的粒度很小。有些业务就需要连接多张数据库表才能实现。而如果数据库模型的粒度很大（这是大部分项目的选择），代码的质量（重用性、稳定性、扩展性）就很差。由于没有从业务的角度去仔细定义每一个对象，每个人会根据自己的需要建立各种QueryModel或ViewModel(相信三层架构用久了的同学都会遇到这个问题)。\n\n而且现在很多大型系统都会采用分布式的架构，如现在的微服务架构。服务内不仅仅是简单的增删查改，会有更多的与其它服务交互的内容，而服务的拆分也是以业务模型为导向的。\n\n这个时候DDD(领域驱动)分层架构就会更有优势。\n\n![依赖倒置的DDD分层架构](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/DDD.png)\n\nDDD分层架构主要包含四层:用户接口层、应用层、领域层、基础层。\n\n* 用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口适配相关的功能。\n* 应用层：位于领域层的上一层，理论上不应该有业务规则或逻辑。主要用来实现服务组合和编排，协作完成业务操作，负责处理业务用例的执行顺序以及结果的拼装，以粗粒度的服务通过 API 网关向前端发布提供安全认证、权限校验、事务控制、发送或订阅领域事件等功能。\n* 领域层：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和事件等领域对象，以及它们组合所形成的业务能力。\n* 基础层：贯穿所有层的，为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。基础层包含基础服务，它可以采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响。\n\n![DDD分层架构](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/DDD%E5%86%85%E5%AE%B9.png)\n\nDDD分层架构也分为严格分层架构和松散分层架构，在严格分层架构中，领域服务只能被应用服务调用，而应用服务只能被用户接口层调用，服务是逐层对外封装或组合的，依赖关系清晰。而在松散分层架构中，领域服务可以同时被应用层或用户接口层调用，服务的依赖关系比较复杂且难管理。因此我个人推荐使用严格的分层架构\n\n### 3.如何选择三层架构还是DDD分层架构\n\n对于项目开发中应该如何选择我们可以基于两点考虑：系统本身的业务复杂度和团队人员能力。\n\n#### 3.1 系统本身的业务复杂度\n\n如果你们的系统只是个简单的小系统有或者系统本身业务并不复杂，基本都是些增删改查。那么三层架构将是你良好的选择。它会让你的开发变得简单，会大大提高你的开发效率，而且这种分层架构的学习成本很低，新人简单熟悉就可以很容易的上手。对于简单的系统使用DDD分层，反而增加了系统的复杂度。\n\n而如果你们的系统很复杂或者对于一些成长性的网站系统(一开始很小，随着业务发展慢慢壮大的系统)，那么你可以考虑使用DDD分层架构，DDD的思想可以让你更好的对业务进行建模，这种分层架构会让你的系统扩展性很好，在网站壮大的过程中，单体系统必然会向分布式系统进行发展，而DDD的思想可以对服务进行很好的拆分，如当下的微服务架构，DDD的思想就可以帮助我们很好的定义服务的边界。\n\n#### 3.2 团队人员能力\n\n团队人员的能力仍然是选择要考虑的因素。因为DDD对于人员的能力要求相对于三层架构要高。它需要团队的人员要有一个良好的逻辑思想和建模能力，而且DDD的学习成本也要高一些。如果你的团队成员能力一般或者以入行不久的新人为主，或者你的团队人员流动性较大的话，也是不建议使用DDD的。这种情况下使用三层架构会更好一些。\n\n总有些人会觉得DDD的概念“高大上”，因此为了使用DDD而使用DDD,更有甚至，根本都没有真正弄明白DDD，就开始使用，最终搞的个四不像，不仅没有解决问题，反而徒增了系统复杂度，拉低性能和效率，其实真正项目中改如何选择，应该结合你的团队和系统来，权衡利弊综合考虑。简单、优雅、方便、快捷的解决问题岂不是更好?\n\n### 4.两种分层架构对应的代码模型\n\n一旦选定了分层架构，项目中所对应的代码模型也就确定了。我们以.net为例(java只需要把程序集当成jar包来看就可以了)，推荐下面这两种代码模型。\n\n#### 4.1 三层架构\n\n![简单的三层架构](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E7%AE%80%E5%8D%95%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png)\n\n这是最简单的三层架构代码模型，业务逻辑层,数据访问层，应用接口层(界面层，界面层可以是mvc，也可以是webapi。（因为现在很多项目都是前后端分离，服务端开发人员不需要写页面，所以就没有写MVC，界面层我也改叫用户接口层了)。。当然现在几乎是没有人这么用的。因为这样做的依赖性很高。不利于扩展。因此我们要引入依赖倒置的概念。因此我们的结构需要做如下变形\n\n![依赖倒置的三层架构](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png)\n\n这种结构在简单三层的基础上对业务逻辑层和数据访问层引入了其抽象层，这样就很好的将层与层之间的依赖关系进行了解耦。\n\n比如，我曾经遇到多个项目数据库从MSSQL转到MySql。在三层架构中，其实大量的逻辑都应该被封装在业务逻辑层。这个时候我们是需要把DAL换成MySql的DAL，业务逻辑不需要任何改动。如果是最简单的三层架构那种绝对依赖关系，我们必然要改动业务逻辑层以接入新的DAL。而这种依赖倒置的层次结构则不需要。\n\n由于三层架构中同层引用时应该避免的。业务逻辑也是基于数据库模型建立的，而有些业务则需要组合多个业务来实现，为了实现业务逻辑代码复用有些可以采用继承和多态的方式来实现。有些时候则需要再引入一个服务层(防腐层)来组合模块间的交互。也可以把记录日志、验证权限、处理异常等职责分配给这一层。\n\n![完整的三层架构](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E5%AE%8C%E5%96%84%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png)\n\n很多项目可能还要加个工具层，用来放一些常用的工具类。但是工具类这个东西，**与项目有关的可以放在这里，如果是多项目之间可以复用的，最好用更专业的做法：单独管理维护，打包成Nuget包(maven包)，由各个项目进行调用**。\n\n#### 4.2 DDD分层代码模型\n\n按照 DDD 分层架构模型设计出来的代码模型应该长什么样子呢？\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.png)\n\n如上图所示:\n\n1. 用户接口层\n* Controller:提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理\n   * DTO:数据传输的载体，内部不存在任何业务逻辑，我们通过 DTO 把内部的领域对象与外界隔离。\n   * Mapper: 实现 DTO 与领域对象之间的相互转换和数据交换。\n2. 应用层\n\n   * Event:存放事件相关代码，可以进行事件的发布和处理。事件发布和订阅放在应用层，事件相关的业务逻辑放在领域层。\n\n   * Service：对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是一段独立的业务逻辑。\n3. 领域层\n   * Aggregate：是Entity、Event、Service、Repository的根目录，聚合内实现高内聚的业务逻辑，可以根据实际项目中业务的聚合名称命名。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。如果我们的项目需要进行微服务的拆分，那么一个聚合里的内容可以拆分为一个单独的服务。\n   * Entity：用来存放聚合根、实体、值对象以及工厂模式（Factory）相关代码。实体类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现。跨实体的业务逻辑代码在领域服务中实现。\n   * Event：存放事件实体以及与事件活动相关的业务逻辑代码。\n   * Service：存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑。领域服务封装多个实体或方法后向上层提供应用服务调用。\n   * Repository：存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，最好一个聚合对应一个仓储。\n\n4. 基础设施层\n   * Config：主要存放一些配置相关代码。\n   * Util：其它诸如数据库、缓存、文件，第三方类库相关的代码可以在这个目录下建立子目录。\n\n在DDD的代码模型中需要注意的是:\n\n* 分层的概念一定要清晰，明确各层的职责。\n* 聚合的代码边界一定要清晰，聚合之间一定是松耦合低关联的。\n\n### 小结\n\n毫无疑问，项目中选择合适的分层架构并设计一个优秀的代码模型有着巨大的好处，但实际上无论是三层架构还是DDD分层架构都没有明确的规定其标准的代码模型。因此以上两种代码模型仅供大家参考。\n\n而经常会有些设计者在设计的时候总喜欢“炫技”，设计出来的代码模型“深奥复杂”、晦涩难懂，美其名曰“高大上”。熟不知大道至简，优秀的设计是用简单的方式解决复杂的问题，而不是把简单的问题复杂化，在解决问题的基础上，简单实用才是正途！\n\n同是天涯撸码人，码农何必为难码农，希望每个项目都能有一个好的设计人员，结合实际情况，设计出一个好的代码模型，利己利人！\n\n\n\n","slug":"效能管理/团队方法论/两种Web开发中常用的分层架构及其代码模型","published":1,"updated":"2021-03-14T03:04:50.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzg00dnhyjfd0atifs0","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以扫描下方二维码，关注公众号，回复“密码”，即可解锁本站所有文章。</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"1372451ff30ddd46d3eb9fcf0250854c31b4fccaf8e10d6728b7a47105a22c58\">8f610614102f451bf88ffd89236bc0bd1ed418b1474d1c8c11660b63f86a5c2383a415c313e0c2e0e7867f032eadf3e33e42fda20adb5cba2ea12b4c016d950f348d4ef28027c135ff803d99b2b759a8b7c790f75c370f835c3dbc5bf604082c7585f33da90ba74748df13c9333e8b3d578c8e6b70852b8117684f0b879c8b2a412a324d6d03bfa54e0ba0bac4d538a69b924ee08e68c53a0766c682e6d2eab7bd5090fff7e7aa20797f2fbfd2bbbe895f99b17f8ec0cf213ba72dcbc8d8ae8abce7728c7b0b3bbea1106ca718dc56fdd8db333538cd50b50f2785186af892d2e423e161d79411ce4530262fac5be03aa758f5206e6053290dba2cf551bd49caa2d966df4eb1f9cbcc295ca15c6e23e7770ff01d068c615e0d3ed0f3d3c9670b8f9a0c16c0b2e33a70ac216685c68f776e0b78a46fc932f91b7f822c1111260b67376ef59d99de7b231ae20cabef557b01d53b94dac0ebc51456e44a1c79ee1626729d7840f0e182f35f36fb72926930ff3d175bdefb65d092e1230b941a0dae1ef45f8fdbfa52ee50e0fc8e8ddef11dac8551d72ec23dd02e0cea44a74b2aec63b2514542d180aceb19e2830c4098db02b6e231e1fe5d63444e244f2edd90bba345e952a7affa9d0fc9ee64e31bbbd0d62f205c99c896561a3a8d5a1be84c271799078254af9811eb7d03501755c4e10fb8551d08c87d785e8079a276f3d3b0bae15b91a4d10f71194ea37ebef4f476e20e0e38b2a1dfb08d1974b97e5686e705a6932828230b72bf33054f908ae8c49a24a4394cfd490374cc92189ea5bef81f89f3b67fbe9f8c51d7a35e61c57ab0152e672eec753b82d0f33923edbc83c4dc2efd2b413ebd81ddc8cb87ad63067eec99ec5c56ee8514aaeb2aea91e7681b5d4683088b4e636c0ae9621eccbe395c2f135e7990a704fc6a10b5bfdd9fe82361f0621e8f81fa879d302c272762dcb5238d620bd4eb137408119a26c98fa19183c56658aa52564c124cc9e8dc7859ffcd3d9766bf1f0dcb271f8620fc26154c1b7e7e333d3ff83e7d5dfdf1abe2e1824e12fb395f54711bd17fea2dbdca44ff266f54202ede4e6a455fbf176aa7bcd5041aef8a5660d7d083bf10ebd16d5837b01d268fb6776ac8ae3d3f16f9b2c9c6f34957cb700bb30007c5573ec4245079f61931245de6c7b957dcdeb5567895ccf2a38cf62c9bd9ce05c98f0a11cfecdcec4140f7b0d4868ee046e7bfe21d1c216b9b1ab639b51bfba4a9c6ee37a141510af7dc3c918ae451563b9bbdb6559068ab5aaca1dcb408d79d774d029d1aeeb52b80dabe6373ed9dec3ed103d87905ebb39531867b5caee9aba935e76008c5a8c59b7d22ed242acf50de9acb755db7122f4a1bbf518039e231be04aa4d7652742479e8f9ce73c4f40409cd03a04be448188743e128c5c3695e81af143c67909e8c52b086b313c6dc1ac26beffda29d2f8cb072b921c9543bac948270e84a3c30546f54333dc1bc775df994cb03f406fbdb55b229c16eeb0348e18507fa4f1b47757ad5c5f357bae9eb22d9122d588abf66bcfcf70af9a6df4ed4d25646d3884afd570a575cb44386aa71b8517c6a322e90b091e1355792b33898ff9dcb775326bcd585d45b0cbc03fd7c765763a3842d258fc9aa5b07ea7c5cf5790b3a0bd244c03612043c29760f8fa17f498333b3fd5620a2c05dff5791a6aeadb4b1553ed664476d8b6f54e044e0b8cfe93c91b6c86274e43e44583fa802964db9a79554d763bbde9143551083c9683e6ae7fe7295571dee1085c1afda08b7e706e767696cb424668491a9ed8777c34e031562ddb41acc5f5719638aac40f0f6cd0a02602e7162ad38cca68233072468b07893aacf45cadd1f2af044c1711c46233a4eca4610eda5a8a1ace75a50bbf7aac5e7fba6b7827f4f6e58d7e4d750d9bdcabfac88acc823e0e4eaac85034cb4f99a27594c96deea20f44e936c7f3182de5068311f70a41a8447e8ede11f4a6fe2fbbdd01f665c36940b4cc6394ed5ae142fe890d7287ead93085dd80d51bc5a99f44c8a62475835fa427f81b2cee8b75755bcc700b97f16f17520f6d29b6167d2d6bf7c4f285aace16a0e50e87c1170bbca27849c2337d927cd9c3acfaf404bffe79fd4c42671020fa19b9e6614951e6eb58c6eee495dd7e9f9238a13f7a81dc2a91c13ddc610059ce87e5e034e5ef472eec98637ccd92f34750c3dd63014928481f1f239c9c760a772a011e541a6b2354227c4bb606cb5195fe31aa6442029f4ceb4a74d056fc5c38261f2301c0edd06a456b447b1e0ccd1cd9c470dce4b5d9ff7e14d6423b4668adf750e1b7810167e6c6b1286a800efe8c9fe4060d4dc01cf2905b8142c7635295b2a4cf03a2b2ae42a23d468cab24a8df28b29a867dcd10a568df850530dce7fae148de116ae4d9911f6202c6d66209bbfd42fc64d2f0127641459305f4a0e8b778b0337293c810d157f239cc07a3c6f4ba008a01da7a0e60e8cb910383364afe7e84d2a84aa03b0afb0a320f90124f0d6baa1ce76a1816b4f5b8edfaabf37791439efd26e6750daa23c228fa740e780d342f9f77c9b6b5afe716b607fb2fed2e91fa3261093446418b5c3db352055d170055c790b352f02a62551e07f8bd0ae1b07001cb13e9160216fb356f39855a50ac13ffb4ee096675a1d06c3e65502895de7512ae97bd0e92cb1b6daa0e06f81e1f7f24ecaf300f7c1433b04ca89556ba7aa901f651447e0ab815013016c15b913c9db5e16d029d1de008fabdad14385a2a74115fb89f816ff3c8d1c369f5518d589f98272cf07ae2f23306e91ed2e66fff77a99bb371fc6bcd87416bcee7021b309109028f1e2aa39d2096877ccb7b607a8b7ea8676d7206f00b93c5748c457ae319e001da7b01a6a11fea5d17b5acebe30f94707419d14d2f454f0e23c05debe96bf89e1a30279d90da8879a0c4beef547ebbac08242f0b66fb595ece91ab432755bde0dd8e4e2eb8266dbca5c9f4ec5d4244cda3d396e523ea37546d080d51b3c33b11f029a971eab9256ef1b0aee40d5d81c7b749bc9406d40ff5afa6909c3406a1b445c0795585238915a6fe1348d1ac33f8dddc08a93b2a353256685b865f12e29a1b01a6ed28854e560c7c342103724d18d8a8d0e6e11779581d9c804046a6353359a134f9a354e29b605cd18fe17f280777c97b5b587a6ea3aee84acd176f695e03459cffbabce6e6aa6644ce0a78741bd9bf6194845c35c83ba8ee6d22affb46347a7f754bdbac4f509eb658ec25b2b5dfeaa1ac5f4c28592152099e85077e0be2acbff1dbdf0225621904980cc84a680f658271bbe83088ef38265416f41823509c405536a1d9c7c07b16a9e051a55217fb0b411c4c2c3dff960a7e5147677701dbcc9c25f39abcdd71cc94814e88e5be99650f65dbab5a7e31d272c72e1b60ec8fa98a976503e8e7fccc386c8e69232414589502cb0db90345944d57ad1bc45449b7883dfacbb2edfb2db65267a9e0253203d825ac75ab338c1ae5c6c4e8e6546faad96b3cf6f7b1e44c457c5f5a0aed2022e417be68e4a37b3c3ddf14cc9f9c8bb1c58dd44f67f94631e79225b5e74b766267ca23d75bb1b928556a9f6b716c2a1a5bc8a42e7b842f88305f8090b38dbd8a8121b94de566736625ffd9341de61359ae0312fc66966d9c16d57acc0385ee854aeea09768091c6091a1efdb5824a04528b9ca188c221abdf47a5089652b5468d46b1278a8b0b4a91ce457ed63a94f27ff8bf26a4e9f0daa0937b90a30f35aee47383c963efbee01813034400688123102a5178bc04a5474827167c6e60b5a3b399486ed2fa0d5b4b78f171f5fab7e88dca2ed08c9e6a1d820ea889fcd999825f5eeeece0947fcdac0746612a397b9f8289ad90f8d5d4bb69fefa57eade75d8214bfe8ce375453c37e17dab81dfceaa4a28604081b5463fcf5f01e97bc89e7ffb6b3076728aa3edb8e166275c47f36d7d58ae3f0d5708834ffcdd6274420e0d7d8b60f5b2feb2fbfe0d88ac8189e89d6c5864fd42752303ffed2307ce150c5e4082b04c0bff326561d7dfabba709bbd43009ea50e5ce86fbc77ba17b5e829e5f9063484f269200adabd3946065c69d5a83e425245c71b3e9ff48940dab9bd2c2eab17d32de9e3ccc025ace28e1248235ccfc9310a7b70d2c04e61ff73c2ce8a07b40217d38be1c9484d4780184e4a767c2511e54c05cbe28246ca7c41e6c6bbe451bafa0876da95e63187dfcd8ddcb1dc15248dccaf0a46e23e3dad10b51b3a86dd31e692df0deccd6e46de0329fbc52a3901f2570ca05ec2e72d4c4c2ba08d79ae6b42b46f1a04fce5732bbbc9f4ef1395eb744ee715f156a330a333677f0756b4daac7aea5780beaee1c2d7a1439977676f5e69d3197a375d6b73a4e7c6821325270cb79cb72a815be5e1c59dbbe9c18bb1bf47e72a09f75d174a18fe1484996c97c26bdb8f0143bf7519674888ed2ca70a3ee8420360e76a27043cfb090a1b43e05988ccb393f99b6c3fe5fe3d6d4a05785b22caf9082e59cff7f45c869ed5ff4ab628c6f8eec5ec059128666db261359b556650374d4322535edf25b39d48558d0089d95db4e8333cb99b92ca999222ec5de32a702a103caac9df31fdfdb2e1b557ca86b5cf556ad563c6a33a8e4170ed859fa07c46e6d85ca75e91eecace96c9f2e6eadb8e5fb21524f500813547a10edd628fa38b0e84833abbc6e083b8bdaa41bf6b3cbc35bffaddb3f42b17d19641586e429c8eee619f3f0e32ba39061189e6477b43776229142d8938240bd555ab28021592b80741e762bd9687a26210b8c8772e390e64b75adcfdd32dc877257b60e4d56ef1750b00f098db0c516b253ac9ce1ada1f25d9f9f3c4b064b0de50e46bc1fc2fb07027f98764135b04b95f30d7da2873b18cc3727a4422cbc4cc61466f5de86360756b5c7d84a0f9881e4236c2e49c6908ac8ddab468e152a6bb03f6ad1804887cd6ff85867a2c17468f293f8a28d55cd0bed45f338efe2967aee64ccf18e53ad69df3a2bd45b52aefc3c2dbca20add83965e481c102f1ce80f2836bc5b4778f515de7ec41efaba0571c33fb860e81561b5c6ffc7344ea3aa5cf314716786514e34759f84ab34acd12ea4051e8defd0e460eaa674c6fc749fa4f33535dc8cbdb692f18409fb5259970fe0a97b35d193d54bbffcfae57af3ecc6f3ceb244f52456d7d0405c5801817ff610fdbfeab677c9715afa992732bbe45375471b23d1f6d6fca83b7acf9ce21878701ee6bc8496318e3f81ac4d5be7961a6cd183868faa26c6c80ad117b3765d51346e682adccca052061c00fd7542c740c5d733ef743dcb32d69b36e316182b7e4126a8e0ee2a7cc84af099ab92c5b124d159f18ba6e2cd0e6344167fe9cdc5c57b336670da5790a37d06baf08f102db3bf10a2ccc4568ad7a00716b4fdf9e421acf439e2c5c43403633d0c3b7481d93ab5cb741f213055e8fa9ef272946d2fed17c22341d04b1590632f892f612d76db305dc3dfe017a09c69759ba9a28537028ca2dba6a7aac939b900da7671336020005b22ee47716705376dc4b2b2b24918d9862d15530f14dc222e06061af452bfc0a7da953e68410bda8a2ffc677d8766c49a1dd364dec01630e79861c2d45517178da67e013f8a6389793b4840c6daba04f38b7f07223a1be854e266ac8d12a725f6c0760c5c400e03644afe606994c844006ad3530ca3937b891947b7c769ca84206a2cc9a1664f8b8dcf06d4d5ab9b566d2b2b837185bc1a6a719156275639c0702cc00436f31500b394d0c52559aaabdb400bef254253a750da0ed4c1a794b3e9b0d89290e0e0345aac9491eccceea4a37c2b029cd3f72ce6c808a36f692b5608375eba19840c6c1d6eb874697d505bd330104bcd7933b1014e11af6ad0014cd7478a0cfd2a974b054623d47efe18fd76f5d8dc8c47ff1fd71be38ebce7fff7705aaaf27a4ac536db6a7c8bdc21a4a001463065377750719d1573f271e81efdbca0c7d0954cbd1399a38c0395bd9eb88e1d934551c23999a439cd8aa6433e731c750672094fde23048a93304dba60d53928ad2c6c38aed633eae857481806e4e989ab21bec54a8fffdffc8ff7f5481e133e46a105f395118d3bbc3522b948c503b048ff73eb1195c7b0b040d09a716f0af1c93c03d2813a17f6c869e794e5df1b3d8ba0ec201ded91569e2192213dd699b1b7ea4235017b3ac4ed310ae3a0e78d9ae9a584093af2ad7d9755c29961488004834654d19d3f22d4a991e9da9d6865457a6c93087e0d055bd062069c912eb4dad4373e00716d159eb85f56dc49c9b714c9d4e23d21a81a20dac56d8d9905a61e166a18fc67dd67b2d8600b59bc53b7970dab641e653f41851ad57d781676467ad781256071efe33d887e3b0821bd127e26cc7363dc4e0e822eea97fff5b60a4d44fce6a3b64a996cc7eee5ee89017df879c6aac92dcd5fd47a4a17aa28a884cff813f1a3b2f5f0af23882afd97e4f83b5d36aae90457bd0929e0bbf2e55da4b5723fc976a3687743417e864045954c31408efca6b3450f92ef3c9303e7b8472341bb03a7af13a20fbea62f5c17ee55528546cce4bc1b5bb38bdbda2ac8c01acbc1fbb9963ef1ce2e0efb55bf0ac5e455c2e9d935264f817609511698af6b7fee3a8ce2e7a55a49bed31bee7f89c88f74516f5630f0bf161cb7a3016178e2208d84ec51976b7ca7559ba0d60a97b23bc7ce6df223d14ab4eff811e8cd753bcdef9b6094be0e4b62c1663e43ecb8a34c060c41cc2ea0ac5bbebce8404284c2a858e50663960fe00a6671984df9084632a748d2f808ebd405b3862489f0787047b0b0cf9d932525a6cef918aa3d46c5b0effbb26f66e2b92bf8739b817708ef0b257962209b5c151dcb2d24cd6023c54ada3160399650751b44152fc32ae8983907353f559579e6a1ccb145ef401d596d16f8dcfaa68e6ee2989451b49d2bb84fc4785aa147f7e6fded27225f39c8a593f0fb76bd068bd481cb5059f477c488458bc74891becbda864212e0b46b08746cf72e57136cb410db43f75cfc85f992d4b0e9f76bb28acbb896947b57116a6d7d2a40cee4da9ac5e0b5e7844c0e1c5f7436e7aa132fcea25b6d8dc2b64f2ec7278e8e68eea6e7d7a2dc439a228ba8438390a42468fa79e5b5774a3746ef72750b2aef53aad3d4258ba8a8b37fc5278fac483a43cd93cd02fb04194c824ba7ff7898ba2a1c1ced146a2932bc4e0621dd8e4dfce6155a84b0d55074ca79a200807b9d039a8deba2ab5a66e63d9383d8ff9d9e3c6bae6f312883a5ddb0ca7d9e27a8c6fbd38ce5ff5cb7cc6803719fd23bd84d4cc54bd34998b88ffea195a033b57ec7c3aed30d5bb8d4af1d427bb65d6e4357715ab4bc611acd6e8e4d0773d775fca6d8aba927a64f60ae8b039d97d52a610711c4b0b766a71476a58169ba788d892ec8d06dd769e2a713cc26cfea7b2c3cca3cb899f3e82f45ff7c61222f5f225c7ed017842e1a8b970dfcdb8922f3498515c79ae532d8612415b585370e0074f91b4aedb13b72be7872afd19756488a0c3b8a83a2aaae8bf275db505e752203de717372520a9c07e62aec9ebcb6f3c400b8a835dc2619cbd23f182418a64f41490a2d2cc6ab0a9d931015cf8c5073f532a43844be4f03a4f3b4c57fed1c6f4b95159d1982b3bfac241caf1771ef1d3d6fd052069801e84492ec30cfb3244030308ac73e2ad01fd3612cd08121a7de23ac6dd6c432156b654c16039f62385ea282d9e3f922b890c3daacd8490f2dcf71eacd4b7bd49a34d2d4f8ec2816a480045ce7e641e2910de599a26d8d85a7a1788bea47b638e459721c479c4a7107c024d57484aeb072c15657904f38babfb4787b71e956dc566ec4aa23476dee6a6929a5644a749f0b75d84064ea7d305b52cf291ea83f53fa9959dcb96e274bbe22f1945ba9bfc4749b08590a1d86f783f46c3987e1252a801a28000e2f340f17eda6307a9140adb3190f88fbc0ff362a470097433e54bc9a5863176133d8a2467faa9346e06eeae8287c16da312a6491a29fc2605c2c8c6059138fd8440655a7e6db83082f7a71f00d0f061985070fade3f5d20e7170b754f3249107b10ed92d715f8fe38852195f3edd13df4a86f21762574c99d2977d4a29b0099a1622e91d528e2ef2de912c73ea00f6d98ed5e506ea05650748831e5f3898eb2d2b472991f274fa49b019e7134cc53b0fced82552814419c711aa9da64d5f30bdc24933e2a316d50c68942c6b4e6efe0577d903d6eca85f53124192a536909a8dd0f0ddb09c6151eafbe5abd2b24eab145cacd783439d2a9db91996b68c0803177da91e0b21a87399e7c2ee01dcce3159a2fb142645b20b4d77c7ae043667e935d1fdc02c00f9fcb7bd44dc565c99cad3e9c3901619ac0d7bcb4d8f4c078a4a7ac176ebc03e510c74099cf589f08b98c245f1d435b8bf83e18e3e06381317f49bb575dde43acb8d34c0dda98ead248ba9063b599c59fc87ee54cb532e1865773d13a9bb4e8d9aeb7ed045d1d288be45a7a07a94e0382189aa4252aba4b2e093bac2f0c43ab52b045b61b7ba1732de2e32d0da70a887401c5cd33e08d89f65340736e656aa16d648e39d22d3a94ef04babdf3c05312edd72d1f78e428a2b283cd5893b1545a25dae650cde115c20adf833e163623410c722a227574ea055e5cc8588ad804ba318ed3ce138ead8b8a6b0bbae8a6e49b5a1bd00a1c14eb3000eebd5b97115db93ebf57f764319940967ea4e3bd8ee47f832fc7d5aa8941919181696bd99f79e1ee0e44be0e988f571b6b4cfb5c8c91bcce3f1e891447071f1d32f6dc436c5bfd4dfb8d115b31e9a38525e6b145a4eaf9c32b3ab1867c50c73338653dfa964e22a55a3e4b99d0f41ef5d763abf0fb77d17f141efb8b77763584aee9b47f998417769f176c64a787fe71489f441dfb242a7cb0f9f41354b6e43a7e72962a16f5b529f8bad203d550566651f4e3064b3a5802429704a1fc09b732383b1a7a93d797d31b570652abef271a6af1534605d74193728acac3ebb539004fe72a9e16b6b373b788beb9082fe240e0db0b79006e331f62f8c45448c4ca56fb1d3dc1a3fd6125cc6ab49ae246bc5705bdb42b914be52be30f670a635f8ee4a26a83781bf1a1c92cbcfa5e7933f61b5512a45933caf13139045747ef10cb13429d64a8e9665395aab5b44409fdd4c5f1b04f1edbb209135fbef6cafeb42dabca5662b6b23f5d54809b3c5e34d41c935731c414bb87d0260630f8d825929a83a80634d4482673b1bd89b982c691a3aa94877c70514d1264565021cce91936ea22c909475c9eb1f6442b1563c7d58545bc0e20497a23b8a23480f48dc30fcee781859fca5a4a7080489eef2c534aa4a9fb5b5747c75c9dd49dab8c6f621bb2b4a7e751f323679100b58f90644bf91bf21a74ba691a161d72f11aa918b8209a43cc8e3447376d93ac4e7150b027de7ccc385d20e6ff7b4d34aff3f41afcf57d07b4cf3b5c737cf58b6118092bcc80c95be11d29972c582ef97eda1f5b691fc2e6c922ea400c12ae69a0511cc145b8df92750dbc873dddbf07af7a9bb4ce75f460018fabfd56cdaacc036de058bb51fd2f347f897a2aaa6104458e428fd45520768e776d70cfedab0f9c181b4ab934ab158f6d31f241f45af76365565662410e5990732aea8ca887639c14da616b62d9a48c81f46a4c0a58eacbaa88357e7387ed0601833ae29a158c73c0fb1a2bfc94ebd340189ee466af1e4372f3423cb9dbb81e3714145b3b190c4079645c3986b005036ea583034a399846c9627e7dcb4c7daaab7dade3ac6393a091258054c64f2153c90abeee95e28cd13af0eae67ed54bf1d57d12a13cc3a240c865b4a1ce48450f7f4bbf83f7e4be5762695ceb00b94123264c79032adb0708232ff7264990ced4c377c91ad7fc8d6fab0a8edd711e59c26b30663f29869f2fd54d37af57ae40cd20d3b6d4cad83526f2014e100c9250c64d0f3db1fabafac86542ecb65033e2fbd66a94a8da22d9f91525670eae45857e0136b6603ba6dd082b60a69764463ff2e94dd0434ce7bc522a121d70da2253b544f790bf96420fa53eb5e9bbfc60dd11aec96c4573fe395bea86f46371288fbc6e7966eb09b0253871089e3d8f5845750b31f1578901f178aeb91387f4a27e38d77221a717cc2f86045355814e25196ff3a2880220166b16f61601788597f22c3132c9a48e4b80593fbe3444dea07431c88801375b1f5d56e89784a5ddc3655283fab992dd4a561c44c9b885261b8846748bafbcd6182198dda6c14c085c94c0940b02f52a39a37c57a2c4bc99bec3a74567edec78afeba91fd1b77af5c662b81e47a1b09607826924d13db2613c8ee4f6fe8c6e30af34cc640bd7bc276eb07bc7bf161078a0dce705ffb60bc0e122049e4efec7b640298790c57ed2a65982bf9463dd230b4b8467b9134712933a1d7af06f0b805d1b153ae73f1d45fb2e4499d92e45c1a94e5dcf15e54783f70e9523118cd0505084f7355ef39feff938118507b68c0b48b4ca2aa5376a8936b0c95e5a0396921b38c059a0e2bab8f6ef49862e337d23243ac044b79fb403e3eb375ccf39668f7a96d8b8984cb1fa23123f64bb5c8a7779f70df1aed10709ae0206ee00a50695cf185f318f37c2e4ffb49c23e990b313241eefa11b5ecd7fd783b143b28726035d2cfea1ab1386a47a8ae7eda668db742040478aeda408587e482ee9d3a3c3f9842ab6e575cc28ebe688eb0d38285af225f40e77bb2170349f7ab9a304d38ee1798240fd395ca726d542162fb639333ce08caab3ac8a866738df230e95349eaeb21fe1b68d969fd07c50cd3c93807fe17d8944953c1c2bfe1c287c0227d29065a0dede5c3355b0648134e851dedcd1e3a5c88f4f9fd667b43bf8d8292cbea81ab07d5315283e24088c9e0c7aef2da2b70326ff098b671473e4eac4c4e2137ec807adb61e54f4471d0e52d35f1e766e443637a388a7213241e3267516e475e46c15a9ba2656c1abbf225d1c587512b383a5bd3f44fd4ae3a491b18079f457a9e5a6726a3ea79ea31b1b87190149a4964b2925b07284f98d88ed64e17dfe1c3d02697b1e380011e8708999791ec0f9c040a7b05a6913ea58cb23aabc5f827a373e8d92ada188709bf2ce8845701a93615610684f51e976c60d8bdf69d973d79b1555eddd39caeeb255b8270665e4fc30b454178449ae65460ace7863a487faee8f4b0f6395214a2efe6bb059463cac06027788cbc06ebbd84d8cd99e23968b8f65b6cd4afcdc953a3f668605bff10fe87fd663dc871e99122b79146b5a0e81a163a4e4ed6110a43a17c8740c59662ef07e303139d921867aa53729bfe016d62229172d046f13aeb06e2c64dacf7db90adaaa51b85353e8053cbdb690a01418da52ec6bc9e7133820a568d483f1fa979b8a900e21af66dfefc4efc2497694d6ae0c250c934c225ddb3b972ba5c9aaca49788d12f7585fa962cfda1aec04eef45d839bd7598d2fb59960e046bbaafd5d0942a11b564506e4303acb3c61445606026e5a27a4c9e39d6326f06e29f4efe78529f720e10831f8c5eef558f1eb3816e94dffbf10871e690877507cdf5993f36ca9eadbafb133767132bf827791631b1a1e9f10206c151dc700233d5bc6e564fd5d9b3d3ccbc8deb24a82ccab042b2003cedf401fc6469fa777ca0b861cf70c4e3bcdec0bdfce3a5ecc1c4590d1a5c812e95778552a6c1326963e50cf46a4e1395c7722ed1a26d5911686f97ac0ea7bd7391cb865f20c7d230a2bbbaf908a3cc818cbf1d0450fea0ed6b026744bb1776c69f040ec27efa102739725c8f6e422a58aa0b59df357da27f0495bb6e6348d14a2f5c61479b645ad3e21619da32a8ea70ebe396f035e63b458ad75002573885268dfb55b69c3321c396e9e1e2cff791700c5550bee4f730b1b2b513c816757ee7535b6c0e1ae6fa5153658d9c52a5bed5bb2af3a0fc0cd1ba65864d34b9af2ed3332fe078b7f36615d7d402b3a5ea5da59827dd7f6f23b29452c91218cdf1dece9c047182759861f6955522b5e642547e2278ef78218a13f7a960e624b9a944c9837f2aa73e3a54f3c62b3a26ea0381a6340a8a4d2e140e86ec450eb6521079092d24687c30aa4da9073aee7c744745b0f33e42b1b772dbe8ea2de3a3fadeeb466d46f6c74009141e39147b5dfc62172cd150d97ca03c9f5a1126c34bb9cba7502de02039344ec4cde64e3c9923ffa4edb313dcf3fba0ec7ae704482eadd9e340089a516d9088bd2e349a54376573527fb1029af8babde9940deab87c0204c8766e38048c3bd8842dca23a10acaeb34a8024556c0e7bd2f2c2d7ce34e0bcb00cc6fe8e56a4b5633497a0b1589fa3c6477345ab4310a0a441e7e3e45c34ab4aeb708e7a4cabc0665f2edc43e52e4c4d945cbc6c128da5aa596c829e5cfe0c48994b54ff3cc00e29b6f1122abcc86bbd37d3281e00cb28eb607246b97092f4bfa5dfc1a784f9567364a2562b8ae77039c5a6ff235b4a8e533367143a7454550406d19869676e8cc491f500f08257352f621cd732e4bbd8bbf44c2212994d859f0abaefe9e0b3e313915cea05000ab952ce2c89cf94254ff72ee7bfe579494b625aec07e4ce6f42dfe9371273713102a79587045ff8b70e41052a1c38d6b3572cda9922b7292ac0a525aa6ebcc1d553f1eb4b9c361a7bcfdc632c8bed24f6e4de63b3cd0d8b88591e593a2f3553792f4a2d2b0da01d42eac8cf0b5b17c71a9dea8f6cf6002db2fbd91cdb849b4b967266a18d7ee434f5f8a5cabbdf2077f74cf88572562df0f1d0b8f5a57029521c06b6088629bff283fdaa5977dc7b6298be0b869d949ae4f4afe32526e1366ce2f83dc26b944a4492da0674956c9994b31412719c65d71c259a1c5690412714b388504882483832ff54fdc91f0404c30e4f37a60d2340570de8137220602d0e061b08aaa28bbbdc7591ac90e2f4aa9bb3932a5aabf20d6e9d77f95509a9fcc61829f4da7220c8ff1bfed38e68eb78352f5ebeeeb5fff2520328c4e310222e98b6fee62d83ad0a2ae4aeceb8f8d8744440fd2b78cff623c6c8bd35fd9ea976d96e0db519b62a46247d01dbe4ea32ed42b317689aa7e8de009b353329b718f06773035916b31633dddf591e040bc4121a4f5e0f464ba7bd1ae817dc6bc2fff184448960d63c2d086b5619a76d75d6763276ff53fb4bbea149949b72c963e78e38811733d3ac159c20b2b32bb5d7be7cac26c98debd1ddee30fc9109520695aef9fd905047d132ab6d708f96aef041f098befb200a9e20220944c3c531f615e43cb0d135a456195a942b334ddac362dffb5e226380ebfd61560ff17288fbaf774a20c99416617fdf14685d1a1f5e13a36b82066f5278948f9508495677ff053ee58928d96a2435ec03126191c8721298ef6a3dee727630755d9d9b4e64baa070b06acd2a52dbe0a6a2c9acbcc5003fd9d4c690a2a7f63e59fc50a58cb7c9e9f884a7c1504a4fd138123332e11ee9ef55171d5ab61d456fdadb732391b36407a579eae08d6d72979eaffcc2e9013fae4356044effc77021cdde7dc12657bf2f37d46058de8ff91b03ca3e94ac284694cf3b86b0a01b0a8f8e1ed512a7db27d373a8df6264ad9fdd5a7b9f7d9fd525ca8036fbdce30ef2b5c9fa3f2bd4e615e7091110ea862f7d6f442ff168c2c0644966d23c7f577f99d110ada86f5586ff328ef8d4e9f3eee8780190b37008f5ec1100a38c3bdf51c2ee74299bef779e42b48dc438883f46363d3d6ed920f286263da7f0ee9492020bf9c14749712660abfd3fab1b595acc1a921b8b360b8da4817e2499a5e3943a0daf5d0622bf0318c4bd7cba1dfa8048935a581d544d7aff8d57df1f15ba88740319106f7f7d9ea44e4658fa4f70e1cb8e2a3629016fe41b44994409f8c6b996bbdc4b5dcc57700959c144af0b557ce5a2e4669f29c678dd163218f612f0e066004e294e9aa826f3f61705564b49e010450faad48938d241b99c6919056f6c26af64962f9109832368d15d8f6b338758a85c09585cbca5495d42b56f83955b92b4787b2df4fd6fcc6abfdecd9ba985dbd41a5992eff2718bfc85164ab3fa01113f3b9eee8b6bbe865a63823c8ab62fcfdd67a54cebaba8dc3ec90b4c89323e91cf09be1cdfe22a55b1cad7e6d68bf2eade94e892858541d3738288e49214e6007239e1f3a8254a0e17790f85b11950c279885b94356c6318c77d9630b545d7859d3d911ebaacca7234a282155715f17634faac500b79989fe4438a360fb29a760aa4342080e1227ff61d85f09d21bd69590bbfc0146d562ffb6f44265ad73f6541000f4064ab53643c1b516313055c38e04eac5b32f96e768f68a1a20d7414a112e3a192cd4558c9c4fb272f8b812339b9d9e03664a007c6a87f14414d8c171d162c3094c5a64e61bbff53cb38a36c3d684d591f6d5402e147fdd018caa8ec7c86e06ff3d2c16b2219071a8b40aed12537570650b5edea3906a45c5c8dbf1207c2c39a51e6e03e75ba818bbf616151d1648ac3cd27b2417b6c85afc6db26000a1faf258846895efc2cb562aabdba191f732d5774d1c9a9c57c947b3e822c8104d2f39aa61cb5f18ec10bf9d48f94189bbf2f2091e9c788b701baba533c55a62a67aae072bd70d0809979b5e863f779732ef79869a726b119da739a80de8d333ec6b6e15af374148f502061e7b9b4ff456415f039b9ac28a869bfd55e346451755f54af66c56fa1e4d61c13adcfd2cb7bcc3484ea74d23b993a5f3104d08c8ff227a2a08a9c1519df6f50d79a5cd3b8dddbe794c7fff2a291e60b9b8043230453560e379533381154ddd7c6d0afee598d302a17dfa84442782939d6f124a333eb968e49c45e79fd08a9400d54114ace41141c8a73a781cf542568e7e5fe61574139c7c57ff223725804d9e7fd8d3fde64798e770c230ef90fbe2f1fae0611ab47b5957240a64ac2f83828108191330cd56fa285162f3e1ea01e3522cb8ef8129027d0428147494fd49c3078c1a29c1d797223724be83cba440ddac6db53adb34aa6bfb4612f375dfc7990af5680690861bb70f260bd65e3b205dadb4a5c702dacd87aa248a15a257b6d807a957da1cce74a0409c3b35ad8ad3f813fb66389aacdb786884ae9c988d9b2670034242e3d9f9b204d9005e9c3b53293206e503278d2877bb018f326617bd7735efcc3d0cb595aa3128bcb8ec71a08c3ae81754e5f7509eb06692bd457c39ef10250239dedae5a1456462c08bae443d1c96148bd738810c15974c47ad798a9f120e9b6067d6e17d0342ef9d36b29d08d39bc4a76c58149688cc3aa2bacaa5980d331038d1afe6ddaa526a24205e8543b4ef871f75e376de72e76ddc72570e72fb7a3f8cee797f0a4d3484ba4756f376fe499ff1bf3003ac6dcc6fe5c363bfa69cb9c584e53277fb88bf95a933058ca6b7029485850be5ed948e8a351313cf3708e529bb84ff5c49f5756ee80f887faf7b61e45ea4b65cae741418f85aa4f5800f6bfb7b607d62a6292bde3b4577779cbfe5c1fbed562505efa308fce0289120aac4cc2c72d226272b4c8c584249b962a2bc565f1142038dfee10f6c526203ebc643bcbfdc67678cae4100f46c23219f69488c963c7d7deffcbd7fd3deff1313b02eab8798cde757230e4877a41fd6337f8fd56e4a1ae6b01cc273fe5cfc2ca3b5dc57cb10212d2f5df65db0ff7b91180fe1e742537681e7212e52a5555e42d77ba7ceea60fcf169904eaab6e1e49eba53232b0333ee38ab88d5d0fc49e9a81a4be2cc9219e3795c7e2c22222da334ebe22f7d51111de5752c8c12af969a490a8ae74fc2ec98f9a3dc94f7a4539a4469392011e3bdac83dd73eecfe1b99b9e43a260864c6c7eab8a6cc1432a7905942bc6d11ad6247bf32d69a14af50ecd04c4f1217d062966b7fd509ef97a4b4ee7e63bdd20636bbf8188663c9fd9fbeda60219bf16215a293b1dfa72b4df961406695b23a501c9f1b360e4fb32ffdb542247312872279f8b71e1fdb654956bfdc0717e057e406f58611805dbec3dd71bb238bf7bff5f3a15ee98ebac946445deecea92ab601089a3223f46828181b1366832678a0684902df8e49baa200353e32bba3590336bf16eb91f1b1cd0f1863c85d6def35ca9a5c042b04a18ba611d3405409c2fb4792842a1c6434a78a571681c5b0eee7c0ccf00aafbe8e0b5c7bfa23b846ef4c28b4db6827a652739d54f339aac2365b466a919828f971d0ef63d0df5c20c29c5e81b9a2816daab7ea4cd96ac7273e0eccf5e345666d314caab86cd8484d8f8f3a5714ea382184a5cb007336e47f5880c7bd8dd8a4406375d4be896714d06d633d37b6aa6749d546dbe887e5c5aeb0bc6e22394771a9dce9b3fdb8930f092559e88e96f7609153521fc7a5f1aadacd3c106a980a08dc39b7c48fac2d2970300002aba94277da2e03edc22164e8cd16903c7a73357020c41f922591a300595ceda38e2bc41291296561496e4638c7a20168171f63c8b9ca7cf7401d1d32d412e23b640c95c376d0cc96023ba7612deaa9e0ff49d460e775b9c5cba8f17c4318d31a949f3b69fcb560b42d4290e83f4cadf6a0235c75437d65f5a727ec85d8e75bcb2051ce3cf5e26175d590c4dca4ba17add3d9ec772b00ed6988b41d5ba08d08202006b2fa61379da8df599a21664b911523de693ef988a7ed32b71238627354ddf0a74a60dfcfd3fd10113935ce0c9aa64be89148a82f8181872c0f8e3d24a66fa9f0526356addcee47533b6338fd2c8cd39d86645884b6cd33bb3dabaca459dd43566b879f17ca77d475435d39b61712608524817e6d6e1ff4daf74fc21e5ebbc28db3bf14c56b5af0e9b1848a9cfe1d415bec1cf5232bda489f20403f8748c63c9843c8635ece03911a07e00f5027556bc04da346772f59ab59ffd7c5a8ba8e66840cf76b6f1c3e4626c488079f72dd75e4889e6ca431a1be738f13f901feab89258948d873429cb3a78ea2761c4767ba58db942197f547d2f369dae016cce773367c51ecbc2a73782512f102480ac6e860e0abcb4afa1eb8e5026ad65c2cae3a377f719b54942c3cfe049b8a064566b803e71aa8dfbbce1e1ea12ec5d43742a451712607399b6d77ca914accf2627bbbac92e7a59de4e9363ab4a5954ea41ee3b979c38856bd9b0fd378c755af4c87908a86bea9f37f6836f08f4db8e3aba5c0f7375a56ddb632081168969c92ca759dc5b68ddb4aff5c4743c780f60ceffec2a184a9e439a4bb367791c7a0ca551b8c5f161b2271957057cdb1708479051253159982f32e80f7fc9794edd79b66bde4551ac2b06ca9f8b5d0536c4bbe260fa4465d3648391b27455928fa4d23d16c5631b47bff13cec9e7c065498cdcff4fc7d700b2895688058782f18075ec826288018303048046e525c6f8097b96dc275d79b94f8a22a03f20a279dd7b882c2e21ccd4d746704d6884046e391249bfdac0771eef9f1d81c5a2f490e9041b546db57c22787dd769e36fbac9868be2ced038aaebb8292035efbf309429cd8da9dc6b64aa63de968035be166c17858652091759ec6885450b95d623b555bd3ba4842d3ad5c8030a7ee0c2a6ca579a94e4b5df01a4f003366656a3c519abd887d8a1745a2efe6773e7f53b68f8f4d93ca0b05cb104adb21c85a0a882ec1125c20cddeb4aca1832cd7285ed22f7ed6ac00e40c6fb07873bbd242c40cd7d304a69a5fcaec9e58840f5dcd405ae52fa65da48699cfc594acc5250943ad3f94a4d7e20da5bfd0142b0a25a1e7c172344604079af2655388bafc4951bb72c8fdad7ad60913db21b8981997a0f475c717c91d61a4ba9862815847b2cfd7329c9821cc311e5fc7244a54122107fe81c12921c2378df1251d99bb6d5dcd34b4e034925ba9da7031c8ce4968e5a3f83c6d802998e9170912ba3e01c2e7ef653bdd957833f9b6156eae79d1507b9cc6ee8f9f48371a3e80d6fd4b28d8cd11a547194af41907e26080bd762e9a2456fd4bd6e6fb06768afbf19444fb52f5f78392bb652c37d2107b67818941d06d223fac6095f0d2261c23f80a41e7478066fc556187483dac6938b3e709e78b61a2502f4dcc1aa2da653e7168aceda29f96a348899b54576e077824d3ae05ec0c5ef1195d2925a9e0ed34ae5a0a38bb722af440525cfb4ea9e1e1d5103fc8cbe206de21a68949bcf0b1db954b65d5fff8211e54f0ea67e9e5037eedadc5bf93ff11f684ecbddbb42956a40140036a8da2d4d31687bd6d8fd71d168ebe698afb228683728fd5c42d28e86bcaf55c0efd2b2473b59096390aa721af931b02254300474fc0a270c28ecc8e9192c3571082077ba44570708c2b06fef49f35443255c24f4a98936ccdec77a717cc156f3b4063ffa036d35cbda7ac1728d63f657d0510de5c201aceb0cdd9425a7776f5a7ca924c415b1de787c2a9e0b160ad40c8f40d7d11fee8dd112a05fdf9101bd6213ae4935f4117df5bad12ed2ab55cf123fea4479495234736a8626b4bbc15be2bf73fdcd7be0f4324f8356421d0f490b4a54c138e5e88403088b47a034f093eb3ec7b45cec545751a385db46aa3e1b292f8b0844223a0af07d7a25b959fd1b3d5611bd53cc76e261929ac3fcd90f3f477f41e7d75844681d580987bd0e97987215c1243b8e9ef2eaf2455334223fe8d4bc2c05f5190025b5cd41bcdad37ce6e697e21c13c955ccda869250122059da10ead28f1e5cbf398995e3cf469dda895ae5904e753887742add79cfcdf6ecc2d7e94ac1e6c2fdfb5569fd8f18601e31acc48face0494f4e3f04a969e8983c1f746eee53674b730fd8caf40b2f7424930d9b113ddabbc15be12a95368f766107e25580d10f287fae23313f1160c05869c977f71f392fffa453d8af43f4ee6436306204d37f30345f574337a4186ad15ebd290b7f9403463dd216f40a08b1c47c84ec9520fd939af6b0afcba152a608e1bfbfd972eb6ac19ccc5c3174222eef9af63fc876c19412366d2a82077a4ed00a536f04604bbd3b68b3edf497cb0bd000effb16b073f278fc469245f9568e19cdbc57305a6e6767aeaacb6d4b9dd1c683efb2676a3e56741d79b348487ef3c1f632964e2b55fc7b5ad1ccd806cac699d856984f61d886d10625340f6ec62091c44a09d250a663aab08e9ef2cec93768c464db7f3a1f6f28f82383512758de0be9fd0ecd80582b1d39ab4a286ea67bdc1bc951fbf69bbcee0383292d1760b43124b87cc74298748385f2f203652975dea7ba608a91bc1bb8ee6954665fcfac1e4b310432e236a7dc3d7176ef1c1ede6e1ecb6a9f772718211b698d5029285f31775df9f3e1552de9bb22f2fee3202a058734fdc9c60599ee2f8c1fcb09c829d623733438fad620912d4714b6da756e6ba602e5d2b9e3e8c7715e9a3ae70ca5e8ad7a60982eb896bdd9f6272d215e5e1c6324a3235124530e904543b58876d27db06f34736b87049462063e0ac5b178eb0f211b8caaf17de484c70e44f7a8b64ca5f4c71466feac46bb2926edb2d7c5c662e78f7ca23191a42633f8870cda08bcf14c3e83621114e4aaaf02fb7c2d946c6a6aafdf22e021137208ebc9ad7a95f9a221f48a878995196ed36e1b4f3e5314062c54baa8f197b6a10eb0314e3b1f30f9e8302b2d88b7cc861bf381b2a78f6b432e422c8071976b8add2b2c79e42597c4b35b726013a2bd3a78a9422a94adea25dee843603b332daf879e4427c1c48a9cee68d9ad060868f1db6c9ad4cb4de04592938f7e5377efab2c27e18317d05e1966307763002091e2d4e0296ac96beb6709fc0c5b4a0766b86e69c0c918d259a3efd79beb9aa4dc1bd098458c3a857b95e93f9f75682977f4dc3b1b6cd405d9ceb5ef4e37d46d23f1e753e8b0e763203416c4108d4c0497fe401201ee1c3415fd0a1144d1e086b6e3e92665d52bf45b08a509d127224a4f9a21fc2a66aca4117f276e1a1bb6b7ffdd2f9c6080957d40945d101035cc7dfd35d3d37e35d0a111f5c06df07de2669397567ad80b3a44700b96accdcb1fadd2490b9f182bca3743eb58b5973af8f76092afb93cd6f63e6b15301561293d9a2d46f432f8de0f03240a2ab539766fa483085bfc87a647406d467fc6b62541a73692442aca890a8921120dfd1bbf7be368ec771f81406e8b0b8ac822a30af11806e26d63802ce13021f406d9eca9514799e49b15dde4c00af8a4ce076b4439ffdcb140d44ad73403d55f9a186feb307ae78dfe1bc3c958fc87ce78f5cfcdea6b368401bcbd91b0880327a55122ae22d23d55b9285aaf9d367cca45aa9118b1e35daaa709f139fc7b7b659c6242d8a4ce2ab6111d70914be27464f896a135b56605b19a2247ff522157d0585f00a96e9791577bfde76ccc0b57b68f5516a85d607bdfd2e54e170090317011d63dd8e41309debe927fca81f897bdc3c7a9088d5ebc29a0092d89427956b8208f6cd2f573c758244d087a86c7efdb40b5fb887bfef1c06fc6f1898a509a72183511c580da47cd7af1f86c020ad08474c0ca73abd7376d6ae92770b58b06f7df3e8b9fbc62229cfa51a615dd6f21adefdceeb5fb0c77ce5a7434683409d161294782b3d2cf895d0a477da05013a1f66a511aa4c8c5f782c0c3c66cbe6937fc9641b110af082cb7450d8574b037e83410688fc00a04b4c0824cfb16d73554b3942a64b06a906b133a00cd1e955cf0e9ecc89f7c457f58c8c38f06748fc3afad46ae3c922f94bbb45c27874f085249f5197415961ed3e89a52970ee19117e3016acc970a1bb34a5376665dd52242c2bd36df1661c73b0f8590b5dbb753bc0c9e8101813793479379b22a429794bd0372ca65c16e9c7f1df46763c05a536c7ecf6362e6d4329569b78c2be667be5906969d6ca385808b60065a31bc8772a0fe27968fc12917203662f775b88830c1b632f719071f24c35f54d9f670eff27f720040003f1131e2b74d1999b28a378ba5166160a3da0c2528517749fc086911303aee20497cf7e6e39b0424926e62c6058af55f9eede81b02796b2b32fab6d3591b52cb7568dc8cd79e0a0e456a1563a482a8cd4ec2c50870554356f3da80cc3fc8f53569f73c4c01cfd1f9fdb7f6d066db2941a5817db3880eccf3b9bf2162dcc5641628d6f4313b2da1f982642e783d2277a4c740e983dc62952d0b75843061d9296325d7464e9db1fe30fbeeb88acd5e75bd7ea4408f942be4aba1bea01abef0a80e04f18af008f806a0b5ec3fcfdf59642766811cdf1ee6e2df4f473dfad3be4707eab64704c7a6e40a477f1459867756456119dc15c9e5e7209f795765b1d53cd2d2bd41dcc6cd667711a068e8f1b99073d2ae25cac27b3a650e8a2f76fdb5689524ef818386763a583db69cbde5045f7d77f84079a4dd3db44b06e222be3df95825b2896a1444b05944a4ce30706c629de80b7f77256a18acb12b387c9b321717c8730b5dc76c816d4d8d5ebc3558159b9a1293762d46e1022152e10d470cb076b8350f7c49dd24b23ac4a269069320beec2776df6c5d0658c8831001124acb6641ad90b8fc5556f64ca2e8e43f42c89f181d4a7fd3e3f712c4f713ae00f7ea917e81cbbbbe64b2e29dc51f14f7aea18c2a1854d289dd4f882b221645b140cb03447674ba931548091eedf4cac3c61767df6c3bb1584373eccf6cb550f6a0a61b0ac6162e0b7eff8f691d6d3133b7a3abfe296ce41936bad1e21230c680112bd09958e2b82219b0dc64acb39ba012943bb74b9f9f1aaab092b2dd6ed6c6dc58e849a06535272879fda00077fa3d812bc136d2cbd11b6b</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","more":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","origin":"<h2 id><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h2><p>昨天妹子让我帮她解决个问题，本以为可以轻松搞定，但是打开他们项目的一瞬间，我头皮发麻。本身功能不多的一个小项目，解决方案里竟然有几十个类库。仅仅搞明白各个类库的作用，代码层次之间的引用关系就花了一个多小时。<a id=\"more\"></a></p>\n<p>显然可能他们项目结构的代码模型出了问题，设计混乱，不容易上手。</p>\n<p>项目中一个好的的代码模型一定是简单、清晰、明了、易于上手的。它总是会让人用起来很舒服，它可以让项目团队成员更好地理解代码，根据代码规范实现团队协作；它可以让各层的逻辑互不干扰、分工协作、各据其位、各司其职，避免不必要的代码混淆。它可以让我们的代码扩展性很好，可以让系统的可维护性更好……</p>\n<p>而代码模型的搭建跟项目的分层架构有关系，绝大多数项目开发中都会会采用分层开发，它有着分散关注、松散耦合、逻辑复用、标准定义、扩展性强等众多好处。而在分层架构中最常用的有两种:三层架构和DDD(领域驱动)分层架构。我们选择的分层方式也决定了我们的项目结构中的代码模型。</p>\n<h3 id=\"1-三层架构\"><a href=\"#1-三层架构\" class=\"headerlink\" title=\"1.三层架构\"></a>1.三层架构</h3><p>三层架构是一种严格分层模式，而严格分层架构模式的特点是上层只能访问相邻的下层，其他层次间的调用都不允许。它把职责划分为界面展示、业务逻辑、数据访问三层，还有一个业务实体，前面三层都要依赖它，所以它并不构成一个层。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%20%281%29.png\" alt></p>\n<p>三层架构是一种面向过程的编程思想，它有几个特点</p>\n<ul>\n<li>业务实体类中基本上只有属性没有方法。</li>\n<li>业务逻辑层的类基本上只有方法没有属性。</li>\n</ul>\n<p>在使用三层架构开发的时候我们通常会直接将数据表结构映射为业务实体类。这样的好处是只需要理解一套模型，以至于市场上也产生了一系列的代码生成工具可以一键生成实体和增删改查的代码。但对于复杂点的业务，这样做也会产生很多的问题。</p>\n<p>而当业务不再是简单的增删查改时，我们可以在三层架构的基础上有个简单的变形：提取一个服务层出来，用来组合模块间的交互，还为业务逻辑层提供了一个防腐层，可以把记录日志、验证权限、处理异常等职责分配给服务层。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E6%94%B9%E8%BF%9B%20%282%29.png\" alt></p>\n<h3 id=\"2-DDD分层架构\"><a href=\"#2-DDD分层架构\" class=\"headerlink\" title=\"2. DDD分层架构\"></a>2. DDD分层架构</h3><p>三层架构有一个显著缺点就是它的内存模型不是基于业务模型而是是基于数据库模型建立的。而很多时候我们的业务模型并不能和我们的数据库模型完全吻合。</p>\n<p>例如：如果你的数据库模型的粒度很小。有些业务就需要连接多张数据库表才能实现。而如果数据库模型的粒度很大（这是大部分项目的选择），代码的质量（重用性、稳定性、扩展性）就很差。由于没有从业务的角度去仔细定义每一个对象，每个人会根据自己的需要建立各种QueryModel或ViewModel(相信三层架构用久了的同学都会遇到这个问题)。</p>\n<p>而且现在很多大型系统都会采用分布式的架构，如现在的微服务架构。服务内不仅仅是简单的增删查改，会有更多的与其它服务交互的内容，而服务的拆分也是以业务模型为导向的。</p>\n<p>这个时候DDD(领域驱动)分层架构就会更有优势。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/DDD.png\" alt=\"依赖倒置的DDD分层架构\"></p>\n<p>DDD分层架构主要包含四层:用户接口层、应用层、领域层、基础层。</p>\n<ul>\n<li>用户接口层：面向前端提供服务适配，面向资源层提供资源适配。这一层聚集了接口适配相关的功能。</li>\n<li>应用层：位于领域层的上一层，理论上不应该有业务规则或逻辑。主要用来实现服务组合和编排，协作完成业务操作，负责处理业务用例的执行顺序以及结果的拼装，以粗粒度的服务通过 API 网关向前端发布提供安全认证、权限校验、事务控制、发送或订阅领域事件等功能。</li>\n<li>领域层：实现领域的核心业务逻辑。这一层聚集了领域模型的聚合、聚合根、实体、值对象、领域服务和事件等领域对象，以及它们组合所形成的业务能力。</li>\n<li>基础层：贯穿所有层的，为其它各层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库等。比较常见的功能还是提供数据库持久化。基础层包含基础服务，它可以采用依赖倒置设计，封装基础资源服务，实现应用层、领域层与基础层的解耦，降低外部资源变化对应用的影响。</li>\n</ul>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/DDD%E5%86%85%E5%AE%B9.png\" alt=\"DDD分层架构\"></p>\n<p>DDD分层架构也分为严格分层架构和松散分层架构，在严格分层架构中，领域服务只能被应用服务调用，而应用服务只能被用户接口层调用，服务是逐层对外封装或组合的，依赖关系清晰。而在松散分层架构中，领域服务可以同时被应用层或用户接口层调用，服务的依赖关系比较复杂且难管理。因此我个人推荐使用严格的分层架构</p>\n<h3 id=\"3-如何选择三层架构还是DDD分层架构\"><a href=\"#3-如何选择三层架构还是DDD分层架构\" class=\"headerlink\" title=\"3.如何选择三层架构还是DDD分层架构\"></a>3.如何选择三层架构还是DDD分层架构</h3><p>对于项目开发中应该如何选择我们可以基于两点考虑：系统本身的业务复杂度和团队人员能力。</p>\n<h4 id=\"3-1-系统本身的业务复杂度\"><a href=\"#3-1-系统本身的业务复杂度\" class=\"headerlink\" title=\"3.1 系统本身的业务复杂度\"></a>3.1 系统本身的业务复杂度</h4><p>如果你们的系统只是个简单的小系统有或者系统本身业务并不复杂，基本都是些增删改查。那么三层架构将是你良好的选择。它会让你的开发变得简单，会大大提高你的开发效率，而且这种分层架构的学习成本很低，新人简单熟悉就可以很容易的上手。对于简单的系统使用DDD分层，反而增加了系统的复杂度。</p>\n<p>而如果你们的系统很复杂或者对于一些成长性的网站系统(一开始很小，随着业务发展慢慢壮大的系统)，那么你可以考虑使用DDD分层架构，DDD的思想可以让你更好的对业务进行建模，这种分层架构会让你的系统扩展性很好，在网站壮大的过程中，单体系统必然会向分布式系统进行发展，而DDD的思想可以对服务进行很好的拆分，如当下的微服务架构，DDD的思想就可以帮助我们很好的定义服务的边界。</p>\n<h4 id=\"3-2-团队人员能力\"><a href=\"#3-2-团队人员能力\" class=\"headerlink\" title=\"3.2 团队人员能力\"></a>3.2 团队人员能力</h4><p>团队人员的能力仍然是选择要考虑的因素。因为DDD对于人员的能力要求相对于三层架构要高。它需要团队的人员要有一个良好的逻辑思想和建模能力，而且DDD的学习成本也要高一些。如果你的团队成员能力一般或者以入行不久的新人为主，或者你的团队人员流动性较大的话，也是不建议使用DDD的。这种情况下使用三层架构会更好一些。</p>\n<p>总有些人会觉得DDD的概念“高大上”，因此为了使用DDD而使用DDD,更有甚至，根本都没有真正弄明白DDD，就开始使用，最终搞的个四不像，不仅没有解决问题，反而徒增了系统复杂度，拉低性能和效率，其实真正项目中改如何选择，应该结合你的团队和系统来，权衡利弊综合考虑。简单、优雅、方便、快捷的解决问题岂不是更好?</p>\n<h3 id=\"4-两种分层架构对应的代码模型\"><a href=\"#4-两种分层架构对应的代码模型\" class=\"headerlink\" title=\"4.两种分层架构对应的代码模型\"></a>4.两种分层架构对应的代码模型</h3><p>一旦选定了分层架构，项目中所对应的代码模型也就确定了。我们以.net为例(java只需要把程序集当成jar包来看就可以了)，推荐下面这两种代码模型。</p>\n<h4 id=\"4-1-三层架构\"><a href=\"#4-1-三层架构\" class=\"headerlink\" title=\"4.1 三层架构\"></a>4.1 三层架构</h4><p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E7%AE%80%E5%8D%95%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png\" alt=\"简单的三层架构\"></p>\n<p>这是最简单的三层架构代码模型，业务逻辑层,数据访问层，应用接口层(界面层，界面层可以是mvc，也可以是webapi。（因为现在很多项目都是前后端分离，服务端开发人员不需要写页面，所以就没有写MVC，界面层我也改叫用户接口层了)。。当然现在几乎是没有人这么用的。因为这样做的依赖性很高。不利于扩展。因此我们要引入依赖倒置的概念。因此我们的结构需要做如下变形</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png\" alt=\"依赖倒置的三层架构\"></p>\n<p>这种结构在简单三层的基础上对业务逻辑层和数据访问层引入了其抽象层，这样就很好的将层与层之间的依赖关系进行了解耦。</p>\n<p>比如，我曾经遇到多个项目数据库从MSSQL转到MySql。在三层架构中，其实大量的逻辑都应该被封装在业务逻辑层。这个时候我们是需要把DAL换成MySql的DAL，业务逻辑不需要任何改动。如果是最简单的三层架构那种绝对依赖关系，我们必然要改动业务逻辑层以接入新的DAL。而这种依赖倒置的层次结构则不需要。</p>\n<p>由于三层架构中同层引用时应该避免的。业务逻辑也是基于数据库模型建立的，而有些业务则需要组合多个业务来实现，为了实现业务逻辑代码复用有些可以采用继承和多态的方式来实现。有些时候则需要再引入一个服务层(防腐层)来组合模块间的交互。也可以把记录日志、验证权限、处理异常等职责分配给这一层。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/%E5%AE%8C%E5%96%84%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png\" alt=\"完整的三层架构\"></p>\n<p>很多项目可能还要加个工具层，用来放一些常用的工具类。但是工具类这个东西，<strong>与项目有关的可以放在这里，如果是多项目之间可以复用的，最好用更专业的做法：单独管理维护，打包成Nuget包(maven包)，由各个项目进行调用</strong>。</p>\n<h4 id=\"4-2-DDD分层代码模型\"><a href=\"#4-2-DDD分层代码模型\" class=\"headerlink\" title=\"4.2 DDD分层代码模型\"></a>4.2 DDD分层代码模型</h4><p>按照 DDD 分层架构模型设计出来的代码模型应该长什么样子呢？</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.png\" alt></p>\n<p>如上图所示:</p>\n<ol>\n<li>用户接口层</li>\n</ol>\n<ul>\n<li>Controller:提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理<ul>\n<li>DTO:数据传输的载体，内部不存在任何业务逻辑，我们通过 DTO 把内部的领域对象与外界隔离。</li>\n<li>Mapper: 实现 DTO 与领域对象之间的相互转换和数据交换。</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>应用层</p>\n<ul>\n<li><p>Event:存放事件相关代码，可以进行事件的发布和处理。事件发布和订阅放在应用层，事件相关的业务逻辑放在领域层。</p>\n</li>\n<li><p>Service：对多个领域服务或外部应用服务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是一段独立的业务逻辑。</p>\n</li>\n</ul>\n</li>\n<li><p>领域层</p>\n<ul>\n<li>Aggregate：是Entity、Event、Service、Repository的根目录，聚合内实现高内聚的业务逻辑，可以根据实际项目中业务的聚合名称命名。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。如果我们的项目需要进行微服务的拆分，那么一个聚合里的内容可以拆分为一个单独的服务。</li>\n<li>Entity：用来存放聚合根、实体、值对象以及工厂模式（Factory）相关代码。实体类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现。跨实体的业务逻辑代码在领域服务中实现。</li>\n<li>Event：存放事件实体以及与事件活动相关的业务逻辑代码。</li>\n<li>Service：存放领域服务代码。一个领域服务是多个实体组合出来的一段业务逻辑。领域服务封装多个实体或方法后向上层提供应用服务调用。</li>\n<li>Repository：存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，最好一个聚合对应一个仓储。</li>\n</ul>\n</li>\n<li><p>基础设施层</p>\n<ul>\n<li>Config：主要存放一些配置相关代码。</li>\n<li>Util：其它诸如数据库、缓存、文件，第三方类库相关的代码可以在这个目录下建立子目录。</li>\n</ul>\n</li>\n</ol>\n<p>在DDD的代码模型中需要注意的是:</p>\n<ul>\n<li>分层的概念一定要清晰，明确各层的职责。</li>\n<li>聚合的代码边界一定要清晰，聚合之间一定是松耦合低关联的。</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>毫无疑问，项目中选择合适的分层架构并设计一个优秀的代码模型有着巨大的好处，但实际上无论是三层架构还是DDD分层架构都没有明确的规定其标准的代码模型。因此以上两种代码模型仅供大家参考。</p>\n<p>而经常会有些设计者在设计的时候总喜欢“炫技”，设计出来的代码模型“深奥复杂”、晦涩难懂，美其名曰“高大上”。熟不知大道至简，优秀的设计是用简单的方式解决复杂的问题，而不是把简单的问题复杂化，在解决问题的基础上，简单实用才是正途！</p>\n<p>同是天涯撸码人，码农何必为难码农，希望每个项目都能有一个好的设计人员，结合实际情况，设计出一个好的代码模型，利己利人！</p>\n","encrypt":true},{"title":"2020年工作上的最大收获——监控告警体系","copyright":true,"date":"2021-01-08T03:29:26.000Z","keywords":"监控告警体系","_content":"### 1 背景\n\n2020年工作上的最大收获就是初步完善了系统的监控告警体系。\n2020年工作上可谓是非常苦逼的，项目上忙到脚打后脑勺的同时还被各种发布问题、生产事件按在地上摩擦。可怜还因疫情原因公司福利大大缩减。\n<!--more-->\n总结了一下令人头疼的问题：\n\n1. 每次大的发布总会产生一堆的生产问题\n1. 日常应用出错不能第一时间感知，总是到了客户那里才报过来\n\n比如有一次发布后产生了一个小小的传值问题，但是会阻碍一部分客户下单，结果两天后通过客户报障才发现，最终导致大量订单损失！\n总体来讲就是缺乏对系统的掌控，应用发布上去后，就像个黑匣子，你只知道它在运行，却不知道里面到底是个什么状况，也许内部已经乱的不可开交,你却一无所知，发布之后只留下一脸懵逼的你独自凌乱。以致于每次发布后的几天都是提心吊胆，有点风吹草动就慌得一比！而在互联网这个频繁发布的行业简直就是灾难\n痛定思痛！终于在下半年的时候忍无可忍，决定给系统插上X光机。不仅要扒掉系统这个“美女”的黑色外衣，甚至让其骨骼线条都赤裸裸的暴露在开发人员眼中。这个X光机就是监控告警体系。\n### 2 技术方案\n我们所使用的是公司自研的监控系统。其大致实现如下图:\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610016490223-213e566b-6127-42fa-8dc1-904858d5cbf4.png#align=left&display=inline&height=459&margin=%5Bobject%20Object%5D&name=image.png&originHeight=459&originWidth=861&size=80822&status=done&style=none&width=861)\n\n1. 各应用系统通过代理客户端写入Kafka\n1. 持久化层服务订阅Kafka消息进行持久化，这其中Influxdb主要存储时序埋点，MySql与ES存储点的一些特性方便检索与聚合\n1. UI层读取展示埋点信息，监控告警配置，主要借助两个强大的可视化工具，Graphana与Kibana。\n\n实现监控告警体系其实就分3步：\n\n1. 应用系统埋点\n1. 可视化展示\n1. 监控告警配置\n\n最简单的方式可以通过 ES+Kibana的方案来实现\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610017130202-4bb10e63-96cc-4e9e-9951-21c1a1192ca6.png#align=left&display=inline&height=188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=188&originWidth=858&size=15663&status=done&style=none&width=858)\n注意;在系统没有遇到瓶颈的时候应该尽可能的用最简单的方案解决问题，每引入一个中间件便大大增加了系统的复杂度和维护成本\n### 3 监控内容\n技术上的实现，其实只是监控体系的第一步。最重要的部分在于监控的内容，只有做好了监控内容才算是给你的系统构建了一个良好的监控大网。而监控哪些内容，不同的系统，不同的业务需求都不相同，这就需要根据业务与系统的要求去制定与不断的完善。\n根据我们的经验总结了几个通用的监控点\n\n1. 请求量\n\n请求量不仅可以用来统计接口调用的数量、QPS等信息，还可以发现系统的问题。\n这里请求量主要包含两部分，一个是你自己提供的接口的请求量，一部分是你所依赖接口的请求量\n\n- 如果你自己提供的接口的请求量突然下降，那么说明依赖你接口的下游应用、或是前置页面极有可能除了问题。\n- 而如果你自己接口的请求量正常，而所调用的第三方接口的请求量突然下降，那么极有可能你自己的代码逻辑除了问题\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610018671344-96acd1ec-184f-49a4-af40-e12ceb3ef666.png#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=891&size=49898&status=done&style=none&width=891)\n请求量一般通过曲线图展示，可以更好的反映出来一个趋势。\n\n2. 响应量\n\n响应量通常可以和请求量结合使用，如果一个接口正常响应量小于请求量，那么说明有一部分的请求是存在问题的。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610018889617-2fcc11d9-864c-4179-9c1c-60cad7f192a9.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=312&originWidth=889&size=50224&status=done&style=none&width=739)\n\n3. 耗时\n\n接口耗时主要用来监控接口性能，同样包括你自己提供的接口的耗时和你所依赖的接口耗时。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610019154215-6b9f6f3b-d302-4d23-8220-68228c561563.png#align=left&display=inline&height=312&margin=%5Bobject%20Object%5D&name=image.png&originHeight=312&originWidth=880&size=49026&status=done&style=none&width=880)\n\n4. 订单量\n\n在许多系统中，订单量都是一个很重要的业务指标，也是我们最重要的监控指标之一。\n\n5. 响应状态\n\n响应状态是一个很好的监控指标，它能够很好的反映我们程序的处理结果。响应状态比较适合用饼图来展示。可以很好的反映出各种状态的占比。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610019374339-eecf31f9-1a2d-4aba-b34f-0e39450dc57e.png#align=left&display=inline&height=285&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=875&size=25642&status=done&style=none&width=875)\n\n6. 异常状态\n\n同响应状态一样，异常状态的监控也具有很重要的意义。同时异常状态也是我们用户告警的重要指标之一，他可以很直观的反映出我们系统的健康状态，异常状态可以用饼图，也可以用曲线图来展示。\n\n7. 页面之间转化率\n\n页面之间转化率不仅仅是用户衡量产品价值的指标，同样是我们系统监控的重要指标，如果从一个页面到另一个页面的转化率突然降低，那么极有可能是这之间出现了什么问题。\n\n8. 其它\n\n还有很多针对具体业务的监控指标，如搜索通常会有空搜率，商品会有缺货率。。。\n当然，可能还有很多不足，也可能随着业务需求的变化，有些监控内容可能已经过时，又可能会需要更多监控，\n这里只提供一些思路，总之针对业务上的各种场景你可以尽情去做到一切皆埋点。\n### 4 告警策略\n监控内容最好之后，监控体系并没有结束，还差一步，就是自动告警。自动告警的功能Grafana和Kibana都可以提供，也可以自定义我们想要的告警方式。\n这里我们主要的告警策略主要有三种\n\n1. 阈值\n\n我们可以对请求量、订单量、异常量设定一个阈值，当每分钟每小时请求量下降到某个阈值，或者异常量达到某个阈值的时候，触发我们的告警。\n\n2. 环比\n\n环比主要是与前一段时间的对比，比如这一小时(或一天)的请求量与上一小时(或一天)的请求量对比，如果小于如果小于某个阈值，就触发我们的告警。\n\n3. 同比\n\n有些时候环比是不可靠的，比如，我们系统的特性就是周二、周三、周四的请求量要远大于周五、周六、周天的请求量，此时如果拿周六的请求量和周五的请求量的去对比是没有意义的，这里就需要用到同比，即拿上周五的请求量和本周五的请求量进行对比，当小于某个阈值的时候触发告警。\n**注意:这里的告警和阈值并非可以一蹴而就的，需要结合实际去慢慢调整它到一个合适的值，我们就深感其痛。(起初就因为一些不合理的告警配置，我们优秀的人工智能经常三更半夜给打你电话，结果通常是虚惊一场，它还比较轴，你不处理它就一直打)。**\n### 5 监控成果\n历时半年，我们对系统的监控告警体系的打造总算是告一段落。俗话说要想吃多少肉，就要先挨多少揍。这期间过程虽然是辛苦的，但成果也是巨大的。之前的问题得到了良好的解决。大部分的线上问题，第一时间就暴露了出来，有些问题在测试环境上通过监控就提早发现。这也侧面的助力我们的测试工作。甚至在监控体系上线后一些“陈年”老bug也开始暴露出来。生产事件率大幅下降。\n最重要的是每个开发人员对系统多了一种掌控的感觉，期待有一天，一群苦逼了许久的程序员可以在今后的每次发布后，轻松看着监控大盘，喝茶扯淡！\n\n","source":"_posts/效能管理/团队方法论/2020年工作上的最大收获——监控告警体系.md","raw":"---\ntitle: 2020年工作上的最大收获——监控告警体系\ncopyright: true\ndate: 2021-01-08 11:29:26\ntags: \n- 团队方法论\n- 监控告警体系\ncategories: \n- 团队方法论\n- 监控告警体系\nkeywords: 监控告警体系\n---\n### 1 背景\n\n2020年工作上的最大收获就是初步完善了系统的监控告警体系。\n2020年工作上可谓是非常苦逼的，项目上忙到脚打后脑勺的同时还被各种发布问题、生产事件按在地上摩擦。可怜还因疫情原因公司福利大大缩减。\n<!--more-->\n总结了一下令人头疼的问题：\n\n1. 每次大的发布总会产生一堆的生产问题\n1. 日常应用出错不能第一时间感知，总是到了客户那里才报过来\n\n比如有一次发布后产生了一个小小的传值问题，但是会阻碍一部分客户下单，结果两天后通过客户报障才发现，最终导致大量订单损失！\n总体来讲就是缺乏对系统的掌控，应用发布上去后，就像个黑匣子，你只知道它在运行，却不知道里面到底是个什么状况，也许内部已经乱的不可开交,你却一无所知，发布之后只留下一脸懵逼的你独自凌乱。以致于每次发布后的几天都是提心吊胆，有点风吹草动就慌得一比！而在互联网这个频繁发布的行业简直就是灾难\n痛定思痛！终于在下半年的时候忍无可忍，决定给系统插上X光机。不仅要扒掉系统这个“美女”的黑色外衣，甚至让其骨骼线条都赤裸裸的暴露在开发人员眼中。这个X光机就是监控告警体系。\n### 2 技术方案\n我们所使用的是公司自研的监控系统。其大致实现如下图:\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610016490223-213e566b-6127-42fa-8dc1-904858d5cbf4.png#align=left&display=inline&height=459&margin=%5Bobject%20Object%5D&name=image.png&originHeight=459&originWidth=861&size=80822&status=done&style=none&width=861)\n\n1. 各应用系统通过代理客户端写入Kafka\n1. 持久化层服务订阅Kafka消息进行持久化，这其中Influxdb主要存储时序埋点，MySql与ES存储点的一些特性方便检索与聚合\n1. UI层读取展示埋点信息，监控告警配置，主要借助两个强大的可视化工具，Graphana与Kibana。\n\n实现监控告警体系其实就分3步：\n\n1. 应用系统埋点\n1. 可视化展示\n1. 监控告警配置\n\n最简单的方式可以通过 ES+Kibana的方案来实现\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610017130202-4bb10e63-96cc-4e9e-9951-21c1a1192ca6.png#align=left&display=inline&height=188&margin=%5Bobject%20Object%5D&name=image.png&originHeight=188&originWidth=858&size=15663&status=done&style=none&width=858)\n注意;在系统没有遇到瓶颈的时候应该尽可能的用最简单的方案解决问题，每引入一个中间件便大大增加了系统的复杂度和维护成本\n### 3 监控内容\n技术上的实现，其实只是监控体系的第一步。最重要的部分在于监控的内容，只有做好了监控内容才算是给你的系统构建了一个良好的监控大网。而监控哪些内容，不同的系统，不同的业务需求都不相同，这就需要根据业务与系统的要求去制定与不断的完善。\n根据我们的经验总结了几个通用的监控点\n\n1. 请求量\n\n请求量不仅可以用来统计接口调用的数量、QPS等信息，还可以发现系统的问题。\n这里请求量主要包含两部分，一个是你自己提供的接口的请求量，一部分是你所依赖接口的请求量\n\n- 如果你自己提供的接口的请求量突然下降，那么说明依赖你接口的下游应用、或是前置页面极有可能除了问题。\n- 而如果你自己接口的请求量正常，而所调用的第三方接口的请求量突然下降，那么极有可能你自己的代码逻辑除了问题\n\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610018671344-96acd1ec-184f-49a4-af40-e12ceb3ef666.png#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=891&size=49898&status=done&style=none&width=891)\n请求量一般通过曲线图展示，可以更好的反映出来一个趋势。\n\n2. 响应量\n\n响应量通常可以和请求量结合使用，如果一个接口正常响应量小于请求量，那么说明有一部分的请求是存在问题的。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610018889617-2fcc11d9-864c-4179-9c1c-60cad7f192a9.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=312&originWidth=889&size=50224&status=done&style=none&width=739)\n\n3. 耗时\n\n接口耗时主要用来监控接口性能，同样包括你自己提供的接口的耗时和你所依赖的接口耗时。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610019154215-6b9f6f3b-d302-4d23-8220-68228c561563.png#align=left&display=inline&height=312&margin=%5Bobject%20Object%5D&name=image.png&originHeight=312&originWidth=880&size=49026&status=done&style=none&width=880)\n\n4. 订单量\n\n在许多系统中，订单量都是一个很重要的业务指标，也是我们最重要的监控指标之一。\n\n5. 响应状态\n\n响应状态是一个很好的监控指标，它能够很好的反映我们程序的处理结果。响应状态比较适合用饼图来展示。可以很好的反映出各种状态的占比。\n![image.png](https://cdn.nlark.com/yuque/0/2021/png/479376/1610019374339-eecf31f9-1a2d-4aba-b34f-0e39450dc57e.png#align=left&display=inline&height=285&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=875&size=25642&status=done&style=none&width=875)\n\n6. 异常状态\n\n同响应状态一样，异常状态的监控也具有很重要的意义。同时异常状态也是我们用户告警的重要指标之一，他可以很直观的反映出我们系统的健康状态，异常状态可以用饼图，也可以用曲线图来展示。\n\n7. 页面之间转化率\n\n页面之间转化率不仅仅是用户衡量产品价值的指标，同样是我们系统监控的重要指标，如果从一个页面到另一个页面的转化率突然降低，那么极有可能是这之间出现了什么问题。\n\n8. 其它\n\n还有很多针对具体业务的监控指标，如搜索通常会有空搜率，商品会有缺货率。。。\n当然，可能还有很多不足，也可能随着业务需求的变化，有些监控内容可能已经过时，又可能会需要更多监控，\n这里只提供一些思路，总之针对业务上的各种场景你可以尽情去做到一切皆埋点。\n### 4 告警策略\n监控内容最好之后，监控体系并没有结束，还差一步，就是自动告警。自动告警的功能Grafana和Kibana都可以提供，也可以自定义我们想要的告警方式。\n这里我们主要的告警策略主要有三种\n\n1. 阈值\n\n我们可以对请求量、订单量、异常量设定一个阈值，当每分钟每小时请求量下降到某个阈值，或者异常量达到某个阈值的时候，触发我们的告警。\n\n2. 环比\n\n环比主要是与前一段时间的对比，比如这一小时(或一天)的请求量与上一小时(或一天)的请求量对比，如果小于如果小于某个阈值，就触发我们的告警。\n\n3. 同比\n\n有些时候环比是不可靠的，比如，我们系统的特性就是周二、周三、周四的请求量要远大于周五、周六、周天的请求量，此时如果拿周六的请求量和周五的请求量的去对比是没有意义的，这里就需要用到同比，即拿上周五的请求量和本周五的请求量进行对比，当小于某个阈值的时候触发告警。\n**注意:这里的告警和阈值并非可以一蹴而就的，需要结合实际去慢慢调整它到一个合适的值，我们就深感其痛。(起初就因为一些不合理的告警配置，我们优秀的人工智能经常三更半夜给打你电话，结果通常是虚惊一场，它还比较轴，你不处理它就一直打)。**\n### 5 监控成果\n历时半年，我们对系统的监控告警体系的打造总算是告一段落。俗话说要想吃多少肉，就要先挨多少揍。这期间过程虽然是辛苦的，但成果也是巨大的。之前的问题得到了良好的解决。大部分的线上问题，第一时间就暴露了出来，有些问题在测试环境上通过监控就提早发现。这也侧面的助力我们的测试工作。甚至在监控体系上线后一些“陈年”老bug也开始暴露出来。生产事件率大幅下降。\n最重要的是每个开发人员对系统多了一种掌控的感觉，期待有一天，一群苦逼了许久的程序员可以在今后的每次发布后，轻松看着监控大盘，喝茶扯淡！\n\n","slug":"效能管理/团队方法论/2020年工作上的最大收获——监控告警体系","published":1,"updated":"2021-03-21T08:29:42.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzi00dphyjfze88t5ck","content":"<h3 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1 背景\"></a>1 背景</h3><p>2020年工作上的最大收获就是初步完善了系统的监控告警体系。<br>2020年工作上可谓是非常苦逼的，项目上忙到脚打后脑勺的同时还被各种发布问题、生产事件按在地上摩擦。可怜还因疫情原因公司福利大大缩减。<br><a id=\"more\"></a><br>总结了一下令人头疼的问题：</p>\n<ol>\n<li>每次大的发布总会产生一堆的生产问题</li>\n<li>日常应用出错不能第一时间感知，总是到了客户那里才报过来</li>\n</ol>\n<p>比如有一次发布后产生了一个小小的传值问题，但是会阻碍一部分客户下单，结果两天后通过客户报障才发现，最终导致大量订单损失！<br>总体来讲就是缺乏对系统的掌控，应用发布上去后，就像个黑匣子，你只知道它在运行，却不知道里面到底是个什么状况，也许内部已经乱的不可开交,你却一无所知，发布之后只留下一脸懵逼的你独自凌乱。以致于每次发布后的几天都是提心吊胆，有点风吹草动就慌得一比！而在互联网这个频繁发布的行业简直就是灾难<br>痛定思痛！终于在下半年的时候忍无可忍，决定给系统插上X光机。不仅要扒掉系统这个“美女”的黑色外衣，甚至让其骨骼线条都赤裸裸的暴露在开发人员眼中。这个X光机就是监控告警体系。</p>\n<h3 id=\"2-技术方案\"><a href=\"#2-技术方案\" class=\"headerlink\" title=\"2 技术方案\"></a>2 技术方案</h3><p>我们所使用的是公司自研的监控系统。其大致实现如下图:</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610016490223-213e566b-6127-42fa-8dc1-904858d5cbf4.png#align=left&amp;display=inline&amp;height=459&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=459&amp;originWidth=861&amp;size=80822&amp;status=done&amp;style=none&amp;width=861\" alt=\"image.png\"></p>\n<ol>\n<li>各应用系统通过代理客户端写入Kafka</li>\n<li>持久化层服务订阅Kafka消息进行持久化，这其中Influxdb主要存储时序埋点，MySql与ES存储点的一些特性方便检索与聚合</li>\n<li>UI层读取展示埋点信息，监控告警配置，主要借助两个强大的可视化工具，Graphana与Kibana。</li>\n</ol>\n<p>实现监控告警体系其实就分3步：</p>\n<ol>\n<li>应用系统埋点</li>\n<li>可视化展示</li>\n<li>监控告警配置</li>\n</ol>\n<p>最简单的方式可以通过 ES+Kibana的方案来实现<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610017130202-4bb10e63-96cc-4e9e-9951-21c1a1192ca6.png#align=left&amp;display=inline&amp;height=188&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=188&amp;originWidth=858&amp;size=15663&amp;status=done&amp;style=none&amp;width=858\" alt=\"image.png\"><br>注意;在系统没有遇到瓶颈的时候应该尽可能的用最简单的方案解决问题，每引入一个中间件便大大增加了系统的复杂度和维护成本</p>\n<h3 id=\"3-监控内容\"><a href=\"#3-监控内容\" class=\"headerlink\" title=\"3 监控内容\"></a>3 监控内容</h3><p>技术上的实现，其实只是监控体系的第一步。最重要的部分在于监控的内容，只有做好了监控内容才算是给你的系统构建了一个良好的监控大网。而监控哪些内容，不同的系统，不同的业务需求都不相同，这就需要根据业务与系统的要求去制定与不断的完善。<br>根据我们的经验总结了几个通用的监控点</p>\n<ol>\n<li>请求量</li>\n</ol>\n<p>请求量不仅可以用来统计接口调用的数量、QPS等信息，还可以发现系统的问题。<br>这里请求量主要包含两部分，一个是你自己提供的接口的请求量，一部分是你所依赖接口的请求量</p>\n<ul>\n<li>如果你自己提供的接口的请求量突然下降，那么说明依赖你接口的下游应用、或是前置页面极有可能除了问题。</li>\n<li>而如果你自己接口的请求量正常，而所调用的第三方接口的请求量突然下降，那么极有可能你自己的代码逻辑除了问题</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610018671344-96acd1ec-184f-49a4-af40-e12ceb3ef666.png#align=left&amp;display=inline&amp;height=302&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=302&amp;originWidth=891&amp;size=49898&amp;status=done&amp;style=none&amp;width=891\" alt=\"image.png\"><br>请求量一般通过曲线图展示，可以更好的反映出来一个趋势。</p>\n<ol>\n<li>响应量</li>\n</ol>\n<p>响应量通常可以和请求量结合使用，如果一个接口正常响应量小于请求量，那么说明有一部分的请求是存在问题的。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610018889617-2fcc11d9-864c-4179-9c1c-60cad7f192a9.png#align=left&amp;display=inline&amp;height=259&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=312&amp;originWidth=889&amp;size=50224&amp;status=done&amp;style=none&amp;width=739\" alt=\"image.png\"></p>\n<ol>\n<li>耗时</li>\n</ol>\n<p>接口耗时主要用来监控接口性能，同样包括你自己提供的接口的耗时和你所依赖的接口耗时。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610019154215-6b9f6f3b-d302-4d23-8220-68228c561563.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=312&amp;originWidth=880&amp;size=49026&amp;status=done&amp;style=none&amp;width=880\" alt=\"image.png\"></p>\n<ol>\n<li>订单量</li>\n</ol>\n<p>在许多系统中，订单量都是一个很重要的业务指标，也是我们最重要的监控指标之一。</p>\n<ol>\n<li>响应状态</li>\n</ol>\n<p>响应状态是一个很好的监控指标，它能够很好的反映我们程序的处理结果。响应状态比较适合用饼图来展示。可以很好的反映出各种状态的占比。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610019374339-eecf31f9-1a2d-4aba-b34f-0e39450dc57e.png#align=left&amp;display=inline&amp;height=285&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=285&amp;originWidth=875&amp;size=25642&amp;status=done&amp;style=none&amp;width=875\" alt=\"image.png\"></p>\n<ol>\n<li>异常状态</li>\n</ol>\n<p>同响应状态一样，异常状态的监控也具有很重要的意义。同时异常状态也是我们用户告警的重要指标之一，他可以很直观的反映出我们系统的健康状态，异常状态可以用饼图，也可以用曲线图来展示。</p>\n<ol>\n<li>页面之间转化率</li>\n</ol>\n<p>页面之间转化率不仅仅是用户衡量产品价值的指标，同样是我们系统监控的重要指标，如果从一个页面到另一个页面的转化率突然降低，那么极有可能是这之间出现了什么问题。</p>\n<ol>\n<li>其它</li>\n</ol>\n<p>还有很多针对具体业务的监控指标，如搜索通常会有空搜率，商品会有缺货率。。。<br>当然，可能还有很多不足，也可能随着业务需求的变化，有些监控内容可能已经过时，又可能会需要更多监控，<br>这里只提供一些思路，总之针对业务上的各种场景你可以尽情去做到一切皆埋点。</p>\n<h3 id=\"4-告警策略\"><a href=\"#4-告警策略\" class=\"headerlink\" title=\"4 告警策略\"></a>4 告警策略</h3><p>监控内容最好之后，监控体系并没有结束，还差一步，就是自动告警。自动告警的功能Grafana和Kibana都可以提供，也可以自定义我们想要的告警方式。<br>这里我们主要的告警策略主要有三种</p>\n<ol>\n<li>阈值</li>\n</ol>\n<p>我们可以对请求量、订单量、异常量设定一个阈值，当每分钟每小时请求量下降到某个阈值，或者异常量达到某个阈值的时候，触发我们的告警。</p>\n<ol>\n<li>环比</li>\n</ol>\n<p>环比主要是与前一段时间的对比，比如这一小时(或一天)的请求量与上一小时(或一天)的请求量对比，如果小于如果小于某个阈值，就触发我们的告警。</p>\n<ol>\n<li>同比</li>\n</ol>\n<p>有些时候环比是不可靠的，比如，我们系统的特性就是周二、周三、周四的请求量要远大于周五、周六、周天的请求量，此时如果拿周六的请求量和周五的请求量的去对比是没有意义的，这里就需要用到同比，即拿上周五的请求量和本周五的请求量进行对比，当小于某个阈值的时候触发告警。<br><strong>注意:这里的告警和阈值并非可以一蹴而就的，需要结合实际去慢慢调整它到一个合适的值，我们就深感其痛。(起初就因为一些不合理的告警配置，我们优秀的人工智能经常三更半夜给打你电话，结果通常是虚惊一场，它还比较轴，你不处理它就一直打)。</strong></p>\n<h3 id=\"5-监控成果\"><a href=\"#5-监控成果\" class=\"headerlink\" title=\"5 监控成果\"></a>5 监控成果</h3><p>历时半年，我们对系统的监控告警体系的打造总算是告一段落。俗话说要想吃多少肉，就要先挨多少揍。这期间过程虽然是辛苦的，但成果也是巨大的。之前的问题得到了良好的解决。大部分的线上问题，第一时间就暴露了出来，有些问题在测试环境上通过监控就提早发现。这也侧面的助力我们的测试工作。甚至在监控体系上线后一些“陈年”老bug也开始暴露出来。生产事件率大幅下降。<br>最重要的是每个开发人员对系统多了一种掌控的感觉，期待有一天，一群苦逼了许久的程序员可以在今后的每次发布后，轻松看着监控大盘，喝茶扯淡！</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1 背景\"></a>1 背景</h3><p>2020年工作上的最大收获就是初步完善了系统的监控告警体系。<br>2020年工作上可谓是非常苦逼的，项目上忙到脚打后脑勺的同时还被各种发布问题、生产事件按在地上摩擦。可怜还因疫情原因公司福利大大缩减。<br>","more":"<br>总结了一下令人头疼的问题：</p>\n<ol>\n<li>每次大的发布总会产生一堆的生产问题</li>\n<li>日常应用出错不能第一时间感知，总是到了客户那里才报过来</li>\n</ol>\n<p>比如有一次发布后产生了一个小小的传值问题，但是会阻碍一部分客户下单，结果两天后通过客户报障才发现，最终导致大量订单损失！<br>总体来讲就是缺乏对系统的掌控，应用发布上去后，就像个黑匣子，你只知道它在运行，却不知道里面到底是个什么状况，也许内部已经乱的不可开交,你却一无所知，发布之后只留下一脸懵逼的你独自凌乱。以致于每次发布后的几天都是提心吊胆，有点风吹草动就慌得一比！而在互联网这个频繁发布的行业简直就是灾难<br>痛定思痛！终于在下半年的时候忍无可忍，决定给系统插上X光机。不仅要扒掉系统这个“美女”的黑色外衣，甚至让其骨骼线条都赤裸裸的暴露在开发人员眼中。这个X光机就是监控告警体系。</p>\n<h3 id=\"2-技术方案\"><a href=\"#2-技术方案\" class=\"headerlink\" title=\"2 技术方案\"></a>2 技术方案</h3><p>我们所使用的是公司自研的监控系统。其大致实现如下图:</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610016490223-213e566b-6127-42fa-8dc1-904858d5cbf4.png#align=left&amp;display=inline&amp;height=459&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=459&amp;originWidth=861&amp;size=80822&amp;status=done&amp;style=none&amp;width=861\" alt=\"image.png\"></p>\n<ol>\n<li>各应用系统通过代理客户端写入Kafka</li>\n<li>持久化层服务订阅Kafka消息进行持久化，这其中Influxdb主要存储时序埋点，MySql与ES存储点的一些特性方便检索与聚合</li>\n<li>UI层读取展示埋点信息，监控告警配置，主要借助两个强大的可视化工具，Graphana与Kibana。</li>\n</ol>\n<p>实现监控告警体系其实就分3步：</p>\n<ol>\n<li>应用系统埋点</li>\n<li>可视化展示</li>\n<li>监控告警配置</li>\n</ol>\n<p>最简单的方式可以通过 ES+Kibana的方案来实现<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610017130202-4bb10e63-96cc-4e9e-9951-21c1a1192ca6.png#align=left&amp;display=inline&amp;height=188&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=188&amp;originWidth=858&amp;size=15663&amp;status=done&amp;style=none&amp;width=858\" alt=\"image.png\"><br>注意;在系统没有遇到瓶颈的时候应该尽可能的用最简单的方案解决问题，每引入一个中间件便大大增加了系统的复杂度和维护成本</p>\n<h3 id=\"3-监控内容\"><a href=\"#3-监控内容\" class=\"headerlink\" title=\"3 监控内容\"></a>3 监控内容</h3><p>技术上的实现，其实只是监控体系的第一步。最重要的部分在于监控的内容，只有做好了监控内容才算是给你的系统构建了一个良好的监控大网。而监控哪些内容，不同的系统，不同的业务需求都不相同，这就需要根据业务与系统的要求去制定与不断的完善。<br>根据我们的经验总结了几个通用的监控点</p>\n<ol>\n<li>请求量</li>\n</ol>\n<p>请求量不仅可以用来统计接口调用的数量、QPS等信息，还可以发现系统的问题。<br>这里请求量主要包含两部分，一个是你自己提供的接口的请求量，一部分是你所依赖接口的请求量</p>\n<ul>\n<li>如果你自己提供的接口的请求量突然下降，那么说明依赖你接口的下游应用、或是前置页面极有可能除了问题。</li>\n<li>而如果你自己接口的请求量正常，而所调用的第三方接口的请求量突然下降，那么极有可能你自己的代码逻辑除了问题</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610018671344-96acd1ec-184f-49a4-af40-e12ceb3ef666.png#align=left&amp;display=inline&amp;height=302&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=302&amp;originWidth=891&amp;size=49898&amp;status=done&amp;style=none&amp;width=891\" alt=\"image.png\"><br>请求量一般通过曲线图展示，可以更好的反映出来一个趋势。</p>\n<ol>\n<li>响应量</li>\n</ol>\n<p>响应量通常可以和请求量结合使用，如果一个接口正常响应量小于请求量，那么说明有一部分的请求是存在问题的。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610018889617-2fcc11d9-864c-4179-9c1c-60cad7f192a9.png#align=left&amp;display=inline&amp;height=259&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=312&amp;originWidth=889&amp;size=50224&amp;status=done&amp;style=none&amp;width=739\" alt=\"image.png\"></p>\n<ol>\n<li>耗时</li>\n</ol>\n<p>接口耗时主要用来监控接口性能，同样包括你自己提供的接口的耗时和你所依赖的接口耗时。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610019154215-6b9f6f3b-d302-4d23-8220-68228c561563.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=312&amp;originWidth=880&amp;size=49026&amp;status=done&amp;style=none&amp;width=880\" alt=\"image.png\"></p>\n<ol>\n<li>订单量</li>\n</ol>\n<p>在许多系统中，订单量都是一个很重要的业务指标，也是我们最重要的监控指标之一。</p>\n<ol>\n<li>响应状态</li>\n</ol>\n<p>响应状态是一个很好的监控指标，它能够很好的反映我们程序的处理结果。响应状态比较适合用饼图来展示。可以很好的反映出各种状态的占比。<br><img src=\"https://cdn.nlark.com/yuque/0/2021/png/479376/1610019374339-eecf31f9-1a2d-4aba-b34f-0e39450dc57e.png#align=left&amp;display=inline&amp;height=285&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=285&amp;originWidth=875&amp;size=25642&amp;status=done&amp;style=none&amp;width=875\" alt=\"image.png\"></p>\n<ol>\n<li>异常状态</li>\n</ol>\n<p>同响应状态一样，异常状态的监控也具有很重要的意义。同时异常状态也是我们用户告警的重要指标之一，他可以很直观的反映出我们系统的健康状态，异常状态可以用饼图，也可以用曲线图来展示。</p>\n<ol>\n<li>页面之间转化率</li>\n</ol>\n<p>页面之间转化率不仅仅是用户衡量产品价值的指标，同样是我们系统监控的重要指标，如果从一个页面到另一个页面的转化率突然降低，那么极有可能是这之间出现了什么问题。</p>\n<ol>\n<li>其它</li>\n</ol>\n<p>还有很多针对具体业务的监控指标，如搜索通常会有空搜率，商品会有缺货率。。。<br>当然，可能还有很多不足，也可能随着业务需求的变化，有些监控内容可能已经过时，又可能会需要更多监控，<br>这里只提供一些思路，总之针对业务上的各种场景你可以尽情去做到一切皆埋点。</p>\n<h3 id=\"4-告警策略\"><a href=\"#4-告警策略\" class=\"headerlink\" title=\"4 告警策略\"></a>4 告警策略</h3><p>监控内容最好之后，监控体系并没有结束，还差一步，就是自动告警。自动告警的功能Grafana和Kibana都可以提供，也可以自定义我们想要的告警方式。<br>这里我们主要的告警策略主要有三种</p>\n<ol>\n<li>阈值</li>\n</ol>\n<p>我们可以对请求量、订单量、异常量设定一个阈值，当每分钟每小时请求量下降到某个阈值，或者异常量达到某个阈值的时候，触发我们的告警。</p>\n<ol>\n<li>环比</li>\n</ol>\n<p>环比主要是与前一段时间的对比，比如这一小时(或一天)的请求量与上一小时(或一天)的请求量对比，如果小于如果小于某个阈值，就触发我们的告警。</p>\n<ol>\n<li>同比</li>\n</ol>\n<p>有些时候环比是不可靠的，比如，我们系统的特性就是周二、周三、周四的请求量要远大于周五、周六、周天的请求量，此时如果拿周六的请求量和周五的请求量的去对比是没有意义的，这里就需要用到同比，即拿上周五的请求量和本周五的请求量进行对比，当小于某个阈值的时候触发告警。<br><strong>注意:这里的告警和阈值并非可以一蹴而就的，需要结合实际去慢慢调整它到一个合适的值，我们就深感其痛。(起初就因为一些不合理的告警配置，我们优秀的人工智能经常三更半夜给打你电话，结果通常是虚惊一场，它还比较轴，你不处理它就一直打)。</strong></p>\n<h3 id=\"5-监控成果\"><a href=\"#5-监控成果\" class=\"headerlink\" title=\"5 监控成果\"></a>5 监控成果</h3><p>历时半年，我们对系统的监控告警体系的打造总算是告一段落。俗话说要想吃多少肉，就要先挨多少揍。这期间过程虽然是辛苦的，但成果也是巨大的。之前的问题得到了良好的解决。大部分的线上问题，第一时间就暴露了出来，有些问题在测试环境上通过监控就提早发现。这也侧面的助力我们的测试工作。甚至在监控体系上线后一些“陈年”老bug也开始暴露出来。生产事件率大幅下降。<br>最重要的是每个开发人员对系统多了一种掌控的感觉，期待有一天，一群苦逼了许久的程序员可以在今后的每次发布后，轻松看着监控大盘，喝茶扯淡！</p>"},{"title":"Redis对象——哈希(Hash)","copyright":true,"date":"2020-03-23T02:45:38.000Z","keywords":"Redis,Hash","aside":"redis","_content":"\n\n哈希在很多编程语言中都有着很广泛的应用，而在Redis中也是如此，在redis中，哈希类型是指Redis键值对中的值本身又是一个键值对结构，形如`value=[{field1，value1}，...{fieldN，valueN}]`<!--More-->，其与Redis字符串对象的区别如下图所示:\n\n![Redis-Hash](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash.png)\n\n### 一、内部编码\n\n&nbsp;&nbsp;&nbsp;&nbsp;哈希类型的内部编码有两种：[ziplist(压缩列表)](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/),[hashtable(哈希表)](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/)。只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：\n* 当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）  \n* 所有值都小于hash-max-ziplist-value配置（默认64字节）  \n  `ziplist`使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比`hashtable`更加优秀。当哈希类型无法满足`ziplist`的条件时，Redis会使用`hashtable`作为哈希的内部实现，因为此时`ziplist`的读写效率会下降，而`hashtable`的读写时间复杂度为O（1）。  \n  有关ziplist和hashtable这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。\n  \n  [Redis数据结构——压缩列表](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/)\n  \n  [Redis数据结构——字典](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/)。\n\n### 二、常用命令\n\nRedis哈希对象常用命令如下表(点击命令可查看命令详细说明)。\n\n| 命令                                                         | 说明                                           | 时间复杂度                 |\n| ------------------------------------------------------------ | ---------------------------------------------- | -------------------------- |\n| [HDEL key field [field ...]](http://blog.laoyu.site/2020/redis_command/hash/hdel/) | 删除一个或多个Hash的field                      | O(N) N是被删除的字段数量。 |\n| [HEXISTS key field](http://blog.laoyu.site/2020/redis_command/hash/hexists/) | 判断field是否存在于hash中                      | O(1)                       |\n| [HGET key field](http://blog.laoyu.site/2020/redis_command/hash/hget/) | 获取hash中field的值                            | O(1)                       |\n| [HGETALL key](http://blog.laoyu.site/2020/redis_command/hash/hgetall/) | 从hash中读取全部的域和值                       | O(N) N是Hash的长度         |\n| [HINCRBY key field increment](http://blog.laoyu.site/2020/redis_command/hash/hincrby/) | 将hash中指定域的值增加给定的数字               | O(1)                       |\n| [HINCRBYFLOAT key field increment](http://blog.laoyu.site/2020/redis_command/hash/hincrbyfloat/) | 将hash中指定域的值增加给定的浮点数             | O(1)                       |\n| [HKEYS key](http://blog.laoyu.site/2020/redis_command/hash/hkeys/) | 获取hash的所有字段                             | O(N) N是Hash的长度         |\n| [HLEN key](http://blog.laoyu.site/2020/redis_command/hash/hlen/) | 获取hash里所有字段的数量                       | O(1)                       |\n| [HMGET key field [field ...]](http://blog.laoyu.site/2020/redis_command/hash/hmget/) | 获取hash里面指定字段的值                       | O(N) N是请求的字段数       |\n| [HMSET key field value [field value ...]](http://blog.laoyu.site/2020/redis_command/hash/hmset/) | 设置hash字段值                                 | O(N) N是设置的字段数       |\n| [HSET key field value](http://blog.laoyu.site/2020/redis_command/hash/hset/) | 设置hash里面一个字段的值                       | O(1)                       |\n| [HSETNX key field value](http://blog.laoyu.site/2020/redis_command/hash/hsetnx/) | 设置hash的一个字段，只有当这个字段不存在时有效 | O(1)                       |\n| [HSTRLEN key field](http://blog.laoyu.site/2020/redis_command/hash/hstrlen/) | 获取hash里面指定field的长度                    | O(1)                       |\n| [HVALS key](http://blog.laoyu.site/2020/redis_command/hash/hvals/) | 获得hash的所有值                               | O(N) N是Hash的长度         |\n| [HSCAN key cursor [MATCH pattern] [COUNT count]](http://blog.laoyu.site/2020/redis_command/hash/hscan/) | 迭代hash里面的元素                             |                            |\n\n### 三、适用场景\n\n#### 3.1 存储对象\n\n​\tRedis哈希对象常常用来缓存一些对象信息，如用户信息、商品信息、配置信息等。\n\n我们以用户信息为例,它在关系型数据库中的结构是这样的\n\n| uid  | name  | age  |\n| ---- | ----- | ---- |\n| 1    | Tom   | 15   |\n| 2    | Jerry | 13   |\n\n而使用Redis Hash存储其结构如下图:\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash%20%281%29.png)\n\n相比较于使用Redis字符串存储，其有以下几个优缺点:\n\n1. 原生字符串每个属性一个键。\n\n   ```  \n   set user:1:name Tom\n   set user:1:age 15\n   ```\n\n   优点：简单直观，每个属性都支持更新操作。\n   缺点：占用过多的键，内存占用量较大，同时用户信息内聚性比较差，所以此种方案一般不会在生产环境使用。\n   \n2. 序列化字符串后，将用户信息序列化后用一个键保存\n\n   ```\n   set user:1 serialize(userInfo)\n   ```\n   \n   优点：简化编程，如果合理的使用序列化可以提高内存的使用效率。\n   缺点：序列化和反序列化有一定的开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到Redis中。\n   \n3. 哈希类型：每个用户属性使用一对field-value，但是只用一个键保存。\n\n\t```\n\thmset user:1 name Tom age 15 \n\t```\n\n   优点：简单直观，如果使用合理可以减少内存空间的使用。\n   缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。\n\n此外，我们曾经在做配置中心系统的时候，使用Hash来缓存每个应用的配置信息,其在数据库中的数据结构大致如下表\n\n| AppId | SettingKey | SettingValue |\n| ----- | ---------- | ------------ |\n| 10001 | AppName    | myblog       |\n| 10001 | Version    | 1.0          |\n| 10002 | AppName    | admin site   |\n\n在使用Redis Hash进行存储的时候\n\n新增或更新一个配置项\n\n```c\n127.0.0.1:6379> HSET 10001 AppName myblog\n(integer) 1\n```\n\n获取一个配置项\n\n```c\n127.0.0.1:6379> HGET 10001 AppName \n\"myblog\"\n```\n\n删除一个配置项\n\n```c\n127.0.0.1:6379> HDEL 10001 AppName\n(integer) 1\n```\n\n#### 3.2 购物车\n\n&nbsp;&nbsp;&nbsp;&nbsp;很多电商网站都会使用 cookie实现购物车，也就是将整个购物车都存储到 cookie里面。这种做法的一大**优点:**无须对数据库进行写入就可以实现购物车功能,这种方式大大提高了购物车的性能，而**缺点**则是程序需要重新解析和验证( validate) cookie,确保cookie的格式正确,并且包含的商品都是真正可购买的商品。cookie购物车还有一个**缺点**:因为浏览器每次发送请求都会连 cookie一起发送,所以如果购物车cookie的体积比较大,那么请求发送和处理的速度可能会有所降低。\n\n&nbsp;&nbsp;&nbsp;&nbsp;购物车的定义非常简单:我们以每个用户的用户ID(或者CookieId)作为Redis的Key,每个用户的购物车都是一个哈希表,这个哈希表存储了商品ID与商品订购数量之间的映射。在商品的订购数量出现变化时,我们操作Redis哈希对购物车进行更新:\n\n如果用户订购某件商品的数量大于0,那么程序会将这件商品的ID以及用户订购该商品的数量添加到散列里面。\n\n```c\n//用户1 商品1 数量1\n127.0.0.1:6379> HSET uid:1 pid:1 1\n(integer) 1 //返回值0代表改field在哈希表中不存在，为新增的field\n```\n\n如果用户购买的商品已经存在于散列里面,那么新的订购数量会覆盖已有的订购数量;\n\n```c\n//用户1 商品1 数量5\n127.0.0.1:6379> HSET uid:1 pid:1 5\n(integer) 0 //返回值0代表改field在哈希表中已经存在\n```\n\n相反地,如果用户订购某件商品的数量不大于0,那么程序将从散列里面移除该条目。\n\n```c#\n//用户1 商品1\n127.0.0.1:6379> HDEL uid:1 pid:2\n(integer) 1\n```\n\n#### 3.3 计数器\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis 哈希表作为计数器的使用也非常广泛。它常常被用在记录网站每一天、一月、一年的访问数量。每一次访问，我们在对应的field上自增1\n\n```c\n//记录我的\n127.0.0.1:6379> HINCRBY MyBlog  202001 1\n(integer) 1\n127.0.0.1:6379> HINCRBY MyBlog  202001 1\n(integer) 2\n127.0.0.1:6379> HINCRBY MyBlog  202002 1\n(integer) 1\n127.0.0.1:6379> HINCRBY MyBlog  202002 1\n(integer) 2\n```\n\n也经常被用在记录商品的好评数量，差评数量上\n\n```c#\n127.0.0.1:6379> HINCRBY pid:1  Good 1\n(integer) 1\n127.0.0.1:6379> HINCRBY pid:1  Good 1\n(integer) 2\n127.0.0.1:6379> HINCRBY pid:1  bad  1\n(integer) 1\n```\n\n也可以实时记录当天的在线的人数。\n\n```c#\n//有人登陆\n127.0.0.1:6379> HINCRBY MySite  20200310 1\n(integer) 1\n//有人登陆\n127.0.0.1:6379> HINCRBY MySite  20200310 1\n(integer) 2\n//有人登出\n127.0.0.1:6379> HINCRBY MySite  20200310 -1\n(integer) 1\n```\n\n### 小结\n\n本篇文章我们总结了Redis 哈希对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis哈希对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！\n\n\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","source":"_posts/技术实践/redis/Redis对象——哈希(Hash).md","raw":"---\n\ntitle: Redis对象——哈希(Hash)\ncopyright: true\ndate: 2020-03-23 10:45:38\ntags: \n- Redis\ncategories: Redis\nkeywords: Redis,Hash\naside: redis\n---\n\n\n哈希在很多编程语言中都有着很广泛的应用，而在Redis中也是如此，在redis中，哈希类型是指Redis键值对中的值本身又是一个键值对结构，形如`value=[{field1，value1}，...{fieldN，valueN}]`<!--More-->，其与Redis字符串对象的区别如下图所示:\n\n![Redis-Hash](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash.png)\n\n### 一、内部编码\n\n&nbsp;&nbsp;&nbsp;&nbsp;哈希类型的内部编码有两种：[ziplist(压缩列表)](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/),[hashtable(哈希表)](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/)。只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：\n* 当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）  \n* 所有值都小于hash-max-ziplist-value配置（默认64字节）  \n  `ziplist`使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比`hashtable`更加优秀。当哈希类型无法满足`ziplist`的条件时，Redis会使用`hashtable`作为哈希的内部实现，因为此时`ziplist`的读写效率会下降，而`hashtable`的读写时间复杂度为O（1）。  \n  有关ziplist和hashtable这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。\n  \n  [Redis数据结构——压缩列表](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/)\n  \n  [Redis数据结构——字典](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/)。\n\n### 二、常用命令\n\nRedis哈希对象常用命令如下表(点击命令可查看命令详细说明)。\n\n| 命令                                                         | 说明                                           | 时间复杂度                 |\n| ------------------------------------------------------------ | ---------------------------------------------- | -------------------------- |\n| [HDEL key field [field ...]](http://blog.laoyu.site/2020/redis_command/hash/hdel/) | 删除一个或多个Hash的field                      | O(N) N是被删除的字段数量。 |\n| [HEXISTS key field](http://blog.laoyu.site/2020/redis_command/hash/hexists/) | 判断field是否存在于hash中                      | O(1)                       |\n| [HGET key field](http://blog.laoyu.site/2020/redis_command/hash/hget/) | 获取hash中field的值                            | O(1)                       |\n| [HGETALL key](http://blog.laoyu.site/2020/redis_command/hash/hgetall/) | 从hash中读取全部的域和值                       | O(N) N是Hash的长度         |\n| [HINCRBY key field increment](http://blog.laoyu.site/2020/redis_command/hash/hincrby/) | 将hash中指定域的值增加给定的数字               | O(1)                       |\n| [HINCRBYFLOAT key field increment](http://blog.laoyu.site/2020/redis_command/hash/hincrbyfloat/) | 将hash中指定域的值增加给定的浮点数             | O(1)                       |\n| [HKEYS key](http://blog.laoyu.site/2020/redis_command/hash/hkeys/) | 获取hash的所有字段                             | O(N) N是Hash的长度         |\n| [HLEN key](http://blog.laoyu.site/2020/redis_command/hash/hlen/) | 获取hash里所有字段的数量                       | O(1)                       |\n| [HMGET key field [field ...]](http://blog.laoyu.site/2020/redis_command/hash/hmget/) | 获取hash里面指定字段的值                       | O(N) N是请求的字段数       |\n| [HMSET key field value [field value ...]](http://blog.laoyu.site/2020/redis_command/hash/hmset/) | 设置hash字段值                                 | O(N) N是设置的字段数       |\n| [HSET key field value](http://blog.laoyu.site/2020/redis_command/hash/hset/) | 设置hash里面一个字段的值                       | O(1)                       |\n| [HSETNX key field value](http://blog.laoyu.site/2020/redis_command/hash/hsetnx/) | 设置hash的一个字段，只有当这个字段不存在时有效 | O(1)                       |\n| [HSTRLEN key field](http://blog.laoyu.site/2020/redis_command/hash/hstrlen/) | 获取hash里面指定field的长度                    | O(1)                       |\n| [HVALS key](http://blog.laoyu.site/2020/redis_command/hash/hvals/) | 获得hash的所有值                               | O(N) N是Hash的长度         |\n| [HSCAN key cursor [MATCH pattern] [COUNT count]](http://blog.laoyu.site/2020/redis_command/hash/hscan/) | 迭代hash里面的元素                             |                            |\n\n### 三、适用场景\n\n#### 3.1 存储对象\n\n​\tRedis哈希对象常常用来缓存一些对象信息，如用户信息、商品信息、配置信息等。\n\n我们以用户信息为例,它在关系型数据库中的结构是这样的\n\n| uid  | name  | age  |\n| ---- | ----- | ---- |\n| 1    | Tom   | 15   |\n| 2    | Jerry | 13   |\n\n而使用Redis Hash存储其结构如下图:\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash%20%281%29.png)\n\n相比较于使用Redis字符串存储，其有以下几个优缺点:\n\n1. 原生字符串每个属性一个键。\n\n   ```  \n   set user:1:name Tom\n   set user:1:age 15\n   ```\n\n   优点：简单直观，每个属性都支持更新操作。\n   缺点：占用过多的键，内存占用量较大，同时用户信息内聚性比较差，所以此种方案一般不会在生产环境使用。\n   \n2. 序列化字符串后，将用户信息序列化后用一个键保存\n\n   ```\n   set user:1 serialize(userInfo)\n   ```\n   \n   优点：简化编程，如果合理的使用序列化可以提高内存的使用效率。\n   缺点：序列化和反序列化有一定的开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到Redis中。\n   \n3. 哈希类型：每个用户属性使用一对field-value，但是只用一个键保存。\n\n\t```\n\thmset user:1 name Tom age 15 \n\t```\n\n   优点：简单直观，如果使用合理可以减少内存空间的使用。\n   缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。\n\n此外，我们曾经在做配置中心系统的时候，使用Hash来缓存每个应用的配置信息,其在数据库中的数据结构大致如下表\n\n| AppId | SettingKey | SettingValue |\n| ----- | ---------- | ------------ |\n| 10001 | AppName    | myblog       |\n| 10001 | Version    | 1.0          |\n| 10002 | AppName    | admin site   |\n\n在使用Redis Hash进行存储的时候\n\n新增或更新一个配置项\n\n```c\n127.0.0.1:6379> HSET 10001 AppName myblog\n(integer) 1\n```\n\n获取一个配置项\n\n```c\n127.0.0.1:6379> HGET 10001 AppName \n\"myblog\"\n```\n\n删除一个配置项\n\n```c\n127.0.0.1:6379> HDEL 10001 AppName\n(integer) 1\n```\n\n#### 3.2 购物车\n\n&nbsp;&nbsp;&nbsp;&nbsp;很多电商网站都会使用 cookie实现购物车，也就是将整个购物车都存储到 cookie里面。这种做法的一大**优点:**无须对数据库进行写入就可以实现购物车功能,这种方式大大提高了购物车的性能，而**缺点**则是程序需要重新解析和验证( validate) cookie,确保cookie的格式正确,并且包含的商品都是真正可购买的商品。cookie购物车还有一个**缺点**:因为浏览器每次发送请求都会连 cookie一起发送,所以如果购物车cookie的体积比较大,那么请求发送和处理的速度可能会有所降低。\n\n&nbsp;&nbsp;&nbsp;&nbsp;购物车的定义非常简单:我们以每个用户的用户ID(或者CookieId)作为Redis的Key,每个用户的购物车都是一个哈希表,这个哈希表存储了商品ID与商品订购数量之间的映射。在商品的订购数量出现变化时,我们操作Redis哈希对购物车进行更新:\n\n如果用户订购某件商品的数量大于0,那么程序会将这件商品的ID以及用户订购该商品的数量添加到散列里面。\n\n```c\n//用户1 商品1 数量1\n127.0.0.1:6379> HSET uid:1 pid:1 1\n(integer) 1 //返回值0代表改field在哈希表中不存在，为新增的field\n```\n\n如果用户购买的商品已经存在于散列里面,那么新的订购数量会覆盖已有的订购数量;\n\n```c\n//用户1 商品1 数量5\n127.0.0.1:6379> HSET uid:1 pid:1 5\n(integer) 0 //返回值0代表改field在哈希表中已经存在\n```\n\n相反地,如果用户订购某件商品的数量不大于0,那么程序将从散列里面移除该条目。\n\n```c#\n//用户1 商品1\n127.0.0.1:6379> HDEL uid:1 pid:2\n(integer) 1\n```\n\n#### 3.3 计数器\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis 哈希表作为计数器的使用也非常广泛。它常常被用在记录网站每一天、一月、一年的访问数量。每一次访问，我们在对应的field上自增1\n\n```c\n//记录我的\n127.0.0.1:6379> HINCRBY MyBlog  202001 1\n(integer) 1\n127.0.0.1:6379> HINCRBY MyBlog  202001 1\n(integer) 2\n127.0.0.1:6379> HINCRBY MyBlog  202002 1\n(integer) 1\n127.0.0.1:6379> HINCRBY MyBlog  202002 1\n(integer) 2\n```\n\n也经常被用在记录商品的好评数量，差评数量上\n\n```c#\n127.0.0.1:6379> HINCRBY pid:1  Good 1\n(integer) 1\n127.0.0.1:6379> HINCRBY pid:1  Good 1\n(integer) 2\n127.0.0.1:6379> HINCRBY pid:1  bad  1\n(integer) 1\n```\n\n也可以实时记录当天的在线的人数。\n\n```c#\n//有人登陆\n127.0.0.1:6379> HINCRBY MySite  20200310 1\n(integer) 1\n//有人登陆\n127.0.0.1:6379> HINCRBY MySite  20200310 1\n(integer) 2\n//有人登出\n127.0.0.1:6379> HINCRBY MySite  20200310 -1\n(integer) 1\n```\n\n### 小结\n\n本篇文章我们总结了Redis 哈希对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis哈希对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！\n\n\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","slug":"技术实践/redis/Redis对象——哈希(Hash)","published":1,"updated":"2021-03-14T03:04:50.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzj00drhyjf4wiyhwvw","content":"<p>哈希在很多编程语言中都有着很广泛的应用，而在Redis中也是如此，在redis中，哈希类型是指Redis键值对中的值本身又是一个键值对结构，形如<code>value=[{field1，value1}，...{fieldN，valueN}]</code><a id=\"more\"></a>，其与Redis字符串对象的区别如下图所示:</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash.png\" alt=\"Redis-Hash\"></p>\n<h3 id=\"一、内部编码\"><a href=\"#一、内部编码\" class=\"headerlink\" title=\"一、内部编码\"></a>一、内部编码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;哈希类型的内部编码有两种：<a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">ziplist(压缩列表)</a>,<a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/\">hashtable(哈希表)</a>。只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：</p>\n<ul>\n<li>当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）  </li>\n<li><p>所有值都小于hash-max-ziplist-value配置（默认64字节）<br><code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比<code>hashtable</code>更加优秀。当哈希类型无法满足<code>ziplist</code>的条件时，Redis会使用<code>hashtable</code>作为哈希的内部实现，因为此时<code>ziplist</code>的读写效率会下降，而<code>hashtable</code>的读写时间复杂度为O（1）。<br>有关ziplist和hashtable这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。</p>\n<p><a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">Redis数据结构——压缩列表</a></p>\n<p><a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/\">Redis数据结构——字典</a>。</p>\n</li>\n</ul>\n<h3 id=\"二、常用命令\"><a href=\"#二、常用命令\" class=\"headerlink\" title=\"二、常用命令\"></a>二、常用命令</h3><p>Redis哈希对象常用命令如下表(点击命令可查看命令详细说明)。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hdel/\">HDEL key field [field …]</a></td>\n<td>删除一个或多个Hash的field</td>\n<td>O(N) N是被删除的字段数量。</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hexists/\">HEXISTS key field</a></td>\n<td>判断field是否存在于hash中</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hget/\">HGET key field</a></td>\n<td>获取hash中field的值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hgetall/\">HGETALL key</a></td>\n<td>从hash中读取全部的域和值</td>\n<td>O(N) N是Hash的长度</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hincrby/\">HINCRBY key field increment</a></td>\n<td>将hash中指定域的值增加给定的数字</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hincrbyfloat/\">HINCRBYFLOAT key field increment</a></td>\n<td>将hash中指定域的值增加给定的浮点数</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hkeys/\">HKEYS key</a></td>\n<td>获取hash的所有字段</td>\n<td>O(N) N是Hash的长度</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hlen/\">HLEN key</a></td>\n<td>获取hash里所有字段的数量</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hmget/\">HMGET key field [field …]</a></td>\n<td>获取hash里面指定字段的值</td>\n<td>O(N) N是请求的字段数</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hmset/\">HMSET key field value [field value …]</a></td>\n<td>设置hash字段值</td>\n<td>O(N) N是设置的字段数</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hset/\">HSET key field value</a></td>\n<td>设置hash里面一个字段的值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hsetnx/\">HSETNX key field value</a></td>\n<td>设置hash的一个字段，只有当这个字段不存在时有效</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hstrlen/\">HSTRLEN key field</a></td>\n<td>获取hash里面指定field的长度</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hvals/\">HVALS key</a></td>\n<td>获得hash的所有值</td>\n<td>O(N) N是Hash的长度</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hscan/\">HSCAN key cursor [MATCH pattern] [COUNT count]</a></td>\n<td>迭代hash里面的元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"三、适用场景\"><a href=\"#三、适用场景\" class=\"headerlink\" title=\"三、适用场景\"></a>三、适用场景</h3><h4 id=\"3-1-存储对象\"><a href=\"#3-1-存储对象\" class=\"headerlink\" title=\"3.1 存储对象\"></a>3.1 存储对象</h4><p>​    Redis哈希对象常常用来缓存一些对象信息，如用户信息、商品信息、配置信息等。</p>\n<p>我们以用户信息为例,它在关系型数据库中的结构是这样的</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>name</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Tom</td>\n<td>15</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Jerry</td>\n<td>13</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>而使用Redis Hash存储其结构如下图:</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash%20%281%29.png\" alt></p>\n<p>相比较于使用Redis字符串存储，其有以下几个优缺点:</p>\n<ol>\n<li><p>原生字符串每个属性一个键。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set user:1:name Tom</span><br><span class=\"line\">set user:1:age 15</span><br></pre></td></tr></table></figure>\n<p>优点：简单直观，每个属性都支持更新操作。<br>缺点：占用过多的键，内存占用量较大，同时用户信息内聚性比较差，所以此种方案一般不会在生产环境使用。</p>\n</li>\n<li><p>序列化字符串后，将用户信息序列化后用一个键保存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set user:1 serialize(userInfo)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>   优点：简化编程，如果合理的使用序列化可以提高内存的使用效率。<br>   缺点：序列化和反序列化有一定的开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到Redis中。</p>\n<ol>\n<li><p>哈希类型：每个用户属性使用一对field-value，但是只用一个键保存。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hmset user:1 name Tom age 15</span><br></pre></td></tr></table></figure>\n<p>优点：简单直观，如果使用合理可以减少内存空间的使用。<br>缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</p>\n</li>\n</ol>\n<p>此外，我们曾经在做配置中心系统的时候，使用Hash来缓存每个应用的配置信息,其在数据库中的数据结构大致如下表</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>AppId</th>\n<th>SettingKey</th>\n<th>SettingValue</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>10001</td>\n<td>AppName</td>\n<td>myblog</td>\n</tr>\n<tr>\n<td>10001</td>\n<td>Version</td>\n<td>1.0</td>\n</tr>\n<tr>\n<td>10002</td>\n<td>AppName</td>\n<td>admin site</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>在使用Redis Hash进行存储的时候</p>\n<p>新增或更新一个配置项</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HSET <span class=\"number\">10001</span> AppName myblog</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>获取一个配置项</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HGET <span class=\"number\">10001</span> AppName </span><br><span class=\"line\"><span class=\"string\">\"myblog\"</span></span><br></pre></td></tr></table></figure>\n<p>删除一个配置项</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HDEL <span class=\"number\">10001</span> AppName</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-购物车\"><a href=\"#3-2-购物车\" class=\"headerlink\" title=\"3.2 购物车\"></a>3.2 购物车</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;很多电商网站都会使用 cookie实现购物车，也就是将整个购物车都存储到 cookie里面。这种做法的一大<strong>优点:</strong>无须对数据库进行写入就可以实现购物车功能,这种方式大大提高了购物车的性能，而<strong>缺点</strong>则是程序需要重新解析和验证( validate) cookie,确保cookie的格式正确,并且包含的商品都是真正可购买的商品。cookie购物车还有一个<strong>缺点</strong>:因为浏览器每次发送请求都会连 cookie一起发送,所以如果购物车cookie的体积比较大,那么请求发送和处理的速度可能会有所降低。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;购物车的定义非常简单:我们以每个用户的用户ID(或者CookieId)作为Redis的Key,每个用户的购物车都是一个哈希表,这个哈希表存储了商品ID与商品订购数量之间的映射。在商品的订购数量出现变化时,我们操作Redis哈希对购物车进行更新:</p>\n<p>如果用户订购某件商品的数量大于0,那么程序会将这件商品的ID以及用户订购该商品的数量添加到散列里面。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用户1 商品1 数量1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HSET uid:<span class=\"number\">1</span> pid:<span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span> <span class=\"comment\">//返回值0代表改field在哈希表中不存在，为新增的field</span></span><br></pre></td></tr></table></figure>\n<p>如果用户购买的商品已经存在于散列里面,那么新的订购数量会覆盖已有的订购数量;</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用户1 商品1 数量5</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HSET uid:<span class=\"number\">1</span> pid:<span class=\"number\">1</span> <span class=\"number\">5</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span> <span class=\"comment\">//返回值0代表改field在哈希表中已经存在</span></span><br></pre></td></tr></table></figure>\n<p>相反地,如果用户订购某件商品的数量不大于0,那么程序将从散列里面移除该条目。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用户1 商品1</span><br><span class=\"line\">127.0.0.1:6379&gt; HDEL uid:1 pid:2</span><br><span class=\"line\">(integer) 1</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-计数器\"><a href=\"#3-3-计数器\" class=\"headerlink\" title=\"3.3 计数器\"></a>3.3 计数器</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis 哈希表作为计数器的使用也非常广泛。它常常被用在记录网站每一天、一月、一年的访问数量。每一次访问，我们在对应的field上自增1</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//记录我的</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HINCRBY MyBlog  <span class=\"number\">202001</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HINCRBY MyBlog  <span class=\"number\">202001</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HINCRBY MyBlog  <span class=\"number\">202002</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HINCRBY MyBlog  <span class=\"number\">202002</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>也经常被用在记录商品的好评数量，差评数量上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HINCRBY pid:1  Good 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY pid:1  Good 1</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY pid:1  bad  1</span><br><span class=\"line\">(integer) 1</span><br></pre></td></tr></table></figure>\n<p>也可以实时记录当天的在线的人数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//有人登陆</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY MySite  20200310 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">//有人登陆</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY MySite  20200310 1</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">//有人登出</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY MySite  20200310 -1</span><br><span class=\"line\">(integer) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本篇文章我们总结了Redis 哈希对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis哈希对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>","site":{"data":{}},"excerpt":"<p>哈希在很多编程语言中都有着很广泛的应用，而在Redis中也是如此，在redis中，哈希类型是指Redis键值对中的值本身又是一个键值对结构，形如<code>value=[{field1，value1}，...{fieldN，valueN}]</code>","more":"，其与Redis字符串对象的区别如下图所示:</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash.png\" alt=\"Redis-Hash\"></p>\n<h3 id=\"一、内部编码\"><a href=\"#一、内部编码\" class=\"headerlink\" title=\"一、内部编码\"></a>一、内部编码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;哈希类型的内部编码有两种：<a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">ziplist(压缩列表)</a>,<a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/\">hashtable(哈希表)</a>。只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：</p>\n<ul>\n<li>当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）  </li>\n<li><p>所有值都小于hash-max-ziplist-value配置（默认64字节）<br><code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比<code>hashtable</code>更加优秀。当哈希类型无法满足<code>ziplist</code>的条件时，Redis会使用<code>hashtable</code>作为哈希的内部实现，因为此时<code>ziplist</code>的读写效率会下降，而<code>hashtable</code>的读写时间复杂度为O（1）。<br>有关ziplist和hashtable这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。</p>\n<p><a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">Redis数据结构——压缩列表</a></p>\n<p><a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/\">Redis数据结构——字典</a>。</p>\n</li>\n</ul>\n<h3 id=\"二、常用命令\"><a href=\"#二、常用命令\" class=\"headerlink\" title=\"二、常用命令\"></a>二、常用命令</h3><p>Redis哈希对象常用命令如下表(点击命令可查看命令详细说明)。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hdel/\">HDEL key field [field …]</a></td>\n<td>删除一个或多个Hash的field</td>\n<td>O(N) N是被删除的字段数量。</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hexists/\">HEXISTS key field</a></td>\n<td>判断field是否存在于hash中</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hget/\">HGET key field</a></td>\n<td>获取hash中field的值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hgetall/\">HGETALL key</a></td>\n<td>从hash中读取全部的域和值</td>\n<td>O(N) N是Hash的长度</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hincrby/\">HINCRBY key field increment</a></td>\n<td>将hash中指定域的值增加给定的数字</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hincrbyfloat/\">HINCRBYFLOAT key field increment</a></td>\n<td>将hash中指定域的值增加给定的浮点数</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hkeys/\">HKEYS key</a></td>\n<td>获取hash的所有字段</td>\n<td>O(N) N是Hash的长度</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hlen/\">HLEN key</a></td>\n<td>获取hash里所有字段的数量</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hmget/\">HMGET key field [field …]</a></td>\n<td>获取hash里面指定字段的值</td>\n<td>O(N) N是请求的字段数</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hmset/\">HMSET key field value [field value …]</a></td>\n<td>设置hash字段值</td>\n<td>O(N) N是设置的字段数</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hset/\">HSET key field value</a></td>\n<td>设置hash里面一个字段的值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hsetnx/\">HSETNX key field value</a></td>\n<td>设置hash的一个字段，只有当这个字段不存在时有效</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hstrlen/\">HSTRLEN key field</a></td>\n<td>获取hash里面指定field的长度</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hvals/\">HVALS key</a></td>\n<td>获得hash的所有值</td>\n<td>O(N) N是Hash的长度</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/hash/hscan/\">HSCAN key cursor [MATCH pattern] [COUNT count]</a></td>\n<td>迭代hash里面的元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"三、适用场景\"><a href=\"#三、适用场景\" class=\"headerlink\" title=\"三、适用场景\"></a>三、适用场景</h3><h4 id=\"3-1-存储对象\"><a href=\"#3-1-存储对象\" class=\"headerlink\" title=\"3.1 存储对象\"></a>3.1 存储对象</h4><p>​    Redis哈希对象常常用来缓存一些对象信息，如用户信息、商品信息、配置信息等。</p>\n<p>我们以用户信息为例,它在关系型数据库中的结构是这样的</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>uid</th>\n<th>name</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Tom</td>\n<td>15</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Jerry</td>\n<td>13</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>而使用Redis Hash存储其结构如下图:</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash%20%281%29.png\" alt></p>\n<p>相比较于使用Redis字符串存储，其有以下几个优缺点:</p>\n<ol>\n<li><p>原生字符串每个属性一个键。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set user:1:name Tom</span><br><span class=\"line\">set user:1:age 15</span><br></pre></td></tr></table></figure>\n<p>优点：简单直观，每个属性都支持更新操作。<br>缺点：占用过多的键，内存占用量较大，同时用户信息内聚性比较差，所以此种方案一般不会在生产环境使用。</p>\n</li>\n<li><p>序列化字符串后，将用户信息序列化后用一个键保存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set user:1 serialize(userInfo)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>   优点：简化编程，如果合理的使用序列化可以提高内存的使用效率。<br>   缺点：序列化和反序列化有一定的开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到Redis中。</p>\n<ol>\n<li><p>哈希类型：每个用户属性使用一对field-value，但是只用一个键保存。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hmset user:1 name Tom age 15</span><br></pre></td></tr></table></figure>\n<p>优点：简单直观，如果使用合理可以减少内存空间的使用。<br>缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</p>\n</li>\n</ol>\n<p>此外，我们曾经在做配置中心系统的时候，使用Hash来缓存每个应用的配置信息,其在数据库中的数据结构大致如下表</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>AppId</th>\n<th>SettingKey</th>\n<th>SettingValue</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>10001</td>\n<td>AppName</td>\n<td>myblog</td>\n</tr>\n<tr>\n<td>10001</td>\n<td>Version</td>\n<td>1.0</td>\n</tr>\n<tr>\n<td>10002</td>\n<td>AppName</td>\n<td>admin site</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>在使用Redis Hash进行存储的时候</p>\n<p>新增或更新一个配置项</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HSET <span class=\"number\">10001</span> AppName myblog</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>获取一个配置项</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HGET <span class=\"number\">10001</span> AppName </span><br><span class=\"line\"><span class=\"string\">\"myblog\"</span></span><br></pre></td></tr></table></figure>\n<p>删除一个配置项</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HDEL <span class=\"number\">10001</span> AppName</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-购物车\"><a href=\"#3-2-购物车\" class=\"headerlink\" title=\"3.2 购物车\"></a>3.2 购物车</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;很多电商网站都会使用 cookie实现购物车，也就是将整个购物车都存储到 cookie里面。这种做法的一大<strong>优点:</strong>无须对数据库进行写入就可以实现购物车功能,这种方式大大提高了购物车的性能，而<strong>缺点</strong>则是程序需要重新解析和验证( validate) cookie,确保cookie的格式正确,并且包含的商品都是真正可购买的商品。cookie购物车还有一个<strong>缺点</strong>:因为浏览器每次发送请求都会连 cookie一起发送,所以如果购物车cookie的体积比较大,那么请求发送和处理的速度可能会有所降低。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;购物车的定义非常简单:我们以每个用户的用户ID(或者CookieId)作为Redis的Key,每个用户的购物车都是一个哈希表,这个哈希表存储了商品ID与商品订购数量之间的映射。在商品的订购数量出现变化时,我们操作Redis哈希对购物车进行更新:</p>\n<p>如果用户订购某件商品的数量大于0,那么程序会将这件商品的ID以及用户订购该商品的数量添加到散列里面。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用户1 商品1 数量1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HSET uid:<span class=\"number\">1</span> pid:<span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span> <span class=\"comment\">//返回值0代表改field在哈希表中不存在，为新增的field</span></span><br></pre></td></tr></table></figure>\n<p>如果用户购买的商品已经存在于散列里面,那么新的订购数量会覆盖已有的订购数量;</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用户1 商品1 数量5</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HSET uid:<span class=\"number\">1</span> pid:<span class=\"number\">1</span> <span class=\"number\">5</span></span><br><span class=\"line\">(integer) <span class=\"number\">0</span> <span class=\"comment\">//返回值0代表改field在哈希表中已经存在</span></span><br></pre></td></tr></table></figure>\n<p>相反地,如果用户订购某件商品的数量不大于0,那么程序将从散列里面移除该条目。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用户1 商品1</span><br><span class=\"line\">127.0.0.1:6379&gt; HDEL uid:1 pid:2</span><br><span class=\"line\">(integer) 1</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-3-计数器\"><a href=\"#3-3-计数器\" class=\"headerlink\" title=\"3.3 计数器\"></a>3.3 计数器</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis 哈希表作为计数器的使用也非常广泛。它常常被用在记录网站每一天、一月、一年的访问数量。每一次访问，我们在对应的field上自增1</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//记录我的</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HINCRBY MyBlog  <span class=\"number\">202001</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HINCRBY MyBlog  <span class=\"number\">202001</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HINCRBY MyBlog  <span class=\"number\">202002</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; HINCRBY MyBlog  <span class=\"number\">202002</span> <span class=\"number\">1</span></span><br><span class=\"line\">(integer) <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>也经常被用在记录商品的好评数量，差评数量上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; HINCRBY pid:1  Good 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY pid:1  Good 1</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY pid:1  bad  1</span><br><span class=\"line\">(integer) 1</span><br></pre></td></tr></table></figure>\n<p>也可以实时记录当天的在线的人数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//有人登陆</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY MySite  20200310 1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">//有人登陆</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY MySite  20200310 1</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">//有人登出</span><br><span class=\"line\">127.0.0.1:6379&gt; HINCRBY MySite  20200310 -1</span><br><span class=\"line\">(integer) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本篇文章我们总结了Redis 哈希对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis哈希对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>"},{"title":"Redis对象——有序集合(ZSet)","copyright":true,"date":"2020-03-30T02:45:38.000Z","keywords":"Redis,ZSet,Redis有序集合","aside":"redis","_content":"\n有序集合类型 (Sorted Set或ZSet) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。\n\n<!--more-->\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88.png)\n\n### 一、内部实现\n\n有序集合是由 [ziplist (压缩列表)](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/) 或 [skiplist (跳跃表)](https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/) 组成的。\n\n当数据比较少时，有序集合使用的是 ziplist 存储的，有序集合使用 ziplist 格式存储必须满足以下两个条件：\n\n- 有序集合保存的元素个数要小于 128 个；\n- 有序集合保存的所有元素成员的长度都必须小于 64 字节。\n\n如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。\n\n有关ziplist 和skiplist 这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。\n\n[Redis数据结构——压缩列表](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/)\n\n[Redis数据结构——跳跃表](https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/)。\n\n### 二、常用命令\n\nRedis列表对象常用命令如下表(点击命令可查看命令详细说明)。\n\n| 命令 | 说明 | 时间复杂度 |\n| ---- | ---- | ---------- |\n| [BZPOPMAX key [key ...] timeout](https://blog.laoyu.site/2020/redis_command/sorted_set/bzpopmax/) | 从一个或多个排序集中删除并返回得分最高的成员，或阻塞，直到其中一个可用为止 | O(log(N)) |\n| [BZPOPMIN key [key ...] timeout](https://blog.laoyu.site/2020/redis_command/sorted_set/bzpopmin/) | 从一个或多个排序集中删除并返回得分最低的成员，或阻塞，直到其中一个可用为止 | O(log(N)) |\n| [ZADD key [NXXX] [CH] [INCR] score member [score member ...]](http://blog.laoyu.site/2020/redis_command/sorted_set/zadd/) |添加到有序set的一个或多个成员，或更新的分数，如果它已经存在 | O(log(N)) |\n| [ZCARD key](http://blog.laoyu.site/2020/redis_command/sorted_set/zcard/) | 获取一个排序的集合中的成员数量   | O(1)         |\n| [ZCOUNT key min max](http://blog.laoyu.site/2020/redis_command/sorted_set/zcount/) | 返回分数范围内的成员数量   | O(log(N))         |\n| [ZINCRBY key increment member](http://blog.laoyu.site/2020/redis_command/sorted_set/zincrby/) | 增量的一名成员在排序设置的评分   | O(log(N))         |\n| [ZINTERSTORE](http://blog.laoyu.site/2020/redis_command/sorted_set/zinterstore/) |相交多个排序集，导致排序的设置存储在一个新的关键|O(N*K)+O(M*log(M)) |\n| [ZLEXCOUNT key min max](http://blog.laoyu.site/2020/redis_command/sorted_set/zlexcount/) | 返回成员之间的成员数量   | O(log(N))         |\n| [ZPOPMAX key [count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zpopmax/) | 删除并返回排序集中得分最高的成员 | O(log(N)*M)         |\n| [ZPOPMIN key [count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zpopmin/) | 删除并返回排序集中得分最低的成员 | O(log(N)*M)         |\n| [ZRANGE key start stop [WITHSCORES]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrange/) | 根据指定的index返回，返回sorted set的成员列表   | O(log(N)+M)         |\n| [ZRANGEBYLEX key min max [LIMIT offset count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrangebylex/) | 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。   | O(log(N)+M)         |\n| [ZREVRANGEBYLEX key max min [LIMIT offset count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebylex/) | 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同   | O(log(N)+M)         |\n| [ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrangebyscore/) | 返回有序集合中指定分数区间内的成员，分数由低到高排序。   | O(log(N)+M)         |\n| [ZRANK key member](http://blog.laoyu.site/2020/redis_command/sorted_set/zrank/) | 确定在排序集合成员的索引   | O(log(N))         |\n| [ZREM key member [member ...]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrem/) | 从排序的集合中删除一个或多个成员   | O(M*log(N))         |\n| [ZREMRANGEBYLEX key min max](http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebylex/) | 删除名称按字典由低到高排序成员之间所有成员。   | O(log(N)+M)         |\n| [ZREMRANGEBYRANK key start stop](http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebyrank/) | 在排序设置的所有成员在给定的索引中删除   | O(log(N)+M)         |\n| [ZREMRANGEBYSCORE key min max](http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebyscore/) | 删除一个排序的设置在给定的分数所有成员   | O(log(N)+M)         |\n| [ZREVRANGE key start stop [WITHSCORES]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrange/) | 在排序的设置返回的成员范围，通过索引，下令从分数高到低   | O(log(N)+M)         |\n| [ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebyscore/) | 返回有序集合中指定分数区间内的成员，分数由高到低排序。   | O(log(N)+M)         |\n| [ZREVRANK key member](http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrank/) | 确定指数在排序集的成员，下令从分数高到低   | O(log(N))         |\n| [ZSCORE key member](http://blog.laoyu.site/2020/redis_command/sorted_set/zscore/) | 获取成员在排序设置相关的比分   | O(1)         |\n| [ZUNIONSTORE](http://blog.laoyu.site/2020/redis_command/sorted_set/zunionstore/) |添加多个排序集和导致排序的设置存储在一个新的关键|O(N)+O(M log(M)) |\n| [ZSCAN key cursor [MATCH pattern] [COUNT count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zscan/) | 迭代sorted sets里面的元素   | O(1)         |\n\n### 三、使用场景\n\n#### 3.1 排行榜系统\n\n有序集合比较典型的使用场景就是排行榜系统。例如学生成绩的排名。某视频(博客等)网站的用户点赞、播放排名、电商系统中商品的销量排名等。我们以博客点赞为例。\n\n1. 添加用户赞数\n\n例如小编Tom发表了一篇博文，并且获得了10个赞。\n\n```c\nzadd user:ranking arcticle1 10\n```\n\n2. 取消用户赞数\n\n这个时候有一个读者又觉得Tom写的不好，又取消了赞，此时需要将文章的赞数从榜单中减去1，可以使用zincrby。\n\n```c\nzincrby user:ranking arcticle1 -1\n```\n\n3. 查看某篇文章的赞数\n\n```c\nZSCORE user:ranking arcticle1\n```\n\n4. 展示获取赞数最多的十篇文章\n\n此功能使用zrevrange命令实现：\n\n```c\nzrevrangebyrank user:ranking  0 9\n```\n\n#### 3.2 电话号码(姓名)排序\n\n使用有序集合的[ZRANGEBYLEX(点击可查看该命令详细说明)](https://blog.laoyu.site/2020/redis_command/sorted_set/zrangebylex/)或[ZREVRANGEBYLEX](https://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebylex/)可以帮助我们实现电话号码或姓名的排序,我们以ZRANGEBYLEX为例\n**注意：不要在分数不一致的SortSet集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令,因为获取的结果会不准确。**\n\n1. 电话号码排序\n\n我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:\n\n```c\nredis> zadd phone 0 13100111100 0 13110114300 0 13132110901 \n(integer) 3\nredis> zadd phone 0 13200111100 0 13210414300 0 13252110901 \n(integer) 3\nredis> zadd phone 0 13300111100 0 13310414300 0 13352110901 \n(integer) 3\n```\n\n获取所有号码:\n\n```c\nredis> ZRANGEBYLEX phone - +\n1) \"13100111100\"\n2) \"13110114300\"\n3) \"13132110901\"\n4) \"13200111100\"\n5) \"13210414300\"\n6) \"13252110901\"\n7) \"13300111100\"\n8) \"13310414300\"\n9) \"13352110901\"\n```\n\n获取132号段:\n\n```c\nredis> ZRANGEBYLEX phone [132 (133\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n```\n\n获取132、133号段:\n\n```c\nredis> ZRANGEBYLEX phone [132 (134\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n4) \"13300111100\"\n5) \"13310414300\"\n6) \"13352110901\"\n```\n\n2. 姓名排序\n\n将名称存储到SortSet中:\n\n```c\nredis> zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua \n(integer) 6\n```\n\n获取所有人的名字:\n\n```c\nredis> ZRANGEBYLEX names - +\n1) \"Aidehua\"\n2) \"Aimini\"\n3) \"Bluetuo\"\n4) \"Gaodeng\"\n5) \"Jake\"\n6) \"Toumas\"\n```\n\n获取名字中大写字母A开头的所有人:\n\n```c\nredis> ZRANGEBYLEX names [A (B\n1) \"Aidehua\"\n2) \"Aimini\"\n```\n\n获取名字中大写字母C到Z的所有人:\n\n```c\nredis> ZRANGEBYLEX names [C [Z\n1) \"Gaodeng\"\n2) \"Jake\"\n3) \"Toumas\"\n```\n\n### 小结\n\n本篇文章我们总结了Redis 有序集合对象的内部实现、常用命令以及常用的一些场景，有序集合提供了获取指定分数和元素范围查询、计算成员排名等功能，合理的利用有序集合，能帮助我们在实际开发中解决很多问题。那么大家在项目中对Redis有序集合对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","source":"_posts/技术实践/redis/Redis对象——有序集合(ZSet).md","raw":"---\ntitle: Redis对象——有序集合(ZSet)\ncopyright: true\ndate: 2020-03-30 10:45:38\ntags: \n- Redis\ncategories: Redis\nkeywords: Redis,ZSet,Redis有序集合\naside: redis\n---\n\n有序集合类型 (Sorted Set或ZSet) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。\n\n<!--more-->\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88.png)\n\n### 一、内部实现\n\n有序集合是由 [ziplist (压缩列表)](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/) 或 [skiplist (跳跃表)](https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/) 组成的。\n\n当数据比较少时，有序集合使用的是 ziplist 存储的，有序集合使用 ziplist 格式存储必须满足以下两个条件：\n\n- 有序集合保存的元素个数要小于 128 个；\n- 有序集合保存的所有元素成员的长度都必须小于 64 字节。\n\n如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。\n\n有关ziplist 和skiplist 这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。\n\n[Redis数据结构——压缩列表](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/)\n\n[Redis数据结构——跳跃表](https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/)。\n\n### 二、常用命令\n\nRedis列表对象常用命令如下表(点击命令可查看命令详细说明)。\n\n| 命令 | 说明 | 时间复杂度 |\n| ---- | ---- | ---------- |\n| [BZPOPMAX key [key ...] timeout](https://blog.laoyu.site/2020/redis_command/sorted_set/bzpopmax/) | 从一个或多个排序集中删除并返回得分最高的成员，或阻塞，直到其中一个可用为止 | O(log(N)) |\n| [BZPOPMIN key [key ...] timeout](https://blog.laoyu.site/2020/redis_command/sorted_set/bzpopmin/) | 从一个或多个排序集中删除并返回得分最低的成员，或阻塞，直到其中一个可用为止 | O(log(N)) |\n| [ZADD key [NXXX] [CH] [INCR] score member [score member ...]](http://blog.laoyu.site/2020/redis_command/sorted_set/zadd/) |添加到有序set的一个或多个成员，或更新的分数，如果它已经存在 | O(log(N)) |\n| [ZCARD key](http://blog.laoyu.site/2020/redis_command/sorted_set/zcard/) | 获取一个排序的集合中的成员数量   | O(1)         |\n| [ZCOUNT key min max](http://blog.laoyu.site/2020/redis_command/sorted_set/zcount/) | 返回分数范围内的成员数量   | O(log(N))         |\n| [ZINCRBY key increment member](http://blog.laoyu.site/2020/redis_command/sorted_set/zincrby/) | 增量的一名成员在排序设置的评分   | O(log(N))         |\n| [ZINTERSTORE](http://blog.laoyu.site/2020/redis_command/sorted_set/zinterstore/) |相交多个排序集，导致排序的设置存储在一个新的关键|O(N*K)+O(M*log(M)) |\n| [ZLEXCOUNT key min max](http://blog.laoyu.site/2020/redis_command/sorted_set/zlexcount/) | 返回成员之间的成员数量   | O(log(N))         |\n| [ZPOPMAX key [count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zpopmax/) | 删除并返回排序集中得分最高的成员 | O(log(N)*M)         |\n| [ZPOPMIN key [count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zpopmin/) | 删除并返回排序集中得分最低的成员 | O(log(N)*M)         |\n| [ZRANGE key start stop [WITHSCORES]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrange/) | 根据指定的index返回，返回sorted set的成员列表   | O(log(N)+M)         |\n| [ZRANGEBYLEX key min max [LIMIT offset count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrangebylex/) | 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。   | O(log(N)+M)         |\n| [ZREVRANGEBYLEX key max min [LIMIT offset count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebylex/) | 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同   | O(log(N)+M)         |\n| [ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrangebyscore/) | 返回有序集合中指定分数区间内的成员，分数由低到高排序。   | O(log(N)+M)         |\n| [ZRANK key member](http://blog.laoyu.site/2020/redis_command/sorted_set/zrank/) | 确定在排序集合成员的索引   | O(log(N))         |\n| [ZREM key member [member ...]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrem/) | 从排序的集合中删除一个或多个成员   | O(M*log(N))         |\n| [ZREMRANGEBYLEX key min max](http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebylex/) | 删除名称按字典由低到高排序成员之间所有成员。   | O(log(N)+M)         |\n| [ZREMRANGEBYRANK key start stop](http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebyrank/) | 在排序设置的所有成员在给定的索引中删除   | O(log(N)+M)         |\n| [ZREMRANGEBYSCORE key min max](http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebyscore/) | 删除一个排序的设置在给定的分数所有成员   | O(log(N)+M)         |\n| [ZREVRANGE key start stop [WITHSCORES]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrange/) | 在排序的设置返回的成员范围，通过索引，下令从分数高到低   | O(log(N)+M)         |\n| [ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebyscore/) | 返回有序集合中指定分数区间内的成员，分数由高到低排序。   | O(log(N)+M)         |\n| [ZREVRANK key member](http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrank/) | 确定指数在排序集的成员，下令从分数高到低   | O(log(N))         |\n| [ZSCORE key member](http://blog.laoyu.site/2020/redis_command/sorted_set/zscore/) | 获取成员在排序设置相关的比分   | O(1)         |\n| [ZUNIONSTORE](http://blog.laoyu.site/2020/redis_command/sorted_set/zunionstore/) |添加多个排序集和导致排序的设置存储在一个新的关键|O(N)+O(M log(M)) |\n| [ZSCAN key cursor [MATCH pattern] [COUNT count]](http://blog.laoyu.site/2020/redis_command/sorted_set/zscan/) | 迭代sorted sets里面的元素   | O(1)         |\n\n### 三、使用场景\n\n#### 3.1 排行榜系统\n\n有序集合比较典型的使用场景就是排行榜系统。例如学生成绩的排名。某视频(博客等)网站的用户点赞、播放排名、电商系统中商品的销量排名等。我们以博客点赞为例。\n\n1. 添加用户赞数\n\n例如小编Tom发表了一篇博文，并且获得了10个赞。\n\n```c\nzadd user:ranking arcticle1 10\n```\n\n2. 取消用户赞数\n\n这个时候有一个读者又觉得Tom写的不好，又取消了赞，此时需要将文章的赞数从榜单中减去1，可以使用zincrby。\n\n```c\nzincrby user:ranking arcticle1 -1\n```\n\n3. 查看某篇文章的赞数\n\n```c\nZSCORE user:ranking arcticle1\n```\n\n4. 展示获取赞数最多的十篇文章\n\n此功能使用zrevrange命令实现：\n\n```c\nzrevrangebyrank user:ranking  0 9\n```\n\n#### 3.2 电话号码(姓名)排序\n\n使用有序集合的[ZRANGEBYLEX(点击可查看该命令详细说明)](https://blog.laoyu.site/2020/redis_command/sorted_set/zrangebylex/)或[ZREVRANGEBYLEX](https://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebylex/)可以帮助我们实现电话号码或姓名的排序,我们以ZRANGEBYLEX为例\n**注意：不要在分数不一致的SortSet集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令,因为获取的结果会不准确。**\n\n1. 电话号码排序\n\n我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:\n\n```c\nredis> zadd phone 0 13100111100 0 13110114300 0 13132110901 \n(integer) 3\nredis> zadd phone 0 13200111100 0 13210414300 0 13252110901 \n(integer) 3\nredis> zadd phone 0 13300111100 0 13310414300 0 13352110901 \n(integer) 3\n```\n\n获取所有号码:\n\n```c\nredis> ZRANGEBYLEX phone - +\n1) \"13100111100\"\n2) \"13110114300\"\n3) \"13132110901\"\n4) \"13200111100\"\n5) \"13210414300\"\n6) \"13252110901\"\n7) \"13300111100\"\n8) \"13310414300\"\n9) \"13352110901\"\n```\n\n获取132号段:\n\n```c\nredis> ZRANGEBYLEX phone [132 (133\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n```\n\n获取132、133号段:\n\n```c\nredis> ZRANGEBYLEX phone [132 (134\n1) \"13200111100\"\n2) \"13210414300\"\n3) \"13252110901\"\n4) \"13300111100\"\n5) \"13310414300\"\n6) \"13352110901\"\n```\n\n2. 姓名排序\n\n将名称存储到SortSet中:\n\n```c\nredis> zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua \n(integer) 6\n```\n\n获取所有人的名字:\n\n```c\nredis> ZRANGEBYLEX names - +\n1) \"Aidehua\"\n2) \"Aimini\"\n3) \"Bluetuo\"\n4) \"Gaodeng\"\n5) \"Jake\"\n6) \"Toumas\"\n```\n\n获取名字中大写字母A开头的所有人:\n\n```c\nredis> ZRANGEBYLEX names [A (B\n1) \"Aidehua\"\n2) \"Aimini\"\n```\n\n获取名字中大写字母C到Z的所有人:\n\n```c\nredis> ZRANGEBYLEX names [C [Z\n1) \"Gaodeng\"\n2) \"Jake\"\n3) \"Toumas\"\n```\n\n### 小结\n\n本篇文章我们总结了Redis 有序集合对象的内部实现、常用命令以及常用的一些场景，有序集合提供了获取指定分数和元素范围查询、计算成员排名等功能，合理的利用有序集合，能帮助我们在实际开发中解决很多问题。那么大家在项目中对Redis有序集合对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","slug":"技术实践/redis/Redis对象——有序集合(ZSet)","published":1,"updated":"2021-03-14T03:04:50.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzk00duhyjf0iub5g37","content":"<p>有序集合类型 (Sorted Set或ZSet) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88.png\" alt></p>\n<h3 id=\"一、内部实现\"><a href=\"#一、内部实现\" class=\"headerlink\" title=\"一、内部实现\"></a>一、内部实现</h3><p>有序集合是由 <a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">ziplist (压缩列表)</a> 或 <a href=\"https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/\">skiplist (跳跃表)</a> 组成的。</p>\n<p>当数据比较少时，有序集合使用的是 ziplist 存储的，有序集合使用 ziplist 格式存储必须满足以下两个条件：</p>\n<ul>\n<li>有序集合保存的元素个数要小于 128 个；</li>\n<li>有序集合保存的所有元素成员的长度都必须小于 64 字节。</li>\n</ul>\n<p>如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。</p>\n<p>有关ziplist 和skiplist 这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。</p>\n<p><a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">Redis数据结构——压缩列表</a></p>\n<p><a href=\"https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/\">Redis数据结构——跳跃表</a>。</p>\n<h3 id=\"二、常用命令\"><a href=\"#二、常用命令\" class=\"headerlink\" title=\"二、常用命令\"></a>二、常用命令</h3><p>Redis列表对象常用命令如下表(点击命令可查看命令详细说明)。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://blog.laoyu.site/2020/redis_command/sorted_set/bzpopmax/\">BZPOPMAX key [key …] timeout</a></td>\n<td>从一个或多个排序集中删除并返回得分最高的成员，或阻塞，直到其中一个可用为止</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"https://blog.laoyu.site/2020/redis_command/sorted_set/bzpopmin/\">BZPOPMIN key [key …] timeout</a></td>\n<td>从一个或多个排序集中删除并返回得分最低的成员，或阻塞，直到其中一个可用为止</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zadd/\">ZADD key [NXXX] [CH] [INCR] score member [score member …]</a></td>\n<td>添加到有序set的一个或多个成员，或更新的分数，如果它已经存在</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zcard/\">ZCARD key</a></td>\n<td>获取一个排序的集合中的成员数量</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zcount/\">ZCOUNT key min max</a></td>\n<td>返回分数范围内的成员数量</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zincrby/\">ZINCRBY key increment member</a></td>\n<td>增量的一名成员在排序设置的评分</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zinterstore/\">ZINTERSTORE</a></td>\n<td>相交多个排序集，导致排序的设置存储在一个新的关键</td>\n<td>O(N<em>K)+O(M</em>log(M))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zlexcount/\">ZLEXCOUNT key min max</a></td>\n<td>返回成员之间的成员数量</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zpopmax/\">ZPOPMAX key [count]</a></td>\n<td>删除并返回排序集中得分最高的成员</td>\n<td>O(log(N)*M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zpopmin/\">ZPOPMIN key [count]</a></td>\n<td>删除并返回排序集中得分最低的成员</td>\n<td>O(log(N)*M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrange/\">ZRANGE key start stop [WITHSCORES]</a></td>\n<td>根据指定的index返回，返回sorted set的成员列表</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrangebylex/\">ZRANGEBYLEX key min max [LIMIT offset count]</a></td>\n<td>返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebylex/\">ZREVRANGEBYLEX key max min [LIMIT offset count]</a></td>\n<td>返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrangebyscore/\">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</a></td>\n<td>返回有序集合中指定分数区间内的成员，分数由低到高排序。</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrank/\">ZRANK key member</a></td>\n<td>确定在排序集合成员的索引</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrem/\">ZREM key member [member …]</a></td>\n<td>从排序的集合中删除一个或多个成员</td>\n<td>O(M*log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebylex/\">ZREMRANGEBYLEX key min max</a></td>\n<td>删除名称按字典由低到高排序成员之间所有成员。</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebyrank/\">ZREMRANGEBYRANK key start stop</a></td>\n<td>在排序设置的所有成员在给定的索引中删除</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebyscore/\">ZREMRANGEBYSCORE key min max</a></td>\n<td>删除一个排序的设置在给定的分数所有成员</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrange/\">ZREVRANGE key start stop [WITHSCORES]</a></td>\n<td>在排序的设置返回的成员范围，通过索引，下令从分数高到低</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebyscore/\">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</a></td>\n<td>返回有序集合中指定分数区间内的成员，分数由高到低排序。</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrank/\">ZREVRANK key member</a></td>\n<td>确定指数在排序集的成员，下令从分数高到低</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zscore/\">ZSCORE key member</a></td>\n<td>获取成员在排序设置相关的比分</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zunionstore/\">ZUNIONSTORE</a></td>\n<td>添加多个排序集和导致排序的设置存储在一个新的关键</td>\n<td>O(N)+O(M log(M))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zscan/\">ZSCAN key cursor [MATCH pattern] [COUNT count]</a></td>\n<td>迭代sorted sets里面的元素</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"三、使用场景\"><a href=\"#三、使用场景\" class=\"headerlink\" title=\"三、使用场景\"></a>三、使用场景</h3><h4 id=\"3-1-排行榜系统\"><a href=\"#3-1-排行榜系统\" class=\"headerlink\" title=\"3.1 排行榜系统\"></a>3.1 排行榜系统</h4><p>有序集合比较典型的使用场景就是排行榜系统。例如学生成绩的排名。某视频(博客等)网站的用户点赞、播放排名、电商系统中商品的销量排名等。我们以博客点赞为例。</p>\n<ol>\n<li>添加用户赞数</li>\n</ol>\n<p>例如小编Tom发表了一篇博文，并且获得了10个赞。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zadd user:ranking arcticle1 <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>取消用户赞数</li>\n</ol>\n<p>这个时候有一个读者又觉得Tom写的不好，又取消了赞，此时需要将文章的赞数从榜单中减去1，可以使用zincrby。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zincrby user:ranking arcticle1 <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>查看某篇文章的赞数</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZSCORE user:ranking arcticle1</span><br></pre></td></tr></table></figure>\n<ol>\n<li>展示获取赞数最多的十篇文章</li>\n</ol>\n<p>此功能使用zrevrange命令实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zrevrangebyrank user:ranking  <span class=\"number\">0</span> <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-电话号码-姓名-排序\"><a href=\"#3-2-电话号码-姓名-排序\" class=\"headerlink\" title=\"3.2 电话号码(姓名)排序\"></a>3.2 电话号码(姓名)排序</h4><p>使用有序集合的<a href=\"https://blog.laoyu.site/2020/redis_command/sorted_set/zrangebylex/\">ZRANGEBYLEX(点击可查看该命令详细说明)</a>或<a href=\"https://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebylex/\">ZREVRANGEBYLEX</a>可以帮助我们实现电话号码或姓名的排序,我们以ZRANGEBYLEX为例<br><strong>注意：不要在分数不一致的SortSet集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令,因为获取的结果会不准确。</strong></p>\n<ol>\n<li>电话号码排序</li>\n</ol>\n<p>我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13100111100</span> <span class=\"number\">0</span> <span class=\"number\">13110114300</span> <span class=\"number\">0</span> <span class=\"number\">13132110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13200111100</span> <span class=\"number\">0</span> <span class=\"number\">13210414300</span> <span class=\"number\">0</span> <span class=\"number\">13252110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13300111100</span> <span class=\"number\">0</span> <span class=\"number\">13310414300</span> <span class=\"number\">0</span> <span class=\"number\">13352110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>获取所有号码:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13100111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13110114300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13132110901\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">9</span>) <span class=\"string\">\"13352110901\"</span></span><br></pre></td></tr></table></figure>\n<p>获取132号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone [<span class=\"number\">132</span> (<span class=\"number\">133</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13252110901\"</span></span><br></pre></td></tr></table></figure>\n<p>获取132、133号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone [<span class=\"number\">132</span> (<span class=\"number\">134</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13352110901\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>姓名排序</li>\n</ol>\n<p>将名称存储到SortSet中:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd names <span class=\"number\">0</span> Toumas <span class=\"number\">0</span> Jake <span class=\"number\">0</span> Bluetuo <span class=\"number\">0</span> Gaodeng <span class=\"number\">0</span> Aimini <span class=\"number\">0</span> Aidehua </span><br><span class=\"line\">(integer) <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>获取所有人的名字:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Aidehua\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Aimini\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Bluetuo\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"Gaodeng\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"Toumas\"</span></span><br></pre></td></tr></table></figure>\n<p>获取名字中大写字母A开头的所有人:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names [A (B</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Aidehua\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Aimini\"</span></span><br></pre></td></tr></table></figure>\n<p>获取名字中大写字母C到Z的所有人:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names [C [Z</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Gaodeng\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Toumas\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本篇文章我们总结了Redis 有序集合对象的内部实现、常用命令以及常用的一些场景，有序集合提供了获取指定分数和元素范围查询、计算成员排名等功能，合理的利用有序集合，能帮助我们在实际开发中解决很多问题。那么大家在项目中对Redis有序集合对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>","site":{"data":{}},"excerpt":"<p>有序集合类型 (Sorted Set或ZSet) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。</p>","more":"<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88.png\" alt></p>\n<h3 id=\"一、内部实现\"><a href=\"#一、内部实现\" class=\"headerlink\" title=\"一、内部实现\"></a>一、内部实现</h3><p>有序集合是由 <a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">ziplist (压缩列表)</a> 或 <a href=\"https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/\">skiplist (跳跃表)</a> 组成的。</p>\n<p>当数据比较少时，有序集合使用的是 ziplist 存储的，有序集合使用 ziplist 格式存储必须满足以下两个条件：</p>\n<ul>\n<li>有序集合保存的元素个数要小于 128 个；</li>\n<li>有序集合保存的所有元素成员的长度都必须小于 64 字节。</li>\n</ul>\n<p>如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。</p>\n<p>有关ziplist 和skiplist 这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。</p>\n<p><a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">Redis数据结构——压缩列表</a></p>\n<p><a href=\"https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/\">Redis数据结构——跳跃表</a>。</p>\n<h3 id=\"二、常用命令\"><a href=\"#二、常用命令\" class=\"headerlink\" title=\"二、常用命令\"></a>二、常用命令</h3><p>Redis列表对象常用命令如下表(点击命令可查看命令详细说明)。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://blog.laoyu.site/2020/redis_command/sorted_set/bzpopmax/\">BZPOPMAX key [key …] timeout</a></td>\n<td>从一个或多个排序集中删除并返回得分最高的成员，或阻塞，直到其中一个可用为止</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"https://blog.laoyu.site/2020/redis_command/sorted_set/bzpopmin/\">BZPOPMIN key [key …] timeout</a></td>\n<td>从一个或多个排序集中删除并返回得分最低的成员，或阻塞，直到其中一个可用为止</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zadd/\">ZADD key [NXXX] [CH] [INCR] score member [score member …]</a></td>\n<td>添加到有序set的一个或多个成员，或更新的分数，如果它已经存在</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zcard/\">ZCARD key</a></td>\n<td>获取一个排序的集合中的成员数量</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zcount/\">ZCOUNT key min max</a></td>\n<td>返回分数范围内的成员数量</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zincrby/\">ZINCRBY key increment member</a></td>\n<td>增量的一名成员在排序设置的评分</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zinterstore/\">ZINTERSTORE</a></td>\n<td>相交多个排序集，导致排序的设置存储在一个新的关键</td>\n<td>O(N<em>K)+O(M</em>log(M))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zlexcount/\">ZLEXCOUNT key min max</a></td>\n<td>返回成员之间的成员数量</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zpopmax/\">ZPOPMAX key [count]</a></td>\n<td>删除并返回排序集中得分最高的成员</td>\n<td>O(log(N)*M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zpopmin/\">ZPOPMIN key [count]</a></td>\n<td>删除并返回排序集中得分最低的成员</td>\n<td>O(log(N)*M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrange/\">ZRANGE key start stop [WITHSCORES]</a></td>\n<td>根据指定的index返回，返回sorted set的成员列表</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrangebylex/\">ZRANGEBYLEX key min max [LIMIT offset count]</a></td>\n<td>返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebylex/\">ZREVRANGEBYLEX key max min [LIMIT offset count]</a></td>\n<td>返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrangebyscore/\">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</a></td>\n<td>返回有序集合中指定分数区间内的成员，分数由低到高排序。</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrank/\">ZRANK key member</a></td>\n<td>确定在排序集合成员的索引</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrem/\">ZREM key member [member …]</a></td>\n<td>从排序的集合中删除一个或多个成员</td>\n<td>O(M*log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebylex/\">ZREMRANGEBYLEX key min max</a></td>\n<td>删除名称按字典由低到高排序成员之间所有成员。</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebyrank/\">ZREMRANGEBYRANK key start stop</a></td>\n<td>在排序设置的所有成员在给定的索引中删除</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zremrangebyscore/\">ZREMRANGEBYSCORE key min max</a></td>\n<td>删除一个排序的设置在给定的分数所有成员</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrange/\">ZREVRANGE key start stop [WITHSCORES]</a></td>\n<td>在排序的设置返回的成员范围，通过索引，下令从分数高到低</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebyscore/\">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</a></td>\n<td>返回有序集合中指定分数区间内的成员，分数由高到低排序。</td>\n<td>O(log(N)+M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zrevrank/\">ZREVRANK key member</a></td>\n<td>确定指数在排序集的成员，下令从分数高到低</td>\n<td>O(log(N))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zscore/\">ZSCORE key member</a></td>\n<td>获取成员在排序设置相关的比分</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zunionstore/\">ZUNIONSTORE</a></td>\n<td>添加多个排序集和导致排序的设置存储在一个新的关键</td>\n<td>O(N)+O(M log(M))</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/sorted_set/zscan/\">ZSCAN key cursor [MATCH pattern] [COUNT count]</a></td>\n<td>迭代sorted sets里面的元素</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"三、使用场景\"><a href=\"#三、使用场景\" class=\"headerlink\" title=\"三、使用场景\"></a>三、使用场景</h3><h4 id=\"3-1-排行榜系统\"><a href=\"#3-1-排行榜系统\" class=\"headerlink\" title=\"3.1 排行榜系统\"></a>3.1 排行榜系统</h4><p>有序集合比较典型的使用场景就是排行榜系统。例如学生成绩的排名。某视频(博客等)网站的用户点赞、播放排名、电商系统中商品的销量排名等。我们以博客点赞为例。</p>\n<ol>\n<li>添加用户赞数</li>\n</ol>\n<p>例如小编Tom发表了一篇博文，并且获得了10个赞。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zadd user:ranking arcticle1 <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>取消用户赞数</li>\n</ol>\n<p>这个时候有一个读者又觉得Tom写的不好，又取消了赞，此时需要将文章的赞数从榜单中减去1，可以使用zincrby。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zincrby user:ranking arcticle1 <span class=\"number\">-1</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>查看某篇文章的赞数</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZSCORE user:ranking arcticle1</span><br></pre></td></tr></table></figure>\n<ol>\n<li>展示获取赞数最多的十篇文章</li>\n</ol>\n<p>此功能使用zrevrange命令实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zrevrangebyrank user:ranking  <span class=\"number\">0</span> <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-电话号码-姓名-排序\"><a href=\"#3-2-电话号码-姓名-排序\" class=\"headerlink\" title=\"3.2 电话号码(姓名)排序\"></a>3.2 电话号码(姓名)排序</h4><p>使用有序集合的<a href=\"https://blog.laoyu.site/2020/redis_command/sorted_set/zrangebylex/\">ZRANGEBYLEX(点击可查看该命令详细说明)</a>或<a href=\"https://blog.laoyu.site/2020/redis_command/sorted_set/zrevrangebylex/\">ZREVRANGEBYLEX</a>可以帮助我们实现电话号码或姓名的排序,我们以ZRANGEBYLEX为例<br><strong>注意：不要在分数不一致的SortSet集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令,因为获取的结果会不准确。</strong></p>\n<ol>\n<li>电话号码排序</li>\n</ol>\n<p>我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13100111100</span> <span class=\"number\">0</span> <span class=\"number\">13110114300</span> <span class=\"number\">0</span> <span class=\"number\">13132110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13200111100</span> <span class=\"number\">0</span> <span class=\"number\">13210414300</span> <span class=\"number\">0</span> <span class=\"number\">13252110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br><span class=\"line\">redis&gt; zadd phone <span class=\"number\">0</span> <span class=\"number\">13300111100</span> <span class=\"number\">0</span> <span class=\"number\">13310414300</span> <span class=\"number\">0</span> <span class=\"number\">13352110901</span> </span><br><span class=\"line\">(integer) <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>获取所有号码:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13100111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13110114300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13132110901\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">7</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">8</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">9</span>) <span class=\"string\">\"13352110901\"</span></span><br></pre></td></tr></table></figure>\n<p>获取132号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone [<span class=\"number\">132</span> (<span class=\"number\">133</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13252110901\"</span></span><br></pre></td></tr></table></figure>\n<p>获取132、133号段:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX phone [<span class=\"number\">132</span> (<span class=\"number\">134</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"13200111100\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"13210414300\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"13252110901\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"13300111100\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"13310414300\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"13352110901\"</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>姓名排序</li>\n</ol>\n<p>将名称存储到SortSet中:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; zadd names <span class=\"number\">0</span> Toumas <span class=\"number\">0</span> Jake <span class=\"number\">0</span> Bluetuo <span class=\"number\">0</span> Gaodeng <span class=\"number\">0</span> Aimini <span class=\"number\">0</span> Aidehua </span><br><span class=\"line\">(integer) <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>获取所有人的名字:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names - +</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Aidehua\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Aimini\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Bluetuo\"</span></span><br><span class=\"line\"><span class=\"number\">4</span>) <span class=\"string\">\"Gaodeng\"</span></span><br><span class=\"line\"><span class=\"number\">5</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">6</span>) <span class=\"string\">\"Toumas\"</span></span><br></pre></td></tr></table></figure>\n<p>获取名字中大写字母A开头的所有人:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names [A (B</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Aidehua\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Aimini\"</span></span><br></pre></td></tr></table></figure>\n<p>获取名字中大写字母C到Z的所有人:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; ZRANGEBYLEX names [C [Z</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Gaodeng\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Jake\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Toumas\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本篇文章我们总结了Redis 有序集合对象的内部实现、常用命令以及常用的一些场景，有序集合提供了获取指定分数和元素范围查询、计算成员排名等功能，合理的利用有序集合，能帮助我们在实际开发中解决很多问题。那么大家在项目中对Redis有序集合对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>"},{"title":"Redis持久化——AOF日志","copyright":true,"date":"2021-03-14T00:15:45.000Z","keywords":"Redis,持久化","password":"1234qwer","aside":"redis","_content":"\n上一篇文章我们总结到使用`Redis`内存快照进行持久化，在t 时刻做了一次快照，然后又在 t+n 时刻做了一次快照，此时如果宕机，则会丢失在此期间内修改的数据。但又不能频繁的进行内存快照，那么有什么办法能够尽可能的减少这种数据丢失呢？`Redis`提供了另一种持久化的方式——`AOF`日志（Append Only File）。\n\n<!--more-->\n\n### 1 什么是`AOF`日志持久化\n\n#### 1.1 执行后写日志\n\n与内存快照保存当前内存中的数据所不同，`AOF`持久化是通过保存`Redis`服务器所执行的写命令来记录数据库状态的。即每执行一个命令，就会把该命令写到日志文件里。\n\n需要注意的是写日志的操作在`Redis`执行命令将数据写入内存之后，如下图所示：\n\n![AOF-1](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/AOF-1.png)\n\n这样做的好处就是不会阻塞当前操作，也可以避免额外的检查开销，如果是在命令执行前进行写日志的操作，一旦命令语法是错误的，不进行检查的话就会导致写入到日志文件中的命令是错误的，在使用日志文件恢复数据的时候就会出错。而在命令执行后在进行日志的写入则不会有这个问题。\n\n但是也存在两个问题，\n\n1. `AOF` 虽然避免了对当前命令的阻塞，但却可能会给下一个操作带来阻塞风险。因为，`AOF` 日志是在主进程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了\n\n2. 如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 `Redis` 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 `Redis` 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。\n\n#### 1.2 `AOF` 缓冲区\n\n针对上面两个问题，`Redis`提供了缓冲区的方式进行`AOF`日志的记录，以达到尽可能的避免阻塞和数据丢失的问题。\n\n即`Redis`在执行完命令进行持久化的时候，并非直接写入磁盘日志文件，而是先写入`AOF`缓冲区内，之后再通过某种策略写到磁盘。\n\n![AOF-2](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/AOF-2.png)\n\n使用缓存区的方式进行`AOF`日志的记录，上面提到的两个问题其实就和日志从缓冲区写入磁盘的时机有关系。\n\n#### 1.3 三种回写策略\n\n`Redis AOF` 机制提供了三种回写磁盘的策略。\n\n* `Always(同步写回)`: 命令写入 `AOF`缓冲区后调用系统 `fsync`操作同步到`AOF`文件, `fsync`完成后线程返回\n* `Everysec(每秒写回)`: 命令写人 `AOF`缓冲区后调用系统 `write`操作, `write`完成后线程返回。` fsync`同步文件操作由专门线程每秒调用一次\n* `No(操作系统自动写回)`: 命令写入 `AOF`缓冲区后调用系统 `write`操作,不对`AOF`文件做 `fsync`同步,同步硬盘操作由操作系统负责,通常同步周期最长30秒\n\n但其实可以看出这三种回写策略都并不能完美的解决问题，\n\n配置为 `always`时,每次写入都要同步`AOF`文件,硬盘的写入速度无法与内存相提并论,显然与 `Redis`髙性能特性背道而驰\n\n配置为`no`,由于操作系统每次同步`AOF`文件的周期不可控,而且会加大每次同步硬盘的数据量,虽然提升了性能,但数据安全性无法保证。\n\n配置为 `everysec`,是建议的同步策略,也是默认配置,虽然能做到兼顾性能和数据安全性。但极端情况下一会造成1秒内的数据丢失。\n\n在真正使用中，我们可以根据具体对性能和数据完整性的要求，分析这三种回写策略，选择适合的策略来进行持久化。\n\n| 回写策略             | 优点                     | 缺点                  |\n| -------------------- | ------------------------ | --------------------- |\n| Always(同步写回)     | 可靠性高、数据基本不丢失 | 性能较差              |\n| Everysec(每秒写回)   | 性能适中                 | 宕机时丢失1秒内的数据 |\n| No(操作系统自动写回) | 性能好                   | 宕机时丢失数据较多    |\n\n### 2 `AOF`重写\n\n#### 2.1 日志文件越来越大怎么办\n\n选择了合适的回写策略，`AOF`这种持久化的方式还有其它问题吗？\n\n因为`AOF`持久化是通过保存被执行的写命令来记录数据库状态的,所以随着时间的流逝,`AOF`文件中的内容会越来越多,文件的体积也会越来越大,过大的`AOF`文件不仅追加命令会变慢，而且可能对`Redis`服务器、甚至整个宿主计算机造成影响,并且`AOF`文件的体积越大,使用`AOF`文件来进行数据还原所需的时间就越多。\n\n这个时候就要用到`AOF`重写机制了\n\n```c#\nredis> set testKey testValue\nOK\nredis> set testKey testValue1\nOK\nredis> del testKey\nOK\nredis> set testKey hello\nOK\nredis> set testKey world\nOK\n```\n\n`AOF` 文件是以追加的方式，逐一记录接收到的写命令的。当一个键值对被多条写命令反复修改时，`AOF` 文件会记录相应的多条命令。如上示例，我们执行完命令后，`Redis`会在AOF里面追加5条命令。但实际上只需要`set testKey world`一条命令就够了。\n\n`AOF` 重写机制就是在重写时，`Redis` 根据数据库的现状创建一个新的 `AOF` 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。比如说，当读取了键值对`“testkey”: “world”`之后，重写机制会记录 `set testkey world`这条命令。这样，当需要恢复时，可以重新执行该命令，实现`“testkey”: “world”`的写入。\n\n这样，重写后的日志，从5条变成了1条，而对于可能被修改过成百上千次的键值对来说，重写能节省的空间就更大了。\n\n虽然 `AOF `重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程。这时，我们不得不关注：重写会不会导致阻塞？这就要看看`AOF`重写的过程是怎么样的\n\n#### 2.2 `AOF` 重写过程\n\n因为`AOF`重写也是一个非常耗时的过程，又因为`Redis`单线程的特性，同内存快照一样，`AOF`重写的过程也是由父进程fork出`bgrewriteaof`子进程来完成的.\n\n使用子进程（而不是开启一个线程）进行AOF重写虽然可以避免使用锁的情况下，保证数据安全性，但是会带来子进程和父进程一致性问题。\n例如在开始重写之后父进程又接收了新的键值对此时子进程是无法知晓的，当子进程重写完成后的数据库和父进程的数据库状态是不一致的。\n\n如下表：\n\n| 时间 | 服务器进程（父进程）        | 子进程      |\n| :--- | :-------------------------- | :---------- |\n| T1   | 执行命令 SET K1 V1          |             |\n| T2   | 执行命令 SET K1 V1          |             |\n| T3   | 创建子进程，执行AOF文件重写 | 开始AOF重写 |\n| T4   | 执行命令 SET K2 V2          | 执行重写    |\n| T5   | 执行命令 SET K3 V3          | 执行重写    |\n| T6   | 执行命令 SET K4 V4          | 完成AOF重写 |\n\n在T6时刻服务器进程有了4个键，而子进程却只有1个键\n\n为了解决这种不一致性，`Redis`设置了一个`AOF`重写缓冲区。\n\n![AOF重写](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/AOF重写.png)\n\n在子进程执行`AOF`重写期间。服务器进程需要执行以下3个动作：\n\n1. 执行客户端命令\n2. 执行后追加到`AOF`缓冲区\n3. 执行后追加到`AOF`重写缓冲区\n\n子进程完成`AOF`重写后，它向父进程发送一个信号，父进程收到信号后会调用一个信号处理函数，该函数把`AOF`重写缓冲区的命令追加到新`AOF`文件中然后替换掉现有`AOF`文件。父进程处理完毕后可以继续接受客户端命令调用，可以看出在`AOF`后台重写过程中只有这个信号处理函数会阻塞服务器进程。\n下表是完整的`AOF`后台重写过程：\n\n| 时间 | 服务器进程（父进程）                                       | 子进程                        |\n| :--- | :--------------------------------------------------------- | :---------------------------- |\n| T1   | 执行命令 SET K1 V1                                         |                               |\n| T2   | 执行命令 SET K1 V1                                         |                               |\n| T3   | 创建子进程，执行AOF文件重写                                | 开始AOF重写                   |\n| T4   | 执行命令 SET K2 V2                                         | 执行重写                      |\n| T5   | 执行命令 SET K3 V3                                         | 执行重写                      |\n| T6   | 执行命令 SET K4 V4                                         | 完成AOF重写，向父进程发送信号 |\n| T7   | 接收到信号，将T5 T6 T7 服务器的写命令追加到新的AOF文件末尾 |                               |\n| T8   | 用新的AOF替换旧的AOF                                       |                               |\n\n这样就可以保证重写日志期间的所有操作也都会写入新的AOF文件。\n\n**需要注意的是， T7 T8执行的任务会阻塞服务器处理命令。**\n\n总的来说，就是每次 `AOF` 重写时，`Redis` 会先fork出一个子进程用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。\n\n### 3 `AOF`文件恢复\n\n在`Redis` 服务器重启后，会优先去载入`AOF`日志文件。因为`AOF`文件里面包含了重建数据库状态所需的所有写命令,所以服务器重新执行一遍`AOF`文件里面保存的写命令,就可以还原服务器关闭之前的数据库状态。\n\n而由于`Redis`命令只能在客户端上下文中执行，`Redis`会创建一个没有网络连接的伪客户端来执行`AOF`文件中的内容。\n\n### 4 小结\n\n本文主要总结了`Redis AOF`   持久化的方式，介绍了它同步磁盘的三种策略，以及日志文件过大时如何进行重写。我们知道`Redis`持久化方式有AOF和RDB两种，那么这两种持久化方式各自有什么优点和缺点？真正使用中我们应该如何去选择合适的持久化方式，又可能遇到哪些问题呢？我们下一篇文章继续总结","source":"_posts/技术实践/redis/Redis持久化——AOF日志.md","raw":"---\ntitle:  Redis持久化——AOF日志\ncopyright: true\ndate: 2021-03-14 08:15:45\ntags: \n- Redis\ncategories: Redis\nkeywords: Redis,持久化\npassword: 1234qwer\naside: redis\n---\n\n上一篇文章我们总结到使用`Redis`内存快照进行持久化，在t 时刻做了一次快照，然后又在 t+n 时刻做了一次快照，此时如果宕机，则会丢失在此期间内修改的数据。但又不能频繁的进行内存快照，那么有什么办法能够尽可能的减少这种数据丢失呢？`Redis`提供了另一种持久化的方式——`AOF`日志（Append Only File）。\n\n<!--more-->\n\n### 1 什么是`AOF`日志持久化\n\n#### 1.1 执行后写日志\n\n与内存快照保存当前内存中的数据所不同，`AOF`持久化是通过保存`Redis`服务器所执行的写命令来记录数据库状态的。即每执行一个命令，就会把该命令写到日志文件里。\n\n需要注意的是写日志的操作在`Redis`执行命令将数据写入内存之后，如下图所示：\n\n![AOF-1](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/AOF-1.png)\n\n这样做的好处就是不会阻塞当前操作，也可以避免额外的检查开销，如果是在命令执行前进行写日志的操作，一旦命令语法是错误的，不进行检查的话就会导致写入到日志文件中的命令是错误的，在使用日志文件恢复数据的时候就会出错。而在命令执行后在进行日志的写入则不会有这个问题。\n\n但是也存在两个问题，\n\n1. `AOF` 虽然避免了对当前命令的阻塞，但却可能会给下一个操作带来阻塞风险。因为，`AOF` 日志是在主进程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了\n\n2. 如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 `Redis` 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 `Redis` 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。\n\n#### 1.2 `AOF` 缓冲区\n\n针对上面两个问题，`Redis`提供了缓冲区的方式进行`AOF`日志的记录，以达到尽可能的避免阻塞和数据丢失的问题。\n\n即`Redis`在执行完命令进行持久化的时候，并非直接写入磁盘日志文件，而是先写入`AOF`缓冲区内，之后再通过某种策略写到磁盘。\n\n![AOF-2](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/AOF-2.png)\n\n使用缓存区的方式进行`AOF`日志的记录，上面提到的两个问题其实就和日志从缓冲区写入磁盘的时机有关系。\n\n#### 1.3 三种回写策略\n\n`Redis AOF` 机制提供了三种回写磁盘的策略。\n\n* `Always(同步写回)`: 命令写入 `AOF`缓冲区后调用系统 `fsync`操作同步到`AOF`文件, `fsync`完成后线程返回\n* `Everysec(每秒写回)`: 命令写人 `AOF`缓冲区后调用系统 `write`操作, `write`完成后线程返回。` fsync`同步文件操作由专门线程每秒调用一次\n* `No(操作系统自动写回)`: 命令写入 `AOF`缓冲区后调用系统 `write`操作,不对`AOF`文件做 `fsync`同步,同步硬盘操作由操作系统负责,通常同步周期最长30秒\n\n但其实可以看出这三种回写策略都并不能完美的解决问题，\n\n配置为 `always`时,每次写入都要同步`AOF`文件,硬盘的写入速度无法与内存相提并论,显然与 `Redis`髙性能特性背道而驰\n\n配置为`no`,由于操作系统每次同步`AOF`文件的周期不可控,而且会加大每次同步硬盘的数据量,虽然提升了性能,但数据安全性无法保证。\n\n配置为 `everysec`,是建议的同步策略,也是默认配置,虽然能做到兼顾性能和数据安全性。但极端情况下一会造成1秒内的数据丢失。\n\n在真正使用中，我们可以根据具体对性能和数据完整性的要求，分析这三种回写策略，选择适合的策略来进行持久化。\n\n| 回写策略             | 优点                     | 缺点                  |\n| -------------------- | ------------------------ | --------------------- |\n| Always(同步写回)     | 可靠性高、数据基本不丢失 | 性能较差              |\n| Everysec(每秒写回)   | 性能适中                 | 宕机时丢失1秒内的数据 |\n| No(操作系统自动写回) | 性能好                   | 宕机时丢失数据较多    |\n\n### 2 `AOF`重写\n\n#### 2.1 日志文件越来越大怎么办\n\n选择了合适的回写策略，`AOF`这种持久化的方式还有其它问题吗？\n\n因为`AOF`持久化是通过保存被执行的写命令来记录数据库状态的,所以随着时间的流逝,`AOF`文件中的内容会越来越多,文件的体积也会越来越大,过大的`AOF`文件不仅追加命令会变慢，而且可能对`Redis`服务器、甚至整个宿主计算机造成影响,并且`AOF`文件的体积越大,使用`AOF`文件来进行数据还原所需的时间就越多。\n\n这个时候就要用到`AOF`重写机制了\n\n```c#\nredis> set testKey testValue\nOK\nredis> set testKey testValue1\nOK\nredis> del testKey\nOK\nredis> set testKey hello\nOK\nredis> set testKey world\nOK\n```\n\n`AOF` 文件是以追加的方式，逐一记录接收到的写命令的。当一个键值对被多条写命令反复修改时，`AOF` 文件会记录相应的多条命令。如上示例，我们执行完命令后，`Redis`会在AOF里面追加5条命令。但实际上只需要`set testKey world`一条命令就够了。\n\n`AOF` 重写机制就是在重写时，`Redis` 根据数据库的现状创建一个新的 `AOF` 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。比如说，当读取了键值对`“testkey”: “world”`之后，重写机制会记录 `set testkey world`这条命令。这样，当需要恢复时，可以重新执行该命令，实现`“testkey”: “world”`的写入。\n\n这样，重写后的日志，从5条变成了1条，而对于可能被修改过成百上千次的键值对来说，重写能节省的空间就更大了。\n\n虽然 `AOF `重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程。这时，我们不得不关注：重写会不会导致阻塞？这就要看看`AOF`重写的过程是怎么样的\n\n#### 2.2 `AOF` 重写过程\n\n因为`AOF`重写也是一个非常耗时的过程，又因为`Redis`单线程的特性，同内存快照一样，`AOF`重写的过程也是由父进程fork出`bgrewriteaof`子进程来完成的.\n\n使用子进程（而不是开启一个线程）进行AOF重写虽然可以避免使用锁的情况下，保证数据安全性，但是会带来子进程和父进程一致性问题。\n例如在开始重写之后父进程又接收了新的键值对此时子进程是无法知晓的，当子进程重写完成后的数据库和父进程的数据库状态是不一致的。\n\n如下表：\n\n| 时间 | 服务器进程（父进程）        | 子进程      |\n| :--- | :-------------------------- | :---------- |\n| T1   | 执行命令 SET K1 V1          |             |\n| T2   | 执行命令 SET K1 V1          |             |\n| T3   | 创建子进程，执行AOF文件重写 | 开始AOF重写 |\n| T4   | 执行命令 SET K2 V2          | 执行重写    |\n| T5   | 执行命令 SET K3 V3          | 执行重写    |\n| T6   | 执行命令 SET K4 V4          | 完成AOF重写 |\n\n在T6时刻服务器进程有了4个键，而子进程却只有1个键\n\n为了解决这种不一致性，`Redis`设置了一个`AOF`重写缓冲区。\n\n![AOF重写](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/AOF重写.png)\n\n在子进程执行`AOF`重写期间。服务器进程需要执行以下3个动作：\n\n1. 执行客户端命令\n2. 执行后追加到`AOF`缓冲区\n3. 执行后追加到`AOF`重写缓冲区\n\n子进程完成`AOF`重写后，它向父进程发送一个信号，父进程收到信号后会调用一个信号处理函数，该函数把`AOF`重写缓冲区的命令追加到新`AOF`文件中然后替换掉现有`AOF`文件。父进程处理完毕后可以继续接受客户端命令调用，可以看出在`AOF`后台重写过程中只有这个信号处理函数会阻塞服务器进程。\n下表是完整的`AOF`后台重写过程：\n\n| 时间 | 服务器进程（父进程）                                       | 子进程                        |\n| :--- | :--------------------------------------------------------- | :---------------------------- |\n| T1   | 执行命令 SET K1 V1                                         |                               |\n| T2   | 执行命令 SET K1 V1                                         |                               |\n| T3   | 创建子进程，执行AOF文件重写                                | 开始AOF重写                   |\n| T4   | 执行命令 SET K2 V2                                         | 执行重写                      |\n| T5   | 执行命令 SET K3 V3                                         | 执行重写                      |\n| T6   | 执行命令 SET K4 V4                                         | 完成AOF重写，向父进程发送信号 |\n| T7   | 接收到信号，将T5 T6 T7 服务器的写命令追加到新的AOF文件末尾 |                               |\n| T8   | 用新的AOF替换旧的AOF                                       |                               |\n\n这样就可以保证重写日志期间的所有操作也都会写入新的AOF文件。\n\n**需要注意的是， T7 T8执行的任务会阻塞服务器处理命令。**\n\n总的来说，就是每次 `AOF` 重写时，`Redis` 会先fork出一个子进程用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。\n\n### 3 `AOF`文件恢复\n\n在`Redis` 服务器重启后，会优先去载入`AOF`日志文件。因为`AOF`文件里面包含了重建数据库状态所需的所有写命令,所以服务器重新执行一遍`AOF`文件里面保存的写命令,就可以还原服务器关闭之前的数据库状态。\n\n而由于`Redis`命令只能在客户端上下文中执行，`Redis`会创建一个没有网络连接的伪客户端来执行`AOF`文件中的内容。\n\n### 4 小结\n\n本文主要总结了`Redis AOF`   持久化的方式，介绍了它同步磁盘的三种策略，以及日志文件过大时如何进行重写。我们知道`Redis`持久化方式有AOF和RDB两种，那么这两种持久化方式各自有什么优点和缺点？真正使用中我们应该如何去选择合适的持久化方式，又可能遇到哪些问题呢？我们下一篇文章继续总结","slug":"技术实践/redis/Redis持久化——AOF日志","published":1,"updated":"2021-04-03T12:48:15.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzl00dwhyjf0r8ulzy5","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以扫描下方二维码，关注公众号，回复“密码”，即可解锁本站所有文章。</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"fd8398b16a2efc3e30194655bb7efaff23cfe0ca7830c61af3a604c8eeeda2ae\">710da665e61d8b969924aeb749816315fc4d853ce86e90f1ce15860614b4623cf4f33388ba1e17931abcebb84e5898e104d92ae2815669486bb9e7f60997004dfc0d3a5646b8d45a9db0af1a899958c20f07c21827e8b08eef30384254e95f0b932bebfd5e83becadc01642b11d6c15cdddbcd7d3684799440f1daa915cd850a5d1243af21c79131336a5f73331f3ae5590659873ba7d68005503801dc25ee91d866bdf749c1b586d667aa8281453f67fc07159e8b0d6c99137faf912995722f073d4ebebf8b56abf3619a7451a7cffcdd431c09abc5fdc1dbe7eecf6d46eee89f0f3d8dd5e6b2f022b2786bd5bd77e34573602f2e2204d6b3ab13c6cea79b2aca67e5692bb64bbae4ed18ba1f7f09fbb97a1f77cb8e4a816ab5131de2ff73566a213655536a1d21e8158d53cf7345edd5a1cf773c781d6238acb7069232b489310ea8cfb29657ef6309a2c94abd2397c01fe3bfe84ac619a69e817d4bdf383359a9a136bcff9d5f3de56fe2ed3b2999a70daf75e6f971206d8feb92ee99969ed1ae4be3c989ce18457be41542920701d901aaf1c9b03b3e17bf0ac43905d8bc72c5eef90ada60ad4e291424228c29b2b1df940a8d19aa79031907441a617ef0ca04d285d79f856c1eab3d0e864883e65520a41affe7c2068c5563050680b169778d193911afe232a4c693561c07f0bd420a08f41b3b29e3a0dccb34d7610a1191bc080707753ad063ad86da8b8b63f96b313b35a8c5f2f779ea7b5ce24743f2ba8a5725da88ab3e8682b4814881fb2188d43c9b50a7bf65a0e138f7ed983e9343f44db8c349a6294187a16a1e4f28fdf8b32b120260fe64cceaf1005e0e69e08bbdec5ac2eb630993351358e713465dbb4903d12d69990ab54aec9788a341fc98731916eaa812c31dbc0cfb8283fc97fd44281bc4cea2b7be94cedc5f2609938ea3bcf82afb05253ded26e02094ae1ff3587b2ef5dd32a5067ab1e2cec1120c9d9e7ba0c7a7cdbeaea9aad7b08349e22be39d725e3c22644ef7e920e27eb8c181f5ab150083cf0526bd358ee3df1b82044322b844287aa1be1bc1bbc913cadc3da62df1694feb11ea013f895d3d15062786016ffa4edb24b99959675fba58d986317ee8313f712281045c9390e0f9eb33887d9e8b97a07a8542c51fbbb590736367d2b55f340e400da0250737905dda805ad5c79832249fc8db66f0945bea70c2e8b300e2e8ec5466393b46ffeae6a2290f52299544d520eeef2e9268b0e5fc86e531bc81cb0245e2e633cc1aaeb8095bce7971428203e66572742d778e84ce903e9d1fcf21e1333e39413d968130856993caa0a4cba8bbc645e842efbaaebd84cc0e877200ef0dff8b85391e2c81d01fec26c1b6d4b8b52312d7d2c77044257e2a53b701e03b46e35649b3ceb673f87dc059d019b0233835bb221118303a9c91c2d12e039ce92a168686cef2bb8ea050a9db5508f4105937f6ab61b3f62e5773130b5b068cac0e8b405402ef42661fbe67832376e7f7e097f9fc59d2be72938f5c86812af0af3161176443193cb5f1a57ac44c7dbd5d9fb0bd5a29cdd23332944abde44de363a9ebf891361e9ee75eb680e4a95afe6f87be13bf6fc1bf96270e8f6b2b6cc242105a244ebf5564b51e9923a4ed198def0c99a26714819720bb36d15b43b19e11f1bf371757e224f778eb5a2b76c19d13467b8bc02be1bd7e1895de2583ebb64501975e19cd685260821d704da4d7b8a7a21c3c354c09ca3ad568b834c386718d7fb3c75b5e9d08dfbb023a8a6ce787fd51a19771ae7a55826c45cc2c17c899153fa011fd1dc090aa9b3b9255ce671e204ad6bc10fa5e144bf80aa9aeef50333de8799563e6849fa910e00814d00fc717c085bfade733acc2a031128ca850d7993f81b8f4c90871e036a10f4320b783718484351ae5912c5a3e53d2d69fdb649eb0cd5d4981fd7d2eeefe56f98c090c58568a60b035c9c62db2fa5d05f686a3ebd3f486478cf0c79dd96fa019182f25581c14395cc714a2173e27a5cb54a1f8f2c08fdb2623ba35a8bc8ab4ff2f6c0c21f78311ef64f2a046f11bcbe18ac5428c58e3f13a67ef2cf148110deba7dbd3c98ee725f7102038ea0c315f36392fa56823d91c9b8e2a9a193bf4b48f02113ddb4bb22abbe69c3948326f982c398241e6e3a3a02e01426d5396a0662e9774a9046ac27f39eba75719e3f3eef0febd73513e1198506903ebf62b08212e9a64a51f8e174ab6fde59db4f54082a460c0388caf63fc7ba737421208e2b25a69b18f12d5288a9cfcb9973ebdcca33184956cf16408f0e7fc308d00adafa077758bfb6301489d019b2318a3e28fbf05e9a14ad70dd0ede42fca4abe998fb94969860dedb94fef0c58861f7292a9ceb4aa69c80d2cf3e2c404e7266d04b6557e2aa33e05672e99d1a313ed9ccf3dd902b201bcb1afd0cd8494f757d654d19c20c07e639c384710d897c64befd5b69dc519f7492a52d32a8966c6e7664340bae952abbfd1119dbe31fc4d5fa86191cd6701823077ec15e310a56636631b3ecae69cd065bf62e16b932c3a5872c1a1640bb03ae16616aee44c9a5f3ec2bc2ae0ae3a0a39751c0967559c12dc3c9678963262bd1949e220d62b5046cee11d476ed8d1f740e394e56578961017f1145f61a5b5a2a1660e35ebc4269208d33fbd31fbaf3b246b908bc2b3888a6a3f36d6496fa54c1a0eb553a54e1b82ec460b2e6333c57084cb7388c65dcb516c9606f0aa77bbe7e8b945f3d88706509601411b29a7c9a86903b889375591e56a3cce0aaa139b519bf4e034a38a9527f39ff671d0c04b8d0e520c297e7564c28d83dee6ee3fce94a7862c9d4154b5287427ab39ec0dfc1b8e7af29933b80958aea77aaa245caeef8fadaec46ecd0d8235364c3539fd13820939a02f5616d040c71b71772380ba5af9e8be891b1f25ab057d59c6d4e68fbbd38dfaf009685ff5882cf1711ec15773b60fbac0323316b76911074f707a9223fba2d11472b78e3e59a2a2390c16f3bc9d19d410b70e03388f007fd88fd940dcb3d3e39b3340da3adc21ec47fd79a86e8910e0c275169a1d3287ff0badd0d91ec29c1e3e2b3ec5d30e13374cab409418f4a314e0c19480818ca8d37d716731713bb72beb0e814e708b42ec64987fd52431a3e01b07e8379574cbd3e6134723b8568786e052cbe02fcdc3ad4f95c66bf8edfd673ec156568073c77078f384bbf5aba20f6c4eeda6074bb2b0a34f703506ea3d572049b85ef412aabb3a2d1d88169b95e4efc6d65daac3961cc05a558d6e5320416ddf98ba126a890266094a2dad10eca3f2aa79c95d01cacae44007168879247aecc752ec3deab892755f3e22579ab715d64d6817cbabab556f260870fc230c8249c1c34bd3795fb1f9ee9113e77e1089d6104e71e9890ee86d6dfad10a0673e26307483d8db9305d34be8099c8997c22e02f3affce489b9a8517a529eede4d85c16658be10db0dc5dc056d5f2af22cb9e6e0a7894078fefa59610c8a3bda4c9a34e075c30b69e7ef9b9e20b1853198e6f875b6ff3701e68c788bce331913ed90f40ad245bc51f1900ac0285b8157576ec5cd81ef69876396af817b971e30252efd3d90a2295244d041c9ef1356a6f44b563bff7f4a7f87ef1f03775c143a5ae7f05b7857bcf261e70c2c3b47b119bfa32666cd43e44e27e95e1fcbaf57e18dbcb39b92d3e97155ca5c62d919072afc763f3c0949abab8e3ea23a0e0bbbe28b13ebea68dca9270db62ee91f9a7a0a633a3217f7369b99d66e97cc90ea92d3a38a18922a069a2db7a7ad341f9326212454f497eac56facc717f23158f665a0ca900f3ef6cd54e9aef9f70d70b8298a1412b9be35d1eb3dc081308a0c41751b2718b0ef68ee0d25643b0eee7e261355b99417be7dc9ad5c09e88f7c51c620344eb1b1555825f2cdc978067da01277cfec870c77cbf14b1390652ecddcdc0749b70da58a11ea4961c0fde51b17bfb829e9e04e9958aeb2481ba95c51d48678853c87e7e3670de9e22b86399466d266f449601c4f88b419904845b41c4dabc4c6bf2f59ab3a16cea487fc5879240555f5c1cc867d3fe752de7689dea6a9881c7702bb706cb8355f9190af7618720f41b458fc5150f6ca82415a2685dbc33d19f7d1ff27a29a44ff52de8063c2c3ac194f49a419dfc6ed21cf3f585195ceb0dcd3e22969a8a6deaeafae27c85c75a258d4c5ed8d323aaf293f18ddca3458aae09696611233548b2ab60adf5540c645c0398b3af83a22f04d7c84de7194a7fdf45034dc316d365b778d2f8a6fd20428fce21d3be73327cdb13148c5c01fcf8659d1587fce79aabe2fcef7059adf2fa8a5e8695b09c3f9406c2690c780398fb84f628dcd008d73eb5e6515f4c77e8f8a1cbf7d40df6ecc48adafcff028192cd98470cc6905f644208bf63820e5e5ed945bae64eba4075b97ab0225d2e4b4f5afba09e20339308806fb11a266da2b22bb3c6c3e223dc62a6fa95df57931bfb2952a1ff195e3d5550d8e55399f3e425c53ebfcb4ed8753155c35332fe8575d425e0b50feff434c714cb394211440e92f20afbf7252b855c402a7f73419fdd97ee59d273ef1936d50bcab5630c8bd2ee01f19369b8bdccdb295531aaf8153d72f2e0fc181defb1f8b80291d5e1c60d6fa5096300b1cd627b1d253e7554299d75066d2b33ecd396a5eae74a0fc792d80be129c00644269399ceb15e05919e736861ade7b46bb759653788891fbe2493bed592391c708535c7bcb7b55bf4727d422f6c55d1799e44ac0aa50d87dbf950bda28005d7ea6e2a9d1129fac4791d235350a2dc8fa9709dafd7ca9ed65a32e6c9ab06c8126b370195929fbc2f7b917df7375eaebd7233cd46b3e246882718b2485e852eff4399dc73fda52ad7d077c549749b3f64e36207d8e6930b65f99c679cb9edf7c88287f92685c8a41853b7404c2df5a610dd10778201bb4cb3b988afb7a64bbb5f299bf0de797191b3dbebf987a03f421d22f37153b570832c2229c8f737b00609db98e0722ed9e6ebac2a9fd7b27238114402f3cf7f6f71bbfb10449d2e88db7cc78db0106eadbbf7402c6f0d69436a31466551b33bf32f9fde985cf46fcf9bf0b4d70056b02b90037139c3eecbc63c804f28a0cbbd0a9b028d1518c09d8798dcc43a435264be3e33a8aea36d266220e7b8ca768b7dfcc0b4f42b7f51c6e8d32b0af9daf86c7365ca57dfa9d2e27a07eb4124030a472ba16cad5f851fee7a4c501879f5dd4afeb0261ba2f56f3db7d87e79da82badcf3a23c987da6817771cc786e819c90936878269015b95ae591c560f0fc0e92c82fe7007dd70ff76363e01bc9eb1ac4853d97b3fa8a8eb88ccd84d136f094a60a49308029352a21df83fe4693d498928b02c0c86d92e947314c76cac3e7692c87599485a3ce6c6bdb8d353747b32140870873eb47dab2548292b5725f325381e505ff1b7dd784171c271b324f9d331e3eacac696dd34bd72f0c39b3d91f74feec7f20258ca76d7811aa53685894e332ea05c2d195d4dc226ee91012ca23bfb724380b6c10fc1f40c3a2fd8dce3c4190d1bf8b3d4d37f61077d767fcce317a284ccc3d1d465b998d6a54fd7a7644a2963b3860b19995fb9c740d34fcb48cb96acb13cfed976b805a0d85d9019d4223efcb2ee55d219086fa87e1653c51ee26b6d92e592a198ea09b16fbbfdd6c7aa30f82dc4a2d131f870a2c77e2d736c0b3a8366bc2a456c96682f457acf35337975e26b1eb4f78b237653c2a45f8a652a790eb994be70c394dc3a997f109a4b9d2e61657c69c55d8abea4035249fc3cfc02d3de2ce5b465374481f06875487cca1f8bb03e3e86c40afbafb38bed97916258002cbae81da921f932ce94a2768cbfb9381c3f85d34e13ecd43ee6ea6ba16494e96bb716ac6873c8979bb78477976d9b2abbc5f52cc3b50246d06561972b92c17070ca66083cfb8c1288f687da2faec26927b5835e3729ab71a9a799ab6bd4447d46e5b05d41347f2b0f4413ce148a975feccacd9805c5281dec0e944b074d97be91d666cc33cabb757275b6e908035be2b54241fc22be0217b2cec8dd48f88f791ff519ccd91b87c6204f6b8fb3db21382aae5c0df70860623112785119042042e35d215ed8429c7551be74da300ef0782335663aed057f3371fb1976668651f49e4f7e17faefff6ab55e4828f5fd3497644a5f117b47ef07761edd178aa292927639c9403d36a2cb758f37a64e0ad2d07604e9544f2336b164568346f83d88ea881e59bcf7b440faf4157f0a0353522e11a927947ca0bebb32e4d84c25754404e8d2fe7facb3b93927076cc020adc41796f0f1f15b9ca76bc3bd79a89402c316bb7e86c4a11d02a73e933075e09e5f3fb49a7786b9f6ecbe49577b07eb84c9340135b1bc200950d2d3ea31c8c5f6d235e1752d475422d7e83e6ca9150e16340703583a27183e3e09b83498e52783d415a96519593004e5e3d0e43c22fb018cd851d5065f23d585d58fe493b5f6a6247178a5bad497bda87e7a5e89c5c68a4e5886becc6446ac3a6f78c90310cc98a9e360d9aaf500c10c2e339ff04c6c1f4a5b0f8a353c4f0414b09c7eed45cafa490f9211ba5df7635195b9483c5c541bb121a40246fda8c5b40c639ba2f9be6aaf5e4276725ac486486f99b5cde150ecda34e4ac33c159115e392db46ca65189429f24b488dca84e000d2673a5b12cc48684e879ee20cffe20b53d88bd8b945e5991d0ec343b040cc3e604b90c4e7d5d1f8dbfb4a5d361c71dfebb458b454064286a2efb7b7b4ce6027d09f955fd5aa38eef2b6a43c716d1ec63e2d86bf8bcb7e0426d10e883a235e2de8006fae149e1668e067d51e75bd764a6db6bc9e5f2fa4cdc54c50eb6b6421124d408bbd942951c8ae445497d4e120d03f53c4e81650eeb0bf0c20bfc9e0897d08d299fa58d3f6253a975619586d6628dbd3de7700997d5f47f18dac98c95cc6d570c3d7e2bfd741273cd751a7dd161f77fad232d855b4359bd7dbdece49821897b385bfaf6b5a5a4a46be523992b241be1272fe797bbf4a43d3400b0ec834d92e7149d5ae7c07838723f0406bc489c6a94aba00fed721e795aa11e2a3c9c62f18bcc636de4a3719331c884cb271765b5dffe3ca218765050a55ede3f00a80e4eb2728f9ae0edd255dc4c4c126f13504e6c318ce36086ac67b232e6c250ab1ea80e9ceeb5fa76700caf25db213a1a7f9a31fa35818d11647997b19ce16e83e1acce9c9342c99ea49fdf43898a6a0d73981da7578cefd3aa5278ec779164c5665eadbb4d5737c4838c887c46ce96b64d39e65fd00960fa5376cb4f42f331669b5318fbc1f1ffaaf9aa4b2a253d2a3c287adb0d4376147c4fadb35d3d4a8d2e6e5d573a71eb43569cbea4ececba25483d4efcec4eb56a82b5f6d3f406c59ff8db68550d63719785a60425c4579f01b9990e49308fadf6153a0740b8de6ed81acc7bd7ee0d28a6e0d93abd0634af2131f6209a445a7d7ac36a5beea32449ed124880eaf8dc405b180a5c3264667c025d397becd71ae0b61d6bb70b7f0e70f5653d71a0b97c09b654d04ef9c52584e8c5eca08615c1d34e38211c960f6fc89e1859f2fb5e150d4d13b7894fe1fcee24af2995a2fd11c3c5574045ba6367debfc6c3965052c0b6df889a19faf759cfcfaf7d0d76b5665177559ab360ef89d0806b16acef6f60e38109950ad6798ab99c32f63a732cf5aa8c1a04f16b40a6963167d499420310bc64821c523537705842a3d31144f21aded2e7e185e573e66e41a450f47c034d7217bb26d1f920e4f800c7b6f2366a247ff6185b3d300e9348244fcb1bf8e1df2b79825c4faea87d8d65f8850e39a31fc548c83e381f56511f51fcae850bcb32a9bbe0f688e5bfacdb396ee52a1813b461b76b6d9d4128cae8d9a62778ee59086dcfef1bc82a1d5730ab6c8617ad9b6bc6e245607d0665dbd67a94fed45b957a99eba1ae56baa9b5d3d877644e1f10ff768bfb13701129a5255108de814071b09126df19413b65bbea5f9ff6f1c42de8001d5d77404e1f23c9a6282e5551d45d856964bc0566828aa58c2002cc28d2e2ca28a0b05dbc628aa6982960f70f576f9002a0fd70b5aa498e61b2371164cd8c7d948a0e8a4a0afc390856d7db512c5f9991008411a249c59fb3327f4cfe8e1a938eab015d7ce083465b7bae64bb2962f45636e65a4abc7e4a9029bf3262d709451b1e0180d726be9ca1ea285717f5b5637ee379e8001782c1b27debe4109b5151496580e6bc08b0baad6a75f6a6450f6ef23fc395b5b1ff07bd29f16017a76d03505b6b2e267f8a29ea541b589df38ffb2a1dd4228f6ebea98762768a574f1d7eccf6f05d119b937b851fe30eeaeb921f1170968adb0be70c1134798a9f1860c49a4a55e6f7bf7ca68faa7b91257619e0e5650af5e093e32e98c81d4f5b2e06c4518436d5419c304fd2c10eba1850bdf5a619207e8462d1e08381b44dc2a4e26f372e9a5939323b7b9298a17500b52923b5e167bcfe7c260fe0498bbbde9ef10782ff3306593a95c68a8b168fb3da620cf361dc29696d5b4eebcf6b880f4b521121e7e0c1103c7d3ec6c56fefc9cbece88b6f0f7cbadeb0c66ccbf901052afcc1e443ff04c60362be43276f65e060e202082c6442985609d9bdf5a4b1757a8588f334fd1abe4cb9650f27f47c97c719e91aa648f57f37162c12f98716856f6cbdd3dbfb2b882e7d066b7ea37bb551751ae78bd6ffc3b800ebea3e79e5954ecdf4674a8894f404de5aa0132378b3c19f590d344bad68b95abe0cf86fc5a22ff63ff4d7f53f925ab3fec6ee6045c0584b9f41f5216f40ac0fc574196842960646c43dab1153c1f3ee9d003433b4430d25565bb4bbed8dda494ada070d159752f18e822ecf1d35c194ee86690e4ad0d11e50829156c29b8eceb87f7e2ff2266a0a47c46e5b02947d1225b91a42a215d00c49a9f1122066a8479b929587a79e9b17fe6da7ee4ea7ce1f39406ead048533124ed6361f23dad023fd9373a6dd9bfae187d9c1c86da848957a4616bcc0d0d710fd86474aac8080ff5a33eab9d8432542b9172ddf4466728659ccfb98a55f24db2b8bed1add6bc3b06427841458effd79fde4ef85cda08f7da6372fc342064133724dbaf165538c6be0c3054dd803b2243dc70a62b535c14393854781034cbfc76d28285337c643a70d3b9677636eb31f07c95058f724164a72362f45863f37891d9be8739b63c0add7956d9e16d06892dc055a26509c07dc2c196608eb959291ae9189b074f425a6ff17370259fc0fe2533244d8a79cc90241a7dd6e3d257aea31b9d667da9d2d09d90233af61e96842246766414cca76ac0de103b943d6d337be49043995059fab2d9a51923c1b4ea15705dc34f70eae2a922f04330d9aba5adbeb8ec3a4f5fd939a5413cde9e1f4fcb9949d299d6eb0d5a5c6d64ad7773e4f174bebefc31839dcd399fc264c20c41bd2a4fa20eb7160b3fe5e480b2dbaaa6aec200b5f7c133aed4b0096530db3f4804ed23bb704d3240a83d62a39e70946c404bf261e389b8253969e94ddfe5df4eaf8a2371b2ce401840c8548ec48cc2afb8452907cf4548852de8d97bec60f89e3ac1ab18456f7a9ae11c491cedb471f357a31e10cc9b5c80e73a878bb89940e21f3e81ec3d78dd4ecfbcb28de3ffb7e206b967608f74450a03397a530d97f14b15d26b7dfe88cfcee2d87a8c459e3f0108da6db55e054072a8bf1748d1004f416e5ef896068c980a0d311b85797a79d18d1feb2a258c134ff284d030e1bb97bc67366e47e213851d6218aa74fe20b2f41096f4dd85c96699ce1452f89941e097452f19a7cf83864e17f07e848c610c8873a077d9e3178b236fec00b90badfa2451b27b516844e37785cffa59477ff6e40ab4a4408f8268db1cb892dacac5781d5ec91d653b4e67ad9d4bb00d2c0a4add5fe81e86b3193a93606a866b022ade5a3dcd430d9c3225b21ac0f5b837aca6bf70800c4760bd70c2c75485836d6b5dda5bc05607bfb19bfadb54538167cd38a5cf4fbb12b14372a3c54898a39eb6ca58b71083bdf546a9cfab8a110668ccde4c16435820cdb6b6b30105ac3cbd28e47d639a83283eba75d004719cb6ed131381c3363b3be83d9ecc2fe8335fd98d75a16fb117be0c42ce7805461c5db180e470e7fc7079ff75d1c848c6d7582430669a83dea693b9b47dfe79dc01d853f4e7e56ddc2321676a397490ef26f8d76cb54fa0f80e1986ffc704c06db1915faca343d652838b089bb0cff681fc0a0768afe3cddd67dbf1d7e2be81a26bac52233cf31a151c99a21fa503b7fd44d778fdcc40ced7588882989b72bab12bf8c142bdc311927dd734c6600a3d098c7b9a694445e104ea54fb292d390d10b618557af2252152171d2635c6cc340e28dcaa815891ccee97c3bfa899841f64201e78f8bf6b284c02cf40c320dd1fefaedb16432c1c73ccffaa9a15e5bc2d5116c7b9f086a288f6140f26ae47c320be35692e519fb729dcb604d45b0947efff741e8be22c7c11034198132b80a1ed762f68d9a4f184790fb76c8bdcda3cfd1c78661c5473eb4e3e2df2e8c285aa453d30371786629bfdd492c45edfde9b8a556cbc326a2f2bc15c232bad012f5994fc54f90aaa92999e65817c1eba67bf166a9b0840c4dc79582d0b002100ce114134b96f3933102f80295bb221fdfc0dd99cf2ad4a17da5689ed1009e5fab7ad8ec4e40dfd30185cb1ee4163af674e9d69a321da3bbcbba93deb50a57597990e4012e096cb1a87350c661435be611adb6f71d1fa96b14c007bb59376db6e72b9b14f0902e862bd397904dfefb77c15c7095be8663751c657b7561e9427b4db5895b8f5a349393c9c6655cf725b2b4af708bb2c00f7bfe19b963680228c7d5075f22729bb814173e486ccd4be043d46bbc8fcded3b15b41838b30270b99b886f4d469dbe8201ef484bcd52ccbfbe79dfe366fd44992878bba47d61ca5ec104520dbc19f4cea1832f115e027a505880589dad275815cd8fb2a6e6463fe1d7274e43cc50ce119bf79c8809d6287628ee187ad5b5a5c508e28d25fd43d4c0df34ecc83a6cab44c6917b682013b8ea62e7763f91c6cfb790b0fa07bf814d85a1d72540d42586f6b0053daf359db9903beb510e7fda900dd07acdfede29ec767f45db6c721f6b3a1d62719325813f6ba7be9efa8b61d5c62d8f62e658512b60f43fddbcc76faf8868d0b28f045e412d6689ddc26a93d395d41b883541dacf4aa11b0096d5b9d096ea2bef1d598b3bbf0c9ac207dd08f27f0ff6fb8744933ecdc9ab61c8fd2cbcfaabdae24a94bf20ac67463040509b3d624b7b3b486bc20694d415a2e804192250eb619b078fe8ed448b507168b5345d9e241b1f06592c2d541dbb15c1022e8105b8944cf5b06fc80f782a108b6ab838f487489fa1ffd5ba6f651b23a26381af0dbbb18f0277661093d4de6d47ea3b04ee0cbe6e864b2cd645b1d6e8da87aeaf1053edc17527e70ccbd296412be44bf8d56a068ec86bbf1407b3027098e4f0ba6a31e80dd6239dec1818d8c5e4f53c61d2048682b8573d7dc32103d111b52dadec5273065a63e566b09fd9e749fb6fc3c8058ec4aeabb6fa94f2f78ebc1d01369f5552bc45e555372ba7a929396eceadc7b15c579b181f2087bfa5111df5acf770348dc9f5c9271ab0fba0312ceea57539340681708b6905cf67474dba519930437d017f3363235a06847f7a2f5ac71bec3601e68b428ad8c59c0cf67dea6250b7a8a1e170e71e046d7418499ec16de87ccd1ede95aa657ebc9eba049b7fa74eb9db4191748901ad1c1fe162c8f68e305d436fdb6cd01510cf5e512bb09694b5eb294a11d1dd3a442f050c7232c3874a707d8dbbd92fb221fcf3319dbbc2933e19e13bf2518852c7de1243e273e95d0453a3db0a17753f773afa34b84cfb61d643f3d43c1cab622ced6b30cbbe551808eb97451416872930c1052244d0eb1e334b2587379e1ec8a6d8c2841916a76f6c038fb9a8b9b3d0ec45d78e8c50efa52328143b7e585168f868b8fb27fa5752eff5bec74a88e87c6c698a76d3271eef8bdf7fc83d1389b7583830b007134bd5fba0ba0a38aeecffc070669a2754ef69f612a0c0512c3fc69a5f80765beed3c6d8438e3e884e6bf99de50e7a53d99ef5a9a4edbd4dc7acba5d22ce01c14a53725aa44f37414a201e1f97b8bc62c7e314ebd9ab6b719fdd4d79ca295e4e99e0902fecf8c09e4656a686fc40e0a6f8766261e4831d47e4807ce75ad9ca5fd6fe464167cc8e16bb8b7cab9dc0ed175a6bdec474263918aa78dfdc124a36798158408d7ebef81e4cd7b77220961761c296f97344a19da5bba635fa49a5465c5359bae7de82d9604ee13178e0a81d3541c2cb9cb9a3ee8ec4eda2ad7efb566573caa8cbb8193569fcdfdef8d7826cf078c4f330fe2660d8043225adb076acced624a5342d24cb6a5cab480523d0fdac290e9e24e102f1a4fdbbf0fac57cf1150eb5b3a61a65bf7c4f8149c68f62bc7c9791ee63b41c79c036eb482c02dc456ecd64455313568968fd623ac7cd96529ccaa9c9c043f9d85d61af36d0d41564769ec29fa4d179d9b9cb78d7d14828d902e15498f9826c9e4bd39dfbd9dbd1811d4e09f56778fc1f6161abbfcd122684fba32f76ef8ac34902492da24ecc4bc563ad7d81e9d74e827a20e23f2f5ee8311ceefb4497f3bc3e5b8ed6e103d4a8baedbeb92368086bca863aa419690071af7455fb60a6e8cee3c716d62f1fbb83d15f683268af007210c39e55dd5ee252a459fa9eaae5e0c6fe94d41279ff5041a62505d3b0059ea2e406af8a024563ab06ebe685d9eefe75ea67b60611b7f933dc3df444a91830cafba0cd33eb7765bdd34003d0a2861c5ca2e6b052c9be20fe38a8d1502c1231a8961e16443e31dd8ead73e16a6d250553187476eaa02f4eceb88a5d22e992cffff7cea93cfbc4f6428f7eb6588724d3cb2f73617c288808874f37dbd440dd855b8119e31fd51a6bdaec224a3fdb254b66bda95c2c202f486c8c50b6b409498b31b377cf6255dd88bfeb270af95c893b105f084cf881301c205aa09598c7d197f36f186cc2ea86528c60153c917c11866191f88c57a3860f5c9f20c9f85b19e5f6ec7ab073402a94635e281a4037d8e819da34061aab7eacb97a04d496697e28021a03387d7a35fa7984c17106a804d802269da1fef2e3de0b057edc2b13e434f8ad8499cd49e9b53a26c3370bcb9337d73e5eaf03815872f3e644ff31bbc41790ae6e8fdfc30e2ff75c8445819bcbb9cbc94ade0661a02ba89bbc34a00b19d953b60332f2465b72312528a552088eb98748a1951896fc4aca6d4e05d012b9960d6f009e27f4bbb0da06988360a3884ff03192b156fe5737d70084442b8245eac9e7375c2222c042a6d3ccf01ecdef8936742389838722bc26bff67ea4cbad6818f6540dcf60ea3b13b2879889acb5cf98ef334975f9d3a750e690cd14db5779bb376ee6b8f95fa62ca8a19826930ac354427be0b3aaf79fa078978ee3818d20a2eed9f71b4fd9cd6a33352d5837707c112c9fd9e3bfea13b4c6401f68e17812396bc8eee24f85111a1740a9ea5ba93eec01dc453557aff854e31743a43a6a73bfc65df2de8b17b435caf3da1e1cbf69caaddb55f710729067b5bb4a926234642806f4468cb2cef214b9f90a06076ffcbbb0125925d834a0814d7a4e32640720f8759e0ba1cb93264a607fa54db8451e7895ca1cdb9ed4611fa0102d23106c3a73ab441f9687a82f80cde9206923c08bde27ef12564e2c0d06b847d71ec8ed133412c8bc9cedc081addfde443061a1639bd470d51b146eaa806037b2cbc83609a65a1ffd11fb4b5047283098d2f535e6c2114c369fd4cc47e598af1f77b9cade830903b599a7738a74de0d6ccc39146c50df9be938c6a3ccb513029b278f7d3f2cedb36b9de5f9c16d461899f14d18bbf80cbb2573dcdace4bb5b231d3ad253cbd564f1216d71fad81671eaa9d49f44a894fefe8e863af2ecac3f91735e40813b37c90dde71e5713135764ac30b524ad32367e5f767f0deb1ce18208d3b32d0aa796233ee12fc4e7490c85d2e8b414fc4a4fb2bf3affbe7eaae0e270656c1838f686f054f9818202704a90c87fd46c5b280b94cab51b8f0d436669e8e936d631af101ec3fbb6dbdbd8f50064420fda55f3519c3a50f36d5b280dc80a3516e283370d6f0e06fe2968a3fd8bacd7210c66d96421a2b31e90d14c7762c65ce5a352019261ff463ffdff357b9327a8c41a75c46900d623ed2a19e46ef29f775e42021023779f8144a2d70154a81f55d371027363bb7dcac96a8310e84043b7e7ac7763ec00c57d02058b05c5e74f5649af0b4971ab11154403eed40f5868384936d8834f0cadd4798226af7f643a5419b8e10bc9b61a187b82c13df3eb1f03d26b0dcba373f8365fc16b3cc55c4d0262181a32c1af487f499d6b9963e097865aea881d56a2c703d56207e7e192754b950b5e793c57cf0d2f49d11aebfe6bc537e3fb81782e17d452bbbca7c6df1732678a1e2a690d9d286f3f2e8c05fb95542b5be4eb366d6769a93ddc9ac49bb6b77458297e3ed4d58fc0619da28cdda2f94b3a9c99969b2ca95014494ea8f8a1a3e66a773900d132ac41741d86ef24518e04e354679bc3b9113557f8fcebff3c52176b986c5675fcc694ac82702c47c7703d06d38d039ec5f1bacdb69beb8c8a44fb08a5e259a7cead4bf0c35573eb97294555c1bce0c6c667f017e19fc40ef43c52828d14b4ade0fcc86e63112b27ea12d2badc65fde27e40c1ac5f9965347f19eee5289f7c61a896ba1b2d03ee7392c532924620ceb3faf3624ceac077a6c542d2571a3f8867aa65bab5b6902cf1018a15f0b1d3629cecad57bf98519170bb113ecbfafd96957cb267e8efa5c2d7a4b20ca9e0f77b745d9af56d6685c5b8ae8ed6f5f3fe152890b1122b064732e75d32d88abe57a23fd74046130aca157277f7cea1763bb198523c240be6e8e9465c6b5941ca172d7ce30cb79c62d970bd5ee12b255538a5c983188bfe0050310524e7e819f3d1ff591f0fd741d2093ee224eef4c4b432304e90c0bedad324cbc3c40e7a002e8d673a1d935113c586722f8b7d0e915af37f1cf7c7846d606c1e72a83e400393f206b514ff33ad3f2575f1b759bc8edf276df731cfce92799a8cd9fb0bcf5326cb886c81ca2bdfc56d225abbf6a293d61dbc664d513163f42a48cb5cb62a8a2a70a967190c2622daf09f069f8df652e4fc5e3604b7792762fbe4cca779d96a9d6454e783a3d9256710bec17c75c71e26e812651eaa47733f9f875544aca3bfdac427a9d1deefc9f61c3c68f49baf21e6b4697fec8bd394065f3b29d33dc18fdb1ae0e7290ea46d0abf8d1a0f49ff32f9f5f379c2a12c6ad0ca701271334fac7032ffafb78bbd20c04e79b591f1cd75d44234db7e28f8674afc902ae5704daaa9aebd09426217443e3a98c20129f4d0509b72ee49eaeb8a285b8a6590f86be73430230338a444e33e16bf5bac5a24a073e519b86b11e3b212c124f8c148e96d09aebca5a1201ea220b655b534c9ebba876bb092ac0257e14f619cf7c670b0da4117ec57c82f6418aaf8ea3733ef33d33894c9c37a4436eacfcaf01d50752767baaf42dd7f1c53a7f43bf2911bef720c59154cadd13a2baae450242dc83ff0b2f8fffe98dcc8d89f4873b6f840779b061eca0abdfa60e07a8fbd5370d6492143c3e9e205d63709c62a6f988673bb72b2d12b195275664f4c6307b33f7be0ad854a6927151f4ad6e2ba49d08d16c9ae47be475df5add2650fa1d5f73e4a7b1373cff62070b418ab8cf1cae905a77f90dd7617599a561cd0c975e9d2218a4b322fc3be5175b7931de0d265766360b28ae6194a247b8fc177b27ce215f3cec5258e1f6112cec230d1254e6318569d52eca8844eaf98db1a5b7ca86919dcf4dbd5254eeeeb3a81cf19abe898eb6aafac26cff02090e7c80d07a1ca7d707b7279f69f1d566c3dc2e699b5378c284b25167a4860871e81a4a8bebbe6fc2b09b889a968595f22bda259a35370634c2aea61fa6f43e886371abd8aaabd1370341ddfe2fd864f9b80002002207f47388b327549a343d95ec781c35bea5d7d3604567c195d162c30c41f49296b4dc91eed494e7f0603516fba9a50eff34c2270a98971334b0ccad29d156e950a4aa471ef30557faf5286b4878c266d37fdc39dc061006d65e72f05a6dc65f0e1e4eb9346742e248879458e20caba15102ab1f5458a758fe8c59f32cc58b7731cb47647af9bbbe3d7f18d94ee09d34434638ba460fd3789ffb8e86d656545690b671d034fac5527f0b942c5a53da052bdf21583b794b4655139439c9b4a00d7ce92671bcea43a67207a2d6f0ea08c1bb3b3ffb65be962ad3ef04ef79422e6a289a094a8e3f90e707750b22936bdcfb06c5920d6d2f6c18f8a1fc8aeba0b00853010f68041adc8a1e2de9f23e164d222a48da1abda03612e077f91000b14748b37255fdaf9891173cf03100a77769a9f555d1e89ebffdc73dd7f4cb8567abab3ac49a5f5e318d805a88df4d30d20a141e826e18374a7e4664be061243b7bef4ddcd45fa431ba3b2c3bf10529f1c536cf6fa06cf33ef8e032cd0f44854579ffe1228fb686276de22b4a318a1d9500c5dbf15c7ff3ee67788c434cc248be216ed9458582ef0c76545e1a2290eac8e26ef61339cfc09279d9f45d3136f9cce85a647fc0a597bee190cbcd2a35fc2bfe1e6311edf136a0537afca73092eb5d38981ef70b0c976328a48f5ae09fc84fc2c0d79862aa58f1c14dc6322a63885c51c910101ad00380d1d349c38a2e8e0283143870d6e8f1883b65570e8314cc1ea4e82ed103dfc1e497ff98b4162c9fbb90e29a85062fec9736ab58e1ff4cbd481594cf26cbc3aae5bb323a292bc6cbac9db6db848827016d02d2e1d7f7efc4496125bd62353d70d16f30fe43550916de60a35b6994e54c0a8174316c8da22a375300d67e83709d8e10184d39fadb155189be1527ae340ecb3e50c7f99c550a4e979af6f49a4eec81d7023de67e6a76fd88c2b54b45c6e40762514a18f1a9772ab83308413d0cd878a9af02056d89a600560e490158e5d7c967df9d05d1d80bb463f3ebd101ba638c2d508289db680b34e88252c77eb25857223991c74e66d2c46635e2704bbd2063f91765be57236c4c10a1f6a0fe720d44a4402944b22b2b544f21299944235220f7d89989d70cc70537e250d89bce6134a0875faad2a83c8268325dd1607a45248ed0eaa184d82789cb93a16665ae5172e379812c4dc134d3c11e79b2506786ac5a7ce95aad6223e248b2f9b161b9248ce5b2403b930248b35cf6eb68f2071cadb8a02f0e96a22ff10405c354c3a59d31d0671000183856ae06007ba8cbf02bb632c506a224dcb2efe13b327bc7486c35cb3825a518d6ca2eda31648aa6e1ab84a33408af76e5bba7fe9ad68d2d1f4bfd65cb717188c7c48376d020cae779d2da7da0f8c51379abb8d98cbf1780f86d6425c69d14d3cec4bca8c4022e90f1593ee3bac6d9eed5a7ceadf0263170ad7c264c9cb28ec89fc5ee75e48a9d8366e479287ddd11cfba78bd923dbe4edf9a308805ddc72d5ca920c90db6c4bd7fd736a2b2e02f005d9a41278d8eaff20b211346bbd102a3d13e64f0a1c54cd51471b0abd17f33a2b9b252a4f2afc70f18a241cd3a3169fda2d8316854f09d918a8a57ff102e4be3305fa95c339d6a5da9401074932a96df847d66a3a3d33765ff699abffa9fbde766c3e050a73edbc6a51da92b857c110b7c0ef0493dfa0f91588111d5559571e1ffabdd9e70fe33c673c6e106a70bfd0d2684f1aacd14c08707ae87c1f46f6a44c0d013ddd06aa5644fb30d3e22c7d859428748b530940fb7dfda6820bbdf654317440899759f176294d1a74fc24934070142d35c8e996653ae264e4f73470b00ea4ad4fd0b97c92d53564b81eb967934e6160581b8fc3950cafa5eeb6ff664f1f1b8a066c0d9e64c9ede13db85196f3d22192853f79a0c15c54f118db0bcaef65226e409aee2cefed3ca12317ac0cdd053cf2b7b51f1e6544d22367c9d036482faa7500b1452eb790d300126141e55e6329f2bd1ff9fa3b97db8efda8150386b4b1210e30d04758a8da18bceb4b00a4706a19800129ef2542826d0ae7d54ef08bd69a8cf527ae948d14c6b1223ecd0eeb506ab4b3bd32d65d4803f124145a0d8c47317c1e511987a7f56774bf1f7eac67e164dd2ab684bedee81b9946cbbca34357e5fb0eb7baebb45d8118ee14e1b06321ccca3735dc5aa5711d154fdf1790dce2a02a84243678e6c12b3bb6c5b80798da9e44684335f4ea3174e6446c4e546f2517220f460e337e64d8eed2e32d1495ec60994078ce61c5fc59aeaedcabf863833fce40673fc8fdd891aea8b450c4366220d8c36434b060b683e0e8ab2aa321325129e6d46c4d0a97839d63a173fb4fe5d0c106b25615dd14f357f4a3c7e6ba5d0e09de9358f904a8c011a4f092b0418abadd7ebc62a660bbb2bb451b2d2cebf90f50052a9627b190288ce7588911384b94dd6019808e9daba5426d36fae0dc1d4f68a247c4c818fca61ae718b0c34f24bd5d791e82d1e19f84f12051f58a4f56003388dbcfa995406ae68352587ddbe9e9dd29a4763e0bd8f1bfafa37c9e096fbe1a2670021efb78b18b0e4989d5f753f98a0e042f9ed7f87a42dc1c07d57041aee425b7f14e494abdbe88fbc1fb8c346e64da293a64905ff352e9e06da25c95526464f2120308cde1c422aec7f597ed16821393a5e52848bc10e83deb87ae5f5ae9dcd79ca523c5d9e73b36c26bad47a912d63527e20919131d066896a883d2a70d77e8521de9de951e02448c9065256ef6634d8c46671768813c2f83e73cfeb8a9aba5d814be1327e6f4b2fdef850069aa0cad2fd6ce36a401522e50e9c917263a0a9f51bd39310c1b7bf6404527c8a4bfa6d0659a05b121428ef5ff46e379091b605dedab6b9caa16de0cb7182e2da2a333796a163a338993515f8ad0203459fef4b2029234b47f01cfa61fa14e12d0a90a1fa0e4d39956320763981248cda2ea27159b8e84fcb04942212714f11fcdcc48ee9e7170405c14bf45e9afe8bc279fcc6e7c8c9ecc88e641bc4c9b00bf0460f341a1f704940206a6f3280828fd2bad6c413e3676627f3bedf8778fde2dbacf487117ecceaa028714a56c92d8daf4d1e672f2025c4e25100e6cd9c6978232c7709bb613418c51bf6717043e4ff73983404f5e06c3ea5a5702fbf20f8e1b76450cd96c02f40e86a87516364694a813ae486301cb977a01fb058502e17efb0b6349900dff8b7b89c6df997e7f7fb96db5201345a4e6ecdcadbf84b65089c590570a8788a1a036ff9e0228c79aca4a4dc62a295c0d0f4516bd6b0d45e0d84d6f8b4bba76cb2cf4361a9778fd943a66268e2802b3e6c33a725224a5154658df7613b690b285ccf8309c6870ace504d2a42e4445fc7489aad97ef0d915fde4613dc3d7b830919ce5b6863319cddb155b2ce67ce2340eaefc7e127050e57db40f09e1ccf6ad4d80e89f5cd256508c3139fc700116ed168cf1cdde5c37285ee967a1d4a16f308a7a1da66f9c93256ac0b8e503d5fbf74e01ec840b1580eac2af6d1329b96f45498c636cec71c743488ae92b24379cac3b760efaf0d2060baf47ea8086d3d64677d6162119dde9d63b8a160699b4cc2af2d36d55b48db32746e26bd4f1ea23731761947761b8a449c1fa54010364236501fcc8d369765339a91cd73181aca1608831f664f1980eb541cc953af28f34b36babac6667de49b6ce96f19fda170075569acca9f3e76bd2d43ad36aa3c41e7341c82f786360be60fb3a93ca25f0f2d94ca1c05e12b213c8d5776bd17c024be856d65ac79d6dc1b2fb6be9d15eb50fa51e2ffe170a7cf83bbe9cab9956f9afed05699088acc3767a09bc0beedf3b024d45a4c0d08d92b1ec8d596c5dfee7ffacd985f4094efe41110758cb4f6f5dcf8d233ffee02889a87234a1d1ee612c456d8d3465aa7f07225d36f26125dfa5b13051ecf62cc0cbada0e89a917a26ff2fdff5bedf79a9a62c7756f2a40881917ad0e8b2777a0efc9478b38eb1964125542340de2a386af9c40feabe843749af729a2c596a6d6270768fa6aff53e36d6623b367fc2a63923f5084d126b26ac67d30f346d6a3e7f35bf343aa4652e6b4b7d23e161c6dae4782e23247c4e0d4bcda206a1bf72077458fe6b5d836ea9a14ba7768cead591767bbe4c58f29dde44e2ca21ebd9354fcaff306e0f262229f6fa411daadd4b9eb35c99c3e091570d5e0920244d791643203ba455e045e39360efcbaa9c8de9639f6fcf59852f7b03576a5d1d84a74c8e680f55fd2bb9846d191323ed168e8741e5f1b26dc064a87eeb3a32988a9a77599d4160f12ffbe7e5e740633404eb39fb53d71d1cac767ae019fd8da539484c69d30a417e6efc0d141fa7f766dfd1a828d8a1d37e267a5fac6bc27cb99f6d2be93eeab31d1e05e4b50b5b69425662ca32c8688c05b200237e356eeabc54b97ccf22bb2662dbc39cef669249655db2696899cbc91120f86c86aae38feff56548f3c2949eafa80a9dc038f1ad43885156f9b3b182157ccbbbd439d953d92dee0b5780de26e2bb42d190431730dd065f2a7cd1e89eb6a49a2e4a65404da43262714637d6e2f74af922a7016d41cc23c9b41de2c63549acb6e7506ac733af21220ff4d743259daaf3cb1d0d401ac68cb74db11d736bbc4</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","more":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","origin":"<p>上一篇文章我们总结到使用<code>Redis</code>内存快照进行持久化，在t 时刻做了一次快照，然后又在 t+n 时刻做了一次快照，此时如果宕机，则会丢失在此期间内修改的数据。但又不能频繁的进行内存快照，那么有什么办法能够尽可能的减少这种数据丢失呢？<code>Redis</code>提供了另一种持久化的方式——<code>AOF</code>日志（Append Only File）。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-什么是AOF日志持久化\"><a href=\"#1-什么是AOF日志持久化\" class=\"headerlink\" title=\"1 什么是AOF日志持久化\"></a>1 什么是<code>AOF</code>日志持久化</h3><h4 id=\"1-1-执行后写日志\"><a href=\"#1-1-执行后写日志\" class=\"headerlink\" title=\"1.1 执行后写日志\"></a>1.1 执行后写日志</h4><p>与内存快照保存当前内存中的数据所不同，<code>AOF</code>持久化是通过保存<code>Redis</code>服务器所执行的写命令来记录数据库状态的。即每执行一个命令，就会把该命令写到日志文件里。</p>\n<p>需要注意的是写日志的操作在<code>Redis</code>执行命令将数据写入内存之后，如下图所示：</p>\n<p><img src=\"https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/AOF-1.png\" alt=\"AOF-1\"></p>\n<p>这样做的好处就是不会阻塞当前操作，也可以避免额外的检查开销，如果是在命令执行前进行写日志的操作，一旦命令语法是错误的，不进行检查的话就会导致写入到日志文件中的命令是错误的，在使用日志文件恢复数据的时候就会出错。而在命令执行后在进行日志的写入则不会有这个问题。</p>\n<p>但是也存在两个问题，</p>\n<ol>\n<li><p><code>AOF</code> 虽然避免了对当前命令的阻塞，但却可能会给下一个操作带来阻塞风险。因为，<code>AOF</code> 日志是在主进程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了</p>\n</li>\n<li><p>如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 <code>Redis</code> 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 <code>Redis</code> 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。</p>\n</li>\n</ol>\n<h4 id=\"1-2-AOF-缓冲区\"><a href=\"#1-2-AOF-缓冲区\" class=\"headerlink\" title=\"1.2 AOF 缓冲区\"></a>1.2 <code>AOF</code> 缓冲区</h4><p>针对上面两个问题，<code>Redis</code>提供了缓冲区的方式进行<code>AOF</code>日志的记录，以达到尽可能的避免阻塞和数据丢失的问题。</p>\n<p>即<code>Redis</code>在执行完命令进行持久化的时候，并非直接写入磁盘日志文件，而是先写入<code>AOF</code>缓冲区内，之后再通过某种策略写到磁盘。</p>\n<p><img src=\"https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/AOF-2.png\" alt=\"AOF-2\"></p>\n<p>使用缓存区的方式进行<code>AOF</code>日志的记录，上面提到的两个问题其实就和日志从缓冲区写入磁盘的时机有关系。</p>\n<h4 id=\"1-3-三种回写策略\"><a href=\"#1-3-三种回写策略\" class=\"headerlink\" title=\"1.3 三种回写策略\"></a>1.3 三种回写策略</h4><p><code>Redis AOF</code> 机制提供了三种回写磁盘的策略。</p>\n<ul>\n<li><code>Always(同步写回)</code>: 命令写入 <code>AOF</code>缓冲区后调用系统 <code>fsync</code>操作同步到<code>AOF</code>文件, <code>fsync</code>完成后线程返回</li>\n<li><code>Everysec(每秒写回)</code>: 命令写人 <code>AOF</code>缓冲区后调用系统 <code>write</code>操作, <code>write</code>完成后线程返回。<code>fsync</code>同步文件操作由专门线程每秒调用一次</li>\n<li><code>No(操作系统自动写回)</code>: 命令写入 <code>AOF</code>缓冲区后调用系统 <code>write</code>操作,不对<code>AOF</code>文件做 <code>fsync</code>同步,同步硬盘操作由操作系统负责,通常同步周期最长30秒</li>\n</ul>\n<p>但其实可以看出这三种回写策略都并不能完美的解决问题，</p>\n<p>配置为 <code>always</code>时,每次写入都要同步<code>AOF</code>文件,硬盘的写入速度无法与内存相提并论,显然与 <code>Redis</code>髙性能特性背道而驰</p>\n<p>配置为<code>no</code>,由于操作系统每次同步<code>AOF</code>文件的周期不可控,而且会加大每次同步硬盘的数据量,虽然提升了性能,但数据安全性无法保证。</p>\n<p>配置为 <code>everysec</code>,是建议的同步策略,也是默认配置,虽然能做到兼顾性能和数据安全性。但极端情况下一会造成1秒内的数据丢失。</p>\n<p>在真正使用中，我们可以根据具体对性能和数据完整性的要求，分析这三种回写策略，选择适合的策略来进行持久化。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>回写策略</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Always(同步写回)</td>\n<td>可靠性高、数据基本不丢失</td>\n<td>性能较差</td>\n</tr>\n<tr>\n<td>Everysec(每秒写回)</td>\n<td>性能适中</td>\n<td>宕机时丢失1秒内的数据</td>\n</tr>\n<tr>\n<td>No(操作系统自动写回)</td>\n<td>性能好</td>\n<td>宕机时丢失数据较多</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-AOF重写\"><a href=\"#2-AOF重写\" class=\"headerlink\" title=\"2 AOF重写\"></a>2 <code>AOF</code>重写</h3><h4 id=\"2-1-日志文件越来越大怎么办\"><a href=\"#2-1-日志文件越来越大怎么办\" class=\"headerlink\" title=\"2.1 日志文件越来越大怎么办\"></a>2.1 日志文件越来越大怎么办</h4><p>选择了合适的回写策略，<code>AOF</code>这种持久化的方式还有其它问题吗？</p>\n<p>因为<code>AOF</code>持久化是通过保存被执行的写命令来记录数据库状态的,所以随着时间的流逝,<code>AOF</code>文件中的内容会越来越多,文件的体积也会越来越大,过大的<code>AOF</code>文件不仅追加命令会变慢，而且可能对<code>Redis</code>服务器、甚至整个宿主计算机造成影响,并且<code>AOF</code>文件的体积越大,使用<code>AOF</code>文件来进行数据还原所需的时间就越多。</p>\n<p>这个时候就要用到<code>AOF</code>重写机制了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; set testKey testValue</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; set testKey testValue1</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; del testKey</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; set testKey hello</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; set testKey world</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p><code>AOF</code> 文件是以追加的方式，逐一记录接收到的写命令的。当一个键值对被多条写命令反复修改时，<code>AOF</code> 文件会记录相应的多条命令。如上示例，我们执行完命令后，<code>Redis</code>会在AOF里面追加5条命令。但实际上只需要<code>set testKey world</code>一条命令就够了。</p>\n<p><code>AOF</code> 重写机制就是在重写时，<code>Redis</code> 根据数据库的现状创建一个新的 <code>AOF</code> 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。比如说，当读取了键值对<code>“testkey”: “world”</code>之后，重写机制会记录 <code>set testkey world</code>这条命令。这样，当需要恢复时，可以重新执行该命令，实现<code>“testkey”: “world”</code>的写入。</p>\n<p>这样，重写后的日志，从5条变成了1条，而对于可能被修改过成百上千次的键值对来说，重写能节省的空间就更大了。</p>\n<p>虽然 <code>AOF</code>重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程。这时，我们不得不关注：重写会不会导致阻塞？这就要看看<code>AOF</code>重写的过程是怎么样的</p>\n<h4 id=\"2-2-AOF-重写过程\"><a href=\"#2-2-AOF-重写过程\" class=\"headerlink\" title=\"2.2 AOF 重写过程\"></a>2.2 <code>AOF</code> 重写过程</h4><p>因为<code>AOF</code>重写也是一个非常耗时的过程，又因为<code>Redis</code>单线程的特性，同内存快照一样，<code>AOF</code>重写的过程也是由父进程fork出<code>bgrewriteaof</code>子进程来完成的.</p>\n<p>使用子进程（而不是开启一个线程）进行AOF重写虽然可以避免使用锁的情况下，保证数据安全性，但是会带来子进程和父进程一致性问题。<br>例如在开始重写之后父进程又接收了新的键值对此时子进程是无法知晓的，当子进程重写完成后的数据库和父进程的数据库状态是不一致的。</p>\n<p>如下表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">时间</th>\n<th style=\"text-align:left\">服务器进程（父进程）</th>\n<th style=\"text-align:left\">子进程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">T1</td>\n<td style=\"text-align:left\">执行命令 SET K1 V1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T2</td>\n<td style=\"text-align:left\">执行命令 SET K1 V1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T3</td>\n<td style=\"text-align:left\">创建子进程，执行AOF文件重写</td>\n<td style=\"text-align:left\">开始AOF重写</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T4</td>\n<td style=\"text-align:left\">执行命令 SET K2 V2</td>\n<td style=\"text-align:left\">执行重写</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T5</td>\n<td style=\"text-align:left\">执行命令 SET K3 V3</td>\n<td style=\"text-align:left\">执行重写</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T6</td>\n<td style=\"text-align:left\">执行命令 SET K4 V4</td>\n<td style=\"text-align:left\">完成AOF重写</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>在T6时刻服务器进程有了4个键，而子进程却只有1个键</p>\n<p>为了解决这种不一致性，<code>Redis</code>设置了一个<code>AOF</code>重写缓冲区。</p>\n<p><img src=\"https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/AOF重写.png\" alt=\"AOF重写\"></p>\n<p>在子进程执行<code>AOF</code>重写期间。服务器进程需要执行以下3个动作：</p>\n<ol>\n<li>执行客户端命令</li>\n<li>执行后追加到<code>AOF</code>缓冲区</li>\n<li>执行后追加到<code>AOF</code>重写缓冲区</li>\n</ol>\n<p>子进程完成<code>AOF</code>重写后，它向父进程发送一个信号，父进程收到信号后会调用一个信号处理函数，该函数把<code>AOF</code>重写缓冲区的命令追加到新<code>AOF</code>文件中然后替换掉现有<code>AOF</code>文件。父进程处理完毕后可以继续接受客户端命令调用，可以看出在<code>AOF</code>后台重写过程中只有这个信号处理函数会阻塞服务器进程。<br>下表是完整的<code>AOF</code>后台重写过程：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">时间</th>\n<th style=\"text-align:left\">服务器进程（父进程）</th>\n<th style=\"text-align:left\">子进程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">T1</td>\n<td style=\"text-align:left\">执行命令 SET K1 V1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T2</td>\n<td style=\"text-align:left\">执行命令 SET K1 V1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T3</td>\n<td style=\"text-align:left\">创建子进程，执行AOF文件重写</td>\n<td style=\"text-align:left\">开始AOF重写</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T4</td>\n<td style=\"text-align:left\">执行命令 SET K2 V2</td>\n<td style=\"text-align:left\">执行重写</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T5</td>\n<td style=\"text-align:left\">执行命令 SET K3 V3</td>\n<td style=\"text-align:left\">执行重写</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T6</td>\n<td style=\"text-align:left\">执行命令 SET K4 V4</td>\n<td style=\"text-align:left\">完成AOF重写，向父进程发送信号</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T7</td>\n<td style=\"text-align:left\">接收到信号，将T5 T6 T7 服务器的写命令追加到新的AOF文件末尾</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">T8</td>\n<td style=\"text-align:left\">用新的AOF替换旧的AOF</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这样就可以保证重写日志期间的所有操作也都会写入新的AOF文件。</p>\n<p><strong>需要注意的是， T7 T8执行的任务会阻塞服务器处理命令。</strong></p>\n<p>总的来说，就是每次 <code>AOF</code> 重写时，<code>Redis</code> 会先fork出一个子进程用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。</p>\n<h3 id=\"3-AOF文件恢复\"><a href=\"#3-AOF文件恢复\" class=\"headerlink\" title=\"3 AOF文件恢复\"></a>3 <code>AOF</code>文件恢复</h3><p>在<code>Redis</code> 服务器重启后，会优先去载入<code>AOF</code>日志文件。因为<code>AOF</code>文件里面包含了重建数据库状态所需的所有写命令,所以服务器重新执行一遍<code>AOF</code>文件里面保存的写命令,就可以还原服务器关闭之前的数据库状态。</p>\n<p>而由于<code>Redis</code>命令只能在客户端上下文中执行，<code>Redis</code>会创建一个没有网络连接的伪客户端来执行<code>AOF</code>文件中的内容。</p>\n<h3 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4 小结\"></a>4 小结</h3><p>本文主要总结了<code>Redis AOF</code>   持久化的方式，介绍了它同步磁盘的三种策略，以及日志文件过大时如何进行重写。我们知道<code>Redis</code>持久化方式有AOF和RDB两种，那么这两种持久化方式各自有什么优点和缺点？真正使用中我们应该如何去选择合适的持久化方式，又可能遇到哪些问题呢？我们下一篇文章继续总结</p>\n","encrypt":true},{"title":"Redis持久化——内存快照(RDB)","copyright":true,"date":"2021-02-22T00:15:45.000Z","keywords":"Redis,持久化","password":"1234qwer","aside":"redis","_content":"\n我们都知道Redis是内存数据库，它将自己的数据存储的内存中。这样一旦服务器进程退出(断电、重启等原因)，那么数据将会丢失。为了解决这个问题，Redis提供两种持久化的方式来将数据持久化到硬盘上，即内存快照(RDB)与AOF日志。\n<!--more-->\n\n### 1 什么是内存快照\n\n所谓内存快照，顾名思义就是给内存拍个照，在某个时刻把内存中的数据记录下来，以文件的形式保存到硬盘上，这样即使宕机，数据依然存在。在服务器重启后只需要把“照片”中的数据恢复即可。\n\nRDB持久化就是把当前进程的数据在某个时刻生成快照(一个压缩的二进制文件)保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。\n\n#### 1.1 RDB文件的创建\n\nRDB文件的创建可以手动触发，也可以自动触发。\n\n#### 1.1 手动触发\n\n手动触发分别对应save和bgsave命令：\n\n##### 1.1.1 save命令\n\nsave命令会阻塞当前Redis服务器，直到RDB过程完成为止。在服务器进程阻塞期间，服务器不能处理任何命令请求。因此，当save命令正在执行时，客户端发送的所有命令都会被拒绝，知道save命令执行完毕。\n\n```c\nredis>save //等待，直到RDB文件创建完毕\nok\n```\n\n**注意:**\n\n**Redis的单线程模型就决定了，我们要尽量避免所有会阻塞主线程的操作，由于Save命令执行期间阻塞服务器进程，对于内存比较大的实例会造成长时间阻塞，因此线上环境不建议使用。**\n\n##### 1.1.2 bgsave命令\n\nbgsave命令会派生出一个子进程(而不是线程)，由子进程进行RDB文件创建，而父进程继续处理命令。\n\n```\nredis>bgsave\nBackground saving started   //直接返回，由子进程进行RDB文件创建\nredis>\t\t\t\t\t  \t//继续处理其它命令\n```\n\n![Redis 持久化bgsave流程](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/Redis%20%E6%8C%81%E4%B9%85%E5%8C%96bgsave%E6%B5%81%E7%A8%8B.png)\n\n**注意:**\n\n1. **在bgsave命令执行的时候，为了避免父进程与子进程同时执行两个rdbSave的调用而产生竞争条件，客户端发送的save命令会被服务器拒绝。**\n2. **如果bgsave命令正在执行，bgrewriteaof（aof重写）命令会被延迟到bgsave命令之后执行，如果bgrewriteaof命令正在执行，那么客户端发送的bgsave命令会被服务器拒绝。**\n3. **虽然bgsave命令是由子进程进行RDB文件的生成，但是fork()创建子进程的时候会阻塞父进程（详情请往下看）。**\n\n#### 1.2 自动触发\n\n因为bgsave命令可以在不阻塞服务器进程的情况下保存，所以redis可以通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次bgsave命令。如：我们向服务器设置如下配置(这也是redis默认的配置):\n\n```c\nsave 900 1\nsave 300 10\nsave 60  10000\n```\n\n那么只要满足如下条件中的一个bgsave命令就会被执行：\n\n* 服务器在900秒内对数据库进行了至少1次修改\n* 服务器在300秒内对数据库进行了至少10次修改\n* 服务器在60秒内对数据库进行了至少10000次修改\n\n#### 1.2 RDB文件的载入\n\n在Redis启动的时候，只要检测到RDB文件的存在，就会自动加载RDB文件。需要注意的是\n\n* 因为AOF文件的更新频率通常比RDB文件的更新频率高,所以口如果服务器开启了AOF持久化功能,那么服务器会优先使用AOF文件来还原数据库状态。\n\n* 只有在AOF持久化功能处于关闭状态时,服务器才会使用RDB文件来还原数据库状态。\n\n**注意:服务器在载入RDB文件期间,会一直处于阻塞状态,直到载入工作完成为止**\n\n### 2 内存快照的问题\n\n了解了什么是Redis的RDB持久化，我们来思考两个问题。\n\n#### 2.1 快照的时候数据可以修改吗\n\nRedis RDB持久化是对`某一时刻`的内存中的`全量数据`进行拍照。这让我们不得不思考，快照的时候数据可以修改吗？\n\n首先，如果我们使用`save`命令做持久化，那么由于Redis单线程模型的原因，在持久化的过程中会阻塞，是不能执行其它命令的。也许有人会说可以使用`bgave`命令，但使用`bgsave`就没有问题了吗？\n\n我们在拍照的时候，通常摄影师是不让我们动的，因为一动可能照片就模糊了。在Redis 进行内存快照的时候也会如此。如果我们持久化的过程中，有些数据被修改了。那么就会破坏快照的正确性与完整性。\n\n比如在t时刻,我们对内存进行快照，此时我们希望的是记录下来t时刻内存中所有的数据，假设我们的RDB操作需要10s的时间，而t+2s我们执行了一个修改操作把`Key1`的值由A修改成了B，而此时RDB操作却还没有把`Key1`的值写入磁盘。在t+5s的时候读取到`key1`的值写入磁盘。那么此次快照记录的`Key1`的值就是B，而不是t时刻的A。这样就破坏了RDB文件的正确性。\n\nRDB文件的生成是需要时间的，如果快照执行期间数据不能被修改，对于业务系统来说不能接受的。那么Redis 是如何解决这个问题的呢？\n\n![Redis写时复制](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/Redis%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.png)\n\nRedis 借助了操作系统提供的写时复制技术（Copy-On-Write, COW），可以让在执行快照的同时，正常处理写操作。简单来说，bgsave  fork子进程的时候，并不会完全复制主进程的内存数据，而是只复制必要的虚拟数据结构，并不为其分配真实的物理空间，它与父进程共享同一个物理内存空间。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，此时会给子进程分配一块物理内存空间，把要修改的数据复制一份，生成该数据的副本到子进程的物理内存空间。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。\n\n#### 2.2 可以频繁进行快照操作吗\n\n假设我们在t 时刻做了一次快照，然后又在 t+n 时刻做了一次快照，而在这期间，发生了数据修改。而此时宕机了，那么，只能按照 t 时刻的快照进行恢复。那么这n秒的数据就彻底丢失无法恢复了。\n\n所以，要想尽可能恢复数据，就只能缩短快照执行的时间间隔，间隔的时间越小，丢失数据也就越少。那么可以频繁的执行快照操作吗？\n\n我们知道bgsave 执行时并不阻塞主线程，但是这不代表可以频繁执行快照操作。\n\n一方面，持久化是一个写入磁盘的过程，频繁将全量数据写入磁盘，会给磁盘带来很大压力，频繁执行快照也容易导致前一个快照还没有执行完，后一个又开始了，这样多个快照竞争有限的磁盘带宽，容易造成恶性循环。\n\n再者，bgsave所fork出来的子进程执行操作虽然并不会阻塞父进程的操作，但是`fork`出子进程的操作却是由主进程完成的，会阻塞主进程，fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间也就越久。\n\n也许有人会想到是否可以做增量快照呢？也就是只对上一次快照之后的数据做快照。\n\n首先思路肯定是可以，但是增量快照要求记住哪些数据上一次快照之后产生的。这就需要额外的元数据来记录这些信息，会引入额外的空间消耗。这对于内存资源宝贵的 Redis 来说，并不是一个很好的方案。\n\n如果不能频繁执行快照操作，那么该如何解决两次快照之间的数据丢失的问题呢？Redis 还提供了另外一种持久化方式——AOF(append to file)日志。关于AOF日志会在下一篇文章中进行总结！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/技术实践/redis/Redis持久化——内存快照(RDB).md","raw":"---\ntitle:  Redis持久化——内存快照(RDB)\ncopyright: true\ndate: 2021-02-22 08:15:45\ntags: \n- Redis\ncategories: Redis\nkeywords: Redis,持久化\npassword: 1234qwer\naside: redis\n---\n\n我们都知道Redis是内存数据库，它将自己的数据存储的内存中。这样一旦服务器进程退出(断电、重启等原因)，那么数据将会丢失。为了解决这个问题，Redis提供两种持久化的方式来将数据持久化到硬盘上，即内存快照(RDB)与AOF日志。\n<!--more-->\n\n### 1 什么是内存快照\n\n所谓内存快照，顾名思义就是给内存拍个照，在某个时刻把内存中的数据记录下来，以文件的形式保存到硬盘上，这样即使宕机，数据依然存在。在服务器重启后只需要把“照片”中的数据恢复即可。\n\nRDB持久化就是把当前进程的数据在某个时刻生成快照(一个压缩的二进制文件)保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。\n\n#### 1.1 RDB文件的创建\n\nRDB文件的创建可以手动触发，也可以自动触发。\n\n#### 1.1 手动触发\n\n手动触发分别对应save和bgsave命令：\n\n##### 1.1.1 save命令\n\nsave命令会阻塞当前Redis服务器，直到RDB过程完成为止。在服务器进程阻塞期间，服务器不能处理任何命令请求。因此，当save命令正在执行时，客户端发送的所有命令都会被拒绝，知道save命令执行完毕。\n\n```c\nredis>save //等待，直到RDB文件创建完毕\nok\n```\n\n**注意:**\n\n**Redis的单线程模型就决定了，我们要尽量避免所有会阻塞主线程的操作，由于Save命令执行期间阻塞服务器进程，对于内存比较大的实例会造成长时间阻塞，因此线上环境不建议使用。**\n\n##### 1.1.2 bgsave命令\n\nbgsave命令会派生出一个子进程(而不是线程)，由子进程进行RDB文件创建，而父进程继续处理命令。\n\n```\nredis>bgsave\nBackground saving started   //直接返回，由子进程进行RDB文件创建\nredis>\t\t\t\t\t  \t//继续处理其它命令\n```\n\n![Redis 持久化bgsave流程](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/Redis%20%E6%8C%81%E4%B9%85%E5%8C%96bgsave%E6%B5%81%E7%A8%8B.png)\n\n**注意:**\n\n1. **在bgsave命令执行的时候，为了避免父进程与子进程同时执行两个rdbSave的调用而产生竞争条件，客户端发送的save命令会被服务器拒绝。**\n2. **如果bgsave命令正在执行，bgrewriteaof（aof重写）命令会被延迟到bgsave命令之后执行，如果bgrewriteaof命令正在执行，那么客户端发送的bgsave命令会被服务器拒绝。**\n3. **虽然bgsave命令是由子进程进行RDB文件的生成，但是fork()创建子进程的时候会阻塞父进程（详情请往下看）。**\n\n#### 1.2 自动触发\n\n因为bgsave命令可以在不阻塞服务器进程的情况下保存，所以redis可以通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次bgsave命令。如：我们向服务器设置如下配置(这也是redis默认的配置):\n\n```c\nsave 900 1\nsave 300 10\nsave 60  10000\n```\n\n那么只要满足如下条件中的一个bgsave命令就会被执行：\n\n* 服务器在900秒内对数据库进行了至少1次修改\n* 服务器在300秒内对数据库进行了至少10次修改\n* 服务器在60秒内对数据库进行了至少10000次修改\n\n#### 1.2 RDB文件的载入\n\n在Redis启动的时候，只要检测到RDB文件的存在，就会自动加载RDB文件。需要注意的是\n\n* 因为AOF文件的更新频率通常比RDB文件的更新频率高,所以口如果服务器开启了AOF持久化功能,那么服务器会优先使用AOF文件来还原数据库状态。\n\n* 只有在AOF持久化功能处于关闭状态时,服务器才会使用RDB文件来还原数据库状态。\n\n**注意:服务器在载入RDB文件期间,会一直处于阻塞状态,直到载入工作完成为止**\n\n### 2 内存快照的问题\n\n了解了什么是Redis的RDB持久化，我们来思考两个问题。\n\n#### 2.1 快照的时候数据可以修改吗\n\nRedis RDB持久化是对`某一时刻`的内存中的`全量数据`进行拍照。这让我们不得不思考，快照的时候数据可以修改吗？\n\n首先，如果我们使用`save`命令做持久化，那么由于Redis单线程模型的原因，在持久化的过程中会阻塞，是不能执行其它命令的。也许有人会说可以使用`bgave`命令，但使用`bgsave`就没有问题了吗？\n\n我们在拍照的时候，通常摄影师是不让我们动的，因为一动可能照片就模糊了。在Redis 进行内存快照的时候也会如此。如果我们持久化的过程中，有些数据被修改了。那么就会破坏快照的正确性与完整性。\n\n比如在t时刻,我们对内存进行快照，此时我们希望的是记录下来t时刻内存中所有的数据，假设我们的RDB操作需要10s的时间，而t+2s我们执行了一个修改操作把`Key1`的值由A修改成了B，而此时RDB操作却还没有把`Key1`的值写入磁盘。在t+5s的时候读取到`key1`的值写入磁盘。那么此次快照记录的`Key1`的值就是B，而不是t时刻的A。这样就破坏了RDB文件的正确性。\n\nRDB文件的生成是需要时间的，如果快照执行期间数据不能被修改，对于业务系统来说不能接受的。那么Redis 是如何解决这个问题的呢？\n\n![Redis写时复制](https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/Redis%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.png)\n\nRedis 借助了操作系统提供的写时复制技术（Copy-On-Write, COW），可以让在执行快照的同时，正常处理写操作。简单来说，bgsave  fork子进程的时候，并不会完全复制主进程的内存数据，而是只复制必要的虚拟数据结构，并不为其分配真实的物理空间，它与父进程共享同一个物理内存空间。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，此时会给子进程分配一块物理内存空间，把要修改的数据复制一份，生成该数据的副本到子进程的物理内存空间。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。\n\n#### 2.2 可以频繁进行快照操作吗\n\n假设我们在t 时刻做了一次快照，然后又在 t+n 时刻做了一次快照，而在这期间，发生了数据修改。而此时宕机了，那么，只能按照 t 时刻的快照进行恢复。那么这n秒的数据就彻底丢失无法恢复了。\n\n所以，要想尽可能恢复数据，就只能缩短快照执行的时间间隔，间隔的时间越小，丢失数据也就越少。那么可以频繁的执行快照操作吗？\n\n我们知道bgsave 执行时并不阻塞主线程，但是这不代表可以频繁执行快照操作。\n\n一方面，持久化是一个写入磁盘的过程，频繁将全量数据写入磁盘，会给磁盘带来很大压力，频繁执行快照也容易导致前一个快照还没有执行完，后一个又开始了，这样多个快照竞争有限的磁盘带宽，容易造成恶性循环。\n\n再者，bgsave所fork出来的子进程执行操作虽然并不会阻塞父进程的操作，但是`fork`出子进程的操作却是由主进程完成的，会阻塞主进程，fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间也就越久。\n\n也许有人会想到是否可以做增量快照呢？也就是只对上一次快照之后的数据做快照。\n\n首先思路肯定是可以，但是增量快照要求记住哪些数据上一次快照之后产生的。这就需要额外的元数据来记录这些信息，会引入额外的空间消耗。这对于内存资源宝贵的 Redis 来说，并不是一个很好的方案。\n\n如果不能频繁执行快照操作，那么该如何解决两次快照之间的数据丢失的问题呢？Redis 还提供了另外一种持久化方式——AOF(append to file)日志。关于AOF日志会在下一篇文章中进行总结！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"技术实践/redis/Redis持久化——内存快照(RDB)","published":1,"updated":"2021-04-03T12:48:31.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzl00e1hyjfnekrqx9q","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以扫描下方二维码，关注公众号，回复“密码”，即可解锁本站所有文章。</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"df62d2ab397fc27f210cef48ac42bfed86dfd5f446456641df9cf9b3eeaa3fd2\">75f187a2be09825d38f7fefa23a4285dad982c41921f09abed5d656bafd1c93c85238169b91076e12dc10d5663093574f9acdbd47b6b5bafcaec0b482e2a12cfd894522c61d584fe31ae4d7d01666ab4eed91af3890e06e45803dac1a879f23af247ecf2f0dd35fdeed5d01073161001ce3765d0927136a3806f6ee55cb93a4fae4f086702511db85de4de03ff2a54c771d0ca79e1b2dc53f912533322188ac6ebf57abd99b38d7e176c4c8f8b66061b22815e813becbf287ca617f5a67c799d38c295991547c0ba8de9ddf3cc6aa4209ce2bd881f854678767b0981ef46a49f4aead73819c1fbc05e402117b093041e6e1b8f1a25fa6e75c98a233225fb1b77ab9233726c97d9133d5aab658fc2a5c478f86abfe80cc7ec77dc0af357fc775cb9cd86743e4c2d7884a2c6316cd18ef60c8e4a8160a334f7982d7bc3d20c83a8b1e83b0552c53ef88add1fce7643d1660d2e3b91d44ad98e523420561750070a640bdd62bb5ae6673fc83f3854e84c9f9a2079f04e033a3ee92b3762869e82766a981908bcfc1f95c678cff9d41f68b0f78813d3af7181b3e50b753fc247f994bf2335dfad2894ba84cc54eccc1ecf2eaaf03194ac8d456157b7bac9d9347db978afb894ab102b70cac7792025175765568d8faa7dc5b305cbf24a546d9c3539d2f413937e32013f47efa8359e4e95847661fa9f67accb0e7a30cbad98be9b08c0c097bad609f7d5de36732f5971767aaa146c1ee32ebe0490ee2acb5bbf5f2eea5ef129ebec0aa62c37b75ebd32b43e3dcb6eec54edd7b801fe93ff3f3d3faea19bbe2260cb128a8c3401d3ab7238c4c2bbe304099aa6f974a34ca21bf45ad08fa27c951cf507f4a1e5b7bd786c878a351a40c88cf1c0446e874df2cfd9f7f58e97169880673c614b548bf943ffac831b297c0f7235ecf5f53f6eda62aed688763cd1b06164c97cc9035ad24be406aecd21f762712a471d2dc1f10563c296b1828913f5f155dcab1cf5c2393477bac4f15e71c01e7d0a754cc2b30a2704af23a1c59ce13ec767e169e5de88d199dca4aefeb4feec35f2abab47a75969f148754ec2a7e0dfa085c5abd51bdac02f1edfd108d44eff762746bf5639ab8228d52b684dd472d69c5a68361e56d5ea06727d2a2d8245d52e16441007de4d37b4359d1457ec9741cd0fbebf4baf23c7a6df8e662611ba98e6b9bb7b59270a9c006bc5e423ac8f5d8882bad05eaf3971522c879792a2d1cddcf482cff38770bb04bee674d674973df29f6e7aec69fff2cf5715500e9771c59428694792d425a0c2ffee6ecfddb276a8f69b8f82422fcf8a7e8e03d7105a0b6f85b184187280dcccdc55f6c56aaeefe40bede71b16a22e2416c0f103859cb30309094966ba3f29fe9dfdbd1bd95077dfe600c0397952941b811f1ce33d1f5536098dd8566bc89641932fe631fa0e8739d94a41265db2cd491e84167ce374cbdc86de80ce1774e5b080cc0ddb1751d0ebb9b3a9f9a63fda088e9766f8fcf71db47fa4a7014f79e615dbc66bb996547d209a78cbbac5c9bb3e082ee40e43314f53a0779b574d67a443ff34b1964687acc7527b40c1cdea1c9d27b770cf67ca79f087a6fceae516d14c3f1232de446b3e06734281e5538610d2dc93271c4cb2244e576f4e3e24b311318ef9d251a03cd250f2bf22f58aae67551dd790bee347a6a66f587dce43c3c5ab6c2f7be99ecab044d4f29a8741bdcd18364e4d85c9ceeda549726321bdd10ead720634ecd535f4d4fb3c512ebf1178c5fad979fe2f666024b6bb7ad831f9dc7f6ed8c7c9f472b9d6e47e812983a7c695e65df16fa74f1586329ee55d4df1cbc420903e53895de3e2f2a8e6de26ded8077eb9435aba564d5b636865034a8873df2759ff3f6e22898760792d04ba2014dfc7f21e1b06fdfb1f7268a2294973ba09b1cf46881fc451a943be9fdbc88ff8d06928a5c50dfca8530ddd859c082cbf5f23f4fca025ec7275591c927d1fdfc196ab90a037ce0b734268948c1b3895ca33cbd6c449bb52f81385fe28c3da88496dd9760752633b11cd23c6e1025f71cc25a685216f34e1394215e310592499ebfc5b3aa739c8118ce71421584c5725f2d4570b79e2406298b906ae9f10dff21d1c868b6a05dfa1af15e7dc1965b5cabf0098fcd8fb79c8ba27c1750ece5fb03bad21bc9d9ea023108e66b4e742428d9baaf698581db889b259d9f8f1bf53f2106f27802cdd3909116dd05991cd7cc41229cd2cfe0e645fc7fcfcc4631e08a422db2840b6ce4522b9eeeb80866c0944fb01a7cf93754ba7ed980933be005df440b6eedf887ceebe86fadf8b56875c5fe48b2d7a0701386b8b5d3ba0fc4ef94e3541ff69cbb01307a8d76588e98984542aff518d92fa6c55921349f1614e581da3e63e02fc3809719665de974acc90cfe5a88097bd8f46deed8212794ef8ec4813fd9343f7a4436129ab86667ad5be1b056c35a04b9d5f3b70f94f17884a011b5281a185ab8720d3ee4c6cdd6f4f32baf028ccfa65acc2b4c4c364a7a3773aa9cb3b026d1d375b0cca35b0729225fd83d16e7f443f8cb0a0b1953a571a41908276b022e275200656ae7cb3d5961574db7a60d33e78f846238a73fcafd85f7c248a7eaff50c4a5dece0ae6dc618f492ea9b8f31918be45e64d23852729991e368491e77865656cf6d9b097c76b7782c8256bc84848fb9f618eb1523e06ebe007b7ec16e56f0f63b445a46e3a715cd8fc38a009b69601e0896641332ccca02103d065f90294a95166dd85084c4d1908432d31aac7f38a2bbc41dc44d83f0e88b28881640bd82b552bf3b9816e629e80dce6858f036c7434208ed442263a1dc750844a90a708433f37bd45e5e207b4eda75ad13d30d5f5da15ac720eb85bb16009f97e8325d81c41b22b3e2489b7b7d6fe3dd4d805994d30b0531e6b1f7b673aae252222c871be08711f5f47199c1477d4ce3d1d3bffe864d6d1dd537453fbfdbc7df8f54f455daf9d67eec2dfa1301297fb87f054b074cf23bb0d702c168d7fe36492a6c2f0d12329dced6f01e570329c452f5d0173bda351920a69e937e54f5e4c6c68c3190cb7a02e1e93d7a6031c41e194c419ace8cdc908fd60c42d8f1e5364cbe2a2a2644911f4544b9f0c2a02410c581fff850ccc8a7b08eafdaca8192bfa61c1581653a4e077fd5a8745fc0309d2e55834efd16beaa6de8d7a5f94d63762e8a3fdd4fa42043518e0a7c3072f48290d393efe8fba98d86ce067eaa2f95300ce3144afa717a81fd897e108b9376fe894d8ff692a0a10333b5d4216e0c56476dbdbc72fa56e8e2032ae748e70b9efb673dc2c7b6c2bfb8079a37d49a3fd8fe485734d6abcac3b1426f58a3374d09b168146ff47fbbde4d0f0bacb6a277dd24d7cd112e30ce95b07440db73b47814b805d3f71f95911608d32bed7fb31fe352ee5aad0a4fe6e4243fe008db3dcf7e3785dbcb19df3502eada55722f59a6710d7c42a23025d8e308b24d585c068fa647eead60ab2a972d19f263b7895a7478a4b56df33ea546369339b042904d8735afd1deda846267ad19c6be5ad955e6d178b859d4d0f39f2a5a03d2da53e6bf936730bc46a28060892fc1efc2e2da74305917e80ddcad4823964a2664b54cd33c39aaf46f10bb8e6e4d35620051d74d061c488ede1265364372cb0c8150ed913673d2a598e6a475983b84a688904b89872d99852d67d3af3309d6aad5acbb72464e084d28f402349c851be8f418179103875fe85f658adce7386812bf7cbfba5fef705bf8ecca24c420a394abf0fade10db313d1470b21288b9c52c71e2960a8c7be99a80071175f883b5100dcb697d9e8412a948f23bab0243a0447c29e8309d49238b5f60743e8b44c3b48e8fc97ea25215d3f99121dce821e6a4247de1ab3441e86310bcc0fb389d9365516262b70935893860a103bdebb557c26a2bfc7fc94877f547c6eaa5ff64e45e04a416f7756b7f2a95fd8a9eda02641cfc65b02ba0677bba6f1f581e457d54232260a3412a62c0c909d361bdb281cef3f941d4035a62c4da3d2e9e90cf7ab4582cda218fdf152a10d3a4131b2ffcf45893bf330873793db72fd2ed1fdde3242078bc21eea03ef8695d8ce89009a4954cfc147811a8c014b99722142ec38b282a40f697d538ddd67730df0fb6493f68ffd24380c2bbdc8f3e115401da0f9f59e9e66e9d82f75e1ec590b62a246d4c3f9d7dc4cadab2200391c34e0c513a0ec57915f228aa3c72d0a1d493ec1824de053f38476f66f1cda707d5d7133f6350a556c7dd7fc829cd26d3007c20fa65c7185461f01d851127eddf2b27b2a94ce06fed7b28220e6cb1cc267d55ff333b91cd39ddee1a5ad3a5cbdd88ea1b29c79c9e911f4639e1f587641be4873b7a95afe7ac8514a17cc049bb3489662fd9fed919edf80d3633f3ec80d85fec24b7725ae29d7f6ace36e5197773df32c26ecf6aae1c1cfab0f53b02fe9721d36aee742c8771f0fb9b03ba2465fd20a86afc925d2f00885343eec6cb795ada35200de8b2f4377f6ea7bd69a5c5014da9881b27aa90ef1c9e3368753625881af284f6cd26f03ad074182abeac95b23d7562bb18f89e0f2d3a6f3bed358c668dc1109ebc7a3b30ebf191ac4400f326ddcc63fdf8fe25c56258cfcb41f3fdf7b9d990133423cc71f798286e05ca149a593b68d09d57a6dded11d4728cce46fd8583ad19164a449557529b000c07be0dbccdeb19f8c63286943bb37749e959768a81033f4d0caeb5bf1cce563c20fa8d304b7784089cbc032a17a42f2defc93cd419f1620ad09fb3addcd654d07a17549670a9ce1cbd05173c3b49355248f10fbf8c89e14d0f7a701b0ba2c2ae9a09ee55e240b1199fb7c1aaab68c78bdce1f49a322b9695f0617240fbab886be5f817e641521bfb6beb9541e0c5deecdbbd639215ac7d583634ea433a4a551ef1a7446dd74afb20075baeed4413e43ef85aa5a5d63ba521950cbf7495b4e80f412ca82eaf570bd00cf8c97a5c1c3e74b1841252ca5ca4a5ab040758979fe986f2bd9b3b2bf7b9fb17d020fd9533430fa5f48204067714a6ee9fa17172a7e5f202418c22794e80a79f565162a967956906bb91278720a89ca21e85f797b22770f9546340f67ddd15efd3df70262e9798b033e4ee0cc5bd3892126cf7e29752a3418b5e57be5b44e396d0e285826c38e054b218aab46f6a41a25f6f2d3b24b1a4d704d21ccaba72ce67debf92e84369ff319347e15cdb226383837f9b33709f49779540600202ea7f91ccdf6caa2c8c5024aea43776516d6c86ecf2ecee403ec5efd375e5a165271300dc16d0899bce2d646c902da203b3d7582427cf87a72c67cd5ed94ea602bce141b4b3f9bb7ec4eac633de45a13a62556c2ecadcde1fb5a2bd852ee86b22dcfb2f0c784820854f15ffe3ff58f4367a3a5705731638e7adc8b4d1e92ff07a3d7138e111858c34c4ed8685e499606eb9c1f5e8a7ab3f774afa671af8c1bf008657c6a9a0c827e87b6d2feaf9e79f5a86edcfd91dbba79d0abf776bb0d035081400bb092df0887b91dcb39721c29888a1139670955aca68c9f0d1a16a528728f5a09f0cab8b272ea42f3016af0f17e09ae858fb4abc55816af97b70ff63393b33ffde4cd00471db9667819b3ae96c609823c83362c11f1f4f5dacf120e1b7727f7c3c4c63f8eebce0cda93982d5aaad38f90e5a15de54878d1487569017fa4ce8f97bd36dd15a8ab2b243a666249a1b5923b729a93cbeb4d68eb9d7ed12ac5cba099cbebfb6b59dc00ce0709365aee68920b94381812a97b6b968891f1bc32b7b615987cd68ba444748a84e5861a75069990ab6fc737fb09559983a4b0fb5d1cecbaffcf744f42e71f2f56d2a3b107aa62fef1d4dbbefad4fc40d7915187a6c949845dbc3a3b9cb294a9d0d9cd74b70e8c550a4b6e1ab8446fb0446854f3673952a81589032fe44c3c8c8e7568bc1dc89405b0c03be3474f4ade0b7a7d0d0892c5f0b8dad8f61e2ef8fe87c3c2fae4726bec5d336145b3ab6b3b8c4166f6a26a3023356b3d0b69194459675b1f21d7898e8658b0666d6d8be9af840b599747325241e7bd2e9e967b3a1356f8acbe8b882ebfe7e71f0a1e0d89a0cd7e5a3fa5e2f80110869f8d73efbf6a41f0fb1eb93292e3a4d0329098dd89bbedaf6672805dd79e52a60f0b8803061bcc410fc03b8aa675d79668902051051306aa4dcc4f08cf920d3819af778748f089887a01bf434612f926f49305e0a4520d914d1c14acad2bc734eafbdc026ae0253fd3f2ded16d418cf59d412477eb9e5eb2c5b70f5a09924530b761d0b75089cef9934d9afaef4bfa8445fd8e099d71db4fdf40581059dd1d9bfb6aad682f82b555b29e13326a50ad47c4cda8766d623088da120e7e9fe1a9412579ddd55329d1352edcbab6a506c0a9b62167c9af6b622f8fe5827f94a230c1ffac9ce72a447919938c9b646253c20ee54bca3a5e14c1495d46259d74a5681d4f17f781bc8b0c61452e49b3f1d70e185c05a6a19a13b9bab88bb0ee0e8c0c51b1389dd251a7fc9898ab3fca39bb986031d9c20eb081bfd24e57c10f5c0a42ee5c583ed3f2dda8a8cf2392a2a44a651a20ea67a8516bec05ab37a6d65d37ff96d653e25e1faecc27caf633446749b6aad49a657497d5cb182ca6d0f320d229d09282a60b7a6eb2964203033275b95d191d2b58836d047fa51230a08ae8744a97a476d705c2c32fe55b2d89be3b75fcff40b81d849bfd21db7e7b3e53fa85ab218c78e5fa984c595b66da67e34ad2d1ecdebc19e7d041f9c2ebbfc7e23242a4af85f8c3cf04b33e4a761beb6fa4dc73e8c3038449d51e9d8ee474e10169555a5406115a7458ffe1d12887dbbd6b6774df59687b70864f33f9b7869885ce524b75348d6badd4731306fd0fee1c57a2e3c48aaffeee4f8e5f01d9724b7ffe97527676e7c6717e5660708860b4008efe4af9059190a4309fddd6ae50d1a860d7a570a44738a7229eb2bace75ccc4c3145079c2cba6ab5c912cd07d5887af14e3b08697f54be42c058826bbcddb98f50af746a0a24a8fe9172ea153876502522c1f4055aa7f5f71ff80fdb0cb5410f89b27f32cde4688c6a93898c47a9f6545a8bdc20ebedd32d4b0dc4d7c212cf5759b69e9f0935068ccf8ea16e9e959bcbb31c5b171503be9edc1df5233555ca30b7d73123f3951bbf3c7c99906f0ebc97b1a015e39f174fdda7b53009d94962fc8042e8864d9145a46e119cc890f5a1b8f425f0ff26a16130dd33c4b8d2935834db8746edf2dc816fa58f1ba8549d912a699b4472dd2b975d5b2528b3c125f0a5a655f7a453380964db7c578cbd5c5837b1ad0a5d5fccee7901c06df2fb0758de96418ff9316eb90dbe4eea7d6c40c7e4b448702007c78f2a5c836021c27e073a5d9b98305305b8dbf03f3f85acf4265b598c9ac8d4c86eabaa568c0b4a12edefbd89f02a4b1bbb7e7392597eeb5a78637fbf97e1e0dbedfc4732ac67ea1cf9a3e2d063e493b1c71ce5f71754807ce8eeaacd62d9fdbf411852af25dd07006eeec93f951ac7e8edb70d701d5c9818aa8dc3755e24f98e2b95bd47f6e8102c925b25dffe3ae6f9e7f3ea54e71abf5a18e53aa9f0b003d8d74339fc2c10593560396116817afcf72b3f8eda35a5e828393d0a340565f6d9d4f16f652ab5b41bd960befd181e11a942c6146678986a3f901f0a57f372b465e5b493d5737f969d1cb3d262e6e908a6b0e7c79b117ef7e7f3a6338140ca56f9b085ec1e32f082b6e241bcac65f501a4e327f39c2f42a8fb65893f15797dcae924b6c10db333b40fe1dfff34df6940dff9f2b5049dda5d252be9f50929ba81bdd52aacd2af4a0eaa9ac40d60923dc9dada11ce44b2963c7c2d8dc90953563e46b01d05d3a2116dcb1059597bec9cf7632abc46a97a6c7bb178816aded78324ecd8c4fd4224813aa3f36146695deb1676415344f2f8fe1243d5e33e15064a1973daa2f71f6014fd0427c503b4a24b383cc7a82ddb9b1dcc3dd39839a7146e8086e0a495777d2aee49fd3552b08b4ffbe462f98692ab31bdc9e793fb41f2d76aabdf9a7cdaeaf647ff92c2a0e94842e9ed7dcb81b0f50361be4a2ff91cf2068759eae5638d26db9771f0672d5f2e9e1b245a5dc1ac524e51dd4a5ee13905ca95e1eb8e1876e47caf8b9858b666d7ac7abe874d9d49c05616f2d71c21be707bb872bc2273d532744b0583024def7ffd90201a3a8caf993a37ac9672c9b00f1ebc8704e2e055d1e0e5b23eec22efbab87f0d5db1a6d7bf19545530dc48d57b45c2df802759507a48393ca519a7bb68b4de8bd10a8fbbdf854b4a41204415600c332b81198350cd3368720fc1307cd17b2036352e9b9646fc8f94af0029b870120611616152b56f36af3f997dd1f5ba2de87e73a2383a4e6ba4e3f84360d5b94a3516bf550835699e671491d7fccb1cea312f20888f892c3f2ef6a5456d45962267bf6395f5e44ee12ccd0d1ece78f7293a316a62be10d8a2fae27576cf2c72ce526c1656e188f4a75f3f14f908e8c7660bb9cfa07fb650cf31557ec56ba906f1851bde45c1fd41d7331431ac7b7bd94145daa6096a7d38901c20caf18f85c7fcaad59c66d1a5b4c4327aaed83357b66ee58ad19913c181e65cb9f19d103058df4b8c3aad47810e2d4a3c047876068c8a0c10f6c44e3416bf0b4e3e81452093301a248255276143792b651df0541057295d884950bab6c14b0283a5c8c4d63d4f345c93c584f87da2f25636a571e29f511075f4636a7766b5118e554934bdb3db1532bd329295830265a8092b932755129cf519c95a2ac10758ebee6ae1c5ad3dad8039f92705c06ef1bbbe2efcfb7b5571c78e3f4c2a487c30232024abec1a91e4e5387503e94b0b7f3d79f79339da06798257b8f08e8ecee5489a4d8b4ec8fd872fb52c422f8c2de93c9936279b8874c389a009d93723ed80c9cc424828abc963f43a833e901189ebb42bd35511c634587574fbc2dc7fe9994dad179b7dfd7869348d82012f63a569143e84a3a11fa5549c7a7303a86fb1cec717fe52a258b46adf569c60076b4413641c497258e5828dfd34386de729da942de26988c27617a8967c29ff7993b07f1f2f1a2b5befde78aab1b4899e2d460a4c16d2288d944f23d3dfafd70ac3266df7899a12d45a869c5a9cefe0ea6fd3b5a71c7f438984451d260d1093aa8c690c2b42e97fd9b6f7747f77fcf3687ae94e41dd847cd354c65671c67601cede2198d14c1e733922e3088064489a5716fd0da9002a9a8841c713aba24650730a710df870531977e99e2278d27d1ad648e07d496cd366c4df7b2d1de098e2bd1ab6441b28289f3deb2ca0c78ba1e5e527a5802972e523a0f6b1c4cd403631fa2cf2118931fafd45421a2ada96591adf8f13a0d30f04da1775a006b04477a42098a357c73c14d5975313f007efbbe14e5fb80c18c7cc9e5779b797d31ed8d56d265fd0ab7027a56e869aa5ea9b1f226bf1636d8ef98ddc2e1ae5f7e924eb4f124e05a49f1414597635303d5c24e9421717aa0a49e5d64984d6307bdd1154818e2c416582ddc916dcc39030741dadb995a8e7aa64d06d835be7b0a16a1aa2cbbf2f62e934e6748a64e75b42082c0cb86bcde6e3a9c81324cd06afe190ad9fc9faeecaecd340119763ebf8c8f88170597dc8f11d066dfbb54971881be320c419556f1e0ce9d195a48431d9a15558754c5f2bbf5acf5dc5de30e09c470d0946a81c4424d4c14b82bb9d10f2d4ac6725a798b248f47dc127d62ed10cfcbb95893634186b29754ac7419cbeb3150619eb981206798fa3bee665f3f602ab21fa91eb3135d4138f9ce689d70bb9008c1cbe4d24887d68f18242637e5c7a96b64b836f3fbe2c094fc1c7c62f0904d398f1405a089b578a60cc19a7345d76a130671ca5a1b88aab66b611e0164fca1f70cd38019ba46795d4c6a8856ea2ab66c197dac0a9a436a5533d24b567b32883b4ad09025a86983f0e3289fcfc44dfe8baaec9b1a7e6a896925f227d116be235c82e12de50f706e974ef4fbb140257ff7b0cc7126ba195bca8d93fcfd210f59a25ffd4c419d8b1849c970bba24fcc73226384a22d7cdb2ccc7d0754bc879a4199fed4ede8793ebcb6c434b62d96d16f994336de262861149242cdcc9799f37ac59b5c499c0d480642223c431188a35d3538a2f2d4022edf66fdba093a62765be29b9c20bdae0f4878514a3bbeaba62a2d56ce24a27dc55385b2779035c8f1bbc2c24f595cade435779d3bbf6a8b91828b553c430224dbb69f4e6149f50dd80fe00fd0c93046672379ea8d7103c615e7429604326f9a38768b215f2c7494cc805713a022600a9d4bdf7c6970f6b6b2652d27c66286997ce7c1051c0d3c1cec019539d786bee5d0a38fc8a2dfef41f09bb37c18fcbc75163974ebf2c0ab01ecee9618ad1a9b2f9605461217276a916c89667715c67dc4eaf53f141549fa3f50f21c42eb329f09155870e0a932cdd442b44d1b34032d3654895555f7a623eea2a0bcb0627364891424f974fffeda9c53b9db61055ed95933bfa3623f2c0aaeedae64e393c14ff48ce7d452ae145a6b8c9ab170c8ffe49cbddb764c0cf03e4472f33b4c7b9ea69d42c7efc9c1921440b55f01cc022a07a9ba5dae2a7cd25c9529598275d084fec212bfc81beef16cc45c3191ba0c11017aa2363bf98550c7fda99dce259776df452a2effbf7f3750af50044ae2a1620ca6b492525ec1c4f2c2ba042e59b8e575bb3d3bed2463e241f7dc3a50fb331e84130cc7cf472eccbf3f72a33d97551a639c6ad914ee6ad18912150f79db0335de8b968dcce1bf986a2e11d355d4f06a77d353a3167e0289574a52767c6f39cd64c864c94dc954e453cfacd6825405d245d93a63e7d774399b833eb562c0e1438f6b86b43ec63f747e6a77721547e9a0053a808c50b8974910e701f423dacd64d4cd4ed6f88795ee1aba557590c2a03dcda5a603ec69f2e64db354cb2c618029bc8d158d2b97297e5997291198b847679f8d3adaa89ec640aa9c86f434027d790d435bb4ef2c52c911c91cbd7ec62a0e41623c56d5cb70f24aed7fe716b1cdcd254ca2733487f8d13c8455f8b1482b6601c2993a739151d1111528bc7830f98ac19f1705e3c6c3ff63b3a6f58a213a7bd5c7dcef1526cf3fabdcbe6e988a66a75483d81aeb1c47ffcceb371c0914c21bbd51b61a41584b065cc5b05289d60f1a68357a8c3f0a3875e611a06ae2a9f683ae5a44c094199a3df5285bb4db47f10b262633436ae48a4e17b6c77dd6092d6f41ac745b78367f37b070f59b565268f4a0d86488ea03eb85f825d1ec1f7cb4dc28bca4ed12cd2badbd5df91590848454f802e060dcfa45c34c2f9fa7801bac9dc3918c61aa1dbf34da6f9583da00a03db32f760ba1cb24f9a3e2ae14e84207ecc26a1b7a024d15a1fea56e40e305a681dd9459ccf2bd7a11ad3e567dd78716335a5cfc3be84e8d5a0bb4651874e964e35200e5eca065f452d30fef0bbe31a1484338030a50c6f9a03339299acf553eef0bad4828cf5955471e5a5a526e15f6e1be3e533022c68988e7c15cd690a7f1eb54d68a75f609589ad4ed807e3448840c90c1abcf72d36b4c3b4816e07697e377574d36924c38798957465b648fbddf2674f1e58258ca383e463692bd1a80ede2448a115c9216f8588cd63b6465bcd97b80c6b2cb5bc719d7f116af38583c27f2154a5b01711a8d425836375925f5e9ebe7f6e9447ef2e4178bcafda15b8057538b0188223ba5f31dc6a9e6655a3a657b971d9684c762b3e20886e6b33a03943225eb87218e5db0467f4e38b4a5dc46edd736ecf2b9e690e98544758fb66146a7c22a96cda0a8a283809a0873b7ccb19b38c34d060ae26ca83c3bf40eeb2e8428e34dbac56d36002a40fd7b9fc5646624e2fbbc2e02949e452e3c26334fc3c46f25ed48cbbed7fa9d64cfabee2b5a235e99def7e772ec5fe7f63d8767c70c2905199837c0060c4f76637dbf18fc359ed8e1760d5d5a403ec84f1e8062a5d7fc666258f7c3fc0d65ae37d4f3c47614f05fd451c46590556b4d63d0042b1d18073d5b69211875b89aff71c2a7ccc0b4b0cec10f434f495d2bb84f2ec94eacac69bdd81ad67dd4ecc272a47287b7f4471abda6cdcacbe3bedb26f639b0d2c989dc00639fb24c267cb61e4e277f84ec661bcf41934a0aa3339e85d13f36c4559122ee1e014d620d7be28aceb4d29a2034f5e99c456ea843a3d84816bfb756e79afbdea51943a7e80485a42da62d0e9d5f05f980ea09a7e4930cea5eafd8524f755083a78a1218bff9d1b4ea67e1e94a7568237360d54ed25e13d5acb86917e3337edc741b2f8302ca65f0f70c401f8209a07a04946f441142f721c0c128efb080108f0ade1c810928e38f25f81e26d77b6b3cc43696f92fb51db3cf8d3a75fc4ce1915c9600cd6dfb181278ce34ce0e57eee6dea68449a69898003030f007f2b7bbf54e4aeb47a5ff8e16389020502fdaa730eab3bc525c9e26404239ce4f7eff82096f8e294f11a085cd32a399ad17ffac89656e8353d8e13bc254711520955f55484d0b588afb0f598b7092c022b7274d1a4ac9a0d47aa948055a50c9f23e3218afc0083c80cc8216b2248240dd5ad7726f2c9755e1ecf958ad9056d13e161b1a4056cc3a9072fb9c05ad61a532a2f32ba090fbed087a1772f2d6e316194c1ddfe63c64fc1d1fac095c7f9ac8eb68f16075dd395d7728369cceff02b4b7f915246d296aa94d8883e5a5317e32d026547f0e2d9a7feff1bc8ce03699aab8b5e1522a1965ec7f59822b8bf85596351771b3cbe6bfb922d5b5fd7b459c249cec27187230455b79310716b5d7ce0212d84c26987dd6e21439fd06d7e15471cd644b400d0049c274ac719729660b506e85e6e62d0e10e486bd48f4ae6a7f3cd7f7c6a093dfe598a098d2c4cf8d35556534a859b2e79beaea958ded0966a10c28976d95c3d26d74b0cbe0a9af07cfa99351aa2241234a7320d57567a0b45b5c13c8914fb3236230fa32de84c4a4ce87a0698fb02f73e63ea4e74fe8ed52596a0ef95239f207b45ee5d1fefc6e608c34155d43e53d16123ba9dc09f522fb44123cecfadae6f9f79b2a3a49f25d614dba1cb466686841ba51f627566dc65ae561f8e00e8c7ec584fc7a1be6089fb62f03f498cc9575646d3e04c2f79e609d74713fcb4dbbedd015f735b9d35270d567fd00198c2e6030030f4f362b4995274b5114eec74e5b3ca0124e7a6079b5719271fdb496516c15b9ad8ddb8e27a0f92dbca8968cc0f9200c99396337ebbd107c43ea5291c8e83a58945f1314d50976ae153c7491c34cc4ebb16832be6563e92f7719b19d9247c678ecbf3aeec1b847fb6fcc434b6f666421e2b62431dc583cd028d9eb58e770450ad4f5be125080ab0b0b350b2e3d58e8b1c665c6a30e3640d9d848992b132457620742959183323da0c016d6b1619bfb93dcb884f8f5182724f507addb661c3b5f972ae148bbf2829fd4dcf86cadfe6bffe5d124c7a80fa9f45def890c1ed52672bd50e0c2bcfbecd4415e9a3217b195dc67281e05874d90c0865f95e2cc45e4c645d14d5df4a53ee001e197871664e27d2cbf97569d833bc85b126a6ffadb7bada195cf3cca9be26bf568acca78edbafd577a9995ca3da7c2614ea665a47983c36f2238c378e53f332990fabc75a37dc27e6913f17d4c21e984422394dc3b23615de2d48bb21aca27ac1d5222692f65f738fac58d6976c1d5749683995e1776f98e602a773970db14e52716b497efd83a59257ad1affa584ddc861d5033c16de058c7ef1537a37178a42c936a87c23a9ef129f856c67d1e6ff17d971141410e079fadb10a307e009dbaadf35fa17d7335fc6c49462b780959227cd4794e0775eeccbcc180dc59391ca81f1b3c323a65775df9775f021179fcfe1c231b27b104564cbe88d9dbf60c8374ccc25ec62ff6fadc7bc84f4774547639aea717f7eba30ea655a9b4c8e9739498b840695af7e8bc32e650b24993470e4909ec71618ed7ecebab52898fde713925591adfb14af3526c12053069d6d132dd0b1b736e13f60c81546349bff1d8844be3634463861f7348aa71b389b09e63d2a97da78d85e2bd0e3f71ba46dc7a7038aad1091b27673e8823b909a2d3e0343482d4452ee70c12f75c161498012d90143cd3e1acbc392b6e63e5fec9234fd1196cd9b0856a7572f744bbb91c632d8bdf363b46c27d98d4b264d88cc1af26d7ac2e616a9d271b46bfc24615c9cc901a3857541278cb33b7891e5d497c7a8d576f689a8c4c54f7e60ed9a7d22b8b489eb3be9e7381daf34af91d37037081cf331cc6f3a9aee07421b18357110bf546e1a518c811c9784bfe4f55b355ef8320ff7101ee68d0576912c71e17229b9ee32eca7267f95ceb9aab3afe18944d845f0046d018c15d9221adc8eb692d569ed7b9ceeba418bf92a896d0ffb01dfbd9e2a0c38aeb6f0df6f826f4e98ff293661e7ac748a5f3e1190b78807702c0f946aa8f22441c0c4db2e543e8bcee63a0ac16c141c9871af8f7ed12060bc75b593f364e193ae622cb06c73929849c7030d5baf26c58bce30951e311c59625b7d62e33f6550b164d33a78275aeb545607277a9d31a16b22203696cf3deb7858252c4faefe6594fc36f40b40d403cd971a1dc542fee477a63789a43bdc20c763be58f2baac592bd6a0bf6a20058fbfb0d089896343d50cab639e76d568989ce85ee9203f098012638ce94392e47fccd35de81274cbc78ba2ae9b91701ace0c7cd68eca0071493176a1556791bde3525d7c4355b09622123421d4d2dff6aba1112ad0373cc996f3cf57336e88e4369fe10286490d79ceb6b9e346d335cad7c88c36f5163f2f3ad1b6fa8d0c3dff08916f010d509cc3d9e7065dbbbea5e0d0142e7b6b8713eda7129c21819821a2c9360c02ca7fb4331d1d2a2d943d67d624e55cfcbd398ae79be23ab7a2846c4d0f0fda9fd43e498e5d3d69699d68b3ae63c7739eba81cb8b0a334d83a8a6c14caf7a39cb14ff71815accdb6789d459d9abba53a65d432d6a927dbdf0b48032149522d761ba731c997875867442f83ecab9205c0f7431a12f1da3948f9c7011dad7f2dd1229c2771efe523d015ed6ed4f8c5700f8f30fabd398f87157a39e52420b7e20d5da51a85adfc35c91fe0bff341107d97b28106381681b0e5d5b8214cad9bf5674915287c0fe162bd4cfc9675ec5ccf6a01301fc6e56864a554e03a193cbd45743ab6edb940c6ae84d17f9d0bf62637cb21c88587b07f3afb4032b70b2fe784d94061a80fc86dfe48a5de669e9712a348a136ed6b99a96b92ea322775affeb2569ae43ce8cff2ebf9f2d1f2b12302b28356cd9486ba20ed69989c3a4d5e32ae6c69cf17f0b5f1953a2ff6de6362c5961581fa1a8b6b799ba72e846ddbe185ee311715cc18057667975f5c8c9ef04a9259d408a77cd76bb921cd3de8d5ea31478f91f1ed9dcc8e2fe208e33c18609ea1bbae4d36e6a4731032f2550aac901fcd738c4d6f2841c47d62b6ed1ef0836e820bd7310b9fd734bb732c4d99a67417b677117eeeec9bb3acf57912d97777374fe3e182f1d171f47442e69026f3e22c456fa4552ae025a4613a9677b26bc6be9b80d20888dd8d67d5c11c96a06f8136080</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","more":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","origin":"<p>我们都知道Redis是内存数据库，它将自己的数据存储的内存中。这样一旦服务器进程退出(断电、重启等原因)，那么数据将会丢失。为了解决这个问题，Redis提供两种持久化的方式来将数据持久化到硬盘上，即内存快照(RDB)与AOF日志。<br><a id=\"more\"></a></p>\n<h3 id=\"1-什么是内存快照\"><a href=\"#1-什么是内存快照\" class=\"headerlink\" title=\"1 什么是内存快照\"></a>1 什么是内存快照</h3><p>所谓内存快照，顾名思义就是给内存拍个照，在某个时刻把内存中的数据记录下来，以文件的形式保存到硬盘上，这样即使宕机，数据依然存在。在服务器重启后只需要把“照片”中的数据恢复即可。</p>\n<p>RDB持久化就是把当前进程的数据在某个时刻生成快照(一个压缩的二进制文件)保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p>\n<h4 id=\"1-1-RDB文件的创建\"><a href=\"#1-1-RDB文件的创建\" class=\"headerlink\" title=\"1.1 RDB文件的创建\"></a>1.1 RDB文件的创建</h4><p>RDB文件的创建可以手动触发，也可以自动触发。</p>\n<h4 id=\"1-1-手动触发\"><a href=\"#1-1-手动触发\" class=\"headerlink\" title=\"1.1 手动触发\"></a>1.1 手动触发</h4><p>手动触发分别对应save和bgsave命令：</p>\n<h5 id=\"1-1-1-save命令\"><a href=\"#1-1-1-save命令\" class=\"headerlink\" title=\"1.1.1 save命令\"></a>1.1.1 save命令</h5><p>save命令会阻塞当前Redis服务器，直到RDB过程完成为止。在服务器进程阻塞期间，服务器不能处理任何命令请求。因此，当save命令正在执行时，客户端发送的所有命令都会被拒绝，知道save命令执行完毕。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt;save <span class=\"comment\">//等待，直到RDB文件创建完毕</span></span><br><span class=\"line\">ok</span><br></pre></td></tr></table></figure>\n<p><strong>注意:</strong></p>\n<p><strong>Redis的单线程模型就决定了，我们要尽量避免所有会阻塞主线程的操作，由于Save命令执行期间阻塞服务器进程，对于内存比较大的实例会造成长时间阻塞，因此线上环境不建议使用。</strong></p>\n<h5 id=\"1-1-2-bgsave命令\"><a href=\"#1-1-2-bgsave命令\" class=\"headerlink\" title=\"1.1.2 bgsave命令\"></a>1.1.2 bgsave命令</h5><p>bgsave命令会派生出一个子进程(而不是线程)，由子进程进行RDB文件创建，而父进程继续处理命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt;bgsave</span><br><span class=\"line\">Background saving started   //直接返回，由子进程进行RDB文件创建</span><br><span class=\"line\">redis&gt;\t\t\t\t\t  \t//继续处理其它命令</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/Redis%20%E6%8C%81%E4%B9%85%E5%8C%96bgsave%E6%B5%81%E7%A8%8B.png\" alt=\"Redis 持久化bgsave流程\"></p>\n<p><strong>注意:</strong></p>\n<ol>\n<li><strong>在bgsave命令执行的时候，为了避免父进程与子进程同时执行两个rdbSave的调用而产生竞争条件，客户端发送的save命令会被服务器拒绝。</strong></li>\n<li><strong>如果bgsave命令正在执行，bgrewriteaof（aof重写）命令会被延迟到bgsave命令之后执行，如果bgrewriteaof命令正在执行，那么客户端发送的bgsave命令会被服务器拒绝。</strong></li>\n<li><strong>虽然bgsave命令是由子进程进行RDB文件的生成，但是fork()创建子进程的时候会阻塞父进程（详情请往下看）。</strong></li>\n</ol>\n<h4 id=\"1-2-自动触发\"><a href=\"#1-2-自动触发\" class=\"headerlink\" title=\"1.2 自动触发\"></a>1.2 自动触发</h4><p>因为bgsave命令可以在不阻塞服务器进程的情况下保存，所以redis可以通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次bgsave命令。如：我们向服务器设置如下配置(这也是redis默认的配置):</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save <span class=\"number\">900</span> <span class=\"number\">1</span></span><br><span class=\"line\">save <span class=\"number\">300</span> <span class=\"number\">10</span></span><br><span class=\"line\">save <span class=\"number\">60</span>  <span class=\"number\">10000</span></span><br></pre></td></tr></table></figure>\n<p>那么只要满足如下条件中的一个bgsave命令就会被执行：</p>\n<ul>\n<li>服务器在900秒内对数据库进行了至少1次修改</li>\n<li>服务器在300秒内对数据库进行了至少10次修改</li>\n<li>服务器在60秒内对数据库进行了至少10000次修改</li>\n</ul>\n<h4 id=\"1-2-RDB文件的载入\"><a href=\"#1-2-RDB文件的载入\" class=\"headerlink\" title=\"1.2 RDB文件的载入\"></a>1.2 RDB文件的载入</h4><p>在Redis启动的时候，只要检测到RDB文件的存在，就会自动加载RDB文件。需要注意的是</p>\n<ul>\n<li><p>因为AOF文件的更新频率通常比RDB文件的更新频率高,所以口如果服务器开启了AOF持久化功能,那么服务器会优先使用AOF文件来还原数据库状态。</p>\n</li>\n<li><p>只有在AOF持久化功能处于关闭状态时,服务器才会使用RDB文件来还原数据库状态。</p>\n</li>\n</ul>\n<p><strong>注意:服务器在载入RDB文件期间,会一直处于阻塞状态,直到载入工作完成为止</strong></p>\n<h3 id=\"2-内存快照的问题\"><a href=\"#2-内存快照的问题\" class=\"headerlink\" title=\"2 内存快照的问题\"></a>2 内存快照的问题</h3><p>了解了什么是Redis的RDB持久化，我们来思考两个问题。</p>\n<h4 id=\"2-1-快照的时候数据可以修改吗\"><a href=\"#2-1-快照的时候数据可以修改吗\" class=\"headerlink\" title=\"2.1 快照的时候数据可以修改吗\"></a>2.1 快照的时候数据可以修改吗</h4><p>Redis RDB持久化是对<code>某一时刻</code>的内存中的<code>全量数据</code>进行拍照。这让我们不得不思考，快照的时候数据可以修改吗？</p>\n<p>首先，如果我们使用<code>save</code>命令做持久化，那么由于Redis单线程模型的原因，在持久化的过程中会阻塞，是不能执行其它命令的。也许有人会说可以使用<code>bgave</code>命令，但使用<code>bgsave</code>就没有问题了吗？</p>\n<p>我们在拍照的时候，通常摄影师是不让我们动的，因为一动可能照片就模糊了。在Redis 进行内存快照的时候也会如此。如果我们持久化的过程中，有些数据被修改了。那么就会破坏快照的正确性与完整性。</p>\n<p>比如在t时刻,我们对内存进行快照，此时我们希望的是记录下来t时刻内存中所有的数据，假设我们的RDB操作需要10s的时间，而t+2s我们执行了一个修改操作把<code>Key1</code>的值由A修改成了B，而此时RDB操作却还没有把<code>Key1</code>的值写入磁盘。在t+5s的时候读取到<code>key1</code>的值写入磁盘。那么此次快照记录的<code>Key1</code>的值就是B，而不是t时刻的A。这样就破坏了RDB文件的正确性。</p>\n<p>RDB文件的生成是需要时间的，如果快照执行期间数据不能被修改，对于业务系统来说不能接受的。那么Redis 是如何解决这个问题的呢？</p>\n<p><img src=\"https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/Redis%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.png\" alt=\"Redis写时复制\"></p>\n<p>Redis 借助了操作系统提供的写时复制技术（Copy-On-Write, COW），可以让在执行快照的同时，正常处理写操作。简单来说，bgsave  fork子进程的时候，并不会完全复制主进程的内存数据，而是只复制必要的虚拟数据结构，并不为其分配真实的物理空间，它与父进程共享同一个物理内存空间。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，此时会给子进程分配一块物理内存空间，把要修改的数据复制一份，生成该数据的副本到子进程的物理内存空间。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p>\n<h4 id=\"2-2-可以频繁进行快照操作吗\"><a href=\"#2-2-可以频繁进行快照操作吗\" class=\"headerlink\" title=\"2.2 可以频繁进行快照操作吗\"></a>2.2 可以频繁进行快照操作吗</h4><p>假设我们在t 时刻做了一次快照，然后又在 t+n 时刻做了一次快照，而在这期间，发生了数据修改。而此时宕机了，那么，只能按照 t 时刻的快照进行恢复。那么这n秒的数据就彻底丢失无法恢复了。</p>\n<p>所以，要想尽可能恢复数据，就只能缩短快照执行的时间间隔，间隔的时间越小，丢失数据也就越少。那么可以频繁的执行快照操作吗？</p>\n<p>我们知道bgsave 执行时并不阻塞主线程，但是这不代表可以频繁执行快照操作。</p>\n<p>一方面，持久化是一个写入磁盘的过程，频繁将全量数据写入磁盘，会给磁盘带来很大压力，频繁执行快照也容易导致前一个快照还没有执行完，后一个又开始了，这样多个快照竞争有限的磁盘带宽，容易造成恶性循环。</p>\n<p>再者，bgsave所fork出来的子进程执行操作虽然并不会阻塞父进程的操作，但是<code>fork</code>出子进程的操作却是由主进程完成的，会阻塞主进程，fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间也就越久。</p>\n<p>也许有人会想到是否可以做增量快照呢？也就是只对上一次快照之后的数据做快照。</p>\n<p>首先思路肯定是可以，但是增量快照要求记住哪些数据上一次快照之后产生的。这就需要额外的元数据来记录这些信息，会引入额外的空间消耗。这对于内存资源宝贵的 Redis 来说，并不是一个很好的方案。</p>\n<p>如果不能频繁执行快照操作，那么该如何解决两次快照之间的数据丢失的问题呢？Redis 还提供了另外一种持久化方式——AOF(append to file)日志。关于AOF日志会在下一篇文章中进行总结！</p>\n","encrypt":true},{"title":"Redis对象——字符串(String)","copyright":true,"date":"2019-12-24T06:38:45.000Z","keywords":"Redis String","aside":"redis","_content":"### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章简单介绍了`Redis`的对象系统。`Redis`使用对象来表示数据库中的键和值每个对象都由一个`redisObject`结构表示,该结构中和保存数据有关的三个属性分别是`type`属性、 `encoding`属性和`ptr`属性。\n\n<!--more-->\n\n```c\ntypedef struct redisObiect{\n\t//类型\n\tunsigned type:4;\n\t//编码\n\tunsigned encoding:4;\n\t//指向底层数据结构的指针\n\tvoid *ptr;\n}\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;字符串对象是 Redis 中最基本的数据类型,也是我们工作中最常用的数据类型。redis中的键都是字符串对象，而且其他几种数据结构都是在字符串对象基础上构建的。字符串对象的值实际可以是字符串、数字、甚至是二进制，最大不能超过512MB 。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2.png)\n\n### 一、内部实现\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis字符串对象底层的数据结构实现主要是int和简单动态字符串SDS(这个字符串，和我们认识的C字符串不太一样，了解具体请看[图解Redis之数据结构篇——简单动态字符串SDS](https://www.cnblogs.com/hunternet/p/9957913.html))，其通过不同的编码方式映射到不同的数据结构。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1.png)\n\n字符串对象的内部编码有3种 ：`int`、`raw`和`embstr`。Redis会根据当前值的类型和长度来决定使用哪种编码来实现。\n\n1. 如果一个字符串对象保存的是整数值,并且这个整数值可以用`long`类型来表示,那么字符串对象会将整数值保存在字符串对象结构的`ptr`属性里面(将`void*`转换成`1ong`),并将字符串对象的编码设置为`int`。\n\n   ![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-int.png)\n\n2. 如果字符串对象保存的是一个字符串值,并且这个字符串值的长度大于32字节,那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值,并将对象的编码设置为`raw`。\n\n   ![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-raw.png)\n\n3. 如果字符串对象保存的是一个字符串值,并且这个字符申值的长度小于等于32字节，那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值，并将对象的编码设置为`embstr`\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-embstr.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;`embstr`编码是专门用于保存短字符串的一种优化编码方式，我们可以看到`embstr`和`raw`编码都会使用`SDS`来保存值，但不同之处在于`embstr`会通过一次内存分配函数来分配一块连续的内存空间来保存`redisObject`和`SDS`。而`raw`编码会通过调用两次内存分配函数来分别分配两块空间来保存`redisObject`和`SDS`。Redis这样做会有很多好处。\n\n* `embstr`编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次\n* 释放 `embstr`编码的字符串对象同样只需要调用一次内存释放函数\n* 因为`embstr`编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用CPU缓存提升性能。\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis中根据数据类型和长度来使用不同的编码和数据结构存储存在于Redis中的每一种对象类型上。其这种小细节上的优化令我叹服不止，后续我们会看到Redis中到处都是这种内存与性能上的小细节优化！\n\n### 二、常用命令\n\n&nbsp;&nbsp;&nbsp;&nbsp;字符串类型的命令比较多 ,我们先来了解几个日常开发中常用的。\n\n#### 1 设置值\n\n```shell\nredis> set testKey testValue\nOK\n```\n```shell\nset key value [ex seconds] [px milliseconds] [nx|xx]\n```\n\n* `ex seconds`：为键设置秒级过期时间。\n\n  如命令:`set username xiaoming ex 100`相当于执行下面两条命令\n\n  ```shell\n  SET username xiaoming \n  EXPIRE username 100\n  ```\n\n  `set key value [ex seconds]`操作是原子性的，相比连续执行上面两个命令，它更快。\n\n* `px milliseconds`：为键设置毫秒级过期时间。\n\n* `nx`：键必须不存在，才可以设置成功，用于添加。\n\n  ```shell\n  //mykey 不存在\n  redis> set mykey \"Hello\" nx\n  (integer) 1\n  //mykey 已经存在\n  redis> set mykey \"World\" nx\n  (integer) 0\n  redis> GET mykey\n  \"Hello\"\n  redis> \n  ```\n\n  由于`set key value nx`同样是原子性的操作，因此可以作为分布式锁的一种实现方案。\n\n* `xx`：与nx相反，键必须存在，才可以设置成功，用于更新 \n\n\n以上几个命令的替代命令是`SETNX`, `SETEX`,`PSETEX`，但是由于`SET`命令加上选项已经可以完全取代`SETNX`, `SETEX`,`PSETEX`的功能，所以在将来的版本中，redis可能会不推荐使用并且最终抛弃这几个命令。\n\n#### 2 获取值\n\n```shell\nget key\n```\n\n返回`key`的`value`。如果key不存在，返回特殊值`nil`。如果`key`的`value`不是string，就返回错误，因为`GET`只处理string类型的`values`。\n\n```shell\nredis> GET nokey\n(nil)\nredis> SET mykey \"Hello World\"\nOK\nredis> GET mykey\n\"Hello World\"\n```\n\n#### 3 批量设置值\n\n&nbsp;&nbsp;&nbsp;&nbsp;由于Redis目前的应用非常广泛，目前大多数公司对Redis的调用基本都会有一层自己的封装，看起来就像是在调用本地缓存一样，对于批量性的操作，一些对于Redis不太了解的可能就像使用本地缓存一样进行循环set。这样对性能是有很大的损耗的。实际上Redis提供了批量操作的命令。\n\n```shell\nMSET key value [key value ...]\n```\n\n对应给定的keys到他们相应的values上。`MSET`会用新的value替换已经存在的value，就像普通的`SET`命令一样。如果不想覆盖已经存在的values，可以使用`MSETNX key value [key value ...]`\n\n注意:`MSET`是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。\n\n```shell\nredis> MSET key1 \"Hello\" key2 \"World\"\nOK\nredis> GET key1\n\"Hello\"\nredis> GET key2\n\"World\"\n```\n\n#### 4 批量获取值\n\n```powershell\nMGET key [key ...]\n```\n\n结果是按照传入键的顺序返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。\n\n```powershell\nredis> SET key1 \"Hello\"\nOK\nredis> SET key2 \"World\"\nOK\nredis> MGET key1 key2 nokey\n1) \"Hello\"\n2) \"World\"\n3) (nil)\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis可以支撑每秒数万的读写操作，但是这指的是Redis服务端的处理能力，对于客户端来说，一次命令除了命令时间还是有网络时间，如n次get操作\n\n使用`get`命令\n\n```n次get时间 = n次网络时间 + n次命令时间 ```\n\n而`mget`操作\n\n```n次get时间 = 1次网络时间 + n次命令时间 ```\n\n而在实际开发中因为Redis的处理能力已经足够高，性能瓶颈的因素往往是网络。 \n\n学会使用批量操作，有助于提高效率，但是要掌握一个平衡的度，每次批量操作所发送的命令数并不是无节制的由于Redis是**单线程架构**，如果数量过多可能造成Redis阻塞或者网络拥塞。 \n\n#### 5 计数\n\n```powershell\nincr key\n```\n\n对存储在指定`key`的数值执行原子的加1操作。\n\n如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为`0`。\n\n如果指定的key中存储的值不是字符串类型（fix：）或者存储的字符串类型不能表示为一个整数，\n\n那么执行这个命令时服务器会返回一个错误(eq:(error) ERR value is not an integer or out of range)。\n\n这个操作仅限于64位的有符号整型数据。\n\n**注意**: 由于redis并没有一个明确的类型来表示整型数据，所以这个操作是一个字符串操作。\n\n执行这个操作的时候，key对应存储的字符串被解析为10进制的**64位有符号整型数据**。\n\n事实上，Redis 内部采用整数形式（Integer representation）来存储对应的整数值，所以对该类字符串值实际上是用整数保存，也就不存在存储整数的字符串表示（String representation）所带来的额外消耗。\n\n```\nredis> SET mykey \"1\"\nOK\nredis> INCR mykey\n(integer) 2\nredis> GET mykey\n\"3\"\nredis> \n```\n\n除了`incr`命令， Redis提供了`decr（自减）` 、 `incrby（自增指定数字）` 、`decrby（自减指定数字）` 、 `incrbyfloat（自增浮点数）`  \n\n```\ndecr key\nincrby key increment\ndecrby key decrement\nincrbyfloat key increment\n```\n\n#### 6 其它\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于常用的redis字符串命令和一些其它的命令我们列一个表格以便来更直观的看到。\n\n| 命令                                               | 描述 | 时间复杂度 |\n| -------------------------------------------------- | ---- | ---------- |\n| `set key value [ex seconds] [px milliseconds] [nx|xx]`| 设置值 | O(1) |\n| `get key` | 获取值 | O(1) |\n| `del key [key ...]` | 删除key | O(N)(N是键的个数) |\n| `mset key [key value ...]` | 批量设置值 | O(N)(N是键的个数) |\n| `mget key [key ...]` | 批量获取值 | O(N)(N是键的个数) |\n| `incr key` | 将 key 中储存的数字值增一 | O(1) |\n| `decr key` | 将 key 中储存的数字值减一 | O(1) |\n| `incrby key increment` | 将 key 所储存的值加上给定的增量值（increment） | O(1) |\n| `decrby key increment` | key 所储存的值减去给定的减量值（decrement） | O(1) |\n| `incrbyfloat key increment` | 将 key 所储存的值加上给定的浮点增量值（increment） | O(1) |\n| `append key value` | 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾 | O(1) |\n| `strlen key` | 返回 key 所储存的字符串值的长度。 | O(1) |\n| `setrange key offset value` | 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始 | O(1) |\n| `getrange key start end` | 返回 key 中字符串值的子字符 | O(N)(N是字符串的长度) |\n\n### 三、常用场景\n\n&nbsp;&nbsp;&nbsp;&nbsp;reids字符串的使用场景应该是最为广泛的，甚至有些对redis其它几种对象不太熟悉的人，基本所有场景都会使用字符串(序列化一下直接扔进去)。在众多的使用场景中总结一下大概分以下几种。\n\n#### 1. 作为缓存层\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF--%E7%BC%93%E5%AD%98%E5%B1%82.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上图，Redis经常作为缓存层，来缓存一些热点数据。来加速读写性能从而降低后端的压力。一般在读取数据的时候会先从Redis中读取，如果Redis中没有，再从数据库中读取。在Redis作为缓存层使用的时候，必须注意一些问题，如：缓存穿透、雪崩以及缓存更新问题......\n\n#### 2. 计数器\\限速器\\分布式系统ID\n\n&nbsp;&nbsp;&nbsp;&nbsp;计数器\\限速器\\分布式ID等主要是利用Redis字符串自增自减的特性。\n\n* 计数器：经常可以被用来做计数器，如微博的评论数、点赞数、分享数，抖音作品的收藏数，京东商品的销售量、评价数等。\n* 限速器：如验证码接口访问频率限制，用户登陆时需要让用户输入手机验证码，从而确定是否是用户本人，但是为了短信接口不被频繁访问，会限制用户每分钟获取验证码的频率，例如一分钟不能超过5次。\n* 分布式ID：由于Redis自增自减的操作是原子性的因此也经常在分布式系统中用来生成唯一的订单号、序列号等。\n\n#### 3. 分布式系统共享session\n\n&nbsp;&nbsp;&nbsp;&nbsp;通常在单体系统中，Web服务将会用户的Session信息（例如用户登录信息）保存在自己的服务器中。但是在分布式系统中，这样做会有问题。因为分布式系统通常有很多个服务，每个服务又会同时部署在多台机器上，通过负载均衡机制将将用户的访问均衡到不同服务器上。这个时候用户的请求可能分发到不同的服务器上，从而导致用户登录保存Session是在一台服务器上，而读取Session是在另一台服务器上因此会读不到Session。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%AF%8F%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%8F%AA%E8%83%BD%E8%AF%BB%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84Session.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;这种问题通常的做法是把Session存到一个公共的地方，让每个Web服务，都去这个公共的地方存取Session。而Redis就可以是这个公共的地方。(数据库、memecache等都可以各有优缺点)。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%20Session%E5%85%B1%E4%BA%AB.png)\n\n#### 4. 二进制存储\n\n&nbsp;&nbsp;&nbsp;&nbsp;由于Redis字符串可以存储二进制数据的特性，因此也可以用来存储一些二进制数据。如图片、 音频、 视频等。\n\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","source":"_posts/技术实践/redis/Redis对象——字符串(String).md","raw":"---\ntitle: Redis对象——字符串(String)\ncopyright: true\ndate: 2019-12-24 14:38:45\ntags: \n- Redis\ncategories: Redis\nkeywords: Redis String\naside: redis\n---\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章简单介绍了`Redis`的对象系统。`Redis`使用对象来表示数据库中的键和值每个对象都由一个`redisObject`结构表示,该结构中和保存数据有关的三个属性分别是`type`属性、 `encoding`属性和`ptr`属性。\n\n<!--more-->\n\n```c\ntypedef struct redisObiect{\n\t//类型\n\tunsigned type:4;\n\t//编码\n\tunsigned encoding:4;\n\t//指向底层数据结构的指针\n\tvoid *ptr;\n}\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;字符串对象是 Redis 中最基本的数据类型,也是我们工作中最常用的数据类型。redis中的键都是字符串对象，而且其他几种数据结构都是在字符串对象基础上构建的。字符串对象的值实际可以是字符串、数字、甚至是二进制，最大不能超过512MB 。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2.png)\n\n### 一、内部实现\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis字符串对象底层的数据结构实现主要是int和简单动态字符串SDS(这个字符串，和我们认识的C字符串不太一样，了解具体请看[图解Redis之数据结构篇——简单动态字符串SDS](https://www.cnblogs.com/hunternet/p/9957913.html))，其通过不同的编码方式映射到不同的数据结构。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1.png)\n\n字符串对象的内部编码有3种 ：`int`、`raw`和`embstr`。Redis会根据当前值的类型和长度来决定使用哪种编码来实现。\n\n1. 如果一个字符串对象保存的是整数值,并且这个整数值可以用`long`类型来表示,那么字符串对象会将整数值保存在字符串对象结构的`ptr`属性里面(将`void*`转换成`1ong`),并将字符串对象的编码设置为`int`。\n\n   ![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-int.png)\n\n2. 如果字符串对象保存的是一个字符串值,并且这个字符串值的长度大于32字节,那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值,并将对象的编码设置为`raw`。\n\n   ![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-raw.png)\n\n3. 如果字符串对象保存的是一个字符串值,并且这个字符申值的长度小于等于32字节，那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值，并将对象的编码设置为`embstr`\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-embstr.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;`embstr`编码是专门用于保存短字符串的一种优化编码方式，我们可以看到`embstr`和`raw`编码都会使用`SDS`来保存值，但不同之处在于`embstr`会通过一次内存分配函数来分配一块连续的内存空间来保存`redisObject`和`SDS`。而`raw`编码会通过调用两次内存分配函数来分别分配两块空间来保存`redisObject`和`SDS`。Redis这样做会有很多好处。\n\n* `embstr`编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次\n* 释放 `embstr`编码的字符串对象同样只需要调用一次内存释放函数\n* 因为`embstr`编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用CPU缓存提升性能。\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis中根据数据类型和长度来使用不同的编码和数据结构存储存在于Redis中的每一种对象类型上。其这种小细节上的优化令我叹服不止，后续我们会看到Redis中到处都是这种内存与性能上的小细节优化！\n\n### 二、常用命令\n\n&nbsp;&nbsp;&nbsp;&nbsp;字符串类型的命令比较多 ,我们先来了解几个日常开发中常用的。\n\n#### 1 设置值\n\n```shell\nredis> set testKey testValue\nOK\n```\n```shell\nset key value [ex seconds] [px milliseconds] [nx|xx]\n```\n\n* `ex seconds`：为键设置秒级过期时间。\n\n  如命令:`set username xiaoming ex 100`相当于执行下面两条命令\n\n  ```shell\n  SET username xiaoming \n  EXPIRE username 100\n  ```\n\n  `set key value [ex seconds]`操作是原子性的，相比连续执行上面两个命令，它更快。\n\n* `px milliseconds`：为键设置毫秒级过期时间。\n\n* `nx`：键必须不存在，才可以设置成功，用于添加。\n\n  ```shell\n  //mykey 不存在\n  redis> set mykey \"Hello\" nx\n  (integer) 1\n  //mykey 已经存在\n  redis> set mykey \"World\" nx\n  (integer) 0\n  redis> GET mykey\n  \"Hello\"\n  redis> \n  ```\n\n  由于`set key value nx`同样是原子性的操作，因此可以作为分布式锁的一种实现方案。\n\n* `xx`：与nx相反，键必须存在，才可以设置成功，用于更新 \n\n\n以上几个命令的替代命令是`SETNX`, `SETEX`,`PSETEX`，但是由于`SET`命令加上选项已经可以完全取代`SETNX`, `SETEX`,`PSETEX`的功能，所以在将来的版本中，redis可能会不推荐使用并且最终抛弃这几个命令。\n\n#### 2 获取值\n\n```shell\nget key\n```\n\n返回`key`的`value`。如果key不存在，返回特殊值`nil`。如果`key`的`value`不是string，就返回错误，因为`GET`只处理string类型的`values`。\n\n```shell\nredis> GET nokey\n(nil)\nredis> SET mykey \"Hello World\"\nOK\nredis> GET mykey\n\"Hello World\"\n```\n\n#### 3 批量设置值\n\n&nbsp;&nbsp;&nbsp;&nbsp;由于Redis目前的应用非常广泛，目前大多数公司对Redis的调用基本都会有一层自己的封装，看起来就像是在调用本地缓存一样，对于批量性的操作，一些对于Redis不太了解的可能就像使用本地缓存一样进行循环set。这样对性能是有很大的损耗的。实际上Redis提供了批量操作的命令。\n\n```shell\nMSET key value [key value ...]\n```\n\n对应给定的keys到他们相应的values上。`MSET`会用新的value替换已经存在的value，就像普通的`SET`命令一样。如果不想覆盖已经存在的values，可以使用`MSETNX key value [key value ...]`\n\n注意:`MSET`是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。\n\n```shell\nredis> MSET key1 \"Hello\" key2 \"World\"\nOK\nredis> GET key1\n\"Hello\"\nredis> GET key2\n\"World\"\n```\n\n#### 4 批量获取值\n\n```powershell\nMGET key [key ...]\n```\n\n结果是按照传入键的顺序返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。\n\n```powershell\nredis> SET key1 \"Hello\"\nOK\nredis> SET key2 \"World\"\nOK\nredis> MGET key1 key2 nokey\n1) \"Hello\"\n2) \"World\"\n3) (nil)\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis可以支撑每秒数万的读写操作，但是这指的是Redis服务端的处理能力，对于客户端来说，一次命令除了命令时间还是有网络时间，如n次get操作\n\n使用`get`命令\n\n```n次get时间 = n次网络时间 + n次命令时间 ```\n\n而`mget`操作\n\n```n次get时间 = 1次网络时间 + n次命令时间 ```\n\n而在实际开发中因为Redis的处理能力已经足够高，性能瓶颈的因素往往是网络。 \n\n学会使用批量操作，有助于提高效率，但是要掌握一个平衡的度，每次批量操作所发送的命令数并不是无节制的由于Redis是**单线程架构**，如果数量过多可能造成Redis阻塞或者网络拥塞。 \n\n#### 5 计数\n\n```powershell\nincr key\n```\n\n对存储在指定`key`的数值执行原子的加1操作。\n\n如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为`0`。\n\n如果指定的key中存储的值不是字符串类型（fix：）或者存储的字符串类型不能表示为一个整数，\n\n那么执行这个命令时服务器会返回一个错误(eq:(error) ERR value is not an integer or out of range)。\n\n这个操作仅限于64位的有符号整型数据。\n\n**注意**: 由于redis并没有一个明确的类型来表示整型数据，所以这个操作是一个字符串操作。\n\n执行这个操作的时候，key对应存储的字符串被解析为10进制的**64位有符号整型数据**。\n\n事实上，Redis 内部采用整数形式（Integer representation）来存储对应的整数值，所以对该类字符串值实际上是用整数保存，也就不存在存储整数的字符串表示（String representation）所带来的额外消耗。\n\n```\nredis> SET mykey \"1\"\nOK\nredis> INCR mykey\n(integer) 2\nredis> GET mykey\n\"3\"\nredis> \n```\n\n除了`incr`命令， Redis提供了`decr（自减）` 、 `incrby（自增指定数字）` 、`decrby（自减指定数字）` 、 `incrbyfloat（自增浮点数）`  \n\n```\ndecr key\nincrby key increment\ndecrby key decrement\nincrbyfloat key increment\n```\n\n#### 6 其它\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于常用的redis字符串命令和一些其它的命令我们列一个表格以便来更直观的看到。\n\n| 命令                                               | 描述 | 时间复杂度 |\n| -------------------------------------------------- | ---- | ---------- |\n| `set key value [ex seconds] [px milliseconds] [nx|xx]`| 设置值 | O(1) |\n| `get key` | 获取值 | O(1) |\n| `del key [key ...]` | 删除key | O(N)(N是键的个数) |\n| `mset key [key value ...]` | 批量设置值 | O(N)(N是键的个数) |\n| `mget key [key ...]` | 批量获取值 | O(N)(N是键的个数) |\n| `incr key` | 将 key 中储存的数字值增一 | O(1) |\n| `decr key` | 将 key 中储存的数字值减一 | O(1) |\n| `incrby key increment` | 将 key 所储存的值加上给定的增量值（increment） | O(1) |\n| `decrby key increment` | key 所储存的值减去给定的减量值（decrement） | O(1) |\n| `incrbyfloat key increment` | 将 key 所储存的值加上给定的浮点增量值（increment） | O(1) |\n| `append key value` | 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾 | O(1) |\n| `strlen key` | 返回 key 所储存的字符串值的长度。 | O(1) |\n| `setrange key offset value` | 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始 | O(1) |\n| `getrange key start end` | 返回 key 中字符串值的子字符 | O(N)(N是字符串的长度) |\n\n### 三、常用场景\n\n&nbsp;&nbsp;&nbsp;&nbsp;reids字符串的使用场景应该是最为广泛的，甚至有些对redis其它几种对象不太熟悉的人，基本所有场景都会使用字符串(序列化一下直接扔进去)。在众多的使用场景中总结一下大概分以下几种。\n\n#### 1. 作为缓存层\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF--%E7%BC%93%E5%AD%98%E5%B1%82.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上图，Redis经常作为缓存层，来缓存一些热点数据。来加速读写性能从而降低后端的压力。一般在读取数据的时候会先从Redis中读取，如果Redis中没有，再从数据库中读取。在Redis作为缓存层使用的时候，必须注意一些问题，如：缓存穿透、雪崩以及缓存更新问题......\n\n#### 2. 计数器\\限速器\\分布式系统ID\n\n&nbsp;&nbsp;&nbsp;&nbsp;计数器\\限速器\\分布式ID等主要是利用Redis字符串自增自减的特性。\n\n* 计数器：经常可以被用来做计数器，如微博的评论数、点赞数、分享数，抖音作品的收藏数，京东商品的销售量、评价数等。\n* 限速器：如验证码接口访问频率限制，用户登陆时需要让用户输入手机验证码，从而确定是否是用户本人，但是为了短信接口不被频繁访问，会限制用户每分钟获取验证码的频率，例如一分钟不能超过5次。\n* 分布式ID：由于Redis自增自减的操作是原子性的因此也经常在分布式系统中用来生成唯一的订单号、序列号等。\n\n#### 3. 分布式系统共享session\n\n&nbsp;&nbsp;&nbsp;&nbsp;通常在单体系统中，Web服务将会用户的Session信息（例如用户登录信息）保存在自己的服务器中。但是在分布式系统中，这样做会有问题。因为分布式系统通常有很多个服务，每个服务又会同时部署在多台机器上，通过负载均衡机制将将用户的访问均衡到不同服务器上。这个时候用户的请求可能分发到不同的服务器上，从而导致用户登录保存Session是在一台服务器上，而读取Session是在另一台服务器上因此会读不到Session。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%AF%8F%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%8F%AA%E8%83%BD%E8%AF%BB%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84Session.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;这种问题通常的做法是把Session存到一个公共的地方，让每个Web服务，都去这个公共的地方存取Session。而Redis就可以是这个公共的地方。(数据库、memecache等都可以各有优缺点)。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%20Session%E5%85%B1%E4%BA%AB.png)\n\n#### 4. 二进制存储\n\n&nbsp;&nbsp;&nbsp;&nbsp;由于Redis字符串可以存储二进制数据的特性，因此也可以用来存储一些二进制数据。如图片、 音频、 视频等。\n\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","slug":"技术实践/redis/Redis对象——字符串(String)","published":1,"updated":"2021-03-21T08:33:03.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzm00e4hyjf3sfmv0b9","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章简单介绍了<code>Redis</code>的对象系统。<code>Redis</code>使用对象来表示数据库中的键和值每个对象都由一个<code>redisObject</code>结构表示,该结构中和保存数据有关的三个属性分别是<code>type</code>属性、 <code>encoding</code>属性和<code>ptr</code>属性。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObiect</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//类型</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//编码</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//指向底层数据结构的指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;字符串对象是 Redis 中最基本的数据类型,也是我们工作中最常用的数据类型。redis中的键都是字符串对象，而且其他几种数据结构都是在字符串对象基础上构建的。字符串对象的值实际可以是字符串、数字、甚至是二进制，最大不能超过512MB 。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2.png\" alt></p>\n<h3 id=\"一、内部实现\"><a href=\"#一、内部实现\" class=\"headerlink\" title=\"一、内部实现\"></a>一、内部实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis字符串对象底层的数据结构实现主要是int和简单动态字符串SDS(这个字符串，和我们认识的C字符串不太一样，了解具体请看<a href=\"https://www.cnblogs.com/hunternet/p/9957913.html\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——简单动态字符串SDS</a>)，其通过不同的编码方式映射到不同的数据结构。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1.png\" alt></p>\n<p>字符串对象的内部编码有3种 ：<code>int</code>、<code>raw</code>和<code>embstr</code>。Redis会根据当前值的类型和长度来决定使用哪种编码来实现。</p>\n<ol>\n<li><p>如果一个字符串对象保存的是整数值,并且这个整数值可以用<code>long</code>类型来表示,那么字符串对象会将整数值保存在字符串对象结构的<code>ptr</code>属性里面(将<code>void*</code>转换成<code>1ong</code>),并将字符串对象的编码设置为<code>int</code>。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-int.png\" alt></p>\n</li>\n<li><p>如果字符串对象保存的是一个字符串值,并且这个字符串值的长度大于32字节,那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值,并将对象的编码设置为<code>raw</code>。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-raw.png\" alt></p>\n</li>\n<li><p>如果字符串对象保存的是一个字符串值,并且这个字符申值的长度小于等于32字节，那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值，并将对象的编码设置为<code>embstr</code></p>\n</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-embstr.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式，我们可以看到<code>embstr</code>和<code>raw</code>编码都会使用<code>SDS</code>来保存值，但不同之处在于<code>embstr</code>会通过一次内存分配函数来分配一块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code>。而<code>raw</code>编码会通过调用两次内存分配函数来分别分配两块空间来保存<code>redisObject</code>和<code>SDS</code>。Redis这样做会有很多好处。</p>\n<ul>\n<li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次</li>\n<li>释放 <code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数</li>\n<li>因为<code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用CPU缓存提升性能。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis中根据数据类型和长度来使用不同的编码和数据结构存储存在于Redis中的每一种对象类型上。其这种小细节上的优化令我叹服不止，后续我们会看到Redis中到处都是这种内存与性能上的小细节优化！</p>\n<h3 id=\"二、常用命令\"><a href=\"#二、常用命令\" class=\"headerlink\" title=\"二、常用命令\"></a>二、常用命令</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;字符串类型的命令比较多 ,我们先来了解几个日常开发中常用的。</p>\n<h4 id=\"1-设置值\"><a href=\"#1-设置值\" class=\"headerlink\" title=\"1 设置值\"></a>1 设置值</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">redis&gt;</span> set testKey testValue</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set key value [ex seconds] [px milliseconds] [nx|xx]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>ex seconds</code>：为键设置秒级过期时间。</p>\n<p>如命令:<code>set username xiaoming ex 100</code>相当于执行下面两条命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET username xiaoming </span><br><span class=\"line\">EXPIRE username 100</span><br></pre></td></tr></table></figure>\n<p><code>set key value [ex seconds]</code>操作是原子性的，相比连续执行上面两个命令，它更快。</p>\n</li>\n<li><p><code>px milliseconds</code>：为键设置毫秒级过期时间。</p>\n</li>\n<li><p><code>nx</code>：键必须不存在，才可以设置成功，用于添加。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//mykey 不存在</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> set mykey \"Hello\" nx</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">//mykey 已经存在</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> set mykey \"World\" nx</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> GET mykey</span><br><span class=\"line\">\"Hello\"</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span></span><br></pre></td></tr></table></figure>\n<p>由于<code>set key value nx</code>同样是原子性的操作，因此可以作为分布式锁的一种实现方案。</p>\n</li>\n<li><p><code>xx</code>：与nx相反，键必须存在，才可以设置成功，用于更新 </p>\n</li>\n</ul>\n<p>以上几个命令的替代命令是<code>SETNX</code>, <code>SETEX</code>,<code>PSETEX</code>，但是由于<code>SET</code>命令加上选项已经可以完全取代<code>SETNX</code>, <code>SETEX</code>,<code>PSETEX</code>的功能，所以在将来的版本中，redis可能会不推荐使用并且最终抛弃这几个命令。</p>\n<h4 id=\"2-获取值\"><a href=\"#2-获取值\" class=\"headerlink\" title=\"2 获取值\"></a>2 获取值</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get key</span><br></pre></td></tr></table></figure>\n<p>返回<code>key</code>的<code>value</code>。如果key不存在，返回特殊值<code>nil</code>。如果<code>key</code>的<code>value</code>不是string，就返回错误，因为<code>GET</code>只处理string类型的<code>values</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">redis&gt;</span> GET nokey</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> SET mykey \"Hello World\"</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> GET mykey</span><br><span class=\"line\">\"Hello World\"</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-批量设置值\"><a href=\"#3-批量设置值\" class=\"headerlink\" title=\"3 批量设置值\"></a>3 批量设置值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;由于Redis目前的应用非常广泛，目前大多数公司对Redis的调用基本都会有一层自己的封装，看起来就像是在调用本地缓存一样，对于批量性的操作，一些对于Redis不太了解的可能就像使用本地缓存一样进行循环set。这样对性能是有很大的损耗的。实际上Redis提供了批量操作的命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MSET key value [key value ...]</span><br></pre></td></tr></table></figure>\n<p>对应给定的keys到他们相应的values上。<code>MSET</code>会用新的value替换已经存在的value，就像普通的<code>SET</code>命令一样。如果不想覆盖已经存在的values，可以使用<code>MSETNX key value [key value ...]</code></p>\n<p>注意:<code>MSET</code>是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">redis&gt;</span> MSET key1 \"Hello\" key2 \"World\"</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> GET key1</span><br><span class=\"line\">\"Hello\"</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> GET key2</span><br><span class=\"line\">\"World\"</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-批量获取值\"><a href=\"#4-批量获取值\" class=\"headerlink\" title=\"4 批量获取值\"></a>4 批量获取值</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MGET key [key ...]</span><br></pre></td></tr></table></figure>\n<p>结果是按照传入键的顺序返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET key1 <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; SET key2 <span class=\"string\">\"World\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; MGET key1 key2 nokey</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) (nil)</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis可以支撑每秒数万的读写操作，但是这指的是Redis服务端的处理能力，对于客户端来说，一次命令除了命令时间还是有网络时间，如n次get操作</p>\n<p>使用<code>get</code>命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">而`mget`操作</span><br><span class=\"line\"></span><br><span class=\"line\">```n次get时间 = 1次网络时间 + n次命令时间</span><br></pre></td></tr></table></figure>\n<p>而在实际开发中因为Redis的处理能力已经足够高，性能瓶颈的因素往往是网络。 </p>\n<p>学会使用批量操作，有助于提高效率，但是要掌握一个平衡的度，每次批量操作所发送的命令数并不是无节制的由于Redis是<strong>单线程架构</strong>，如果数量过多可能造成Redis阻塞或者网络拥塞。 </p>\n<h4 id=\"5-计数\"><a href=\"#5-计数\" class=\"headerlink\" title=\"5 计数\"></a>5 计数</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">incr key</span><br></pre></td></tr></table></figure>\n<p>对存储在指定<code>key</code>的数值执行原子的加1操作。</p>\n<p>如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为<code>0</code>。</p>\n<p>如果指定的key中存储的值不是字符串类型（fix：）或者存储的字符串类型不能表示为一个整数，</p>\n<p>那么执行这个命令时服务器会返回一个错误(eq:(error) ERR value is not an integer or out of range)。</p>\n<p>这个操作仅限于64位的有符号整型数据。</p>\n<p><strong>注意</strong>: 由于redis并没有一个明确的类型来表示整型数据，所以这个操作是一个字符串操作。</p>\n<p>执行这个操作的时候，key对应存储的字符串被解析为10进制的<strong>64位有符号整型数据</strong>。</p>\n<p>事实上，Redis 内部采用整数形式（Integer representation）来存储对应的整数值，所以对该类字符串值实际上是用整数保存，也就不存在存储整数的字符串表示（String representation）所带来的额外消耗。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey &quot;1&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; INCR mykey</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\">&quot;3&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n<p>除了<code>incr</code>命令， Redis提供了<code>decr（自减）</code> 、 <code>incrby（自增指定数字）</code> 、<code>decrby（自减指定数字）</code> 、 <code>incrbyfloat（自增浮点数）</code>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">decr key</span><br><span class=\"line\">incrby key increment</span><br><span class=\"line\">decrby key decrement</span><br><span class=\"line\">incrbyfloat key increment</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-其它\"><a href=\"#6-其它\" class=\"headerlink\" title=\"6 其它\"></a>6 其它</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于常用的redis字符串命令和一些其它的命令我们列一个表格以便来更直观的看到。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>`set key value [ex seconds] [px milliseconds] [nx</td>\n<td>xx]`</td>\n<td>设置值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>get key</code></td>\n<td>获取值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>del key [key ...]</code></td>\n<td>删除key</td>\n<td>O(N)(N是键的个数)</td>\n</tr>\n<tr>\n<td><code>mset key [key value ...]</code></td>\n<td>批量设置值</td>\n<td>O(N)(N是键的个数)</td>\n</tr>\n<tr>\n<td><code>mget key [key ...]</code></td>\n<td>批量获取值</td>\n<td>O(N)(N是键的个数)</td>\n</tr>\n<tr>\n<td><code>incr key</code></td>\n<td>将 key 中储存的数字值增一</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>decr key</code></td>\n<td>将 key 中储存的数字值减一</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>incrby key increment</code></td>\n<td>将 key 所储存的值加上给定的增量值（increment）</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>decrby key increment</code></td>\n<td>key 所储存的值减去给定的减量值（decrement）</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>incrbyfloat key increment</code></td>\n<td>将 key 所储存的值加上给定的浮点增量值（increment）</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>append key value</code></td>\n<td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>strlen key</code></td>\n<td>返回 key 所储存的字符串值的长度。</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>setrange key offset value</code></td>\n<td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>getrange key start end</code></td>\n<td>返回 key 中字符串值的子字符</td>\n<td>O(N)(N是字符串的长度)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"三、常用场景\"><a href=\"#三、常用场景\" class=\"headerlink\" title=\"三、常用场景\"></a>三、常用场景</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;reids字符串的使用场景应该是最为广泛的，甚至有些对redis其它几种对象不太熟悉的人，基本所有场景都会使用字符串(序列化一下直接扔进去)。在众多的使用场景中总结一下大概分以下几种。</p>\n<h4 id=\"1-作为缓存层\"><a href=\"#1-作为缓存层\" class=\"headerlink\" title=\"1. 作为缓存层\"></a>1. 作为缓存层</h4><p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF--%E7%BC%93%E5%AD%98%E5%B1%82.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上图，Redis经常作为缓存层，来缓存一些热点数据。来加速读写性能从而降低后端的压力。一般在读取数据的时候会先从Redis中读取，如果Redis中没有，再从数据库中读取。在Redis作为缓存层使用的时候，必须注意一些问题，如：缓存穿透、雪崩以及缓存更新问题……</p>\n<h4 id=\"2-计数器-限速器-分布式系统ID\"><a href=\"#2-计数器-限速器-分布式系统ID\" class=\"headerlink\" title=\"2. 计数器\\限速器\\分布式系统ID\"></a>2. 计数器\\限速器\\分布式系统ID</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;计数器\\限速器\\分布式ID等主要是利用Redis字符串自增自减的特性。</p>\n<ul>\n<li>计数器：经常可以被用来做计数器，如微博的评论数、点赞数、分享数，抖音作品的收藏数，京东商品的销售量、评价数等。</li>\n<li>限速器：如验证码接口访问频率限制，用户登陆时需要让用户输入手机验证码，从而确定是否是用户本人，但是为了短信接口不被频繁访问，会限制用户每分钟获取验证码的频率，例如一分钟不能超过5次。</li>\n<li>分布式ID：由于Redis自增自减的操作是原子性的因此也经常在分布式系统中用来生成唯一的订单号、序列号等。</li>\n</ul>\n<h4 id=\"3-分布式系统共享session\"><a href=\"#3-分布式系统共享session\" class=\"headerlink\" title=\"3. 分布式系统共享session\"></a>3. 分布式系统共享session</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;通常在单体系统中，Web服务将会用户的Session信息（例如用户登录信息）保存在自己的服务器中。但是在分布式系统中，这样做会有问题。因为分布式系统通常有很多个服务，每个服务又会同时部署在多台机器上，通过负载均衡机制将将用户的访问均衡到不同服务器上。这个时候用户的请求可能分发到不同的服务器上，从而导致用户登录保存Session是在一台服务器上，而读取Session是在另一台服务器上因此会读不到Session。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%AF%8F%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%8F%AA%E8%83%BD%E8%AF%BB%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84Session.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;这种问题通常的做法是把Session存到一个公共的地方，让每个Web服务，都去这个公共的地方存取Session。而Redis就可以是这个公共的地方。(数据库、memecache等都可以各有优缺点)。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%20Session%E5%85%B1%E4%BA%AB.png\" alt></p>\n<h4 id=\"4-二进制存储\"><a href=\"#4-二进制存储\" class=\"headerlink\" title=\"4. 二进制存储\"></a>4. 二进制存储</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;由于Redis字符串可以存储二进制数据的特性，因此也可以用来存储一些二进制数据。如图片、 音频、 视频等。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章简单介绍了<code>Redis</code>的对象系统。<code>Redis</code>使用对象来表示数据库中的键和值每个对象都由一个<code>redisObject</code>结构表示,该结构中和保存数据有关的三个属性分别是<code>type</code>属性、 <code>encoding</code>属性和<code>ptr</code>属性。</p>","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">redisObiect</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//类型</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> type:<span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//编码</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> encoding:<span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//指向底层数据结构的指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;字符串对象是 Redis 中最基本的数据类型,也是我们工作中最常用的数据类型。redis中的键都是字符串对象，而且其他几种数据结构都是在字符串对象基础上构建的。字符串对象的值实际可以是字符串、数字、甚至是二进制，最大不能超过512MB 。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2.png\" alt></p>\n<h3 id=\"一、内部实现\"><a href=\"#一、内部实现\" class=\"headerlink\" title=\"一、内部实现\"></a>一、内部实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis字符串对象底层的数据结构实现主要是int和简单动态字符串SDS(这个字符串，和我们认识的C字符串不太一样，了解具体请看<a href=\"https://www.cnblogs.com/hunternet/p/9957913.html\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——简单动态字符串SDS</a>)，其通过不同的编码方式映射到不同的数据结构。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1.png\" alt></p>\n<p>字符串对象的内部编码有3种 ：<code>int</code>、<code>raw</code>和<code>embstr</code>。Redis会根据当前值的类型和长度来决定使用哪种编码来实现。</p>\n<ol>\n<li><p>如果一个字符串对象保存的是整数值,并且这个整数值可以用<code>long</code>类型来表示,那么字符串对象会将整数值保存在字符串对象结构的<code>ptr</code>属性里面(将<code>void*</code>转换成<code>1ong</code>),并将字符串对象的编码设置为<code>int</code>。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-int.png\" alt></p>\n</li>\n<li><p>如果字符串对象保存的是一个字符串值,并且这个字符串值的长度大于32字节,那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值,并将对象的编码设置为<code>raw</code>。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-raw.png\" alt></p>\n</li>\n<li><p>如果字符串对象保存的是一个字符串值,并且这个字符申值的长度小于等于32字节，那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值，并将对象的编码设置为<code>embstr</code></p>\n</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2-embstr.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式，我们可以看到<code>embstr</code>和<code>raw</code>编码都会使用<code>SDS</code>来保存值，但不同之处在于<code>embstr</code>会通过一次内存分配函数来分配一块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code>。而<code>raw</code>编码会通过调用两次内存分配函数来分别分配两块空间来保存<code>redisObject</code>和<code>SDS</code>。Redis这样做会有很多好处。</p>\n<ul>\n<li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次</li>\n<li>释放 <code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数</li>\n<li>因为<code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用CPU缓存提升性能。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis中根据数据类型和长度来使用不同的编码和数据结构存储存在于Redis中的每一种对象类型上。其这种小细节上的优化令我叹服不止，后续我们会看到Redis中到处都是这种内存与性能上的小细节优化！</p>\n<h3 id=\"二、常用命令\"><a href=\"#二、常用命令\" class=\"headerlink\" title=\"二、常用命令\"></a>二、常用命令</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;字符串类型的命令比较多 ,我们先来了解几个日常开发中常用的。</p>\n<h4 id=\"1-设置值\"><a href=\"#1-设置值\" class=\"headerlink\" title=\"1 设置值\"></a>1 设置值</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">redis&gt;</span> set testKey testValue</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set key value [ex seconds] [px milliseconds] [nx|xx]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>ex seconds</code>：为键设置秒级过期时间。</p>\n<p>如命令:<code>set username xiaoming ex 100</code>相当于执行下面两条命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET username xiaoming </span><br><span class=\"line\">EXPIRE username 100</span><br></pre></td></tr></table></figure>\n<p><code>set key value [ex seconds]</code>操作是原子性的，相比连续执行上面两个命令，它更快。</p>\n</li>\n<li><p><code>px milliseconds</code>：为键设置毫秒级过期时间。</p>\n</li>\n<li><p><code>nx</code>：键必须不存在，才可以设置成功，用于添加。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//mykey 不存在</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> set mykey \"Hello\" nx</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">//mykey 已经存在</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> set mykey \"World\" nx</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> GET mykey</span><br><span class=\"line\">\"Hello\"</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span></span><br></pre></td></tr></table></figure>\n<p>由于<code>set key value nx</code>同样是原子性的操作，因此可以作为分布式锁的一种实现方案。</p>\n</li>\n<li><p><code>xx</code>：与nx相反，键必须存在，才可以设置成功，用于更新 </p>\n</li>\n</ul>\n<p>以上几个命令的替代命令是<code>SETNX</code>, <code>SETEX</code>,<code>PSETEX</code>，但是由于<code>SET</code>命令加上选项已经可以完全取代<code>SETNX</code>, <code>SETEX</code>,<code>PSETEX</code>的功能，所以在将来的版本中，redis可能会不推荐使用并且最终抛弃这几个命令。</p>\n<h4 id=\"2-获取值\"><a href=\"#2-获取值\" class=\"headerlink\" title=\"2 获取值\"></a>2 获取值</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get key</span><br></pre></td></tr></table></figure>\n<p>返回<code>key</code>的<code>value</code>。如果key不存在，返回特殊值<code>nil</code>。如果<code>key</code>的<code>value</code>不是string，就返回错误，因为<code>GET</code>只处理string类型的<code>values</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">redis&gt;</span> GET nokey</span><br><span class=\"line\">(nil)</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> SET mykey \"Hello World\"</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> GET mykey</span><br><span class=\"line\">\"Hello World\"</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-批量设置值\"><a href=\"#3-批量设置值\" class=\"headerlink\" title=\"3 批量设置值\"></a>3 批量设置值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;由于Redis目前的应用非常广泛，目前大多数公司对Redis的调用基本都会有一层自己的封装，看起来就像是在调用本地缓存一样，对于批量性的操作，一些对于Redis不太了解的可能就像使用本地缓存一样进行循环set。这样对性能是有很大的损耗的。实际上Redis提供了批量操作的命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MSET key value [key value ...]</span><br></pre></td></tr></table></figure>\n<p>对应给定的keys到他们相应的values上。<code>MSET</code>会用新的value替换已经存在的value，就像普通的<code>SET</code>命令一样。如果不想覆盖已经存在的values，可以使用<code>MSETNX key value [key value ...]</code></p>\n<p>注意:<code>MSET</code>是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">redis&gt;</span> MSET key1 \"Hello\" key2 \"World\"</span><br><span class=\"line\">OK</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> GET key1</span><br><span class=\"line\">\"Hello\"</span><br><span class=\"line\"><span class=\"meta\">redis&gt;</span> GET key2</span><br><span class=\"line\">\"World\"</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-批量获取值\"><a href=\"#4-批量获取值\" class=\"headerlink\" title=\"4 批量获取值\"></a>4 批量获取值</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MGET key [key ...]</span><br></pre></td></tr></table></figure>\n<p>结果是按照传入键的顺序返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET key1 <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; SET key2 <span class=\"string\">\"World\"</span></span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; MGET key1 key2 nokey</span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"World\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) (nil)</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis可以支撑每秒数万的读写操作，但是这指的是Redis服务端的处理能力，对于客户端来说，一次命令除了命令时间还是有网络时间，如n次get操作</p>\n<p>使用<code>get</code>命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">而`mget`操作</span><br><span class=\"line\"></span><br><span class=\"line\">```n次get时间 = 1次网络时间 + n次命令时间</span><br></pre></td></tr></table></figure>\n<p>而在实际开发中因为Redis的处理能力已经足够高，性能瓶颈的因素往往是网络。 </p>\n<p>学会使用批量操作，有助于提高效率，但是要掌握一个平衡的度，每次批量操作所发送的命令数并不是无节制的由于Redis是<strong>单线程架构</strong>，如果数量过多可能造成Redis阻塞或者网络拥塞。 </p>\n<h4 id=\"5-计数\"><a href=\"#5-计数\" class=\"headerlink\" title=\"5 计数\"></a>5 计数</h4><figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">incr key</span><br></pre></td></tr></table></figure>\n<p>对存储在指定<code>key</code>的数值执行原子的加1操作。</p>\n<p>如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为<code>0</code>。</p>\n<p>如果指定的key中存储的值不是字符串类型（fix：）或者存储的字符串类型不能表示为一个整数，</p>\n<p>那么执行这个命令时服务器会返回一个错误(eq:(error) ERR value is not an integer or out of range)。</p>\n<p>这个操作仅限于64位的有符号整型数据。</p>\n<p><strong>注意</strong>: 由于redis并没有一个明确的类型来表示整型数据，所以这个操作是一个字符串操作。</p>\n<p>执行这个操作的时候，key对应存储的字符串被解析为10进制的<strong>64位有符号整型数据</strong>。</p>\n<p>事实上，Redis 内部采用整数形式（Integer representation）来存储对应的整数值，所以对该类字符串值实际上是用整数保存，也就不存在存储整数的字符串表示（String representation）所带来的额外消耗。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis&gt; SET mykey &quot;1&quot;</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis&gt; INCR mykey</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">redis&gt; GET mykey</span><br><span class=\"line\">&quot;3&quot;</span><br><span class=\"line\">redis&gt;</span><br></pre></td></tr></table></figure>\n<p>除了<code>incr</code>命令， Redis提供了<code>decr（自减）</code> 、 <code>incrby（自增指定数字）</code> 、<code>decrby（自减指定数字）</code> 、 <code>incrbyfloat（自增浮点数）</code>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">decr key</span><br><span class=\"line\">incrby key increment</span><br><span class=\"line\">decrby key decrement</span><br><span class=\"line\">incrbyfloat key increment</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-其它\"><a href=\"#6-其它\" class=\"headerlink\" title=\"6 其它\"></a>6 其它</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于常用的redis字符串命令和一些其它的命令我们列一个表格以便来更直观的看到。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>`set key value [ex seconds] [px milliseconds] [nx</td>\n<td>xx]`</td>\n<td>设置值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>get key</code></td>\n<td>获取值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>del key [key ...]</code></td>\n<td>删除key</td>\n<td>O(N)(N是键的个数)</td>\n</tr>\n<tr>\n<td><code>mset key [key value ...]</code></td>\n<td>批量设置值</td>\n<td>O(N)(N是键的个数)</td>\n</tr>\n<tr>\n<td><code>mget key [key ...]</code></td>\n<td>批量获取值</td>\n<td>O(N)(N是键的个数)</td>\n</tr>\n<tr>\n<td><code>incr key</code></td>\n<td>将 key 中储存的数字值增一</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>decr key</code></td>\n<td>将 key 中储存的数字值减一</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>incrby key increment</code></td>\n<td>将 key 所储存的值加上给定的增量值（increment）</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>decrby key increment</code></td>\n<td>key 所储存的值减去给定的减量值（decrement）</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>incrbyfloat key increment</code></td>\n<td>将 key 所储存的值加上给定的浮点增量值（increment）</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>append key value</code></td>\n<td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>strlen key</code></td>\n<td>返回 key 所储存的字符串值的长度。</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>setrange key offset value</code></td>\n<td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>getrange key start end</code></td>\n<td>返回 key 中字符串值的子字符</td>\n<td>O(N)(N是字符串的长度)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"三、常用场景\"><a href=\"#三、常用场景\" class=\"headerlink\" title=\"三、常用场景\"></a>三、常用场景</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;reids字符串的使用场景应该是最为广泛的，甚至有些对redis其它几种对象不太熟悉的人，基本所有场景都会使用字符串(序列化一下直接扔进去)。在众多的使用场景中总结一下大概分以下几种。</p>\n<h4 id=\"1-作为缓存层\"><a href=\"#1-作为缓存层\" class=\"headerlink\" title=\"1. 作为缓存层\"></a>1. 作为缓存层</h4><p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF--%E7%BC%93%E5%AD%98%E5%B1%82.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上图，Redis经常作为缓存层，来缓存一些热点数据。来加速读写性能从而降低后端的压力。一般在读取数据的时候会先从Redis中读取，如果Redis中没有，再从数据库中读取。在Redis作为缓存层使用的时候，必须注意一些问题，如：缓存穿透、雪崩以及缓存更新问题……</p>\n<h4 id=\"2-计数器-限速器-分布式系统ID\"><a href=\"#2-计数器-限速器-分布式系统ID\" class=\"headerlink\" title=\"2. 计数器\\限速器\\分布式系统ID\"></a>2. 计数器\\限速器\\分布式系统ID</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;计数器\\限速器\\分布式ID等主要是利用Redis字符串自增自减的特性。</p>\n<ul>\n<li>计数器：经常可以被用来做计数器，如微博的评论数、点赞数、分享数，抖音作品的收藏数，京东商品的销售量、评价数等。</li>\n<li>限速器：如验证码接口访问频率限制，用户登陆时需要让用户输入手机验证码，从而确定是否是用户本人，但是为了短信接口不被频繁访问，会限制用户每分钟获取验证码的频率，例如一分钟不能超过5次。</li>\n<li>分布式ID：由于Redis自增自减的操作是原子性的因此也经常在分布式系统中用来生成唯一的订单号、序列号等。</li>\n</ul>\n<h4 id=\"3-分布式系统共享session\"><a href=\"#3-分布式系统共享session\" class=\"headerlink\" title=\"3. 分布式系统共享session\"></a>3. 分布式系统共享session</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;通常在单体系统中，Web服务将会用户的Session信息（例如用户登录信息）保存在自己的服务器中。但是在分布式系统中，这样做会有问题。因为分布式系统通常有很多个服务，每个服务又会同时部署在多台机器上，通过负载均衡机制将将用户的访问均衡到不同服务器上。这个时候用户的请求可能分发到不同的服务器上，从而导致用户登录保存Session是在一台服务器上，而读取Session是在另一台服务器上因此会读不到Session。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%AF%8F%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%8F%AA%E8%83%BD%E8%AF%BB%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84Session.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;这种问题通常的做法是把Session存到一个公共的地方，让每个Web服务，都去这个公共的地方存取Session。而Redis就可以是这个公共的地方。(数据库、memecache等都可以各有优缺点)。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%20Session%E5%85%B1%E4%BA%AB.png\" alt></p>\n<h4 id=\"4-二进制存储\"><a href=\"#4-二进制存储\" class=\"headerlink\" title=\"4. 二进制存储\"></a>4. 二进制存储</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;由于Redis字符串可以存储二进制数据的特性，因此也可以用来存储一些二进制数据。如图片、 音频、 视频等。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>"},{"title":"Redis对象——集合(Set)","copyright":true,"date":"2020-03-30T02:45:38.000Z","keywords":"Redis,Set,Redis集合","aside":"redis","_content":"集合类型 (Set) 是一个无序并唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储。\n\n集合类型和列表类型的区别如下：\n\n- 列表可以存储重复元素，集合只能存储非重复元素；\n- 列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。\n\n一个集合最多可以存储232-1个元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。\n\n<!--more-->\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88.png)\n\n### 一、内部实现\n\n集合类型的内部编码有两种：\n\n* [intset(整数集合)]([https://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/](https://blog.laoyu.site/2019/redis/Redis数据结构——整数集合/)):当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。\n\n* [hashtable(哈希表)](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/):当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。\n\n有关intset和hashtable这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。\n\n[Redis数据结构——整数集合](https://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/)\n\n[Redis数据结构——字典](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/)。\n\n### 二、常用命令\n\nRedis列表对象常用命令如下表(点击命令可查看命令详细说明)。\n\n\n| 命令 | 说明 | 时间复杂度 |\n| ---- | ---- | ---------- |\n| [SADD key member [member ...]](http://blog.laoyu.site/2020/redis_command/set/sadd/) | 添加一个或者多个元素到集合(set)里   | O(N)         |\n| [SCARD key](http://blog.laoyu.site/2020/redis_command/set/scard/) | 获取集合里面的元素数量   | O(1)         |\n| [SDIFF key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sdiff/) | 获得队列不存在的元素   | O(N)         |\n| [SDIFFSTORE destination key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sdiffstore/) | 获得队列不存在的元素，并存储在一个关键的结果集   | O(N)         |\n| [SINTER key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sinter/) | 获得两个集合的交集   | O(N*M)         |\n| [SINTERSTORE destination key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sinterstore/) | 获得两个集合的交集，并存储在一个关键的结果集   | O(N*M)         |\n| [SISMEMBER key member](http://blog.laoyu.site/2020/redis_command/set/sismember/) | 确定一个给定的值是一个集合的成员   | O(1)         |\n| [SMEMBERS key](http://blog.laoyu.site/2020/redis_command/set/smembers/) | 获取集合里面的所有元素   | O(N)         |\n| [SMOVE source destination member](http://blog.laoyu.site/2020/redis_command/set/smove/) | 移动集合里面的一个元素到另一个集合   | O(1)         |\n| [SPOP key [count]](http://blog.laoyu.site/2020/redis_command/set/spop/) | 删除并获取一个集合里面的元素   | O(1)         |\n| [SRANDMEMBER key [count]](http://blog.laoyu.site/2020/redis_command/set/srandmember/) | 从集合里面随机获取一个元素   |            |\n| [SREM key member [member ...]](http://blog.laoyu.site/2020/redis_command/set/srem/) | 从集合里删除一个或多个元素   | O(N)         |\n| [SUNION key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sunion/) | 添加多个set元素   | O(N)         |\n| [SUNIONSTORE destination key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sunionstore/) | 合并set元素，并将结果存入新的set里面   | O(N)         |\n| [SSCAN key cursor [MATCH pattern] [COUNT count]](http://blog.laoyu.site/2020/redis_command/set/sscan/) | 迭代set里面的元素   | O(1)         |\n\n### 三、使用场景\n\n通过上文，我们可以知道集合的主要几个特性，无序、不可重复、支持并交差等操作。因此集合类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。\n\n#### 3.1 标签系统\n\n集合类型比较典型的使用场景是标签（tag）。\n\n1. 给用户添加标签。\n\n   ```c\n   sadd user:1:tags tag1 tag2 tag5\n   sadd user:2:tags tag2 tag3 tag5\n   ...\n   sadd user:k:tags tag1 tag2 tag4\n   ...\n   ```\n   \n2. 给标签添加用户\n\n   ```c\n   sadd tag1:users user:1 user:3\n   sadd tag2:users user:1 user:2 user:3\n   ...\n   sadd tagk:users user:1 user:2\n   ...\n   ```\n3. 使用sinter命令，可以来计算用户共同感兴趣的标签\n\n   ```c\n   sinter user:1:tags user:2:tags\n   ```\n\n这种标签系统在电商系统、社交系统、视频网站，图书网站，旅游网站等都有着广泛的应用。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签，这些数据对于用户体验以及增强用户黏度比较重要。例如一个社交系统可以根据用户的标签进行好友的推荐，已经用户感兴趣的新闻的推荐等，一个电子商务的网站会对不同标签的用户做不同类型的推荐，比如对数码产品比较感兴趣的人，在各个页面或者通过邮件的形式给他们推荐最新的数码产品，通常会为网站带来更多的利益。\n\n#### 3.2 抽奖系统\n\nRedis集合的 [SPOP(随机移除并返回集合中一个或多个元素)](https://blog.laoyu.site/2020/redis_command/set/spop/) 和 [SRANDMEMBER(随机返回集合中一个或多个元素)](https://blog.laoyu.site/2020/redis_command/set/srandmember/) 命令可以帮助我们实现一个抽奖系统\n\n如果允许重复中奖，可以使用SRANDMEMBER 命令\n\n```c\n//添加抽奖名单\n127.0.0.1:6379> SADD lucky:1 Tom\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Jerry\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 John\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Marry\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Sean\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Lindy\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Echo\n(integer) 1\n\n//抽取三等奖3个\n127.0.0.1:6379> SRANDMEMBER lucky:1 3\n1) \"John\"\n2) \"Echo\"\n3) \"Lindy\"\n//抽取二等奖2个\n127.0.0.1:6379> SRANDMEMBER lucky:1 2\n1) \"Sean\"\n2) \"Lindy\"\n//抽取一等奖1个\n127.0.0.1:6379> SRANDMEMBER lucky:1 1\n1) \"Tom\"    \n```\n\n如果不允许重复中奖，可以使用 SPOP 命令\n\n```c\n//添加抽奖名单\n127.0.0.1:6379> SADD lucky:1 Tom\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Jerry\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 John\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Marry\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Sean\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Lindy\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Echo\n(integer) 1\n\n//抽取三等奖3个\n127.0.0.1:6379> SPOP lucky:1 3\n1) \"John\"\n2) \"Echo\"\n3) \"Lindy\"\n//抽取二等奖2个\n127.0.0.1:6379> SPOP lucky:1 2\n1) \"Sean\"\n2) \"Marry\"\n//抽取一等奖1个\n127.0.0.1:6379> SPOP lucky:1 1\n1) \"Tom\"   \n```\n\n**注意:**\n\nRedis 2.6版本开始SRANDMEMBER命令支持Count参数。\n\nRedis 3.2版本开始SRANDMEMBER命令支持Count参数。\n\n其余低版本一次只能获取一个随机元素。\n\n### 小结\n\n本篇文章我们总结了Redis 集合对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis集合对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","source":"_posts/技术实践/redis/Redis对象——集合(Set).md","raw":"---\ntitle: Redis对象——集合(Set)\ncopyright: true\ndate: 2020-03-30 10:45:38\ntags: \n- Redis\ncategories: Redis\nkeywords: Redis,Set,Redis集合\naside: redis\n---\n集合类型 (Set) 是一个无序并唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储。\n\n集合类型和列表类型的区别如下：\n\n- 列表可以存储重复元素，集合只能存储非重复元素；\n- 列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。\n\n一个集合最多可以存储232-1个元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。\n\n<!--more-->\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88.png)\n\n### 一、内部实现\n\n集合类型的内部编码有两种：\n\n* [intset(整数集合)]([https://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/](https://blog.laoyu.site/2019/redis/Redis数据结构——整数集合/)):当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。\n\n* [hashtable(哈希表)](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/):当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。\n\n有关intset和hashtable这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。\n\n[Redis数据结构——整数集合](https://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/)\n\n[Redis数据结构——字典](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/)。\n\n### 二、常用命令\n\nRedis列表对象常用命令如下表(点击命令可查看命令详细说明)。\n\n\n| 命令 | 说明 | 时间复杂度 |\n| ---- | ---- | ---------- |\n| [SADD key member [member ...]](http://blog.laoyu.site/2020/redis_command/set/sadd/) | 添加一个或者多个元素到集合(set)里   | O(N)         |\n| [SCARD key](http://blog.laoyu.site/2020/redis_command/set/scard/) | 获取集合里面的元素数量   | O(1)         |\n| [SDIFF key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sdiff/) | 获得队列不存在的元素   | O(N)         |\n| [SDIFFSTORE destination key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sdiffstore/) | 获得队列不存在的元素，并存储在一个关键的结果集   | O(N)         |\n| [SINTER key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sinter/) | 获得两个集合的交集   | O(N*M)         |\n| [SINTERSTORE destination key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sinterstore/) | 获得两个集合的交集，并存储在一个关键的结果集   | O(N*M)         |\n| [SISMEMBER key member](http://blog.laoyu.site/2020/redis_command/set/sismember/) | 确定一个给定的值是一个集合的成员   | O(1)         |\n| [SMEMBERS key](http://blog.laoyu.site/2020/redis_command/set/smembers/) | 获取集合里面的所有元素   | O(N)         |\n| [SMOVE source destination member](http://blog.laoyu.site/2020/redis_command/set/smove/) | 移动集合里面的一个元素到另一个集合   | O(1)         |\n| [SPOP key [count]](http://blog.laoyu.site/2020/redis_command/set/spop/) | 删除并获取一个集合里面的元素   | O(1)         |\n| [SRANDMEMBER key [count]](http://blog.laoyu.site/2020/redis_command/set/srandmember/) | 从集合里面随机获取一个元素   |            |\n| [SREM key member [member ...]](http://blog.laoyu.site/2020/redis_command/set/srem/) | 从集合里删除一个或多个元素   | O(N)         |\n| [SUNION key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sunion/) | 添加多个set元素   | O(N)         |\n| [SUNIONSTORE destination key [key ...]](http://blog.laoyu.site/2020/redis_command/set/sunionstore/) | 合并set元素，并将结果存入新的set里面   | O(N)         |\n| [SSCAN key cursor [MATCH pattern] [COUNT count]](http://blog.laoyu.site/2020/redis_command/set/sscan/) | 迭代set里面的元素   | O(1)         |\n\n### 三、使用场景\n\n通过上文，我们可以知道集合的主要几个特性，无序、不可重复、支持并交差等操作。因此集合类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。\n\n#### 3.1 标签系统\n\n集合类型比较典型的使用场景是标签（tag）。\n\n1. 给用户添加标签。\n\n   ```c\n   sadd user:1:tags tag1 tag2 tag5\n   sadd user:2:tags tag2 tag3 tag5\n   ...\n   sadd user:k:tags tag1 tag2 tag4\n   ...\n   ```\n   \n2. 给标签添加用户\n\n   ```c\n   sadd tag1:users user:1 user:3\n   sadd tag2:users user:1 user:2 user:3\n   ...\n   sadd tagk:users user:1 user:2\n   ...\n   ```\n3. 使用sinter命令，可以来计算用户共同感兴趣的标签\n\n   ```c\n   sinter user:1:tags user:2:tags\n   ```\n\n这种标签系统在电商系统、社交系统、视频网站，图书网站，旅游网站等都有着广泛的应用。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签，这些数据对于用户体验以及增强用户黏度比较重要。例如一个社交系统可以根据用户的标签进行好友的推荐，已经用户感兴趣的新闻的推荐等，一个电子商务的网站会对不同标签的用户做不同类型的推荐，比如对数码产品比较感兴趣的人，在各个页面或者通过邮件的形式给他们推荐最新的数码产品，通常会为网站带来更多的利益。\n\n#### 3.2 抽奖系统\n\nRedis集合的 [SPOP(随机移除并返回集合中一个或多个元素)](https://blog.laoyu.site/2020/redis_command/set/spop/) 和 [SRANDMEMBER(随机返回集合中一个或多个元素)](https://blog.laoyu.site/2020/redis_command/set/srandmember/) 命令可以帮助我们实现一个抽奖系统\n\n如果允许重复中奖，可以使用SRANDMEMBER 命令\n\n```c\n//添加抽奖名单\n127.0.0.1:6379> SADD lucky:1 Tom\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Jerry\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 John\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Marry\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Sean\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Lindy\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Echo\n(integer) 1\n\n//抽取三等奖3个\n127.0.0.1:6379> SRANDMEMBER lucky:1 3\n1) \"John\"\n2) \"Echo\"\n3) \"Lindy\"\n//抽取二等奖2个\n127.0.0.1:6379> SRANDMEMBER lucky:1 2\n1) \"Sean\"\n2) \"Lindy\"\n//抽取一等奖1个\n127.0.0.1:6379> SRANDMEMBER lucky:1 1\n1) \"Tom\"    \n```\n\n如果不允许重复中奖，可以使用 SPOP 命令\n\n```c\n//添加抽奖名单\n127.0.0.1:6379> SADD lucky:1 Tom\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Jerry\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 John\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Marry\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Sean\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Lindy\n(integer) 1\n127.0.0.1:6379> SADD lucky:1 Echo\n(integer) 1\n\n//抽取三等奖3个\n127.0.0.1:6379> SPOP lucky:1 3\n1) \"John\"\n2) \"Echo\"\n3) \"Lindy\"\n//抽取二等奖2个\n127.0.0.1:6379> SPOP lucky:1 2\n1) \"Sean\"\n2) \"Marry\"\n//抽取一等奖1个\n127.0.0.1:6379> SPOP lucky:1 1\n1) \"Tom\"   \n```\n\n**注意:**\n\nRedis 2.6版本开始SRANDMEMBER命令支持Count参数。\n\nRedis 3.2版本开始SRANDMEMBER命令支持Count参数。\n\n其余低版本一次只能获取一个随机元素。\n\n### 小结\n\n本篇文章我们总结了Redis 集合对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis集合对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","slug":"技术实践/redis/Redis对象——集合(Set)","published":1,"updated":"2021-03-14T03:04:50.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzn00e9hyjfn8iimp1w","content":"<p>集合类型 (Set) 是一个无序并唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储。</p>\n<p>集合类型和列表类型的区别如下：</p>\n<ul>\n<li>列表可以存储重复元素，集合只能存储非重复元素；</li>\n<li>列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。</li>\n</ul>\n<p>一个集合最多可以存储232-1个元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88.png\" alt></p>\n<h3 id=\"一、内部实现\"><a href=\"#一、内部实现\" class=\"headerlink\" title=\"一、内部实现\"></a>一、内部实现</h3><p>集合类型的内部编码有两种：</p>\n<ul>\n<li><p><a href=\"[https://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/](https://blog.laoyu.site/2019/redis/Redis数据结构——整数集合/\">intset(整数集合)</a>):当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</p>\n</li>\n<li><p><a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/\">hashtable(哈希表)</a>:当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。</p>\n</li>\n</ul>\n<p>有关intset和hashtable这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/\">Redis数据结构——整数集合</a></p>\n<p><a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/\">Redis数据结构——字典</a>。</p>\n<h3 id=\"二、常用命令\"><a href=\"#二、常用命令\" class=\"headerlink\" title=\"二、常用命令\"></a>二、常用命令</h3><p>Redis列表对象常用命令如下表(点击命令可查看命令详细说明)。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sadd/\">SADD key member [member …]</a></td>\n<td>添加一个或者多个元素到集合(set)里</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/scard/\">SCARD key</a></td>\n<td>获取集合里面的元素数量</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sdiff/\">SDIFF key [key …]</a></td>\n<td>获得队列不存在的元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sdiffstore/\">SDIFFSTORE destination key [key …]</a></td>\n<td>获得队列不存在的元素，并存储在一个关键的结果集</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sinter/\">SINTER key [key …]</a></td>\n<td>获得两个集合的交集</td>\n<td>O(N*M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sinterstore/\">SINTERSTORE destination key [key …]</a></td>\n<td>获得两个集合的交集，并存储在一个关键的结果集</td>\n<td>O(N*M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sismember/\">SISMEMBER key member</a></td>\n<td>确定一个给定的值是一个集合的成员</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/smembers/\">SMEMBERS key</a></td>\n<td>获取集合里面的所有元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/smove/\">SMOVE source destination member</a></td>\n<td>移动集合里面的一个元素到另一个集合</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/spop/\">SPOP key [count]</a></td>\n<td>删除并获取一个集合里面的元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/srandmember/\">SRANDMEMBER key [count]</a></td>\n<td>从集合里面随机获取一个元素</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/srem/\">SREM key member [member …]</a></td>\n<td>从集合里删除一个或多个元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sunion/\">SUNION key [key …]</a></td>\n<td>添加多个set元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sunionstore/\">SUNIONSTORE destination key [key …]</a></td>\n<td>合并set元素，并将结果存入新的set里面</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sscan/\">SSCAN key cursor [MATCH pattern] [COUNT count]</a></td>\n<td>迭代set里面的元素</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"三、使用场景\"><a href=\"#三、使用场景\" class=\"headerlink\" title=\"三、使用场景\"></a>三、使用场景</h3><p>通过上文，我们可以知道集合的主要几个特性，无序、不可重复、支持并交差等操作。因此集合类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p>\n<h4 id=\"3-1-标签系统\"><a href=\"#3-1-标签系统\" class=\"headerlink\" title=\"3.1 标签系统\"></a>3.1 标签系统</h4><p>集合类型比较典型的使用场景是标签（tag）。</p>\n<ol>\n<li><p>给用户添加标签。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sadd user:<span class=\"number\">1</span>:tags tag1 tag2 tag5</span><br><span class=\"line\">sadd user:<span class=\"number\">2</span>:tags tag2 tag3 tag5</span><br><span class=\"line\">...</span><br><span class=\"line\">sadd user:k:tags tag1 tag2 tag4</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>给标签添加用户</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sadd tag1:users user:<span class=\"number\">1</span> user:<span class=\"number\">3</span></span><br><span class=\"line\">sadd tag2:users user:<span class=\"number\">1</span> user:<span class=\"number\">2</span> user:<span class=\"number\">3</span></span><br><span class=\"line\">...</span><br><span class=\"line\">sadd tagk:users user:<span class=\"number\">1</span> user:<span class=\"number\">2</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用sinter命令，可以来计算用户共同感兴趣的标签</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sinter user:<span class=\"number\">1</span>:tags user:<span class=\"number\">2</span>:tags</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这种标签系统在电商系统、社交系统、视频网站，图书网站，旅游网站等都有着广泛的应用。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签，这些数据对于用户体验以及增强用户黏度比较重要。例如一个社交系统可以根据用户的标签进行好友的推荐，已经用户感兴趣的新闻的推荐等，一个电子商务的网站会对不同标签的用户做不同类型的推荐，比如对数码产品比较感兴趣的人，在各个页面或者通过邮件的形式给他们推荐最新的数码产品，通常会为网站带来更多的利益。</p>\n<h4 id=\"3-2-抽奖系统\"><a href=\"#3-2-抽奖系统\" class=\"headerlink\" title=\"3.2 抽奖系统\"></a>3.2 抽奖系统</h4><p>Redis集合的 <a href=\"https://blog.laoyu.site/2020/redis_command/set/spop/\">SPOP(随机移除并返回集合中一个或多个元素)</a> 和 <a href=\"https://blog.laoyu.site/2020/redis_command/set/srandmember/\">SRANDMEMBER(随机返回集合中一个或多个元素)</a> 命令可以帮助我们实现一个抽奖系统</p>\n<p>如果允许重复中奖，可以使用SRANDMEMBER 命令</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//添加抽奖名单</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Tom</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Jerry</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> John</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Marry</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Sean</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Lindy</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Echo</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//抽取三等奖3个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SRANDMEMBER lucky:<span class=\"number\">1</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"John\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Echo\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Lindy\"</span></span><br><span class=\"line\"><span class=\"comment\">//抽取二等奖2个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SRANDMEMBER lucky:<span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Sean\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Lindy\"</span></span><br><span class=\"line\"><span class=\"comment\">//抽取一等奖1个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SRANDMEMBER lucky:<span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Tom\"</span></span><br></pre></td></tr></table></figure>\n<p>如果不允许重复中奖，可以使用 SPOP 命令</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//添加抽奖名单</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Tom</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Jerry</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> John</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Marry</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Sean</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Lindy</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Echo</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//抽取三等奖3个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SPOP lucky:<span class=\"number\">1</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"John\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Echo\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Lindy\"</span></span><br><span class=\"line\"><span class=\"comment\">//抽取二等奖2个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SPOP lucky:<span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Sean\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Marry\"</span></span><br><span class=\"line\"><span class=\"comment\">//抽取一等奖1个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SPOP lucky:<span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Tom\"</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意:</strong></p>\n<p>Redis 2.6版本开始SRANDMEMBER命令支持Count参数。</p>\n<p>Redis 3.2版本开始SRANDMEMBER命令支持Count参数。</p>\n<p>其余低版本一次只能获取一个随机元素。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本篇文章我们总结了Redis 集合对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis集合对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>","site":{"data":{}},"excerpt":"<p>集合类型 (Set) 是一个无序并唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储。</p>\n<p>集合类型和列表类型的区别如下：</p>\n<ul>\n<li>列表可以存储重复元素，集合只能存储非重复元素；</li>\n<li>列表是按照元素的先后顺序存储元素的，而集合则是无序方式存储元素的。</li>\n</ul>\n<p>一个集合最多可以存储232-1个元素。Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。</p>","more":"<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88.png\" alt></p>\n<h3 id=\"一、内部实现\"><a href=\"#一、内部实现\" class=\"headerlink\" title=\"一、内部实现\"></a>一、内部实现</h3><p>集合类型的内部编码有两种：</p>\n<ul>\n<li><p><a href=\"[https://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/](https://blog.laoyu.site/2019/redis/Redis数据结构——整数集合/\">intset(整数集合)</a>):当集合中的元素都是整数且元素个数小于set-maxintset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</p>\n</li>\n<li><p><a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/\">hashtable(哈希表)</a>:当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。</p>\n</li>\n</ul>\n<p>有关intset和hashtable这两种redis底层数据结构的具体实现可以参考我的另外两篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/\">Redis数据结构——整数集合</a></p>\n<p><a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/\">Redis数据结构——字典</a>。</p>\n<h3 id=\"二、常用命令\"><a href=\"#二、常用命令\" class=\"headerlink\" title=\"二、常用命令\"></a>二、常用命令</h3><p>Redis列表对象常用命令如下表(点击命令可查看命令详细说明)。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sadd/\">SADD key member [member …]</a></td>\n<td>添加一个或者多个元素到集合(set)里</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/scard/\">SCARD key</a></td>\n<td>获取集合里面的元素数量</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sdiff/\">SDIFF key [key …]</a></td>\n<td>获得队列不存在的元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sdiffstore/\">SDIFFSTORE destination key [key …]</a></td>\n<td>获得队列不存在的元素，并存储在一个关键的结果集</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sinter/\">SINTER key [key …]</a></td>\n<td>获得两个集合的交集</td>\n<td>O(N*M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sinterstore/\">SINTERSTORE destination key [key …]</a></td>\n<td>获得两个集合的交集，并存储在一个关键的结果集</td>\n<td>O(N*M)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sismember/\">SISMEMBER key member</a></td>\n<td>确定一个给定的值是一个集合的成员</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/smembers/\">SMEMBERS key</a></td>\n<td>获取集合里面的所有元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/smove/\">SMOVE source destination member</a></td>\n<td>移动集合里面的一个元素到另一个集合</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/spop/\">SPOP key [count]</a></td>\n<td>删除并获取一个集合里面的元素</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/srandmember/\">SRANDMEMBER key [count]</a></td>\n<td>从集合里面随机获取一个元素</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/srem/\">SREM key member [member …]</a></td>\n<td>从集合里删除一个或多个元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sunion/\">SUNION key [key …]</a></td>\n<td>添加多个set元素</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sunionstore/\">SUNIONSTORE destination key [key …]</a></td>\n<td>合并set元素，并将结果存入新的set里面</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td><a href=\"http://blog.laoyu.site/2020/redis_command/set/sscan/\">SSCAN key cursor [MATCH pattern] [COUNT count]</a></td>\n<td>迭代set里面的元素</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"三、使用场景\"><a href=\"#三、使用场景\" class=\"headerlink\" title=\"三、使用场景\"></a>三、使用场景</h3><p>通过上文，我们可以知道集合的主要几个特性，无序、不可重复、支持并交差等操作。因此集合类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p>\n<h4 id=\"3-1-标签系统\"><a href=\"#3-1-标签系统\" class=\"headerlink\" title=\"3.1 标签系统\"></a>3.1 标签系统</h4><p>集合类型比较典型的使用场景是标签（tag）。</p>\n<ol>\n<li><p>给用户添加标签。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sadd user:<span class=\"number\">1</span>:tags tag1 tag2 tag5</span><br><span class=\"line\">sadd user:<span class=\"number\">2</span>:tags tag2 tag3 tag5</span><br><span class=\"line\">...</span><br><span class=\"line\">sadd user:k:tags tag1 tag2 tag4</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>给标签添加用户</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sadd tag1:users user:<span class=\"number\">1</span> user:<span class=\"number\">3</span></span><br><span class=\"line\">sadd tag2:users user:<span class=\"number\">1</span> user:<span class=\"number\">2</span> user:<span class=\"number\">3</span></span><br><span class=\"line\">...</span><br><span class=\"line\">sadd tagk:users user:<span class=\"number\">1</span> user:<span class=\"number\">2</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用sinter命令，可以来计算用户共同感兴趣的标签</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sinter user:<span class=\"number\">1</span>:tags user:<span class=\"number\">2</span>:tags</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这种标签系统在电商系统、社交系统、视频网站，图书网站，旅游网站等都有着广泛的应用。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签，这些数据对于用户体验以及增强用户黏度比较重要。例如一个社交系统可以根据用户的标签进行好友的推荐，已经用户感兴趣的新闻的推荐等，一个电子商务的网站会对不同标签的用户做不同类型的推荐，比如对数码产品比较感兴趣的人，在各个页面或者通过邮件的形式给他们推荐最新的数码产品，通常会为网站带来更多的利益。</p>\n<h4 id=\"3-2-抽奖系统\"><a href=\"#3-2-抽奖系统\" class=\"headerlink\" title=\"3.2 抽奖系统\"></a>3.2 抽奖系统</h4><p>Redis集合的 <a href=\"https://blog.laoyu.site/2020/redis_command/set/spop/\">SPOP(随机移除并返回集合中一个或多个元素)</a> 和 <a href=\"https://blog.laoyu.site/2020/redis_command/set/srandmember/\">SRANDMEMBER(随机返回集合中一个或多个元素)</a> 命令可以帮助我们实现一个抽奖系统</p>\n<p>如果允许重复中奖，可以使用SRANDMEMBER 命令</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//添加抽奖名单</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Tom</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Jerry</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> John</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Marry</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Sean</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Lindy</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Echo</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//抽取三等奖3个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SRANDMEMBER lucky:<span class=\"number\">1</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"John\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Echo\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Lindy\"</span></span><br><span class=\"line\"><span class=\"comment\">//抽取二等奖2个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SRANDMEMBER lucky:<span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Sean\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Lindy\"</span></span><br><span class=\"line\"><span class=\"comment\">//抽取一等奖1个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SRANDMEMBER lucky:<span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Tom\"</span></span><br></pre></td></tr></table></figure>\n<p>如果不允许重复中奖，可以使用 SPOP 命令</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//添加抽奖名单</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Tom</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Jerry</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> John</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Marry</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Sean</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Lindy</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SADD lucky:<span class=\"number\">1</span> Echo</span><br><span class=\"line\">(integer) <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//抽取三等奖3个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SPOP lucky:<span class=\"number\">1</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"John\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Echo\"</span></span><br><span class=\"line\"><span class=\"number\">3</span>) <span class=\"string\">\"Lindy\"</span></span><br><span class=\"line\"><span class=\"comment\">//抽取二等奖2个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SPOP lucky:<span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Sean\"</span></span><br><span class=\"line\"><span class=\"number\">2</span>) <span class=\"string\">\"Marry\"</span></span><br><span class=\"line\"><span class=\"comment\">//抽取一等奖1个</span></span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">6379</span>&gt; SPOP lucky:<span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>) <span class=\"string\">\"Tom\"</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意:</strong></p>\n<p>Redis 2.6版本开始SRANDMEMBER命令支持Count参数。</p>\n<p>Redis 3.2版本开始SRANDMEMBER命令支持Count参数。</p>\n<p>其余低版本一次只能获取一个随机元素。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本篇文章我们总结了Redis 集合对象的内部实现、常用命令以及常用的一些场景，那么大家在项目中对Redis集合对象的使用都有哪些场景呢，欢迎在评论区给我留言和分享，我会第一时间反馈！我们共同学习与进步！</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>"},{"title":"Redis数据结构——quicklist","copyright":true,"date":"2020-03-23T02:45:38.000Z","keywords":"Redis,quicklist","aside":"redis","_content":"### 前言\n\n之前的文章我们曾总结到了[Redis数据结构——链表](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/)和[Redis数据结构——压缩列表](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/)这两种数据结构，他们是Redis List(列表)对象的底层实现方式。但是考虑到链表的附加空间相对太高，prev 和 next 指针就要占去 16 个字节 (64bit 系统的指针是 8 个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。因此Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.\n\n<!--more-->\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/%E9%93%BE%E8%A1%A8%26%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png)\n\n### 一、基本结构\n\n&nbsp;&nbsp;&nbsp;&nbsp;quicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/QuickList.png)\n\n```c\ntypedef struct quicklistNode {\n    struct quicklistNode *prev; //上一个node节点\n    struct quicklistNode *next; //下一个node\n    unsigned char *zl;            //保存的数据 压缩前ziplist 压缩后压缩的数据\n    unsigned int sz;             /* ziplist size in bytes */\n    unsigned int count : 16;     /* count of items in ziplist */\n    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */\n    unsigned int container : 2;  /* NONE==1 or ZIPLIST==2 */\n    unsigned int recompress : 1; /* was this node previous compressed? */\n    unsigned int attempted_compress : 1; /* node can't compress; too small */\n    unsigned int extra : 10; /* more bits to steal for future usage */\n} quicklistNode;\n```\n- prev: 指向链表前一个节点的指针。\n- next: 指向链表后一个节点的指针。\n- zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。\n- sz: 表示zl指向的ziplist的总大小（包括`zlbytes`, `zltail`, `zllen`, `zlend`和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。\n- count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。\n- encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。\n- container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。\n- recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩。\n- attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。\n- extra: 其它扩展字段。目前Redis的实现里也没用上。\n\n```c\ntypedef struct quicklistLZF {\n    unsigned int sz; /* LZF size in bytes*/\n    char compressed[];\n} quicklistLZF;\n```\nquicklistLZF结构表示一个被压缩过的ziplist。其中：\n\n- sz: 表示压缩后的ziplist大小。\n- compressed: 是个柔性数组（[flexible array member](https://en.wikipedia.org/wiki/Flexible_array_member)），存放压缩后的ziplist字节数组。\n\n```c\ntypedef struct quicklist {\n    quicklistNode *head;\n    quicklistNode *tail;\n    unsigned long count;        /* total count of all entries in all ziplists */\n    unsigned long len;          /* number of quicklistNodes */\n    int fill : QL_FILL_BITS;              /* fill factor for individual nodes */\n    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */\n    unsigned int bookmark_count: QL_BM_BITS;\n    quicklistBookmark bookmarks[];\n} quicklist;\n```\n\n- head: 指向头节点（左侧第一个节点）的指针。\n- tail: 指向尾节点（右侧第一个节点）的指针。\n- count: 所有ziplist数据项的个数总和。\n- len: quicklist节点的个数。\n- fill: 16bit，ziplist大小设置，存放`list-max-ziplist-size`参数的值。\n- compress: 16bit，节点压缩深度设置，存放`list-compress-depth`参数的值。\n\n### 二、常用操作\n\n#### 2.1 插入\n\nquicklist可以选择在头部或者尾部进行插入(`quicklistPushHead`和`quicklistPushTail`)，而不管是在头部还是尾部插入数据，都包含两种情况：\n\n- 如果头节点（或尾节点）上ziplist大小没有超过限制（即`_quicklistNodeAllowInsert`返回1），那么新数据被直接插入到ziplist中（调用`ziplistPush`）。\n- 如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到quicklist双向链表中。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%20%284%29.png)\n\n也可以从任意指定的位置插入。`quicklistInsertAfter`和`quicklistInsertBefore`就是分别在指定位置后面和前面插入数据项。这种在任意指定位置插入数据的操作，要比在头部和尾部的进行插入要复杂一些。\n\n- 当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；\n- 当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；\n- 当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。\n- 对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。\n\n#### 2.2 查找\n\nlist的查找操作主要是对index的我们的quicklist的节点是由一个一个的ziplist构成的每个ziplist都有大小。所以我们就只需要先根据我们每个node的个数，从而找到对应的ziplist，调用ziplist的index就能成功找到。\n\n#### 2.3 删除\n\n区间元素删除的函数是 quicklistDelRange\n\nquicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。\n\nquicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。\n\n#### 2.4 其它\n\n除了上面介绍的基本操作之外还有一些其它操作，大家可以尝试着根据链表和压缩列表的数据结构来分析一些quicklist这些操作的时间复杂度。\n\n| 操作                                            | 时间复杂度 |\n| ----------------------------------------------- | ---------- |\n| quicklistCreate:创建 quicklist                  | ？         |\n| quicklistInsertAfter：在某个元素的后面添加数据  | ？         |\n| quicklistInsertBefore：在某个元素的前面添加数据 | ？         |\n| quicklistReplaceAtIndex：替换某个元素           | ？         |\n| quicklistDelEntry：删除单个元素                 | ？         |\n| quicklistDelRange：删除区间元素                 | ？         |\n| quicklistPushHead:头部插入元素                  | ？         |\n| quicklistPushTail:尾部插入元素                  | ？         |\n\n### 小结\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis quicklist是Redis 3.2版本以后针对链表和压缩列表进行改造的一种数据结构，是 zipList 和 linkedList 的混合体，相对于链表它压缩了内存。进一步的提高了效率。\n\n如果你有什么疑问，欢迎在评论区给我留言和分享，我会第一时间反馈！我们一起共同学习与进步！\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n\n\n### -----END-----\n\n","source":"_posts/技术实践/redis/Redis数据结构——quicklist.md","raw":"---\n\ntitle: Redis数据结构——quicklist\ncopyright: true\ndate: 2020-03-23 10:45:38\ntags: \n- Redis\ncategories: Redis\nkeywords: Redis,quicklist\naside: redis\n---\n### 前言\n\n之前的文章我们曾总结到了[Redis数据结构——链表](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/)和[Redis数据结构——压缩列表](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/)这两种数据结构，他们是Redis List(列表)对象的底层实现方式。但是考虑到链表的附加空间相对太高，prev 和 next 指针就要占去 16 个字节 (64bit 系统的指针是 8 个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。因此Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.\n\n<!--more-->\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/%E9%93%BE%E8%A1%A8%26%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png)\n\n### 一、基本结构\n\n&nbsp;&nbsp;&nbsp;&nbsp;quicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/QuickList.png)\n\n```c\ntypedef struct quicklistNode {\n    struct quicklistNode *prev; //上一个node节点\n    struct quicklistNode *next; //下一个node\n    unsigned char *zl;            //保存的数据 压缩前ziplist 压缩后压缩的数据\n    unsigned int sz;             /* ziplist size in bytes */\n    unsigned int count : 16;     /* count of items in ziplist */\n    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */\n    unsigned int container : 2;  /* NONE==1 or ZIPLIST==2 */\n    unsigned int recompress : 1; /* was this node previous compressed? */\n    unsigned int attempted_compress : 1; /* node can't compress; too small */\n    unsigned int extra : 10; /* more bits to steal for future usage */\n} quicklistNode;\n```\n- prev: 指向链表前一个节点的指针。\n- next: 指向链表后一个节点的指针。\n- zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。\n- sz: 表示zl指向的ziplist的总大小（包括`zlbytes`, `zltail`, `zllen`, `zlend`和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。\n- count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。\n- encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。\n- container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。\n- recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩。\n- attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。\n- extra: 其它扩展字段。目前Redis的实现里也没用上。\n\n```c\ntypedef struct quicklistLZF {\n    unsigned int sz; /* LZF size in bytes*/\n    char compressed[];\n} quicklistLZF;\n```\nquicklistLZF结构表示一个被压缩过的ziplist。其中：\n\n- sz: 表示压缩后的ziplist大小。\n- compressed: 是个柔性数组（[flexible array member](https://en.wikipedia.org/wiki/Flexible_array_member)），存放压缩后的ziplist字节数组。\n\n```c\ntypedef struct quicklist {\n    quicklistNode *head;\n    quicklistNode *tail;\n    unsigned long count;        /* total count of all entries in all ziplists */\n    unsigned long len;          /* number of quicklistNodes */\n    int fill : QL_FILL_BITS;              /* fill factor for individual nodes */\n    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */\n    unsigned int bookmark_count: QL_BM_BITS;\n    quicklistBookmark bookmarks[];\n} quicklist;\n```\n\n- head: 指向头节点（左侧第一个节点）的指针。\n- tail: 指向尾节点（右侧第一个节点）的指针。\n- count: 所有ziplist数据项的个数总和。\n- len: quicklist节点的个数。\n- fill: 16bit，ziplist大小设置，存放`list-max-ziplist-size`参数的值。\n- compress: 16bit，节点压缩深度设置，存放`list-compress-depth`参数的值。\n\n### 二、常用操作\n\n#### 2.1 插入\n\nquicklist可以选择在头部或者尾部进行插入(`quicklistPushHead`和`quicklistPushTail`)，而不管是在头部还是尾部插入数据，都包含两种情况：\n\n- 如果头节点（或尾节点）上ziplist大小没有超过限制（即`_quicklistNodeAllowInsert`返回1），那么新数据被直接插入到ziplist中（调用`ziplistPush`）。\n- 如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到quicklist双向链表中。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%20%284%29.png)\n\n也可以从任意指定的位置插入。`quicklistInsertAfter`和`quicklistInsertBefore`就是分别在指定位置后面和前面插入数据项。这种在任意指定位置插入数据的操作，要比在头部和尾部的进行插入要复杂一些。\n\n- 当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；\n- 当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；\n- 当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。\n- 对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。\n\n#### 2.2 查找\n\nlist的查找操作主要是对index的我们的quicklist的节点是由一个一个的ziplist构成的每个ziplist都有大小。所以我们就只需要先根据我们每个node的个数，从而找到对应的ziplist，调用ziplist的index就能成功找到。\n\n#### 2.3 删除\n\n区间元素删除的函数是 quicklistDelRange\n\nquicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。\n\nquicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。\n\n#### 2.4 其它\n\n除了上面介绍的基本操作之外还有一些其它操作，大家可以尝试着根据链表和压缩列表的数据结构来分析一些quicklist这些操作的时间复杂度。\n\n| 操作                                            | 时间复杂度 |\n| ----------------------------------------------- | ---------- |\n| quicklistCreate:创建 quicklist                  | ？         |\n| quicklistInsertAfter：在某个元素的后面添加数据  | ？         |\n| quicklistInsertBefore：在某个元素的前面添加数据 | ？         |\n| quicklistReplaceAtIndex：替换某个元素           | ？         |\n| quicklistDelEntry：删除单个元素                 | ？         |\n| quicklistDelRange：删除区间元素                 | ？         |\n| quicklistPushHead:头部插入元素                  | ？         |\n| quicklistPushTail:尾部插入元素                  | ？         |\n\n### 小结\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis quicklist是Redis 3.2版本以后针对链表和压缩列表进行改造的一种数据结构，是 zipList 和 linkedList 的混合体，相对于链表它压缩了内存。进一步的提高了效率。\n\n如果你有什么疑问，欢迎在评论区给我留言和分享，我会第一时间反馈！我们一起共同学习与进步！\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n\n\n### -----END-----\n\n","slug":"技术实践/redis/Redis数据结构——quicklist","published":1,"updated":"2021-04-03T04:13:46.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzo00echyjfar91vjaf","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>之前的文章我们曾总结到了<a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/\">Redis数据结构——链表</a>和<a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">Redis数据结构——压缩列表</a>这两种数据结构，他们是Redis List(列表)对象的底层实现方式。但是考虑到链表的附加空间相对太高，prev 和 next 指针就要占去 16 个字节 (64bit 系统的指针是 8 个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。因此Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.</p>\n<a id=\"more\"></a>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/%E9%93%BE%E8%A1%A8%26%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png\" alt></p>\n<h3 id=\"一、基本结构\"><a href=\"#一、基本结构\" class=\"headerlink\" title=\"一、基本结构\"></a>一、基本结构</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;quicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/QuickList.png\" alt></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistNode</span> *<span class=\"title\">prev</span>;</span> <span class=\"comment\">//上一个node节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistNode</span> *<span class=\"title\">next</span>;</span> <span class=\"comment\">//下一个node</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl;            <span class=\"comment\">//保存的数据 压缩前ziplist 压缩后压缩的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> sz;             <span class=\"comment\">/* ziplist size in bytes */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> count : <span class=\"number\">16</span>;     <span class=\"comment\">/* count of items in ziplist */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> encoding : <span class=\"number\">2</span>;   <span class=\"comment\">/* RAW==1 or LZF==2 */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> container : <span class=\"number\">2</span>;  <span class=\"comment\">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> recompress : <span class=\"number\">1</span>; <span class=\"comment\">/* was this node previous compressed? */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> attempted_compress : <span class=\"number\">1</span>; <span class=\"comment\">/* node can't compress; too small */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> extra : <span class=\"number\">10</span>; <span class=\"comment\">/* more bits to steal for future usage */</span></span><br><span class=\"line\">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>prev: 指向链表前一个节点的指针。</li>\n<li>next: 指向链表后一个节点的指针。</li>\n<li>zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。</li>\n<li>sz: 表示zl指向的ziplist的总大小（包括<code>zlbytes</code>, <code>zltail</code>, <code>zllen</code>, <code>zlend</code>和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。</li>\n<li>count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。</li>\n<li>encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。</li>\n<li>container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。</li>\n<li>recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩。</li>\n<li>attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。</li>\n<li>extra: 其它扩展字段。目前Redis的实现里也没用上。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistLZF</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> sz; <span class=\"comment\">/* LZF size in bytes*/</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> compressed[];</span><br><span class=\"line\">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure>\n<p>quicklistLZF结构表示一个被压缩过的ziplist。其中：</p>\n<ul>\n<li>sz: 表示压缩后的ziplist大小。</li>\n<li>compressed: 是个柔性数组（<a href=\"https://en.wikipedia.org/wiki/Flexible_array_member\" target=\"_blank\" rel=\"noopener\">flexible array member</a>），存放压缩后的ziplist字节数组。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklist</span> &#123;</span></span><br><span class=\"line\">    quicklistNode *head;</span><br><span class=\"line\">    quicklistNode *tail;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count;        <span class=\"comment\">/* total count of all entries in all ziplists */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;          <span class=\"comment\">/* number of quicklistNodes */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> fill : QL_FILL_BITS;              <span class=\"comment\">/* fill factor for individual nodes */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> compress : QL_COMP_BITS; <span class=\"comment\">/* depth of end nodes not to compress;0=off */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> bookmark_count: QL_BM_BITS;</span><br><span class=\"line\">    quicklistBookmark bookmarks[];</span><br><span class=\"line\">&#125; quicklist;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>head: 指向头节点（左侧第一个节点）的指针。</li>\n<li>tail: 指向尾节点（右侧第一个节点）的指针。</li>\n<li>count: 所有ziplist数据项的个数总和。</li>\n<li>len: quicklist节点的个数。</li>\n<li>fill: 16bit，ziplist大小设置，存放<code>list-max-ziplist-size</code>参数的值。</li>\n<li>compress: 16bit，节点压缩深度设置，存放<code>list-compress-depth</code>参数的值。</li>\n</ul>\n<h3 id=\"二、常用操作\"><a href=\"#二、常用操作\" class=\"headerlink\" title=\"二、常用操作\"></a>二、常用操作</h3><h4 id=\"2-1-插入\"><a href=\"#2-1-插入\" class=\"headerlink\" title=\"2.1 插入\"></a>2.1 插入</h4><p>quicklist可以选择在头部或者尾部进行插入(<code>quicklistPushHead</code>和<code>quicklistPushTail</code>)，而不管是在头部还是尾部插入数据，都包含两种情况：</p>\n<ul>\n<li>如果头节点（或尾节点）上ziplist大小没有超过限制（即<code>_quicklistNodeAllowInsert</code>返回1），那么新数据被直接插入到ziplist中（调用<code>ziplistPush</code>）。</li>\n<li>如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到quicklist双向链表中。</li>\n</ul>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%20%284%29.png\" alt></p>\n<p>也可以从任意指定的位置插入。<code>quicklistInsertAfter</code>和<code>quicklistInsertBefore</code>就是分别在指定位置后面和前面插入数据项。这种在任意指定位置插入数据的操作，要比在头部和尾部的进行插入要复杂一些。</p>\n<ul>\n<li>当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；</li>\n<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；</li>\n<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。</li>\n<li>对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。</li>\n</ul>\n<h4 id=\"2-2-查找\"><a href=\"#2-2-查找\" class=\"headerlink\" title=\"2.2 查找\"></a>2.2 查找</h4><p>list的查找操作主要是对index的我们的quicklist的节点是由一个一个的ziplist构成的每个ziplist都有大小。所以我们就只需要先根据我们每个node的个数，从而找到对应的ziplist，调用ziplist的index就能成功找到。</p>\n<h4 id=\"2-3-删除\"><a href=\"#2-3-删除\" class=\"headerlink\" title=\"2.3 删除\"></a>2.3 删除</h4><p>区间元素删除的函数是 quicklistDelRange</p>\n<p>quicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。</p>\n<p>quicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。</p>\n<h4 id=\"2-4-其它\"><a href=\"#2-4-其它\" class=\"headerlink\" title=\"2.4 其它\"></a>2.4 其它</h4><p>除了上面介绍的基本操作之外还有一些其它操作，大家可以尝试着根据链表和压缩列表的数据结构来分析一些quicklist这些操作的时间复杂度。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>quicklistCreate:创建 quicklist</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistInsertAfter：在某个元素的后面添加数据</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistInsertBefore：在某个元素的前面添加数据</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistReplaceAtIndex：替换某个元素</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistDelEntry：删除单个元素</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistDelRange：删除区间元素</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistPushHead:头部插入元素</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistPushTail:尾部插入元素</td>\n<td>？</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis quicklist是Redis 3.2版本以后针对链表和压缩列表进行改造的一种数据结构，是 zipList 和 linkedList 的混合体，相对于链表它压缩了内存。进一步的提高了效率。</p>\n<p>如果你有什么疑问，欢迎在评论区给我留言和分享，我会第一时间反馈！我们一起共同学习与进步！</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>之前的文章我们曾总结到了<a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/\">Redis数据结构——链表</a>和<a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">Redis数据结构——压缩列表</a>这两种数据结构，他们是Redis List(列表)对象的底层实现方式。但是考虑到链表的附加空间相对太高，prev 和 next 指针就要占去 16 个字节 (64bit 系统的指针是 8 个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。因此Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.</p>","more":"<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/%E9%93%BE%E8%A1%A8%26%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png\" alt></p>\n<h3 id=\"一、基本结构\"><a href=\"#一、基本结构\" class=\"headerlink\" title=\"一、基本结构\"></a>一、基本结构</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;quicklist 实际上是 zipList 和 linkedList 的混合体，它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/QuickList.png\" alt></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistNode</span> *<span class=\"title\">prev</span>;</span> <span class=\"comment\">//上一个node节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistNode</span> *<span class=\"title\">next</span>;</span> <span class=\"comment\">//下一个node</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl;            <span class=\"comment\">//保存的数据 压缩前ziplist 压缩后压缩的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> sz;             <span class=\"comment\">/* ziplist size in bytes */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> count : <span class=\"number\">16</span>;     <span class=\"comment\">/* count of items in ziplist */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> encoding : <span class=\"number\">2</span>;   <span class=\"comment\">/* RAW==1 or LZF==2 */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> container : <span class=\"number\">2</span>;  <span class=\"comment\">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> recompress : <span class=\"number\">1</span>; <span class=\"comment\">/* was this node previous compressed? */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> attempted_compress : <span class=\"number\">1</span>; <span class=\"comment\">/* node can't compress; too small */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> extra : <span class=\"number\">10</span>; <span class=\"comment\">/* more bits to steal for future usage */</span></span><br><span class=\"line\">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>prev: 指向链表前一个节点的指针。</li>\n<li>next: 指向链表后一个节点的指针。</li>\n<li>zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。</li>\n<li>sz: 表示zl指向的ziplist的总大小（包括<code>zlbytes</code>, <code>zltail</code>, <code>zllen</code>, <code>zlend</code>和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。</li>\n<li>count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。</li>\n<li>encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。</li>\n<li>container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。</li>\n<li>recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩。</li>\n<li>attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。</li>\n<li>extra: 其它扩展字段。目前Redis的实现里也没用上。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklistLZF</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> sz; <span class=\"comment\">/* LZF size in bytes*/</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> compressed[];</span><br><span class=\"line\">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure>\n<p>quicklistLZF结构表示一个被压缩过的ziplist。其中：</p>\n<ul>\n<li>sz: 表示压缩后的ziplist大小。</li>\n<li>compressed: 是个柔性数组（<a href=\"https://en.wikipedia.org/wiki/Flexible_array_member\" target=\"_blank\" rel=\"noopener\">flexible array member</a>），存放压缩后的ziplist字节数组。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklist</span> &#123;</span></span><br><span class=\"line\">    quicklistNode *head;</span><br><span class=\"line\">    quicklistNode *tail;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> count;        <span class=\"comment\">/* total count of all entries in all ziplists */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;          <span class=\"comment\">/* number of quicklistNodes */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> fill : QL_FILL_BITS;              <span class=\"comment\">/* fill factor for individual nodes */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> compress : QL_COMP_BITS; <span class=\"comment\">/* depth of end nodes not to compress;0=off */</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> bookmark_count: QL_BM_BITS;</span><br><span class=\"line\">    quicklistBookmark bookmarks[];</span><br><span class=\"line\">&#125; quicklist;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>head: 指向头节点（左侧第一个节点）的指针。</li>\n<li>tail: 指向尾节点（右侧第一个节点）的指针。</li>\n<li>count: 所有ziplist数据项的个数总和。</li>\n<li>len: quicklist节点的个数。</li>\n<li>fill: 16bit，ziplist大小设置，存放<code>list-max-ziplist-size</code>参数的值。</li>\n<li>compress: 16bit，节点压缩深度设置，存放<code>list-compress-depth</code>参数的值。</li>\n</ul>\n<h3 id=\"二、常用操作\"><a href=\"#二、常用操作\" class=\"headerlink\" title=\"二、常用操作\"></a>二、常用操作</h3><h4 id=\"2-1-插入\"><a href=\"#2-1-插入\" class=\"headerlink\" title=\"2.1 插入\"></a>2.1 插入</h4><p>quicklist可以选择在头部或者尾部进行插入(<code>quicklistPushHead</code>和<code>quicklistPushTail</code>)，而不管是在头部还是尾部插入数据，都包含两种情况：</p>\n<ul>\n<li>如果头节点（或尾节点）上ziplist大小没有超过限制（即<code>_quicklistNodeAllowInsert</code>返回1），那么新数据被直接插入到ziplist中（调用<code>ziplistPush</code>）。</li>\n<li>如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到quicklist双向链表中。</li>\n</ul>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/quicklist/%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%20%284%29.png\" alt></p>\n<p>也可以从任意指定的位置插入。<code>quicklistInsertAfter</code>和<code>quicklistInsertBefore</code>就是分别在指定位置后面和前面插入数据项。这种在任意指定位置插入数据的操作，要比在头部和尾部的进行插入要复杂一些。</p>\n<ul>\n<li>当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；</li>\n<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；</li>\n<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。</li>\n<li>对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。</li>\n</ul>\n<h4 id=\"2-2-查找\"><a href=\"#2-2-查找\" class=\"headerlink\" title=\"2.2 查找\"></a>2.2 查找</h4><p>list的查找操作主要是对index的我们的quicklist的节点是由一个一个的ziplist构成的每个ziplist都有大小。所以我们就只需要先根据我们每个node的个数，从而找到对应的ziplist，调用ziplist的index就能成功找到。</p>\n<h4 id=\"2-3-删除\"><a href=\"#2-3-删除\" class=\"headerlink\" title=\"2.3 删除\"></a>2.3 删除</h4><p>区间元素删除的函数是 quicklistDelRange</p>\n<p>quicklist 在区间删除时，会先找到 start 所在的 quicklistNode，计算删除的元素是否小于要删除的 count，如果不满足删除的个数，则会移动至下一个 quicklistNode 继续删除，依次循环直到删除完成为止。</p>\n<p>quicklistDelRange 函数的返回值为 int 类型，当返回 1 时表示成功的删除了指定区间的元素，返回 0 时表示没有删除任何元素。</p>\n<h4 id=\"2-4-其它\"><a href=\"#2-4-其它\" class=\"headerlink\" title=\"2.4 其它\"></a>2.4 其它</h4><p>除了上面介绍的基本操作之外还有一些其它操作，大家可以尝试着根据链表和压缩列表的数据结构来分析一些quicklist这些操作的时间复杂度。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>quicklistCreate:创建 quicklist</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistInsertAfter：在某个元素的后面添加数据</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistInsertBefore：在某个元素的前面添加数据</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistReplaceAtIndex：替换某个元素</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistDelEntry：删除单个元素</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistDelRange：删除区间元素</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistPushHead:头部插入元素</td>\n<td>？</td>\n</tr>\n<tr>\n<td>quicklistPushTail:尾部插入元素</td>\n<td>？</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis quicklist是Redis 3.2版本以后针对链表和压缩列表进行改造的一种数据结构，是 zipList 和 linkedList 的混合体，相对于链表它压缩了内存。进一步的提高了效率。</p>\n<p>如果你有什么疑问，欢迎在评论区给我留言和分享，我会第一时间反馈！我们一起共同学习与进步！</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>"},{"title":"Redis数据结构——压缩列表","copyright":true,"date":"2019-08-05T23:45:04.000Z","keywords":"Redis,数据结构,压缩列表","aside":"redis","_content":"\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;同整数集合一样压缩列表也不是基础数据结构，而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。\n\n<!--more-->\n\n### 一、压缩列表\n\n&nbsp;&nbsp;&nbsp;&nbsp;听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存,是相较于数组的存储思路而言的。我们知道,数组要求每个元素的大小相同,如果我们要存储不同长度的字符串,那我们就需要用最大长度的字符串大小作为元素的大小(假设是20个字节)。存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E6%95%B0%E7%BB%84.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;数组的优势占用一片连续的空间可以很好的利用CPU缓存访问数据。如果我们想要保留这种优势，又想节省存储空间我们可以对数组进行压缩。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E6%95%B0%E7%BB%84%E5%8E%8B%E7%BC%A9.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样有一个问题，我们在遍历它的时候由于不知道每个元素的大小是多少，因此也就无法计算出下一个节点的具体位置。这个时候我们可以给每个节点增加一个lenght的属性。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如此。我们在遍历节点的之后就知道每个节点的长度(占用内存的大小)，就可以很容易计算出下一个节点再内存中的位置。这种结构就像一个简单的压缩列表了。\n\n### 二、Redis压缩列表\n\n&nbsp;&nbsp;&nbsp;&nbsp;压缩列表(zip1ist)是列表和哈希的底层实现之一。\n\n&nbsp;&nbsp;&nbsp;&nbsp;当一个列表只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表的底层实现。\n\n&nbsp;&nbsp;&nbsp;&nbsp;当一个哈希只包含少量键值对,比且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做哈希的底层实现。\n\n#### 2.1 Redis压缩列表的构成\n\n&nbsp;&nbsp;&nbsp;&nbsp;压缩列表是Redis为了节约内存而开发的,是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结枃。一个压缩列表可以包含任意多个节点(entry),每个节点可以保存一个字节数组或者一个整数值，如下图。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/Redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84.png)\n\n示例：\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/Redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84-Example.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上图，展示了一个总长为80字节，包含3个节点的压缩列表。如果我们有一个指向压缩列表起始地址的指针p，那么表为节点的地址就是P+60。\n\n#### 2.2 Redis压缩列表节点的构成\n\n&nbsp;&nbsp;&nbsp;&nbsp;每个压缩列表节点可以保存一个字节数组或者一个整数值。其中，字节数组可以是以下三种长度中的一种。\n\n- 长度小于等于63(2^6-1)字节的字节数组;\n- 长度小于等于16383(2^14-1)字节的字节数组\n- 长度小于等于4294967295(2^32-1)字节的字节数组\n\n整数值可以是以下6种长度中的一种\n\n- 4位长,介于0至12之间的无符号整数\n- 1字节长的有符号整数\n- 3字节长的有符号整数\n- int16_t类型整数\n- int32_t类型整数\n- int64_t类型整数\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;节点的 previous_entry_length属性以字节为单位,记录了压缩列表中前一个节点的长度。 previous_entry_length属性的长度可以是1字节或者5字节。\n\n- 如果前一节点的长度小于254字节,那么 previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。\n- 如果前一节点的长度大于等于254字节,那么 previous_entry_length属性的长度为5字节:其中属性的第一字节会被设置为0xFE(十进制值254),而之后的四个字节则用于保存前一节点的长度.\n\n&nbsp;&nbsp;&nbsp;&nbsp;节点的encoding属性记录了节点的content属性所保存数据的类型以及长度。\n\n- 一字节、两字节或者五字节长,值的最高位为00、01或者10的是字节数组编码这种编码表示节点的 content属性保存着字节数组,数组的长度由编码除去最高两位之后的其他位记录。\n- 一字节长,值的最高位以11开头的是整数编码:这种编码表示节点的content属性保存着整数值,整数值的类型和长度由编码除去最高两位之后的其他位记录。\n\n&nbsp;&nbsp;&nbsp;&nbsp;节点的content属性负责保存节点的值,节点值可以是一个字节数组或者整数,值的类型和长度由节点的encoding属性决定。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B1.png)\n\n- 编码的最高两位00表示节点保存的是一个字节数组。\n- 编码的后六位001011记录了字节数组的长度11。\n- content属性保存着节点的值\"hello world\"。\n- 编码11000000表示节点保存的是一个int16_t类型的整数值;\n- content属性保存着节点的值10086\n\n#### 2.3 常用操作的时间复杂度\n\n| 操作                                                         | 时间复杂度                                                   |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 创建一个新的压缩列表                                         | O(1)                                                         |\n| 创建一个包含给定值的新节点,并将这个新节点添加到压缩列表的表头或者表尾 | 平均O(N)，最坏O(N^2)(可能发生连锁更新)                       |\n| 将包含给定值的新节点插人到给定节点之后                       | 平均O(N)，最坏O(N^2)(可能发生连锁更新)                       |\n| 返回压缩列表给定索引上的节点                                 | O(N)                                                         |\n| 在压缩列表中査找并返回包含了给定值的节点                     | 因为节点的值可能是一个字节数组,所以检查节点值和给定值是否相同的复杂度为O(N),而查找整个列表的复杂度则为(N^2) |\n| 返回给定节点的下一个节点                                     | O(1)                                                         |\n| 返回给定节点的前一个节点                                     | O(1)                                                         |\n| 获取给定节点所保存的值                                       | O(1)                                                         |\n| 从压缩列表中删除给定的节点                                   | 平均O(N)，最坏O(N^2)(可能发生连锁更新)                       |\n| 删除压缩列表在给定索引上的连续多个                           | 平均O(N)，最坏O(N^2)(可能发生连锁更新)                       |\n| 返回压缩列表目前占用的内存字节数                             | O(1)                                                         |\n| 返回压缩列表目前包含的节点数量                               | 点数量小于65535时为O(1),大于65535时为O(N)                    |\n\n### 本文重点\n\n- 压缩列表是Redis为节约内存自己设计的一种顺序型数据结构。\n- 压缩列表被用作列表键和哈希键的底层实现之一。\n- 压缩列表可以包含多个节点,每个节点可以保存一个字节数组或者整数值。\n- 添加新节点到压缩列表,或者从压缩列表中删除节点,可能会引发连锁更新操作,但这种操作出现的几率并不高。\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n\n\n### -----END-----\n\n","source":"_posts/技术实践/redis/Redis数据结构——压缩列表.md","raw":"---\ntitle: Redis数据结构——压缩列表\ncopyright: true\ndate: 2019-08-06 07:45:04\ntags:\n- Redis\n- 数据结构\ncategories: Redis\nkeywords: Redis,数据结构,压缩列表\naside: redis\n---\n\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;同整数集合一样压缩列表也不是基础数据结构，而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。\n\n<!--more-->\n\n### 一、压缩列表\n\n&nbsp;&nbsp;&nbsp;&nbsp;听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存,是相较于数组的存储思路而言的。我们知道,数组要求每个元素的大小相同,如果我们要存储不同长度的字符串,那我们就需要用最大长度的字符串大小作为元素的大小(假设是20个字节)。存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E6%95%B0%E7%BB%84.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;数组的优势占用一片连续的空间可以很好的利用CPU缓存访问数据。如果我们想要保留这种优势，又想节省存储空间我们可以对数组进行压缩。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E6%95%B0%E7%BB%84%E5%8E%8B%E7%BC%A9.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样有一个问题，我们在遍历它的时候由于不知道每个元素的大小是多少，因此也就无法计算出下一个节点的具体位置。这个时候我们可以给每个节点增加一个lenght的属性。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如此。我们在遍历节点的之后就知道每个节点的长度(占用内存的大小)，就可以很容易计算出下一个节点再内存中的位置。这种结构就像一个简单的压缩列表了。\n\n### 二、Redis压缩列表\n\n&nbsp;&nbsp;&nbsp;&nbsp;压缩列表(zip1ist)是列表和哈希的底层实现之一。\n\n&nbsp;&nbsp;&nbsp;&nbsp;当一个列表只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表的底层实现。\n\n&nbsp;&nbsp;&nbsp;&nbsp;当一个哈希只包含少量键值对,比且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做哈希的底层实现。\n\n#### 2.1 Redis压缩列表的构成\n\n&nbsp;&nbsp;&nbsp;&nbsp;压缩列表是Redis为了节约内存而开发的,是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结枃。一个压缩列表可以包含任意多个节点(entry),每个节点可以保存一个字节数组或者一个整数值，如下图。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/Redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84.png)\n\n示例：\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/Redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84-Example.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上图，展示了一个总长为80字节，包含3个节点的压缩列表。如果我们有一个指向压缩列表起始地址的指针p，那么表为节点的地址就是P+60。\n\n#### 2.2 Redis压缩列表节点的构成\n\n&nbsp;&nbsp;&nbsp;&nbsp;每个压缩列表节点可以保存一个字节数组或者一个整数值。其中，字节数组可以是以下三种长度中的一种。\n\n- 长度小于等于63(2^6-1)字节的字节数组;\n- 长度小于等于16383(2^14-1)字节的字节数组\n- 长度小于等于4294967295(2^32-1)字节的字节数组\n\n整数值可以是以下6种长度中的一种\n\n- 4位长,介于0至12之间的无符号整数\n- 1字节长的有符号整数\n- 3字节长的有符号整数\n- int16_t类型整数\n- int32_t类型整数\n- int64_t类型整数\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9.png)\n\n&nbsp;&nbsp;&nbsp;&nbsp;节点的 previous_entry_length属性以字节为单位,记录了压缩列表中前一个节点的长度。 previous_entry_length属性的长度可以是1字节或者5字节。\n\n- 如果前一节点的长度小于254字节,那么 previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。\n- 如果前一节点的长度大于等于254字节,那么 previous_entry_length属性的长度为5字节:其中属性的第一字节会被设置为0xFE(十进制值254),而之后的四个字节则用于保存前一节点的长度.\n\n&nbsp;&nbsp;&nbsp;&nbsp;节点的encoding属性记录了节点的content属性所保存数据的类型以及长度。\n\n- 一字节、两字节或者五字节长,值的最高位为00、01或者10的是字节数组编码这种编码表示节点的 content属性保存着字节数组,数组的长度由编码除去最高两位之后的其他位记录。\n- 一字节长,值的最高位以11开头的是整数编码:这种编码表示节点的content属性保存着整数值,整数值的类型和长度由编码除去最高两位之后的其他位记录。\n\n&nbsp;&nbsp;&nbsp;&nbsp;节点的content属性负责保存节点的值,节点值可以是一个字节数组或者整数,值的类型和长度由节点的encoding属性决定。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B1.png)\n\n- 编码的最高两位00表示节点保存的是一个字节数组。\n- 编码的后六位001011记录了字节数组的长度11。\n- content属性保存着节点的值\"hello world\"。\n- 编码11000000表示节点保存的是一个int16_t类型的整数值;\n- content属性保存着节点的值10086\n\n#### 2.3 常用操作的时间复杂度\n\n| 操作                                                         | 时间复杂度                                                   |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 创建一个新的压缩列表                                         | O(1)                                                         |\n| 创建一个包含给定值的新节点,并将这个新节点添加到压缩列表的表头或者表尾 | 平均O(N)，最坏O(N^2)(可能发生连锁更新)                       |\n| 将包含给定值的新节点插人到给定节点之后                       | 平均O(N)，最坏O(N^2)(可能发生连锁更新)                       |\n| 返回压缩列表给定索引上的节点                                 | O(N)                                                         |\n| 在压缩列表中査找并返回包含了给定值的节点                     | 因为节点的值可能是一个字节数组,所以检查节点值和给定值是否相同的复杂度为O(N),而查找整个列表的复杂度则为(N^2) |\n| 返回给定节点的下一个节点                                     | O(1)                                                         |\n| 返回给定节点的前一个节点                                     | O(1)                                                         |\n| 获取给定节点所保存的值                                       | O(1)                                                         |\n| 从压缩列表中删除给定的节点                                   | 平均O(N)，最坏O(N^2)(可能发生连锁更新)                       |\n| 删除压缩列表在给定索引上的连续多个                           | 平均O(N)，最坏O(N^2)(可能发生连锁更新)                       |\n| 返回压缩列表目前占用的内存字节数                             | O(1)                                                         |\n| 返回压缩列表目前包含的节点数量                               | 点数量小于65535时为O(1),大于65535时为O(N)                    |\n\n### 本文重点\n\n- 压缩列表是Redis为节约内存自己设计的一种顺序型数据结构。\n- 压缩列表被用作列表键和哈希键的底层实现之一。\n- 压缩列表可以包含多个节点,每个节点可以保存一个字节数组或者整数值。\n- 添加新节点到压缩列表,或者从压缩列表中删除节点,可能会引发连锁更新操作,但这种操作出现的几率并不高。\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n\n\n### -----END-----\n\n","slug":"技术实践/redis/Redis数据结构——压缩列表","published":1,"updated":"2021-03-14T03:04:50.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzp00ehhyjfv1jex8wa","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;同整数集合一样压缩列表也不是基础数据结构，而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。</p>\n<a id=\"more\"></a>\n<h3 id=\"一、压缩列表\"><a href=\"#一、压缩列表\" class=\"headerlink\" title=\"一、压缩列表\"></a>一、压缩列表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存,是相较于数组的存储思路而言的。我们知道,数组要求每个元素的大小相同,如果我们要存储不同长度的字符串,那我们就需要用最大长度的字符串大小作为元素的大小(假设是20个字节)。存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E6%95%B0%E7%BB%84.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;数组的优势占用一片连续的空间可以很好的利用CPU缓存访问数据。如果我们想要保留这种优势，又想节省存储空间我们可以对数组进行压缩。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E6%95%B0%E7%BB%84%E5%8E%8B%E7%BC%A9.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样有一个问题，我们在遍历它的时候由于不知道每个元素的大小是多少，因此也就无法计算出下一个节点的具体位置。这个时候我们可以给每个节点增加一个lenght的属性。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如此。我们在遍历节点的之后就知道每个节点的长度(占用内存的大小)，就可以很容易计算出下一个节点再内存中的位置。这种结构就像一个简单的压缩列表了。</p>\n<h3 id=\"二、Redis压缩列表\"><a href=\"#二、Redis压缩列表\" class=\"headerlink\" title=\"二、Redis压缩列表\"></a>二、Redis压缩列表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;压缩列表(zip1ist)是列表和哈希的底层实现之一。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;当一个列表只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表的底层实现。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;当一个哈希只包含少量键值对,比且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做哈希的底层实现。</p>\n<h4 id=\"2-1-Redis压缩列表的构成\"><a href=\"#2-1-Redis压缩列表的构成\" class=\"headerlink\" title=\"2.1 Redis压缩列表的构成\"></a>2.1 Redis压缩列表的构成</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;压缩列表是Redis为了节约内存而开发的,是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结枃。一个压缩列表可以包含任意多个节点(entry),每个节点可以保存一个字节数组或者一个整数值，如下图。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/Redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84.png\" alt></p>\n<p>示例：</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/Redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84-Example.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上图，展示了一个总长为80字节，包含3个节点的压缩列表。如果我们有一个指向压缩列表起始地址的指针p，那么表为节点的地址就是P+60。</p>\n<h4 id=\"2-2-Redis压缩列表节点的构成\"><a href=\"#2-2-Redis压缩列表节点的构成\" class=\"headerlink\" title=\"2.2 Redis压缩列表节点的构成\"></a>2.2 Redis压缩列表节点的构成</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;每个压缩列表节点可以保存一个字节数组或者一个整数值。其中，字节数组可以是以下三种长度中的一种。</p>\n<ul>\n<li>长度小于等于63(2^6-1)字节的字节数组;</li>\n<li>长度小于等于16383(2^14-1)字节的字节数组</li>\n<li>长度小于等于4294967295(2^32-1)字节的字节数组</li>\n</ul>\n<p>整数值可以是以下6种长度中的一种</p>\n<ul>\n<li>4位长,介于0至12之间的无符号整数</li>\n<li>1字节长的有符号整数</li>\n<li>3字节长的有符号整数</li>\n<li>int16_t类型整数</li>\n<li>int32_t类型整数</li>\n<li>int64_t类型整数</li>\n</ul>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;节点的 previous_entry_length属性以字节为单位,记录了压缩列表中前一个节点的长度。 previous_entry_length属性的长度可以是1字节或者5字节。</p>\n<ul>\n<li>如果前一节点的长度小于254字节,那么 previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。</li>\n<li>如果前一节点的长度大于等于254字节,那么 previous_entry_length属性的长度为5字节:其中属性的第一字节会被设置为0xFE(十进制值254),而之后的四个字节则用于保存前一节点的长度.</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;节点的encoding属性记录了节点的content属性所保存数据的类型以及长度。</p>\n<ul>\n<li>一字节、两字节或者五字节长,值的最高位为00、01或者10的是字节数组编码这种编码表示节点的 content属性保存着字节数组,数组的长度由编码除去最高两位之后的其他位记录。</li>\n<li>一字节长,值的最高位以11开头的是整数编码:这种编码表示节点的content属性保存着整数值,整数值的类型和长度由编码除去最高两位之后的其他位记录。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;节点的content属性负责保存节点的值,节点值可以是一个字节数组或者整数,值的类型和长度由节点的encoding属性决定。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B1.png\" alt></p>\n<ul>\n<li>编码的最高两位00表示节点保存的是一个字节数组。</li>\n<li>编码的后六位001011记录了字节数组的长度11。</li>\n<li>content属性保存着节点的值”hello world”。</li>\n<li>编码11000000表示节点保存的是一个int16_t类型的整数值;</li>\n<li>content属性保存着节点的值10086</li>\n</ul>\n<h4 id=\"2-3-常用操作的时间复杂度\"><a href=\"#2-3-常用操作的时间复杂度\" class=\"headerlink\" title=\"2.3 常用操作的时间复杂度\"></a>2.3 常用操作的时间复杂度</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建一个新的压缩列表</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>创建一个包含给定值的新节点,并将这个新节点添加到压缩列表的表头或者表尾</td>\n<td>平均O(N)，最坏O(N^2)(可能发生连锁更新)</td>\n</tr>\n<tr>\n<td>将包含给定值的新节点插人到给定节点之后</td>\n<td>平均O(N)，最坏O(N^2)(可能发生连锁更新)</td>\n</tr>\n<tr>\n<td>返回压缩列表给定索引上的节点</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>在压缩列表中査找并返回包含了给定值的节点</td>\n<td>因为节点的值可能是一个字节数组,所以检查节点值和给定值是否相同的复杂度为O(N),而查找整个列表的复杂度则为(N^2)</td>\n</tr>\n<tr>\n<td>返回给定节点的下一个节点</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>返回给定节点的前一个节点</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>获取给定节点所保存的值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>从压缩列表中删除给定的节点</td>\n<td>平均O(N)，最坏O(N^2)(可能发生连锁更新)</td>\n</tr>\n<tr>\n<td>删除压缩列表在给定索引上的连续多个</td>\n<td>平均O(N)，最坏O(N^2)(可能发生连锁更新)</td>\n</tr>\n<tr>\n<td>返回压缩列表目前占用的内存字节数</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>返回压缩列表目前包含的节点数量</td>\n<td>点数量小于65535时为O(1),大于65535时为O(N)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"本文重点\"><a href=\"#本文重点\" class=\"headerlink\" title=\"本文重点\"></a>本文重点</h3><ul>\n<li>压缩列表是Redis为节约内存自己设计的一种顺序型数据结构。</li>\n<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>\n<li>压缩列表可以包含多个节点,每个节点可以保存一个字节数组或者整数值。</li>\n<li>添加新节点到压缩列表,或者从压缩列表中删除节点,可能会引发连锁更新操作,但这种操作出现的几率并不高。</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;同整数集合一样压缩列表也不是基础数据结构，而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。</p>","more":"<h3 id=\"一、压缩列表\"><a href=\"#一、压缩列表\" class=\"headerlink\" title=\"一、压缩列表\"></a>一、压缩列表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存,是相较于数组的存储思路而言的。我们知道,数组要求每个元素的大小相同,如果我们要存储不同长度的字符串,那我们就需要用最大长度的字符串大小作为元素的大小(假设是20个字节)。存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E6%95%B0%E7%BB%84.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;数组的优势占用一片连续的空间可以很好的利用CPU缓存访问数据。如果我们想要保留这种优势，又想节省存储空间我们可以对数组进行压缩。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E6%95%B0%E7%BB%84%E5%8E%8B%E7%BC%A9.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样有一个问题，我们在遍历它的时候由于不知道每个元素的大小是多少，因此也就无法计算出下一个节点的具体位置。这个时候我们可以给每个节点增加一个lenght的属性。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如此。我们在遍历节点的之后就知道每个节点的长度(占用内存的大小)，就可以很容易计算出下一个节点再内存中的位置。这种结构就像一个简单的压缩列表了。</p>\n<h3 id=\"二、Redis压缩列表\"><a href=\"#二、Redis压缩列表\" class=\"headerlink\" title=\"二、Redis压缩列表\"></a>二、Redis压缩列表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;压缩列表(zip1ist)是列表和哈希的底层实现之一。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;当一个列表只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表的底层实现。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;当一个哈希只包含少量键值对,比且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做哈希的底层实现。</p>\n<h4 id=\"2-1-Redis压缩列表的构成\"><a href=\"#2-1-Redis压缩列表的构成\" class=\"headerlink\" title=\"2.1 Redis压缩列表的构成\"></a>2.1 Redis压缩列表的构成</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;压缩列表是Redis为了节约内存而开发的,是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结枃。一个压缩列表可以包含任意多个节点(entry),每个节点可以保存一个字节数组或者一个整数值，如下图。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/Redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84.png\" alt></p>\n<p>示例：</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/Redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84-Example.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上图，展示了一个总长为80字节，包含3个节点的压缩列表。如果我们有一个指向压缩列表起始地址的指针p，那么表为节点的地址就是P+60。</p>\n<h4 id=\"2-2-Redis压缩列表节点的构成\"><a href=\"#2-2-Redis压缩列表节点的构成\" class=\"headerlink\" title=\"2.2 Redis压缩列表节点的构成\"></a>2.2 Redis压缩列表节点的构成</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;每个压缩列表节点可以保存一个字节数组或者一个整数值。其中，字节数组可以是以下三种长度中的一种。</p>\n<ul>\n<li>长度小于等于63(2^6-1)字节的字节数组;</li>\n<li>长度小于等于16383(2^14-1)字节的字节数组</li>\n<li>长度小于等于4294967295(2^32-1)字节的字节数组</li>\n</ul>\n<p>整数值可以是以下6种长度中的一种</p>\n<ul>\n<li>4位长,介于0至12之间的无符号整数</li>\n<li>1字节长的有符号整数</li>\n<li>3字节长的有符号整数</li>\n<li>int16_t类型整数</li>\n<li>int32_t类型整数</li>\n<li>int64_t类型整数</li>\n</ul>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9.png\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;节点的 previous_entry_length属性以字节为单位,记录了压缩列表中前一个节点的长度。 previous_entry_length属性的长度可以是1字节或者5字节。</p>\n<ul>\n<li>如果前一节点的长度小于254字节,那么 previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面。</li>\n<li>如果前一节点的长度大于等于254字节,那么 previous_entry_length属性的长度为5字节:其中属性的第一字节会被设置为0xFE(十进制值254),而之后的四个字节则用于保存前一节点的长度.</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;节点的encoding属性记录了节点的content属性所保存数据的类型以及长度。</p>\n<ul>\n<li>一字节、两字节或者五字节长,值的最高位为00、01或者10的是字节数组编码这种编码表示节点的 content属性保存着字节数组,数组的长度由编码除去最高两位之后的其他位记录。</li>\n<li>一字节长,值的最高位以11开头的是整数编码:这种编码表示节点的content属性保存着整数值,整数值的类型和长度由编码除去最高两位之后的其他位记录。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;节点的content属性负责保存节点的值,节点值可以是一个字节数组或者整数,值的类型和长度由节点的encoding属性决定。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/ziplist/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B1.png\" alt></p>\n<ul>\n<li>编码的最高两位00表示节点保存的是一个字节数组。</li>\n<li>编码的后六位001011记录了字节数组的长度11。</li>\n<li>content属性保存着节点的值”hello world”。</li>\n<li>编码11000000表示节点保存的是一个int16_t类型的整数值;</li>\n<li>content属性保存着节点的值10086</li>\n</ul>\n<h4 id=\"2-3-常用操作的时间复杂度\"><a href=\"#2-3-常用操作的时间复杂度\" class=\"headerlink\" title=\"2.3 常用操作的时间复杂度\"></a>2.3 常用操作的时间复杂度</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建一个新的压缩列表</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>创建一个包含给定值的新节点,并将这个新节点添加到压缩列表的表头或者表尾</td>\n<td>平均O(N)，最坏O(N^2)(可能发生连锁更新)</td>\n</tr>\n<tr>\n<td>将包含给定值的新节点插人到给定节点之后</td>\n<td>平均O(N)，最坏O(N^2)(可能发生连锁更新)</td>\n</tr>\n<tr>\n<td>返回压缩列表给定索引上的节点</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>在压缩列表中査找并返回包含了给定值的节点</td>\n<td>因为节点的值可能是一个字节数组,所以检查节点值和给定值是否相同的复杂度为O(N),而查找整个列表的复杂度则为(N^2)</td>\n</tr>\n<tr>\n<td>返回给定节点的下一个节点</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>返回给定节点的前一个节点</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>获取给定节点所保存的值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>从压缩列表中删除给定的节点</td>\n<td>平均O(N)，最坏O(N^2)(可能发生连锁更新)</td>\n</tr>\n<tr>\n<td>删除压缩列表在给定索引上的连续多个</td>\n<td>平均O(N)，最坏O(N^2)(可能发生连锁更新)</td>\n</tr>\n<tr>\n<td>返回压缩列表目前占用的内存字节数</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>返回压缩列表目前包含的节点数量</td>\n<td>点数量小于65535时为O(1),大于65535时为O(N)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"本文重点\"><a href=\"#本文重点\" class=\"headerlink\" title=\"本文重点\"></a>本文重点</h3><ul>\n<li>压缩列表是Redis为节约内存自己设计的一种顺序型数据结构。</li>\n<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>\n<li>压缩列表可以包含多个节点,每个节点可以保存一个字节数组或者整数值。</li>\n<li>添加新节点到压缩列表,或者从压缩列表中删除节点,可能会引发连锁更新操作,但这种操作出现的几率并不高。</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>"},{"title":"Redis数据结构——简单动态字符串SDS","copyright":true,"date":"2018-07-14T06:38:45.000Z","keywords":"Redis,数据结构,SDS,简单动态字符串","aside":"redis","_content":"\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;相信用过Redis的人都知道，Redis提供了一个逻辑上的对象系统构建了一个键值对数据库以供客户端用户使用。这个对象系统包括字符串对象，哈希对象，列表对象，集合对象，有序集合对象等。但是Redis面向内存并没有直接使用这些对象。而是使用了简单动态字符串，链表，字典(散列表),跳跃表,整数集合,压缩列表这些数据结构来操作内存。\n\n<!--more-->\n\n![Redis对象结构](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/28083089.jpg)\n\n### 系列文章\n\n[图解Redis之数据结构篇——简单动态字符串SDS](http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/)\n\n[图解Redis之数据结构篇——链表](http://blog.loading.ink/2018/11/15/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/)\n\n### 一、简单动态字符串(SDS)\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis默认并未直接使用C字符串(C字符串仅仅作为字符串字面量，用在一些无需对字符串进行修改的地方，如打印日志)。而是以Struct的形式构造了一个SDS的抽象类型。当Redis需要一个可以被修改的字符串时，就会使用SDS来表示。在Redis数据库里，包含字符串值的键值对都是由SDS实现的(Redis中所有的键都是由字符串对象实现的即底层是由SDS实现，Redis中所有的值对象中包含的字符串对象底层也是由SDS实现)。\n\n#### 1.1 SDS\n\n![Redis简单动态字符串](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/79800085.jpg)\n\n```c\nstruct sdshdr{\n    //int 记录buf数组中未使用字节的数量 如上图free为0代表未使用字节的数量为0\n    int free;\n    //int 记录buf数组中已使用字节的数量即sds的长度 如上图len为5代表未使用字节的数量为5\n    int len;\n    //字节数组用于保存字符串 sds遵循了c字符串以空字符结尾的惯例目的是为了重用c字符串函数库里的函数\n    char buf[];\n}\n```\n\n### 二、为什么要使用SDS\n\n![SDS与C字符串](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/84760041.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;上图表示了SDS与C字符串的区别，关于为什么Redis要使用SDS而不是C字符串，我们可以从以下几个方面来分析。\n\n#### 2.1 缓冲区溢出\n\n![C字符串内存溢出](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/95803102.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;C字符串，如果程序员在字符串修改的时候如果忘记给字符串重新分配足够的空间，那么就会发生内存溢出，如上图所示，忘记给s1分配足够的内存空间, s1的数据就会溢出到s2的空间, 导致s2的内容被修改.。而Redis提供的SDS其内置的空间分配策略则可以完全杜绝这种事情的发生。当API需要对SDS进行修改时,  API会首先会检查SDS的空间是否满足条件, 如果不满足, API会自动对它动态扩展, 然后再进行修改。\n\n![Redis SDS字符串拼接](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/78147668.jpg)\n\n#### 2.2 内存重分配\n\n##### 2.2.1 C字符串内存重分配\n\n&nbsp;&nbsp;&nbsp;&nbsp;在C字符串中，如果对字符串进行修改，那么我们就不得不面临内存重分配。因为C字符串是由一个N+1长度的数组组成，如果字符串的长度变长，我们就必须对数组进行扩容，否则会产生内存溢出。而如果字符串长度变短，我们就必须释放掉不再使用的空间，否则会发生内存泄漏。\n\n##### 2.2.2 SDS空间分配策略\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于Redis这种具有高性能要求的内存数据库，如果每次修改字符串都要进行内存重分配，无疑是巨大的性能损失。而Redis的SDS提供了两种空间分配策略来解决这个问题。\n\n1. 空间预分配\n\n   我们知道在数组进行扩容的时候，往往会申请一个更大的数组，然后把数组复制过去。为了提升性能，我们在分配空间的时候并不是分配一个刚刚好的空间，而是分配一个更大的空间。Redis同样基于这种策略提供了空间预分配。当执行字符串增长操作并且需要扩展内存时，程序不仅仅会给SDS分配必需的空间还会分配额外的未使用空间，其长度存到free属性中。其分配策略如下:\n\n   * 如果修改后len长度将小于1M,这时分配给free的大小和len一样,例如修改过后为10字节, 那么给free也是10字节，buf实际长度变成了10+10+1 = 21byte\n   * 如果修改后len长度将大于等于1M,这时分配给free的长度为1M,例如修改过后为30M,那么给free是1M.buf实际长度变成了30M+1M+1byte\n\n   ![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/45779204.jpg)\n\n2. 惰性空间释放\n\n   惰性空间释放用于字符串缩短的操作。当字符串缩短是，程序并不是立即使用内存重分配来回收缩短出来的字节，而是使用free属性记录起来，并等待将来使用。\n\n   ![Redis 惰性空间释放](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/46610277.jpg)\n\nRedis通过空间预分配和惰性空间释放策略在字符串操作中一定程度上减少了内存重分配的次数。但这种策略同样会造成一定的内存浪费，因此Redis SDS API提供相应的API让我们在有需要的时候真正的释放SDS的未使用空间。\n\n#### 2.3 二进制安全\n\n&nbsp;&nbsp;&nbsp;&nbsp;C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。如果有一种使用空字符来分割多个单词的特殊数据格式，就不能用C字符串来表示，如\"Redis\\0String\"，C字符串的函数会把'\\0'当做结束符来处理，而忽略到后面的\"String\"。而SDS的buf字节数组不是在保存字符，而是一系列二进制数组，SDS API都会以二进制的方式来处理buf数组里的数据，使用len属性的值而不是空字符来判断字符串是否结束。\n\n#### 2.4 时间复杂度\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们来看几个Redis常见操作的时间复杂度。\n\n1. 获取SDS长度: 由于SDS中提供了len属性，因此我们可以直接获取时间复杂度为O(1).\n2. 获取SDS未使用空间长度: 时间复杂度为0(1),原因同1。\n3. 清除SDS保存的内容:由于惰性空间分配策略，复杂度为O(1)。\n4. 创建一个长度为N的字符串:时间复杂度为O(n)。\n5. 拼接一个长度为N的C字符串:时间复杂度为O(n)。\n6. 拼接一个长度为N的SDS字符串:时间复杂度为O(n)。\n\nRedis在获取字符串长度上的时间复杂度为常数级O(1)。\n\n#### 2.5 为什么要使用SDS\n\n&nbsp;&nbsp;&nbsp;&nbsp;通过以上分析，我们可以得到，SDS这种数据结构相对于C字符串有以下优点:\n\n* 杜绝缓冲区溢出\n* 减少字符串操作中的内存重分配次数\n* 二进制安全\n* 由于SDS遵循以空字符结尾的惯例，因此兼容部门C字符串函数\n\nRedis定位于一个高性能的内存数据库，其面向的就是大数据量，大并发，频繁读写，高响应速度的业务。因此在保证安全稳定的情况下，性能的提升非常重要。而SDS这种数据结构屏蔽了C字符串的一些缺点，可以提供安全高性能的字符串操作。\n\n### 三、小结\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis在互联网项目中的应用越来越广泛，会用只是学习Redis中最简单的一步，要想真正的成为Redis高手，了解其底层的实现必不可少。本篇文章简单介绍了Redis中SDS数据结构及其特性，分析了Redis SDS的空间分配策略和其与C字符串相比的优势，后续的文章将继续分享Redis底层实现的其它数据结构。未完待续......\n\n### 四、参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》","source":"_posts/技术实践/redis/Redis数据结构——简单动态字符串SDS.md","raw":"---\ntitle: Redis数据结构——简单动态字符串SDS\ncopyright: true\ndate: 2018-07-14 14:38:45\ntags: \n- Redis\n- 数据结构\ncategories: Redis\nkeywords: Redis,数据结构,SDS,简单动态字符串\naside: redis\n---\n\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;相信用过Redis的人都知道，Redis提供了一个逻辑上的对象系统构建了一个键值对数据库以供客户端用户使用。这个对象系统包括字符串对象，哈希对象，列表对象，集合对象，有序集合对象等。但是Redis面向内存并没有直接使用这些对象。而是使用了简单动态字符串，链表，字典(散列表),跳跃表,整数集合,压缩列表这些数据结构来操作内存。\n\n<!--more-->\n\n![Redis对象结构](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/28083089.jpg)\n\n### 系列文章\n\n[图解Redis之数据结构篇——简单动态字符串SDS](http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/)\n\n[图解Redis之数据结构篇——链表](http://blog.loading.ink/2018/11/15/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/)\n\n### 一、简单动态字符串(SDS)\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis默认并未直接使用C字符串(C字符串仅仅作为字符串字面量，用在一些无需对字符串进行修改的地方，如打印日志)。而是以Struct的形式构造了一个SDS的抽象类型。当Redis需要一个可以被修改的字符串时，就会使用SDS来表示。在Redis数据库里，包含字符串值的键值对都是由SDS实现的(Redis中所有的键都是由字符串对象实现的即底层是由SDS实现，Redis中所有的值对象中包含的字符串对象底层也是由SDS实现)。\n\n#### 1.1 SDS\n\n![Redis简单动态字符串](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/79800085.jpg)\n\n```c\nstruct sdshdr{\n    //int 记录buf数组中未使用字节的数量 如上图free为0代表未使用字节的数量为0\n    int free;\n    //int 记录buf数组中已使用字节的数量即sds的长度 如上图len为5代表未使用字节的数量为5\n    int len;\n    //字节数组用于保存字符串 sds遵循了c字符串以空字符结尾的惯例目的是为了重用c字符串函数库里的函数\n    char buf[];\n}\n```\n\n### 二、为什么要使用SDS\n\n![SDS与C字符串](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/84760041.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;上图表示了SDS与C字符串的区别，关于为什么Redis要使用SDS而不是C字符串，我们可以从以下几个方面来分析。\n\n#### 2.1 缓冲区溢出\n\n![C字符串内存溢出](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/95803102.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;C字符串，如果程序员在字符串修改的时候如果忘记给字符串重新分配足够的空间，那么就会发生内存溢出，如上图所示，忘记给s1分配足够的内存空间, s1的数据就会溢出到s2的空间, 导致s2的内容被修改.。而Redis提供的SDS其内置的空间分配策略则可以完全杜绝这种事情的发生。当API需要对SDS进行修改时,  API会首先会检查SDS的空间是否满足条件, 如果不满足, API会自动对它动态扩展, 然后再进行修改。\n\n![Redis SDS字符串拼接](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/78147668.jpg)\n\n#### 2.2 内存重分配\n\n##### 2.2.1 C字符串内存重分配\n\n&nbsp;&nbsp;&nbsp;&nbsp;在C字符串中，如果对字符串进行修改，那么我们就不得不面临内存重分配。因为C字符串是由一个N+1长度的数组组成，如果字符串的长度变长，我们就必须对数组进行扩容，否则会产生内存溢出。而如果字符串长度变短，我们就必须释放掉不再使用的空间，否则会发生内存泄漏。\n\n##### 2.2.2 SDS空间分配策略\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于Redis这种具有高性能要求的内存数据库，如果每次修改字符串都要进行内存重分配，无疑是巨大的性能损失。而Redis的SDS提供了两种空间分配策略来解决这个问题。\n\n1. 空间预分配\n\n   我们知道在数组进行扩容的时候，往往会申请一个更大的数组，然后把数组复制过去。为了提升性能，我们在分配空间的时候并不是分配一个刚刚好的空间，而是分配一个更大的空间。Redis同样基于这种策略提供了空间预分配。当执行字符串增长操作并且需要扩展内存时，程序不仅仅会给SDS分配必需的空间还会分配额外的未使用空间，其长度存到free属性中。其分配策略如下:\n\n   * 如果修改后len长度将小于1M,这时分配给free的大小和len一样,例如修改过后为10字节, 那么给free也是10字节，buf实际长度变成了10+10+1 = 21byte\n   * 如果修改后len长度将大于等于1M,这时分配给free的长度为1M,例如修改过后为30M,那么给free是1M.buf实际长度变成了30M+1M+1byte\n\n   ![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/45779204.jpg)\n\n2. 惰性空间释放\n\n   惰性空间释放用于字符串缩短的操作。当字符串缩短是，程序并不是立即使用内存重分配来回收缩短出来的字节，而是使用free属性记录起来，并等待将来使用。\n\n   ![Redis 惰性空间释放](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/46610277.jpg)\n\nRedis通过空间预分配和惰性空间释放策略在字符串操作中一定程度上减少了内存重分配的次数。但这种策略同样会造成一定的内存浪费，因此Redis SDS API提供相应的API让我们在有需要的时候真正的释放SDS的未使用空间。\n\n#### 2.3 二进制安全\n\n&nbsp;&nbsp;&nbsp;&nbsp;C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。如果有一种使用空字符来分割多个单词的特殊数据格式，就不能用C字符串来表示，如\"Redis\\0String\"，C字符串的函数会把'\\0'当做结束符来处理，而忽略到后面的\"String\"。而SDS的buf字节数组不是在保存字符，而是一系列二进制数组，SDS API都会以二进制的方式来处理buf数组里的数据，使用len属性的值而不是空字符来判断字符串是否结束。\n\n#### 2.4 时间复杂度\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们来看几个Redis常见操作的时间复杂度。\n\n1. 获取SDS长度: 由于SDS中提供了len属性，因此我们可以直接获取时间复杂度为O(1).\n2. 获取SDS未使用空间长度: 时间复杂度为0(1),原因同1。\n3. 清除SDS保存的内容:由于惰性空间分配策略，复杂度为O(1)。\n4. 创建一个长度为N的字符串:时间复杂度为O(n)。\n5. 拼接一个长度为N的C字符串:时间复杂度为O(n)。\n6. 拼接一个长度为N的SDS字符串:时间复杂度为O(n)。\n\nRedis在获取字符串长度上的时间复杂度为常数级O(1)。\n\n#### 2.5 为什么要使用SDS\n\n&nbsp;&nbsp;&nbsp;&nbsp;通过以上分析，我们可以得到，SDS这种数据结构相对于C字符串有以下优点:\n\n* 杜绝缓冲区溢出\n* 减少字符串操作中的内存重分配次数\n* 二进制安全\n* 由于SDS遵循以空字符结尾的惯例，因此兼容部门C字符串函数\n\nRedis定位于一个高性能的内存数据库，其面向的就是大数据量，大并发，频繁读写，高响应速度的业务。因此在保证安全稳定的情况下，性能的提升非常重要。而SDS这种数据结构屏蔽了C字符串的一些缺点，可以提供安全高性能的字符串操作。\n\n### 三、小结\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis在互联网项目中的应用越来越广泛，会用只是学习Redis中最简单的一步，要想真正的成为Redis高手，了解其底层的实现必不可少。本篇文章简单介绍了Redis中SDS数据结构及其特性，分析了Redis SDS的空间分配策略和其与C字符串相比的优势，后续的文章将继续分享Redis底层实现的其它数据结构。未完待续......\n\n### 四、参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》","slug":"技术实践/redis/Redis数据结构——简单动态字符串SDS","published":1,"updated":"2021-03-14T03:04:50.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzq00ekhyjf97cd9a3z","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;相信用过Redis的人都知道，Redis提供了一个逻辑上的对象系统构建了一个键值对数据库以供客户端用户使用。这个对象系统包括字符串对象，哈希对象，列表对象，集合对象，有序集合对象等。但是Redis面向内存并没有直接使用这些对象。而是使用了简单动态字符串，链表，字典(散列表),跳跃表,整数集合,压缩列表这些数据结构来操作内存。</p>\n<a id=\"more\"></a>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/28083089.jpg\" alt=\"Redis对象结构\"></p>\n<h3 id=\"系列文章\"><a href=\"#系列文章\" class=\"headerlink\" title=\"系列文章\"></a>系列文章</h3><p><a href=\"http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——简单动态字符串SDS</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/15/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——链表</a></p>\n<h3 id=\"一、简单动态字符串-SDS\"><a href=\"#一、简单动态字符串-SDS\" class=\"headerlink\" title=\"一、简单动态字符串(SDS)\"></a>一、简单动态字符串(SDS)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis默认并未直接使用C字符串(C字符串仅仅作为字符串字面量，用在一些无需对字符串进行修改的地方，如打印日志)。而是以Struct的形式构造了一个SDS的抽象类型。当Redis需要一个可以被修改的字符串时，就会使用SDS来表示。在Redis数据库里，包含字符串值的键值对都是由SDS实现的(Redis中所有的键都是由字符串对象实现的即底层是由SDS实现，Redis中所有的值对象中包含的字符串对象底层也是由SDS实现)。</p>\n<h4 id=\"1-1-SDS\"><a href=\"#1-1-SDS\" class=\"headerlink\" title=\"1.1 SDS\"></a>1.1 SDS</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/79800085.jpg\" alt=\"Redis简单动态字符串\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//int 记录buf数组中未使用字节的数量 如上图free为0代表未使用字节的数量为0</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\">    <span class=\"comment\">//int 记录buf数组中已使用字节的数量即sds的长度 如上图len为5代表未使用字节的数量为5</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">//字节数组用于保存字符串 sds遵循了c字符串以空字符结尾的惯例目的是为了重用c字符串函数库里的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、为什么要使用SDS\"><a href=\"#二、为什么要使用SDS\" class=\"headerlink\" title=\"二、为什么要使用SDS\"></a>二、为什么要使用SDS</h3><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/84760041.jpg\" alt=\"SDS与C字符串\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;上图表示了SDS与C字符串的区别，关于为什么Redis要使用SDS而不是C字符串，我们可以从以下几个方面来分析。</p>\n<h4 id=\"2-1-缓冲区溢出\"><a href=\"#2-1-缓冲区溢出\" class=\"headerlink\" title=\"2.1 缓冲区溢出\"></a>2.1 缓冲区溢出</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/95803102.jpg\" alt=\"C字符串内存溢出\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;C字符串，如果程序员在字符串修改的时候如果忘记给字符串重新分配足够的空间，那么就会发生内存溢出，如上图所示，忘记给s1分配足够的内存空间, s1的数据就会溢出到s2的空间, 导致s2的内容被修改.。而Redis提供的SDS其内置的空间分配策略则可以完全杜绝这种事情的发生。当API需要对SDS进行修改时,  API会首先会检查SDS的空间是否满足条件, 如果不满足, API会自动对它动态扩展, 然后再进行修改。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/78147668.jpg\" alt=\"Redis SDS字符串拼接\"></p>\n<h4 id=\"2-2-内存重分配\"><a href=\"#2-2-内存重分配\" class=\"headerlink\" title=\"2.2 内存重分配\"></a>2.2 内存重分配</h4><h5 id=\"2-2-1-C字符串内存重分配\"><a href=\"#2-2-1-C字符串内存重分配\" class=\"headerlink\" title=\"2.2.1 C字符串内存重分配\"></a>2.2.1 C字符串内存重分配</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在C字符串中，如果对字符串进行修改，那么我们就不得不面临内存重分配。因为C字符串是由一个N+1长度的数组组成，如果字符串的长度变长，我们就必须对数组进行扩容，否则会产生内存溢出。而如果字符串长度变短，我们就必须释放掉不再使用的空间，否则会发生内存泄漏。</p>\n<h5 id=\"2-2-2-SDS空间分配策略\"><a href=\"#2-2-2-SDS空间分配策略\" class=\"headerlink\" title=\"2.2.2 SDS空间分配策略\"></a>2.2.2 SDS空间分配策略</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Redis这种具有高性能要求的内存数据库，如果每次修改字符串都要进行内存重分配，无疑是巨大的性能损失。而Redis的SDS提供了两种空间分配策略来解决这个问题。</p>\n<ol>\n<li><p>空间预分配</p>\n<p>我们知道在数组进行扩容的时候，往往会申请一个更大的数组，然后把数组复制过去。为了提升性能，我们在分配空间的时候并不是分配一个刚刚好的空间，而是分配一个更大的空间。Redis同样基于这种策略提供了空间预分配。当执行字符串增长操作并且需要扩展内存时，程序不仅仅会给SDS分配必需的空间还会分配额外的未使用空间，其长度存到free属性中。其分配策略如下:</p>\n<ul>\n<li>如果修改后len长度将小于1M,这时分配给free的大小和len一样,例如修改过后为10字节, 那么给free也是10字节，buf实际长度变成了10+10+1 = 21byte</li>\n<li>如果修改后len长度将大于等于1M,这时分配给free的长度为1M,例如修改过后为30M,那么给free是1M.buf实际长度变成了30M+1M+1byte</li>\n</ul>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/45779204.jpg\" alt></p>\n</li>\n<li><p>惰性空间释放</p>\n<p>惰性空间释放用于字符串缩短的操作。当字符串缩短是，程序并不是立即使用内存重分配来回收缩短出来的字节，而是使用free属性记录起来，并等待将来使用。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/46610277.jpg\" alt=\"Redis 惰性空间释放\"></p>\n</li>\n</ol>\n<p>Redis通过空间预分配和惰性空间释放策略在字符串操作中一定程度上减少了内存重分配的次数。但这种策略同样会造成一定的内存浪费，因此Redis SDS API提供相应的API让我们在有需要的时候真正的释放SDS的未使用空间。</p>\n<h4 id=\"2-3-二进制安全\"><a href=\"#2-3-二进制安全\" class=\"headerlink\" title=\"2.3 二进制安全\"></a>2.3 二进制安全</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。如果有一种使用空字符来分割多个单词的特殊数据格式，就不能用C字符串来表示，如”Redis\\0String”，C字符串的函数会把’\\0’当做结束符来处理，而忽略到后面的”String”。而SDS的buf字节数组不是在保存字符，而是一系列二进制数组，SDS API都会以二进制的方式来处理buf数组里的数据，使用len属性的值而不是空字符来判断字符串是否结束。</p>\n<h4 id=\"2-4-时间复杂度\"><a href=\"#2-4-时间复杂度\" class=\"headerlink\" title=\"2.4 时间复杂度\"></a>2.4 时间复杂度</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;我们来看几个Redis常见操作的时间复杂度。</p>\n<ol>\n<li>获取SDS长度: 由于SDS中提供了len属性，因此我们可以直接获取时间复杂度为O(1).</li>\n<li>获取SDS未使用空间长度: 时间复杂度为0(1),原因同1。</li>\n<li>清除SDS保存的内容:由于惰性空间分配策略，复杂度为O(1)。</li>\n<li>创建一个长度为N的字符串:时间复杂度为O(n)。</li>\n<li>拼接一个长度为N的C字符串:时间复杂度为O(n)。</li>\n<li>拼接一个长度为N的SDS字符串:时间复杂度为O(n)。</li>\n</ol>\n<p>Redis在获取字符串长度上的时间复杂度为常数级O(1)。</p>\n<h4 id=\"2-5-为什么要使用SDS\"><a href=\"#2-5-为什么要使用SDS\" class=\"headerlink\" title=\"2.5 为什么要使用SDS\"></a>2.5 为什么要使用SDS</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;通过以上分析，我们可以得到，SDS这种数据结构相对于C字符串有以下优点:</p>\n<ul>\n<li>杜绝缓冲区溢出</li>\n<li>减少字符串操作中的内存重分配次数</li>\n<li>二进制安全</li>\n<li>由于SDS遵循以空字符结尾的惯例，因此兼容部门C字符串函数</li>\n</ul>\n<p>Redis定位于一个高性能的内存数据库，其面向的就是大数据量，大并发，频繁读写，高响应速度的业务。因此在保证安全稳定的情况下，性能的提升非常重要。而SDS这种数据结构屏蔽了C字符串的一些缺点，可以提供安全高性能的字符串操作。</p>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis在互联网项目中的应用越来越广泛，会用只是学习Redis中最简单的一步，要想真正的成为Redis高手，了解其底层的实现必不可少。本篇文章简单介绍了Redis中SDS数据结构及其特性，分析了Redis SDS的空间分配策略和其与C字符串相比的优势，后续的文章将继续分享Redis底层实现的其它数据结构。未完待续……</p>\n<h3 id=\"四、参考\"><a href=\"#四、参考\" class=\"headerlink\" title=\"四、参考\"></a>四、参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;相信用过Redis的人都知道，Redis提供了一个逻辑上的对象系统构建了一个键值对数据库以供客户端用户使用。这个对象系统包括字符串对象，哈希对象，列表对象，集合对象，有序集合对象等。但是Redis面向内存并没有直接使用这些对象。而是使用了简单动态字符串，链表，字典(散列表),跳跃表,整数集合,压缩列表这些数据结构来操作内存。</p>","more":"<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/28083089.jpg\" alt=\"Redis对象结构\"></p>\n<h3 id=\"系列文章\"><a href=\"#系列文章\" class=\"headerlink\" title=\"系列文章\"></a>系列文章</h3><p><a href=\"http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——简单动态字符串SDS</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/15/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——链表</a></p>\n<h3 id=\"一、简单动态字符串-SDS\"><a href=\"#一、简单动态字符串-SDS\" class=\"headerlink\" title=\"一、简单动态字符串(SDS)\"></a>一、简单动态字符串(SDS)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis默认并未直接使用C字符串(C字符串仅仅作为字符串字面量，用在一些无需对字符串进行修改的地方，如打印日志)。而是以Struct的形式构造了一个SDS的抽象类型。当Redis需要一个可以被修改的字符串时，就会使用SDS来表示。在Redis数据库里，包含字符串值的键值对都是由SDS实现的(Redis中所有的键都是由字符串对象实现的即底层是由SDS实现，Redis中所有的值对象中包含的字符串对象底层也是由SDS实现)。</p>\n<h4 id=\"1-1-SDS\"><a href=\"#1-1-SDS\" class=\"headerlink\" title=\"1.1 SDS\"></a>1.1 SDS</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/79800085.jpg\" alt=\"Redis简单动态字符串\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//int 记录buf数组中未使用字节的数量 如上图free为0代表未使用字节的数量为0</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\">    <span class=\"comment\">//int 记录buf数组中已使用字节的数量即sds的长度 如上图len为5代表未使用字节的数量为5</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">//字节数组用于保存字符串 sds遵循了c字符串以空字符结尾的惯例目的是为了重用c字符串函数库里的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、为什么要使用SDS\"><a href=\"#二、为什么要使用SDS\" class=\"headerlink\" title=\"二、为什么要使用SDS\"></a>二、为什么要使用SDS</h3><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/84760041.jpg\" alt=\"SDS与C字符串\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;上图表示了SDS与C字符串的区别，关于为什么Redis要使用SDS而不是C字符串，我们可以从以下几个方面来分析。</p>\n<h4 id=\"2-1-缓冲区溢出\"><a href=\"#2-1-缓冲区溢出\" class=\"headerlink\" title=\"2.1 缓冲区溢出\"></a>2.1 缓冲区溢出</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/95803102.jpg\" alt=\"C字符串内存溢出\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;C字符串，如果程序员在字符串修改的时候如果忘记给字符串重新分配足够的空间，那么就会发生内存溢出，如上图所示，忘记给s1分配足够的内存空间, s1的数据就会溢出到s2的空间, 导致s2的内容被修改.。而Redis提供的SDS其内置的空间分配策略则可以完全杜绝这种事情的发生。当API需要对SDS进行修改时,  API会首先会检查SDS的空间是否满足条件, 如果不满足, API会自动对它动态扩展, 然后再进行修改。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/78147668.jpg\" alt=\"Redis SDS字符串拼接\"></p>\n<h4 id=\"2-2-内存重分配\"><a href=\"#2-2-内存重分配\" class=\"headerlink\" title=\"2.2 内存重分配\"></a>2.2 内存重分配</h4><h5 id=\"2-2-1-C字符串内存重分配\"><a href=\"#2-2-1-C字符串内存重分配\" class=\"headerlink\" title=\"2.2.1 C字符串内存重分配\"></a>2.2.1 C字符串内存重分配</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在C字符串中，如果对字符串进行修改，那么我们就不得不面临内存重分配。因为C字符串是由一个N+1长度的数组组成，如果字符串的长度变长，我们就必须对数组进行扩容，否则会产生内存溢出。而如果字符串长度变短，我们就必须释放掉不再使用的空间，否则会发生内存泄漏。</p>\n<h5 id=\"2-2-2-SDS空间分配策略\"><a href=\"#2-2-2-SDS空间分配策略\" class=\"headerlink\" title=\"2.2.2 SDS空间分配策略\"></a>2.2.2 SDS空间分配策略</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;对于Redis这种具有高性能要求的内存数据库，如果每次修改字符串都要进行内存重分配，无疑是巨大的性能损失。而Redis的SDS提供了两种空间分配策略来解决这个问题。</p>\n<ol>\n<li><p>空间预分配</p>\n<p>我们知道在数组进行扩容的时候，往往会申请一个更大的数组，然后把数组复制过去。为了提升性能，我们在分配空间的时候并不是分配一个刚刚好的空间，而是分配一个更大的空间。Redis同样基于这种策略提供了空间预分配。当执行字符串增长操作并且需要扩展内存时，程序不仅仅会给SDS分配必需的空间还会分配额外的未使用空间，其长度存到free属性中。其分配策略如下:</p>\n<ul>\n<li>如果修改后len长度将小于1M,这时分配给free的大小和len一样,例如修改过后为10字节, 那么给free也是10字节，buf实际长度变成了10+10+1 = 21byte</li>\n<li>如果修改后len长度将大于等于1M,这时分配给free的长度为1M,例如修改过后为30M,那么给free是1M.buf实际长度变成了30M+1M+1byte</li>\n</ul>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/45779204.jpg\" alt></p>\n</li>\n<li><p>惰性空间释放</p>\n<p>惰性空间释放用于字符串缩短的操作。当字符串缩短是，程序并不是立即使用内存重分配来回收缩短出来的字节，而是使用free属性记录起来，并等待将来使用。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/46610277.jpg\" alt=\"Redis 惰性空间释放\"></p>\n</li>\n</ol>\n<p>Redis通过空间预分配和惰性空间释放策略在字符串操作中一定程度上减少了内存重分配的次数。但这种策略同样会造成一定的内存浪费，因此Redis SDS API提供相应的API让我们在有需要的时候真正的释放SDS的未使用空间。</p>\n<h4 id=\"2-3-二进制安全\"><a href=\"#2-3-二进制安全\" class=\"headerlink\" title=\"2.3 二进制安全\"></a>2.3 二进制安全</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。如果有一种使用空字符来分割多个单词的特殊数据格式，就不能用C字符串来表示，如”Redis\\0String”，C字符串的函数会把’\\0’当做结束符来处理，而忽略到后面的”String”。而SDS的buf字节数组不是在保存字符，而是一系列二进制数组，SDS API都会以二进制的方式来处理buf数组里的数据，使用len属性的值而不是空字符来判断字符串是否结束。</p>\n<h4 id=\"2-4-时间复杂度\"><a href=\"#2-4-时间复杂度\" class=\"headerlink\" title=\"2.4 时间复杂度\"></a>2.4 时间复杂度</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;我们来看几个Redis常见操作的时间复杂度。</p>\n<ol>\n<li>获取SDS长度: 由于SDS中提供了len属性，因此我们可以直接获取时间复杂度为O(1).</li>\n<li>获取SDS未使用空间长度: 时间复杂度为0(1),原因同1。</li>\n<li>清除SDS保存的内容:由于惰性空间分配策略，复杂度为O(1)。</li>\n<li>创建一个长度为N的字符串:时间复杂度为O(n)。</li>\n<li>拼接一个长度为N的C字符串:时间复杂度为O(n)。</li>\n<li>拼接一个长度为N的SDS字符串:时间复杂度为O(n)。</li>\n</ol>\n<p>Redis在获取字符串长度上的时间复杂度为常数级O(1)。</p>\n<h4 id=\"2-5-为什么要使用SDS\"><a href=\"#2-5-为什么要使用SDS\" class=\"headerlink\" title=\"2.5 为什么要使用SDS\"></a>2.5 为什么要使用SDS</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;通过以上分析，我们可以得到，SDS这种数据结构相对于C字符串有以下优点:</p>\n<ul>\n<li>杜绝缓冲区溢出</li>\n<li>减少字符串操作中的内存重分配次数</li>\n<li>二进制安全</li>\n<li>由于SDS遵循以空字符结尾的惯例，因此兼容部门C字符串函数</li>\n</ul>\n<p>Redis定位于一个高性能的内存数据库，其面向的就是大数据量，大并发，频繁读写，高响应速度的业务。因此在保证安全稳定的情况下，性能的提升非常重要。而SDS这种数据结构屏蔽了C字符串的一些缺点，可以提供安全高性能的字符串操作。</p>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis在互联网项目中的应用越来越广泛，会用只是学习Redis中最简单的一步，要想真正的成为Redis高手，了解其底层的实现必不可少。本篇文章简单介绍了Redis中SDS数据结构及其特性，分析了Redis SDS的空间分配策略和其与C字符串相比的优势，后续的文章将继续分享Redis底层实现的其它数据结构。未完待续……</p>\n<h3 id=\"四、参考\"><a href=\"#四、参考\" class=\"headerlink\" title=\"四、参考\"></a>四、参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>"},{"title":"Redis数据结构——链表","copyright":true,"date":"2018-11-15T02:45:38.000Z","keywords":"Redis,数据结构,链表","aside":"redis","_content":"\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis链表为双向无环链表！\n\n&nbsp;&nbsp;&nbsp;&nbsp;[图解Redis之数据结构篇——简单动态字符串SDS](http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/)提到Redis使用了简单动态字符串，链表，字典(散列表),跳跃表,整数集合,压缩列表这些数据结构来操作内存，并且简单介绍了Redis简单动态字符串。本篇文章我们继续来分析链表。\n\n&nbsp;&nbsp;&nbsp;&nbsp;链表是一种非常常见的数据结构，在Redis中使用非常广泛，列表对象的底层实现之一就是链表。其它如慢查询，发布订阅，监视器等功能也用到了链表。\n\n<!--more-->\n\n![Redis对象结构](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/28083089.jpg)\n\n### 系列文章\n\n[图解Redis之数据结构篇——简单动态字符串SDS](http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/)\n\n[图解Redis之数据结构篇——链表](http://blog.loading.ink/2018/11/15/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/)\n\n### 一、复习链表\n\n#### 1.1 数组与链表\n\n&nbsp;&nbsp;&nbsp;&nbsp;数组需要一块连续的内存来存储，这个特性有利也有弊。好处是其支持根据索引下标\"随机访问\"(时间复杂度为O(1))，但是其插入与删除操作为了保证在内存中的连续性将会变得非常低效(时间复杂度为O(N))，并且其一经声明就要占用整块连续内存空间，如果声明过大，系统可能内存不足，声明过小又可能导致不够用，而当数组的空间不足的时候需要对其进行扩容(申请一个更大的空间，将原数组拷贝过去)。\n\n&nbsp;&nbsp;&nbsp;&nbsp;而链表恰恰相反，其不需要一块连续的内存空间，其通过\"指针\"将一组零散的内存连接起来使用。其优点在于本身没有大小限制，天然支持扩容，插入删除操作高效(时间复杂度为O(1))，但缺点是随机访问低效(时间复杂度为O(N))。并且由于需要额外的空间存储指针。\n\n![数组与链表](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/2369874.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;链表的实现方式有很多种，常见的主要有三个，单向链表、双向链表、循环链表。\n\n#### 1.2 单链表\n\n![单链表](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/10687399.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;单链表中每个节点除了包含数据之外还包含一个指针，叫后继指针，因此需要额外的空间来存储后继节点的地址。有两个特殊的节点,头结点和尾节点，其中头节点用来记录链表的基地址，有了它就可以遍历整个链表，尾节点的后继指针不是指向下一个节点，而是指向一个空地址NULL表示这是链表上最后一个节点。与数组一样，单链表也支持数据的查找、插入和删除操作，其中插入和删除操作只需要考虑相邻节点指针的变化，因此为常数级时间复杂度O(1)。要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，因此时间复杂度为O(N)。\n\n![单链表插入与删除操作](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/66618313.jpg)\n\n#### 1.3 双向链表\n\n![双向链表](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/87832417.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;双向链表和单链表不同的是多了一个前驱指针，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。因此存储同样多的数据，双向链表占用比单链表更多的空间。但其优点在于支持双向遍历，体现在以下两个方面。\n\n- 在有序链表中查找某个元素，单链表由于只有后继指针，因此只能从前往后遍历查找时间复杂度为O(N)，而双向链表可以双向遍历，因此可以采用二分的思想进行查找，时间复杂度为O(logn)。\n- 删除给定指针指向的结点。假设已经找到要删除的节点，要删除就必须知道其前驱节点和后继节点，单链表想要知道其前驱节点只能从头开始遍历，时间复杂度为0(n)，而双向链表由于保存了其前驱节点的地址，因此时间复杂度为0(1)。\n\n#### 1.4 循环链表\n\n![循环链表](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/37524267.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;顾名思义。循环链表与单、双链表不同的是其呈环状，单循环链表中其尾节点并非指向NULL而是指向头结点。双循环链表中其头节点的前驱指针指向尾节点，尾节点的后继指针指向头结点。循环链表的优势在于链尾到链头，链头到链尾比较方便适合处理的数据具有环型结构特点。\n\n### 二、Redis链表\n\n#### 2.1 双向无环链表\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis链表使用双向无环链表。\n\n![Redis双向无环链表](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/90004345.jpg)\n\n如图所示，Redis使用一个listNode结构来表示。\n\n```c\ntypedef struct listNode\n{ \n\t// 前置节点 \n\tstruct listNode *prev; \n\t// 后置节点 \n\tstruct listNode *next; \n\t// 节点的值 \n\tvoid *value; \n} listNode;\n```\n\n#### 2.2 list结构\n\n&nbsp;&nbsp;&nbsp;&nbsp;同时Redis为了方便的操作链表，提供了一个list结构来持有链表。如下图所示\n\n![list结构](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/16682936.jpg)\n\n```c\ntypedef struct list{\n    //表头节点\n    listNode *head;\n    //表尾节点\n    listNode *tail;\n    //链表所包含的节点数量\n    unsigned long len;\n    //节点值复制函数\n    void *(*dup)(void *ptr);\n    //节点值释放函数\n    void *(*free)(void *ptr);\n    //节点值对比函数\n    int (*match)(void *ptr,void *key);\n}list;\n```\n\nRedis链表结构其主要特性如下:\n\n- 双向：链表节点带有前驱、后继指针获取某个节点的前驱、后继节点的时间复杂度为0(1)。\n- 无环: 链表为非循环链表表头节点的前驱指针和表尾节点的后继指针都指向NULL，对链表的访问以NULL为终点。\n- 带表头指针和表尾指针：通过list结构中的head和tail指针，获取表头和表尾节点的时间复杂度都为O(1)。\n- 带链表长度计数器:通过list结构的len属性获取节点数量的时间复杂度为O(1)。\n- 多态：链表节点使用void*指针保存节点的值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值。\n\n#### 2.3 双向无环链表在Redis中的使用\n\n&nbsp;&nbsp;&nbsp;&nbsp;链表在Redis中的应用非常广泛，列表对象的底层实现之一就是链表。此外如发布订阅、慢查询、监视器等功能也用到了链表。我们现在简单想一想Redis为什么要使用双向无环链表这种数据结构，而不是使用数组、单向链表等。既然列表对象的底层实现之一是链表，那么我们通过一个表格来分析列表对象的常用操作命令。如果分别使用数组、单链表和双向链表实现列表对象的时间复杂度对照如下:\n\n| 操作\\时间复杂度                   | 数组 | 单链表 | 双向链表 |\n| --------------------------------- | ---- | ------ | -------- |\n| rpush(从右边添加元素)             | O(1) | O(1)   | O(1)     |\n| lpush(从左边添加元素)             | 0(N) | O(1)   | O(1)     |\n| lpop (从右边删除元素)             | O(1) | O(1)   | O(1)     |\n| rpop (从左边删除元素)             | O(N) | O(1)   | O(1)     |\n| lindex(获取指定索引下标的元素)    | O(1) | O(N)   | O(N)     |\n| len (获取长度)                    | O(N) | O(N)   | O(1)     |\n| linsert(向某个元素前或后插入元素) | O(N) | O(N)   | O(1)     |\n| lrem (删除指定元素)               | O(N) | O(N)   | O(N)     |\n| lset (修改指定索引下标元素)       | O(N) | O(N)   | O(N)     |\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到在列表对象常用的操作中双向链表的优势所在。但双向链表因为使用两个额外的空间存储前驱和后继指针，因此在数据量较小的情况下会造成空间上的浪费(因为数据量小的时候速度上的差别不大，但空间上的差别很大)。这是一个时间换空间还是空间换时间的思想问题，Redis在列表对象中小数据量的时候使用压缩列表作为底层实现，而大数据量的时候才会使用双向无环链表。(关于列表对象后续会有文章继续介绍可访问我的个人博客持续关注[blog.loading.ink](http://blog.loading.ink))\n\n### 小结\n\n&nbsp;&nbsp;&nbsp;&nbsp;链表作为一种非常常用的数据结构，内置在许多编程语言里面，更是找工作过程中经常问的面试题之一。本篇文章简单复习了链表这种数据结构常见的几种形式，并且简单分析了Redis中链表的使用。下篇文章将继续分享Redis中用到的数据结构Hash。敬请关注!\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n\n\n\n\n","source":"_posts/技术实践/redis/Redis数据结构——链表.md","raw":"---\ntitle: Redis数据结构——链表\ncopyright: true\ndate: 2018-11-15 10:45:38\ntags: \n- Redis\n- 数据结构\ncategories: Redis\nkeywords: Redis,数据结构,链表\naside: redis\n---\n\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis链表为双向无环链表！\n\n&nbsp;&nbsp;&nbsp;&nbsp;[图解Redis之数据结构篇——简单动态字符串SDS](http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/)提到Redis使用了简单动态字符串，链表，字典(散列表),跳跃表,整数集合,压缩列表这些数据结构来操作内存，并且简单介绍了Redis简单动态字符串。本篇文章我们继续来分析链表。\n\n&nbsp;&nbsp;&nbsp;&nbsp;链表是一种非常常见的数据结构，在Redis中使用非常广泛，列表对象的底层实现之一就是链表。其它如慢查询，发布订阅，监视器等功能也用到了链表。\n\n<!--more-->\n\n![Redis对象结构](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/28083089.jpg)\n\n### 系列文章\n\n[图解Redis之数据结构篇——简单动态字符串SDS](http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/)\n\n[图解Redis之数据结构篇——链表](http://blog.loading.ink/2018/11/15/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/)\n\n### 一、复习链表\n\n#### 1.1 数组与链表\n\n&nbsp;&nbsp;&nbsp;&nbsp;数组需要一块连续的内存来存储，这个特性有利也有弊。好处是其支持根据索引下标\"随机访问\"(时间复杂度为O(1))，但是其插入与删除操作为了保证在内存中的连续性将会变得非常低效(时间复杂度为O(N))，并且其一经声明就要占用整块连续内存空间，如果声明过大，系统可能内存不足，声明过小又可能导致不够用，而当数组的空间不足的时候需要对其进行扩容(申请一个更大的空间，将原数组拷贝过去)。\n\n&nbsp;&nbsp;&nbsp;&nbsp;而链表恰恰相反，其不需要一块连续的内存空间，其通过\"指针\"将一组零散的内存连接起来使用。其优点在于本身没有大小限制，天然支持扩容，插入删除操作高效(时间复杂度为O(1))，但缺点是随机访问低效(时间复杂度为O(N))。并且由于需要额外的空间存储指针。\n\n![数组与链表](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/2369874.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;链表的实现方式有很多种，常见的主要有三个，单向链表、双向链表、循环链表。\n\n#### 1.2 单链表\n\n![单链表](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/10687399.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;单链表中每个节点除了包含数据之外还包含一个指针，叫后继指针，因此需要额外的空间来存储后继节点的地址。有两个特殊的节点,头结点和尾节点，其中头节点用来记录链表的基地址，有了它就可以遍历整个链表，尾节点的后继指针不是指向下一个节点，而是指向一个空地址NULL表示这是链表上最后一个节点。与数组一样，单链表也支持数据的查找、插入和删除操作，其中插入和删除操作只需要考虑相邻节点指针的变化，因此为常数级时间复杂度O(1)。要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，因此时间复杂度为O(N)。\n\n![单链表插入与删除操作](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/66618313.jpg)\n\n#### 1.3 双向链表\n\n![双向链表](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/87832417.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;双向链表和单链表不同的是多了一个前驱指针，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。因此存储同样多的数据，双向链表占用比单链表更多的空间。但其优点在于支持双向遍历，体现在以下两个方面。\n\n- 在有序链表中查找某个元素，单链表由于只有后继指针，因此只能从前往后遍历查找时间复杂度为O(N)，而双向链表可以双向遍历，因此可以采用二分的思想进行查找，时间复杂度为O(logn)。\n- 删除给定指针指向的结点。假设已经找到要删除的节点，要删除就必须知道其前驱节点和后继节点，单链表想要知道其前驱节点只能从头开始遍历，时间复杂度为0(n)，而双向链表由于保存了其前驱节点的地址，因此时间复杂度为0(1)。\n\n#### 1.4 循环链表\n\n![循环链表](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/37524267.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;顾名思义。循环链表与单、双链表不同的是其呈环状，单循环链表中其尾节点并非指向NULL而是指向头结点。双循环链表中其头节点的前驱指针指向尾节点，尾节点的后继指针指向头结点。循环链表的优势在于链尾到链头，链头到链尾比较方便适合处理的数据具有环型结构特点。\n\n### 二、Redis链表\n\n#### 2.1 双向无环链表\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis链表使用双向无环链表。\n\n![Redis双向无环链表](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/90004345.jpg)\n\n如图所示，Redis使用一个listNode结构来表示。\n\n```c\ntypedef struct listNode\n{ \n\t// 前置节点 \n\tstruct listNode *prev; \n\t// 后置节点 \n\tstruct listNode *next; \n\t// 节点的值 \n\tvoid *value; \n} listNode;\n```\n\n#### 2.2 list结构\n\n&nbsp;&nbsp;&nbsp;&nbsp;同时Redis为了方便的操作链表，提供了一个list结构来持有链表。如下图所示\n\n![list结构](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/16682936.jpg)\n\n```c\ntypedef struct list{\n    //表头节点\n    listNode *head;\n    //表尾节点\n    listNode *tail;\n    //链表所包含的节点数量\n    unsigned long len;\n    //节点值复制函数\n    void *(*dup)(void *ptr);\n    //节点值释放函数\n    void *(*free)(void *ptr);\n    //节点值对比函数\n    int (*match)(void *ptr,void *key);\n}list;\n```\n\nRedis链表结构其主要特性如下:\n\n- 双向：链表节点带有前驱、后继指针获取某个节点的前驱、后继节点的时间复杂度为0(1)。\n- 无环: 链表为非循环链表表头节点的前驱指针和表尾节点的后继指针都指向NULL，对链表的访问以NULL为终点。\n- 带表头指针和表尾指针：通过list结构中的head和tail指针，获取表头和表尾节点的时间复杂度都为O(1)。\n- 带链表长度计数器:通过list结构的len属性获取节点数量的时间复杂度为O(1)。\n- 多态：链表节点使用void*指针保存节点的值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值。\n\n#### 2.3 双向无环链表在Redis中的使用\n\n&nbsp;&nbsp;&nbsp;&nbsp;链表在Redis中的应用非常广泛，列表对象的底层实现之一就是链表。此外如发布订阅、慢查询、监视器等功能也用到了链表。我们现在简单想一想Redis为什么要使用双向无环链表这种数据结构，而不是使用数组、单向链表等。既然列表对象的底层实现之一是链表，那么我们通过一个表格来分析列表对象的常用操作命令。如果分别使用数组、单链表和双向链表实现列表对象的时间复杂度对照如下:\n\n| 操作\\时间复杂度                   | 数组 | 单链表 | 双向链表 |\n| --------------------------------- | ---- | ------ | -------- |\n| rpush(从右边添加元素)             | O(1) | O(1)   | O(1)     |\n| lpush(从左边添加元素)             | 0(N) | O(1)   | O(1)     |\n| lpop (从右边删除元素)             | O(1) | O(1)   | O(1)     |\n| rpop (从左边删除元素)             | O(N) | O(1)   | O(1)     |\n| lindex(获取指定索引下标的元素)    | O(1) | O(N)   | O(N)     |\n| len (获取长度)                    | O(N) | O(N)   | O(1)     |\n| linsert(向某个元素前或后插入元素) | O(N) | O(N)   | O(1)     |\n| lrem (删除指定元素)               | O(N) | O(N)   | O(N)     |\n| lset (修改指定索引下标元素)       | O(N) | O(N)   | O(N)     |\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到在列表对象常用的操作中双向链表的优势所在。但双向链表因为使用两个额外的空间存储前驱和后继指针，因此在数据量较小的情况下会造成空间上的浪费(因为数据量小的时候速度上的差别不大，但空间上的差别很大)。这是一个时间换空间还是空间换时间的思想问题，Redis在列表对象中小数据量的时候使用压缩列表作为底层实现，而大数据量的时候才会使用双向无环链表。(关于列表对象后续会有文章继续介绍可访问我的个人博客持续关注[blog.loading.ink](http://blog.loading.ink))\n\n### 小结\n\n&nbsp;&nbsp;&nbsp;&nbsp;链表作为一种非常常用的数据结构，内置在许多编程语言里面，更是找工作过程中经常问的面试题之一。本篇文章简单复习了链表这种数据结构常见的几种形式，并且简单分析了Redis中链表的使用。下篇文章将继续分享Redis中用到的数据结构Hash。敬请关注!\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n\n\n\n\n","slug":"技术实践/redis/Redis数据结构——链表","published":1,"updated":"2021-03-14T03:04:50.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzs00eohyjf2ry84s9b","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis链表为双向无环链表！</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——简单动态字符串SDS</a>提到Redis使用了简单动态字符串，链表，字典(散列表),跳跃表,整数集合,压缩列表这些数据结构来操作内存，并且简单介绍了Redis简单动态字符串。本篇文章我们继续来分析链表。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;链表是一种非常常见的数据结构，在Redis中使用非常广泛，列表对象的底层实现之一就是链表。其它如慢查询，发布订阅，监视器等功能也用到了链表。</p>\n<a id=\"more\"></a>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/28083089.jpg\" alt=\"Redis对象结构\"></p>\n<h3 id=\"系列文章\"><a href=\"#系列文章\" class=\"headerlink\" title=\"系列文章\"></a>系列文章</h3><p><a href=\"http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——简单动态字符串SDS</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/15/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——链表</a></p>\n<h3 id=\"一、复习链表\"><a href=\"#一、复习链表\" class=\"headerlink\" title=\"一、复习链表\"></a>一、复习链表</h3><h4 id=\"1-1-数组与链表\"><a href=\"#1-1-数组与链表\" class=\"headerlink\" title=\"1.1 数组与链表\"></a>1.1 数组与链表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;数组需要一块连续的内存来存储，这个特性有利也有弊。好处是其支持根据索引下标”随机访问”(时间复杂度为O(1))，但是其插入与删除操作为了保证在内存中的连续性将会变得非常低效(时间复杂度为O(N))，并且其一经声明就要占用整块连续内存空间，如果声明过大，系统可能内存不足，声明过小又可能导致不够用，而当数组的空间不足的时候需要对其进行扩容(申请一个更大的空间，将原数组拷贝过去)。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;而链表恰恰相反，其不需要一块连续的内存空间，其通过”指针”将一组零散的内存连接起来使用。其优点在于本身没有大小限制，天然支持扩容，插入删除操作高效(时间复杂度为O(1))，但缺点是随机访问低效(时间复杂度为O(N))。并且由于需要额外的空间存储指针。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/2369874.jpg\" alt=\"数组与链表\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;链表的实现方式有很多种，常见的主要有三个，单向链表、双向链表、循环链表。</p>\n<h4 id=\"1-2-单链表\"><a href=\"#1-2-单链表\" class=\"headerlink\" title=\"1.2 单链表\"></a>1.2 单链表</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/10687399.jpg\" alt=\"单链表\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;单链表中每个节点除了包含数据之外还包含一个指针，叫后继指针，因此需要额外的空间来存储后继节点的地址。有两个特殊的节点,头结点和尾节点，其中头节点用来记录链表的基地址，有了它就可以遍历整个链表，尾节点的后继指针不是指向下一个节点，而是指向一个空地址NULL表示这是链表上最后一个节点。与数组一样，单链表也支持数据的查找、插入和删除操作，其中插入和删除操作只需要考虑相邻节点指针的变化，因此为常数级时间复杂度O(1)。要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，因此时间复杂度为O(N)。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/66618313.jpg\" alt=\"单链表插入与删除操作\"></p>\n<h4 id=\"1-3-双向链表\"><a href=\"#1-3-双向链表\" class=\"headerlink\" title=\"1.3 双向链表\"></a>1.3 双向链表</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/87832417.jpg\" alt=\"双向链表\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;双向链表和单链表不同的是多了一个前驱指针，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。因此存储同样多的数据，双向链表占用比单链表更多的空间。但其优点在于支持双向遍历，体现在以下两个方面。</p>\n<ul>\n<li>在有序链表中查找某个元素，单链表由于只有后继指针，因此只能从前往后遍历查找时间复杂度为O(N)，而双向链表可以双向遍历，因此可以采用二分的思想进行查找，时间复杂度为O(logn)。</li>\n<li>删除给定指针指向的结点。假设已经找到要删除的节点，要删除就必须知道其前驱节点和后继节点，单链表想要知道其前驱节点只能从头开始遍历，时间复杂度为0(n)，而双向链表由于保存了其前驱节点的地址，因此时间复杂度为0(1)。</li>\n</ul>\n<h4 id=\"1-4-循环链表\"><a href=\"#1-4-循环链表\" class=\"headerlink\" title=\"1.4 循环链表\"></a>1.4 循环链表</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/37524267.jpg\" alt=\"循环链表\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;顾名思义。循环链表与单、双链表不同的是其呈环状，单循环链表中其尾节点并非指向NULL而是指向头结点。双循环链表中其头节点的前驱指针指向尾节点，尾节点的后继指针指向头结点。循环链表的优势在于链尾到链头，链头到链尾比较方便适合处理的数据具有环型结构特点。</p>\n<h3 id=\"二、Redis链表\"><a href=\"#二、Redis链表\" class=\"headerlink\" title=\"二、Redis链表\"></a>二、Redis链表</h3><h4 id=\"2-1-双向无环链表\"><a href=\"#2-1-双向无环链表\" class=\"headerlink\" title=\"2.1 双向无环链表\"></a>2.1 双向无环链表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis链表使用双向无环链表。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/90004345.jpg\" alt=\"Redis双向无环链表\"></p>\n<p>如图所示，Redis使用一个listNode结构来表示。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span> </span><br><span class=\"line\">\t<span class=\"comment\">// 前置节点 </span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span> </span><br><span class=\"line\">\t<span class=\"comment\">// 后置节点 </span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span> </span><br><span class=\"line\">\t<span class=\"comment\">// 节点的值 </span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *value; </span><br><span class=\"line\">&#125; listNode;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-list结构\"><a href=\"#2-2-list结构\" class=\"headerlink\" title=\"2.2 list结构\"></a>2.2 list结构</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;同时Redis为了方便的操作链表，提供了一个list结构来持有链表。如下图所示</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/16682936.jpg\" alt=\"list结构\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\">    <span class=\"comment\">//表尾节点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\">    <span class=\"comment\">//链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\">    <span class=\"comment\">//节点值复制函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">//节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">//节点值对比函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr,<span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">&#125;<span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n<p>Redis链表结构其主要特性如下:</p>\n<ul>\n<li>双向：链表节点带有前驱、后继指针获取某个节点的前驱、后继节点的时间复杂度为0(1)。</li>\n<li>无环: 链表为非循环链表表头节点的前驱指针和表尾节点的后继指针都指向NULL，对链表的访问以NULL为终点。</li>\n<li>带表头指针和表尾指针：通过list结构中的head和tail指针，获取表头和表尾节点的时间复杂度都为O(1)。</li>\n<li>带链表长度计数器:通过list结构的len属性获取节点数量的时间复杂度为O(1)。</li>\n<li>多态：链表节点使用void*指针保存节点的值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值。</li>\n</ul>\n<h4 id=\"2-3-双向无环链表在Redis中的使用\"><a href=\"#2-3-双向无环链表在Redis中的使用\" class=\"headerlink\" title=\"2.3 双向无环链表在Redis中的使用\"></a>2.3 双向无环链表在Redis中的使用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;链表在Redis中的应用非常广泛，列表对象的底层实现之一就是链表。此外如发布订阅、慢查询、监视器等功能也用到了链表。我们现在简单想一想Redis为什么要使用双向无环链表这种数据结构，而不是使用数组、单向链表等。既然列表对象的底层实现之一是链表，那么我们通过一个表格来分析列表对象的常用操作命令。如果分别使用数组、单链表和双向链表实现列表对象的时间复杂度对照如下:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作\\时间复杂度</th>\n<th>数组</th>\n<th>单链表</th>\n<th>双向链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rpush(从右边添加元素)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>lpush(从左边添加元素)</td>\n<td>0(N)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>lpop (从右边删除元素)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>rpop (从左边删除元素)</td>\n<td>O(N)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>lindex(获取指定索引下标的元素)</td>\n<td>O(1)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>len (获取长度)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>linsert(向某个元素前或后插入元素)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>lrem (删除指定元素)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>lset (修改指定索引下标元素)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到在列表对象常用的操作中双向链表的优势所在。但双向链表因为使用两个额外的空间存储前驱和后继指针，因此在数据量较小的情况下会造成空间上的浪费(因为数据量小的时候速度上的差别不大，但空间上的差别很大)。这是一个时间换空间还是空间换时间的思想问题，Redis在列表对象中小数据量的时候使用压缩列表作为底层实现，而大数据量的时候才会使用双向无环链表。(关于列表对象后续会有文章继续介绍可访问我的个人博客持续关注<a href=\"http://blog.loading.ink\" target=\"_blank\" rel=\"noopener\">blog.loading.ink</a>)</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;链表作为一种非常常用的数据结构，内置在许多编程语言里面，更是找工作过程中经常问的面试题之一。本篇文章简单复习了链表这种数据结构常见的几种形式，并且简单分析了Redis中链表的使用。下篇文章将继续分享Redis中用到的数据结构Hash。敬请关注!</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis链表为双向无环链表！</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——简单动态字符串SDS</a>提到Redis使用了简单动态字符串，链表，字典(散列表),跳跃表,整数集合,压缩列表这些数据结构来操作内存，并且简单介绍了Redis简单动态字符串。本篇文章我们继续来分析链表。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;链表是一种非常常见的数据结构，在Redis中使用非常广泛，列表对象的底层实现之一就是链表。其它如慢查询，发布订阅，监视器等功能也用到了链表。</p>","more":"<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/28083089.jpg\" alt=\"Redis对象结构\"></p>\n<h3 id=\"系列文章\"><a href=\"#系列文章\" class=\"headerlink\" title=\"系列文章\"></a>系列文章</h3><p><a href=\"http://blog.loading.ink/2018/11/14/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——简单动态字符串SDS</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/15/%E5%9B%BE%E8%A7%A3Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/\" target=\"_blank\" rel=\"noopener\">图解Redis之数据结构篇——链表</a></p>\n<h3 id=\"一、复习链表\"><a href=\"#一、复习链表\" class=\"headerlink\" title=\"一、复习链表\"></a>一、复习链表</h3><h4 id=\"1-1-数组与链表\"><a href=\"#1-1-数组与链表\" class=\"headerlink\" title=\"1.1 数组与链表\"></a>1.1 数组与链表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;数组需要一块连续的内存来存储，这个特性有利也有弊。好处是其支持根据索引下标”随机访问”(时间复杂度为O(1))，但是其插入与删除操作为了保证在内存中的连续性将会变得非常低效(时间复杂度为O(N))，并且其一经声明就要占用整块连续内存空间，如果声明过大，系统可能内存不足，声明过小又可能导致不够用，而当数组的空间不足的时候需要对其进行扩容(申请一个更大的空间，将原数组拷贝过去)。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;而链表恰恰相反，其不需要一块连续的内存空间，其通过”指针”将一组零散的内存连接起来使用。其优点在于本身没有大小限制，天然支持扩容，插入删除操作高效(时间复杂度为O(1))，但缺点是随机访问低效(时间复杂度为O(N))。并且由于需要额外的空间存储指针。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/2369874.jpg\" alt=\"数组与链表\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;链表的实现方式有很多种，常见的主要有三个，单向链表、双向链表、循环链表。</p>\n<h4 id=\"1-2-单链表\"><a href=\"#1-2-单链表\" class=\"headerlink\" title=\"1.2 单链表\"></a>1.2 单链表</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/10687399.jpg\" alt=\"单链表\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;单链表中每个节点除了包含数据之外还包含一个指针，叫后继指针，因此需要额外的空间来存储后继节点的地址。有两个特殊的节点,头结点和尾节点，其中头节点用来记录链表的基地址，有了它就可以遍历整个链表，尾节点的后继指针不是指向下一个节点，而是指向一个空地址NULL表示这是链表上最后一个节点。与数组一样，单链表也支持数据的查找、插入和删除操作，其中插入和删除操作只需要考虑相邻节点指针的变化，因此为常数级时间复杂度O(1)。要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点，因此时间复杂度为O(N)。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/66618313.jpg\" alt=\"单链表插入与删除操作\"></p>\n<h4 id=\"1-3-双向链表\"><a href=\"#1-3-双向链表\" class=\"headerlink\" title=\"1.3 双向链表\"></a>1.3 双向链表</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/87832417.jpg\" alt=\"双向链表\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;双向链表和单链表不同的是多了一个前驱指针，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。因此存储同样多的数据，双向链表占用比单链表更多的空间。但其优点在于支持双向遍历，体现在以下两个方面。</p>\n<ul>\n<li>在有序链表中查找某个元素，单链表由于只有后继指针，因此只能从前往后遍历查找时间复杂度为O(N)，而双向链表可以双向遍历，因此可以采用二分的思想进行查找，时间复杂度为O(logn)。</li>\n<li>删除给定指针指向的结点。假设已经找到要删除的节点，要删除就必须知道其前驱节点和后继节点，单链表想要知道其前驱节点只能从头开始遍历，时间复杂度为0(n)，而双向链表由于保存了其前驱节点的地址，因此时间复杂度为0(1)。</li>\n</ul>\n<h4 id=\"1-4-循环链表\"><a href=\"#1-4-循环链表\" class=\"headerlink\" title=\"1.4 循环链表\"></a>1.4 循环链表</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/37524267.jpg\" alt=\"循环链表\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;顾名思义。循环链表与单、双链表不同的是其呈环状，单循环链表中其尾节点并非指向NULL而是指向头结点。双循环链表中其头节点的前驱指针指向尾节点，尾节点的后继指针指向头结点。循环链表的优势在于链尾到链头，链头到链尾比较方便适合处理的数据具有环型结构特点。</p>\n<h3 id=\"二、Redis链表\"><a href=\"#二、Redis链表\" class=\"headerlink\" title=\"二、Redis链表\"></a>二、Redis链表</h3><h4 id=\"2-1-双向无环链表\"><a href=\"#2-1-双向无环链表\" class=\"headerlink\" title=\"2.1 双向无环链表\"></a>2.1 双向无环链表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis链表使用双向无环链表。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-14/90004345.jpg\" alt=\"Redis双向无环链表\"></p>\n<p>如图所示，Redis使用一个listNode结构来表示。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span> </span><br><span class=\"line\">\t<span class=\"comment\">// 前置节点 </span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span> </span><br><span class=\"line\">\t<span class=\"comment\">// 后置节点 </span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span> </span><br><span class=\"line\">\t<span class=\"comment\">// 节点的值 </span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *value; </span><br><span class=\"line\">&#125; listNode;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-list结构\"><a href=\"#2-2-list结构\" class=\"headerlink\" title=\"2.2 list结构\"></a>2.2 list结构</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;同时Redis为了方便的操作链表，提供了一个list结构来持有链表。如下图所示</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-15/16682936.jpg\" alt=\"list结构\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\">    <span class=\"comment\">//表尾节点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\">    <span class=\"comment\">//链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\">    <span class=\"comment\">//节点值复制函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">//节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\">    <span class=\"comment\">//节点值对比函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr,<span class=\"keyword\">void</span> *key);</span><br><span class=\"line\">&#125;<span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n<p>Redis链表结构其主要特性如下:</p>\n<ul>\n<li>双向：链表节点带有前驱、后继指针获取某个节点的前驱、后继节点的时间复杂度为0(1)。</li>\n<li>无环: 链表为非循环链表表头节点的前驱指针和表尾节点的后继指针都指向NULL，对链表的访问以NULL为终点。</li>\n<li>带表头指针和表尾指针：通过list结构中的head和tail指针，获取表头和表尾节点的时间复杂度都为O(1)。</li>\n<li>带链表长度计数器:通过list结构的len属性获取节点数量的时间复杂度为O(1)。</li>\n<li>多态：链表节点使用void*指针保存节点的值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值。</li>\n</ul>\n<h4 id=\"2-3-双向无环链表在Redis中的使用\"><a href=\"#2-3-双向无环链表在Redis中的使用\" class=\"headerlink\" title=\"2.3 双向无环链表在Redis中的使用\"></a>2.3 双向无环链表在Redis中的使用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;链表在Redis中的应用非常广泛，列表对象的底层实现之一就是链表。此外如发布订阅、慢查询、监视器等功能也用到了链表。我们现在简单想一想Redis为什么要使用双向无环链表这种数据结构，而不是使用数组、单向链表等。既然列表对象的底层实现之一是链表，那么我们通过一个表格来分析列表对象的常用操作命令。如果分别使用数组、单链表和双向链表实现列表对象的时间复杂度对照如下:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作\\时间复杂度</th>\n<th>数组</th>\n<th>单链表</th>\n<th>双向链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rpush(从右边添加元素)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>lpush(从左边添加元素)</td>\n<td>0(N)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>lpop (从右边删除元素)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>rpop (从左边删除元素)</td>\n<td>O(N)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>lindex(获取指定索引下标的元素)</td>\n<td>O(1)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>len (获取长度)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>linsert(向某个元素前或后插入元素)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>lrem (删除指定元素)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>lset (修改指定索引下标元素)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n<td>O(N)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到在列表对象常用的操作中双向链表的优势所在。但双向链表因为使用两个额外的空间存储前驱和后继指针，因此在数据量较小的情况下会造成空间上的浪费(因为数据量小的时候速度上的差别不大，但空间上的差别很大)。这是一个时间换空间还是空间换时间的思想问题，Redis在列表对象中小数据量的时候使用压缩列表作为底层实现，而大数据量的时候才会使用双向无环链表。(关于列表对象后续会有文章继续介绍可访问我的个人博客持续关注<a href=\"http://blog.loading.ink\" target=\"_blank\" rel=\"noopener\">blog.loading.ink</a>)</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;链表作为一种非常常用的数据结构，内置在许多编程语言里面，更是找工作过程中经常问的面试题之一。本篇文章简单复习了链表这种数据结构常见的几种形式，并且简单分析了Redis中链表的使用。下篇文章将继续分享Redis中用到的数据结构Hash。敬请关注!</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>"},{"title":"Redis数据结构——跳跃表","copyright":true,"date":"2019-07-24T06:38:45.000Z","keywords":"Redis,数据结构,跳跃表","aside":"redis","_content":"\n### 前言\n\n​\t跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。这么说，我们可能很难理解，我们可以先回忆一下链表。\n\n<!--more-->\n\n### 一、复习跳跃表\n\n#### 1.1 什么是跳跃表\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。\n\n![单链表](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E5%8D%95%E9%93%BE%E8%A1%A8.png)\n\n​\t如果我们想要提高其查找效率，可以考虑在链表上建索引的方式。每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引。\n\n​\t![一层跳跃表](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E4%B8%80%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8.png)\n\n​\t这个时候，我们假设要查找节点8，我们可以先在索引层遍历，当遍历到索引层中值为 7 的结点时，发现下一个节点是9，那么要查找的节点8肯定就在这两个节点之间。我们下降到链表层继续遍历就找到了8这个节点。原先我们在单链表中找到8这个节点要遍历8个节点，而现在有了一级索引后只需要遍历五个节点。\n\n​\t从这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍的结点个数减少了，也就是说查找效率提高了，同理再加一级索引。\n\n![二层跳跃表](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E4%BA%8C%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8.png)\n\n​\t从图中我们可以看出，查找效率又有提升。在例子中我们的数据很少，当有大量的数据时，我们可以增加多级索引，其查找效率可以得到明显提升。\n\n![跳跃表](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E8%B7%B3%E8%B7%83%E8%A1%A8.png)\n\n​\t**像这种链表加多级索引的结构，就是跳跃表！**\n\n### 二、Redis跳跃表\n\n​\tRedis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的**元素数量比较多**,又或者有序集合中元素的**成员是比较长的字符串**时, Redis就会使用跳跃表来作为有序集合健的底层实现。\n\n​\t这里我们需要思考一个问题——为什么元素数量比较多或者成员是比较长的字符串的时候Redis要使用跳跃表来实现？\n\n​\t从上面我们可以知道，跳跃表在链表的基础上增加了多级索引以提升查找的效率，但其是一个空间换时间的方案，必然会带来一个问题——索引是占内存的。原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略。\n\n#### 2.1 Redis中跳跃表的实现\n\n​\tRedis的跳跃表由zskiplistNode和skiplist两个结构定义,其中 zskiplistNode结构用于表示跳跃表节点,而 zskiplist结构则用于保存跳跃表节点的相关信息,比如节点的数量,以及指向表头节点和表尾节点的指针等等。\n\n\n\n\n\n![Redis跳跃表](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/Redis%E8%B7%B3%E8%B7%83%E8%A1%A8.png)\n\n​\t上图展示了一个跳跃表示例,其中最左边的是 skiplist结构,该结构包含以下属性。\n\n- header:指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)\n\n- tail:指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)\n\n- level:记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。\n\n- length:记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。\n\n  结构右方的是四个 zskiplistNode结构,该结构包含以下属性\n\n- 层(level):\n\n  ​\t节点中用1、2、L3等字样标记节点的各个层,L1代表第一层,L代表第二层,以此类推。\n\n  ​\t每个层都带有两个属性:前进指针和跨度。前进指针用于访问位于表尾方向的其他节点,而跨度则记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)。在上图中,连线上带有数字的箭头就代表前进指针,而那个数字就是跨度。当程序从表头向表尾进行遍历时,访问会沿着层的前进指针进行。\n\n  ​\t每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的“高度”。\n\n- 后退(backward)指针：\n\n  ​\t节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点。\n\n- 分值(score):\n\n  ​\t各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列。\n\n- 成员对象(oj):\n\n  ​\t各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中,各个节点保存的成员对象必须是唯一的,但是多个节点保存的分值却可以是相同的:分值相同的节点将按照成员对象在字典序中的大小来进行排序,成员对象较小的节点会排在前面(靠近表头的方向),而成员对象较大的节点则会排在后面(靠近表尾的方向)。\n\n![zskiplistNode](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/zskiplistNode.png)\n\n#### 2.2 Redis跳跃表常用操作的时间复杂度\n\n| 操作                                                         | 时间复杂度                               |\n| ------------------------------------------------------------ | ---------------------------------------- |\n| 创建一个跳跃表                                               | O(1)                                     |\n| 释放给定跳跃表以及其中包含的节点                             | O(N)                                     |\n| 添加给定成员和分值的新节点                                   | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 删除除跳跃表中包含给定成员和分值的节点                       | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 返回给定成员和分值的节点再表中的排位                         | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 返回在给定排位上的节点                                       | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 给定一个分值范围,返回跳跃表中第一个符合这个范围的节点        | O(1)                                     |\n| 给定一个分值范围,返回跳跃表中最后一个符合这个范围的节点      | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 给定一个分值范围,除跳跃表中所有在这个范围之内的节点          | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 给定一个排位范围,鼎除跳跃表中所有在这个范围之内的节点        | O(N),N为被除节点数量                     |\n| 给定一个分值范固(range),比如0到15,20到28,诸如此类,如果跳氏表中有至少一个节点的分值在这个范間之内,那么返回1,否则返回0 | O(N),N为被除节点数量                     |\n\n### 本文重点\n\n- 跳跃表基于单链表加索引的方式实现\n- 跳跃表以空间换时间的方式提升了查找速度\n- Redis有序集合在节点元素较大或者元素数量较多时使用跳跃表实现\n- Redis的跳跃表实现由 zskiplist和 zskiplistnode两个结构组成,其中 zskiplist用于保存跳跃表信息(比如表头节点、表尾节点、长度),而zskiplistnode则用于表示跳跃表节点\n- Redis每个跳跃表节点的层高都是1至32之间的随机数\n- 在同一个跳跃表中,多个节点可以包含相同的分值,但每个节点的成员对象必须是唯一的跳跃表中的节点按照分值大小进行排序,当分值相同时,节点按照成员对象的大小进行排序。\n\n### 小结\n\n​\t跳跃表可能对我们来说是一种的稍陌生的数据结构。本篇文章简单介绍了跳跃表这种数据结构，并且分析了Redis中跳跃表的使用。下篇文章将继续分享Redis中用到的数据结构整数集合。敬请关注!\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","source":"_posts/技术实践/redis/Redi数据结构——跳跃表.md","raw":"---\ntitle: Redis数据结构——跳跃表\ncopyright: true\ndate: 2019-07-24 14:38:45\ntags: \n- Redis\n- 数据结构\ncategories: Redis\nkeywords: Redis,数据结构,跳跃表\naside: redis\n---\n\n### 前言\n\n​\t跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。这么说，我们可能很难理解，我们可以先回忆一下链表。\n\n<!--more-->\n\n### 一、复习跳跃表\n\n#### 1.1 什么是跳跃表\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。\n\n![单链表](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E5%8D%95%E9%93%BE%E8%A1%A8.png)\n\n​\t如果我们想要提高其查找效率，可以考虑在链表上建索引的方式。每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引。\n\n​\t![一层跳跃表](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E4%B8%80%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8.png)\n\n​\t这个时候，我们假设要查找节点8，我们可以先在索引层遍历，当遍历到索引层中值为 7 的结点时，发现下一个节点是9，那么要查找的节点8肯定就在这两个节点之间。我们下降到链表层继续遍历就找到了8这个节点。原先我们在单链表中找到8这个节点要遍历8个节点，而现在有了一级索引后只需要遍历五个节点。\n\n​\t从这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍的结点个数减少了，也就是说查找效率提高了，同理再加一级索引。\n\n![二层跳跃表](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E4%BA%8C%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8.png)\n\n​\t从图中我们可以看出，查找效率又有提升。在例子中我们的数据很少，当有大量的数据时，我们可以增加多级索引，其查找效率可以得到明显提升。\n\n![跳跃表](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E8%B7%B3%E8%B7%83%E8%A1%A8.png)\n\n​\t**像这种链表加多级索引的结构，就是跳跃表！**\n\n### 二、Redis跳跃表\n\n​\tRedis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的**元素数量比较多**,又或者有序集合中元素的**成员是比较长的字符串**时, Redis就会使用跳跃表来作为有序集合健的底层实现。\n\n​\t这里我们需要思考一个问题——为什么元素数量比较多或者成员是比较长的字符串的时候Redis要使用跳跃表来实现？\n\n​\t从上面我们可以知道，跳跃表在链表的基础上增加了多级索引以提升查找的效率，但其是一个空间换时间的方案，必然会带来一个问题——索引是占内存的。原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略。\n\n#### 2.1 Redis中跳跃表的实现\n\n​\tRedis的跳跃表由zskiplistNode和skiplist两个结构定义,其中 zskiplistNode结构用于表示跳跃表节点,而 zskiplist结构则用于保存跳跃表节点的相关信息,比如节点的数量,以及指向表头节点和表尾节点的指针等等。\n\n\n\n\n\n![Redis跳跃表](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/Redis%E8%B7%B3%E8%B7%83%E8%A1%A8.png)\n\n​\t上图展示了一个跳跃表示例,其中最左边的是 skiplist结构,该结构包含以下属性。\n\n- header:指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)\n\n- tail:指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)\n\n- level:记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。\n\n- length:记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。\n\n  结构右方的是四个 zskiplistNode结构,该结构包含以下属性\n\n- 层(level):\n\n  ​\t节点中用1、2、L3等字样标记节点的各个层,L1代表第一层,L代表第二层,以此类推。\n\n  ​\t每个层都带有两个属性:前进指针和跨度。前进指针用于访问位于表尾方向的其他节点,而跨度则记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)。在上图中,连线上带有数字的箭头就代表前进指针,而那个数字就是跨度。当程序从表头向表尾进行遍历时,访问会沿着层的前进指针进行。\n\n  ​\t每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的“高度”。\n\n- 后退(backward)指针：\n\n  ​\t节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点。\n\n- 分值(score):\n\n  ​\t各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列。\n\n- 成员对象(oj):\n\n  ​\t各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中,各个节点保存的成员对象必须是唯一的,但是多个节点保存的分值却可以是相同的:分值相同的节点将按照成员对象在字典序中的大小来进行排序,成员对象较小的节点会排在前面(靠近表头的方向),而成员对象较大的节点则会排在后面(靠近表尾的方向)。\n\n![zskiplistNode](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/zskiplistNode.png)\n\n#### 2.2 Redis跳跃表常用操作的时间复杂度\n\n| 操作                                                         | 时间复杂度                               |\n| ------------------------------------------------------------ | ---------------------------------------- |\n| 创建一个跳跃表                                               | O(1)                                     |\n| 释放给定跳跃表以及其中包含的节点                             | O(N)                                     |\n| 添加给定成员和分值的新节点                                   | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 删除除跳跃表中包含给定成员和分值的节点                       | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 返回给定成员和分值的节点再表中的排位                         | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 返回在给定排位上的节点                                       | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 给定一个分值范围,返回跳跃表中第一个符合这个范围的节点        | O(1)                                     |\n| 给定一个分值范围,返回跳跃表中最后一个符合这个范围的节点      | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 给定一个分值范围,除跳跃表中所有在这个范围之内的节点          | 平均O(logN),最坏O(logN)(N为跳跃表的长度) |\n| 给定一个排位范围,鼎除跳跃表中所有在这个范围之内的节点        | O(N),N为被除节点数量                     |\n| 给定一个分值范固(range),比如0到15,20到28,诸如此类,如果跳氏表中有至少一个节点的分值在这个范間之内,那么返回1,否则返回0 | O(N),N为被除节点数量                     |\n\n### 本文重点\n\n- 跳跃表基于单链表加索引的方式实现\n- 跳跃表以空间换时间的方式提升了查找速度\n- Redis有序集合在节点元素较大或者元素数量较多时使用跳跃表实现\n- Redis的跳跃表实现由 zskiplist和 zskiplistnode两个结构组成,其中 zskiplist用于保存跳跃表信息(比如表头节点、表尾节点、长度),而zskiplistnode则用于表示跳跃表节点\n- Redis每个跳跃表节点的层高都是1至32之间的随机数\n- 在同一个跳跃表中,多个节点可以包含相同的分值,但每个节点的成员对象必须是唯一的跳跃表中的节点按照分值大小进行排序,当分值相同时,节点按照成员对象的大小进行排序。\n\n### 小结\n\n​\t跳跃表可能对我们来说是一种的稍陌生的数据结构。本篇文章简单介绍了跳跃表这种数据结构，并且分析了Redis中跳跃表的使用。下篇文章将继续分享Redis中用到的数据结构整数集合。敬请关注!\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n\n### -----END-----\n\n","slug":"技术实践/redis/Redi数据结构——跳跃表","published":1,"updated":"2021-03-14T03:04:50.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzs00eshyjfpjwvfbej","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>​    跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。这么说，我们可能很难理解，我们可以先回忆一下链表。</p>\n<a id=\"more\"></a>\n<h3 id=\"一、复习跳跃表\"><a href=\"#一、复习跳跃表\" class=\"headerlink\" title=\"一、复习跳跃表\"></a>一、复习跳跃表</h3><h4 id=\"1-1-什么是跳跃表\"><a href=\"#1-1-什么是跳跃表\" class=\"headerlink\" title=\"1.1 什么是跳跃表\"></a>1.1 什么是跳跃表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E5%8D%95%E9%93%BE%E8%A1%A8.png\" alt=\"单链表\"></p>\n<p>​    如果我们想要提高其查找效率，可以考虑在链表上建索引的方式。每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引。</p>\n<p>​    <img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E4%B8%80%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8.png\" alt=\"一层跳跃表\"></p>\n<p>​    这个时候，我们假设要查找节点8，我们可以先在索引层遍历，当遍历到索引层中值为 7 的结点时，发现下一个节点是9，那么要查找的节点8肯定就在这两个节点之间。我们下降到链表层继续遍历就找到了8这个节点。原先我们在单链表中找到8这个节点要遍历8个节点，而现在有了一级索引后只需要遍历五个节点。</p>\n<p>​    从这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍的结点个数减少了，也就是说查找效率提高了，同理再加一级索引。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E4%BA%8C%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8.png\" alt=\"二层跳跃表\"></p>\n<p>​    从图中我们可以看出，查找效率又有提升。在例子中我们的数据很少，当有大量的数据时，我们可以增加多级索引，其查找效率可以得到明显提升。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E8%B7%B3%E8%B7%83%E8%A1%A8.png\" alt=\"跳跃表\"></p>\n<p>​    <strong>像这种链表加多级索引的结构，就是跳跃表！</strong></p>\n<h3 id=\"二、Redis跳跃表\"><a href=\"#二、Redis跳跃表\" class=\"headerlink\" title=\"二、Redis跳跃表\"></a>二、Redis跳跃表</h3><p>​    Redis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的<strong>元素数量比较多</strong>,又或者有序集合中元素的<strong>成员是比较长的字符串</strong>时, Redis就会使用跳跃表来作为有序集合健的底层实现。</p>\n<p>​    这里我们需要思考一个问题——为什么元素数量比较多或者成员是比较长的字符串的时候Redis要使用跳跃表来实现？</p>\n<p>​    从上面我们可以知道，跳跃表在链表的基础上增加了多级索引以提升查找的效率，但其是一个空间换时间的方案，必然会带来一个问题——索引是占内存的。原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略。</p>\n<h4 id=\"2-1-Redis中跳跃表的实现\"><a href=\"#2-1-Redis中跳跃表的实现\" class=\"headerlink\" title=\"2.1 Redis中跳跃表的实现\"></a>2.1 Redis中跳跃表的实现</h4><p>​    Redis的跳跃表由zskiplistNode和skiplist两个结构定义,其中 zskiplistNode结构用于表示跳跃表节点,而 zskiplist结构则用于保存跳跃表节点的相关信息,比如节点的数量,以及指向表头节点和表尾节点的指针等等。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/Redis%E8%B7%B3%E8%B7%83%E8%A1%A8.png\" alt=\"Redis跳跃表\"></p>\n<p>​    上图展示了一个跳跃表示例,其中最左边的是 skiplist结构,该结构包含以下属性。</p>\n<ul>\n<li><p>header:指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)</p>\n</li>\n<li><p>tail:指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)</p>\n</li>\n<li><p>level:记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。</p>\n</li>\n<li><p>length:记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。</p>\n<p>结构右方的是四个 zskiplistNode结构,该结构包含以下属性</p>\n</li>\n<li><p>层(level):</p>\n<p>​    节点中用1、2、L3等字样标记节点的各个层,L1代表第一层,L代表第二层,以此类推。</p>\n<p>​    每个层都带有两个属性:前进指针和跨度。前进指针用于访问位于表尾方向的其他节点,而跨度则记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)。在上图中,连线上带有数字的箭头就代表前进指针,而那个数字就是跨度。当程序从表头向表尾进行遍历时,访问会沿着层的前进指针进行。</p>\n<p>​    每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的“高度”。</p>\n</li>\n<li><p>后退(backward)指针：</p>\n<p>​    节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点。</p>\n</li>\n<li><p>分值(score):</p>\n<p>​    各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列。</p>\n</li>\n<li><p>成员对象(oj):</p>\n<p>​    各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中,各个节点保存的成员对象必须是唯一的,但是多个节点保存的分值却可以是相同的:分值相同的节点将按照成员对象在字典序中的大小来进行排序,成员对象较小的节点会排在前面(靠近表头的方向),而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p>\n</li>\n</ul>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/zskiplistNode.png\" alt=\"zskiplistNode\"></p>\n<h4 id=\"2-2-Redis跳跃表常用操作的时间复杂度\"><a href=\"#2-2-Redis跳跃表常用操作的时间复杂度\" class=\"headerlink\" title=\"2.2 Redis跳跃表常用操作的时间复杂度\"></a>2.2 Redis跳跃表常用操作的时间复杂度</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建一个跳跃表</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>释放给定跳跃表以及其中包含的节点</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>添加给定成员和分值的新节点</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>删除除跳跃表中包含给定成员和分值的节点</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>返回给定成员和分值的节点再表中的排位</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>返回在给定排位上的节点</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>给定一个分值范围,返回跳跃表中第一个符合这个范围的节点</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>给定一个分值范围,返回跳跃表中最后一个符合这个范围的节点</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>给定一个分值范围,除跳跃表中所有在这个范围之内的节点</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>给定一个排位范围,鼎除跳跃表中所有在这个范围之内的节点</td>\n<td>O(N),N为被除节点数量</td>\n</tr>\n<tr>\n<td>给定一个分值范固(range),比如0到15,20到28,诸如此类,如果跳氏表中有至少一个节点的分值在这个范間之内,那么返回1,否则返回0</td>\n<td>O(N),N为被除节点数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"本文重点\"><a href=\"#本文重点\" class=\"headerlink\" title=\"本文重点\"></a>本文重点</h3><ul>\n<li>跳跃表基于单链表加索引的方式实现</li>\n<li>跳跃表以空间换时间的方式提升了查找速度</li>\n<li>Redis有序集合在节点元素较大或者元素数量较多时使用跳跃表实现</li>\n<li>Redis的跳跃表实现由 zskiplist和 zskiplistnode两个结构组成,其中 zskiplist用于保存跳跃表信息(比如表头节点、表尾节点、长度),而zskiplistnode则用于表示跳跃表节点</li>\n<li>Redis每个跳跃表节点的层高都是1至32之间的随机数</li>\n<li>在同一个跳跃表中,多个节点可以包含相同的分值,但每个节点的成员对象必须是唯一的跳跃表中的节点按照分值大小进行排序,当分值相同时,节点按照成员对象的大小进行排序。</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>​    跳跃表可能对我们来说是一种的稍陌生的数据结构。本篇文章简单介绍了跳跃表这种数据结构，并且分析了Redis中跳跃表的使用。下篇文章将继续分享Redis中用到的数据结构整数集合。敬请关注!</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>​    跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。这么说，我们可能很难理解，我们可以先回忆一下链表。</p>","more":"<h3 id=\"一、复习跳跃表\"><a href=\"#一、复习跳跃表\" class=\"headerlink\" title=\"一、复习跳跃表\"></a>一、复习跳跃表</h3><h4 id=\"1-1-什么是跳跃表\"><a href=\"#1-1-什么是跳跃表\" class=\"headerlink\" title=\"1.1 什么是跳跃表\"></a>1.1 什么是跳跃表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E5%8D%95%E9%93%BE%E8%A1%A8.png\" alt=\"单链表\"></p>\n<p>​    如果我们想要提高其查找效率，可以考虑在链表上建索引的方式。每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引。</p>\n<p>​    <img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E4%B8%80%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8.png\" alt=\"一层跳跃表\"></p>\n<p>​    这个时候，我们假设要查找节点8，我们可以先在索引层遍历，当遍历到索引层中值为 7 的结点时，发现下一个节点是9，那么要查找的节点8肯定就在这两个节点之间。我们下降到链表层继续遍历就找到了8这个节点。原先我们在单链表中找到8这个节点要遍历8个节点，而现在有了一级索引后只需要遍历五个节点。</p>\n<p>​    从这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍的结点个数减少了，也就是说查找效率提高了，同理再加一级索引。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E4%BA%8C%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8.png\" alt=\"二层跳跃表\"></p>\n<p>​    从图中我们可以看出，查找效率又有提升。在例子中我们的数据很少，当有大量的数据时，我们可以增加多级索引，其查找效率可以得到明显提升。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/%E8%B7%B3%E8%B7%83%E8%A1%A8.png\" alt=\"跳跃表\"></p>\n<p>​    <strong>像这种链表加多级索引的结构，就是跳跃表！</strong></p>\n<h3 id=\"二、Redis跳跃表\"><a href=\"#二、Redis跳跃表\" class=\"headerlink\" title=\"二、Redis跳跃表\"></a>二、Redis跳跃表</h3><p>​    Redis使用跳跃表作为有序集合键的底层实现之一,如果一个有序集合包含的<strong>元素数量比较多</strong>,又或者有序集合中元素的<strong>成员是比较长的字符串</strong>时, Redis就会使用跳跃表来作为有序集合健的底层实现。</p>\n<p>​    这里我们需要思考一个问题——为什么元素数量比较多或者成员是比较长的字符串的时候Redis要使用跳跃表来实现？</p>\n<p>​    从上面我们可以知道，跳跃表在链表的基础上增加了多级索引以提升查找的效率，但其是一个空间换时间的方案，必然会带来一个问题——索引是占内存的。原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略。</p>\n<h4 id=\"2-1-Redis中跳跃表的实现\"><a href=\"#2-1-Redis中跳跃表的实现\" class=\"headerlink\" title=\"2.1 Redis中跳跃表的实现\"></a>2.1 Redis中跳跃表的实现</h4><p>​    Redis的跳跃表由zskiplistNode和skiplist两个结构定义,其中 zskiplistNode结构用于表示跳跃表节点,而 zskiplist结构则用于保存跳跃表节点的相关信息,比如节点的数量,以及指向表头节点和表尾节点的指针等等。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/Redis%E8%B7%B3%E8%B7%83%E8%A1%A8.png\" alt=\"Redis跳跃表\"></p>\n<p>​    上图展示了一个跳跃表示例,其中最左边的是 skiplist结构,该结构包含以下属性。</p>\n<ul>\n<li><p>header:指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)</p>\n</li>\n<li><p>tail:指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)</p>\n</li>\n<li><p>level:记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。</p>\n</li>\n<li><p>length:记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。</p>\n<p>结构右方的是四个 zskiplistNode结构,该结构包含以下属性</p>\n</li>\n<li><p>层(level):</p>\n<p>​    节点中用1、2、L3等字样标记节点的各个层,L1代表第一层,L代表第二层,以此类推。</p>\n<p>​    每个层都带有两个属性:前进指针和跨度。前进指针用于访问位于表尾方向的其他节点,而跨度则记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)。在上图中,连线上带有数字的箭头就代表前进指针,而那个数字就是跨度。当程序从表头向表尾进行遍历时,访问会沿着层的前进指针进行。</p>\n<p>​    每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的“高度”。</p>\n</li>\n<li><p>后退(backward)指针：</p>\n<p>​    节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点。</p>\n</li>\n<li><p>分值(score):</p>\n<p>​    各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列。</p>\n</li>\n<li><p>成员对象(oj):</p>\n<p>​    各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中,各个节点保存的成员对象必须是唯一的,但是多个节点保存的分值却可以是相同的:分值相同的节点将按照成员对象在字典序中的大小来进行排序,成员对象较小的节点会排在前面(靠近表头的方向),而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p>\n</li>\n</ul>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/skiplist/zskiplistNode.png\" alt=\"zskiplistNode\"></p>\n<h4 id=\"2-2-Redis跳跃表常用操作的时间复杂度\"><a href=\"#2-2-Redis跳跃表常用操作的时间复杂度\" class=\"headerlink\" title=\"2.2 Redis跳跃表常用操作的时间复杂度\"></a>2.2 Redis跳跃表常用操作的时间复杂度</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建一个跳跃表</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>释放给定跳跃表以及其中包含的节点</td>\n<td>O(N)</td>\n</tr>\n<tr>\n<td>添加给定成员和分值的新节点</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>删除除跳跃表中包含给定成员和分值的节点</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>返回给定成员和分值的节点再表中的排位</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>返回在给定排位上的节点</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>给定一个分值范围,返回跳跃表中第一个符合这个范围的节点</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>给定一个分值范围,返回跳跃表中最后一个符合这个范围的节点</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>给定一个分值范围,除跳跃表中所有在这个范围之内的节点</td>\n<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>\n</tr>\n<tr>\n<td>给定一个排位范围,鼎除跳跃表中所有在这个范围之内的节点</td>\n<td>O(N),N为被除节点数量</td>\n</tr>\n<tr>\n<td>给定一个分值范固(range),比如0到15,20到28,诸如此类,如果跳氏表中有至少一个节点的分值在这个范間之内,那么返回1,否则返回0</td>\n<td>O(N),N为被除节点数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"本文重点\"><a href=\"#本文重点\" class=\"headerlink\" title=\"本文重点\"></a>本文重点</h3><ul>\n<li>跳跃表基于单链表加索引的方式实现</li>\n<li>跳跃表以空间换时间的方式提升了查找速度</li>\n<li>Redis有序集合在节点元素较大或者元素数量较多时使用跳跃表实现</li>\n<li>Redis的跳跃表实现由 zskiplist和 zskiplistnode两个结构组成,其中 zskiplist用于保存跳跃表信息(比如表头节点、表尾节点、长度),而zskiplistnode则用于表示跳跃表节点</li>\n<li>Redis每个跳跃表节点的层高都是1至32之间的随机数</li>\n<li>在同一个跳跃表中,多个节点可以包含相同的分值,但每个节点的成员对象必须是唯一的跳跃表中的节点按照分值大小进行排序,当分值相同时,节点按照成员对象的大小进行排序。</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>​    跳跃表可能对我们来说是一种的稍陌生的数据结构。本篇文章简单介绍了跳跃表这种数据结构，并且分析了Redis中跳跃表的使用。下篇文章将继续分享Redis中用到的数据结构整数集合。敬请关注!</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>"},{"title":"一文回顾Reids五大对象(数据类型)","copyright":true,"date":"2020-04-07T02:45:38.000Z","keywords":"Redis,String,Hash,List,Set,ZSet","aside":"redis","_content":"Redis 是一个高性能的分布式内存型数据库，在国内外各大互联网公司中都有着广泛的使用，即使是一些非互联网公司中也有着非常重要的适用场景，所以对 Redis 的掌握也成为后端工程师必备的基础技能，在面试中，Redis早已成为老生常谈的话题，而在实际工作中，我们更是每时每刻都需要和 Redis 打交道。因此熟练的掌握Redis技术栈的各种武功秘籍至关重要！\n\n<!--more-->\n\nRedis提供了五种主要的对象(数据类型)供开发者使用，它提供了强大且实用的功能。然而实际开发中有大多数的开发者仅简单会用Redis String的Get与Set。这就好比降龙十八掌，你只学会了一掌。在真正实战对敌之时不免略显单薄！这篇文章我们将回顾Redis这五大对象，以便于我们能够在实战中真正做到游刃有余。\n\n### 一、字符串(终究是我扛下了所有)\n\n字符串类型是Redis最基础的数据结构，其他几种数据结构都是在字符串类型基础上构建的。字符串类型的值是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字（整数、浮点数），甚至是二进制（图片、音频、视频）等\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2.png)\n\n字符串对象的内部编码有3种 ：`int`、`raw`和`embstr`。Redis会根据当前值的类型和长度来决定使用哪种编码来实现。\n\n* int:如果一个字符串对象保存的是整数值,并且这个整数值可以用`long`类型来表示\n* raw:如果字符串对象保存的是一个字符串值,并且这个字符串值的长度大于32字节\n* embstr:如果字符串对象保存的是一个字符串值,并且这个字符申值的长度小于等于32字节\n\n&nbsp;reids字符串的使用场景是最为广泛的，甚至有些对redis其它几种对象不太熟悉的人，基本所有场景都会使用字符串(序列化一下直接扔进去),这让本身很单纯的字符串承受了它这个年纪本不该承受的重量。其实Redis的主要使用场景主要有以下几种:\n\n1. 作为缓存层,缓存热点数据\n2. Redis字符串可以自增自减的特性可以用来做计数器、限速器、自增ID生成等\n3. 分布式系统的Session共享\n4. 二进制数据的存储\n\n有关Redis字符串的更详细的介绍，可以查看我的这篇文章。\n\n[Redis对象——字符串(String)](https://blog.laoyu.site/2019/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2(String)/)\n\n### 二、哈希(存储对象我也行)\n\n哈希对象用来存储一组数据对。每个数据对又包含键值两部分。\n\n![Redis-Hash](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash.png)\n\n哈希对象也有两种实现方式。[ziplist(压缩列表)](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/),[hashtable(哈希表)](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/)\n\n同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现哈希对象。具体需要满足两个条件：\n\n* 字典中保存的键和值的大小都要小于 64 字节；\n* 字典中键值对的个数要小于 512 个。\n\n当不能同时满足上面两个条件的时候，Redis 就使用哈希表来实现哈希对象。\n\n当存储的内容是对象的时候，Redis 字符串对象的很多功能使用Redis 哈希对象也可以实现。如缓存用户信息的时候，使用Redis哈希对象存储，简单直观，如果使用合理可以减少内存空间的使用。但也有其缺点，就是要要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。\n\n此外，Redis 哈希对象还可以实现购物车、计数器等功能。\n\n有关Redis哈希对象的更详细的介绍，可以查看我的这篇文章。\n\n[Redis对象——哈希(Hash)](https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C(Hash)/)\n\n### 三、列表(栈和队列我都行)\n\n列表这种对象支持存储一组有序的、不重复的数据。因为其有序性，它可以获取指定范围的元素列表、可以在O(1)的时间复杂度获取指定索引下标的元素等。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/Redis%20List.png)\n\n在Redis3.2版本以前列表类型的内部编码有两种。当满足下面两个条件的时候，Redis 列表对象使用ziplist（压缩列表）来实现。\n\n* 当列表的元素个数小于list-max-ziplist-entries配置（默认512个）\n\n* 当列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节）\n\n当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。\n\n而在Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.\n\n由于列表对象的有序且不可重复的特性，它比较适合用来做文章、商品等列表的存储。\n\n列表类型可以 lpush (左侧push)，同时又可以使用 rpop (右侧弹出)（查询并删除）第一个元素，所以列表类型具有先进先出的特性，可以用来实现消息队列。也可以lpush(左侧push)->lpop(左侧弹出)，具有后进先出的特性，因此开发中需要使用栈的时候，我们也可以借助列表对象来实现。\n有关Redis列表对象的更详细的介绍，可以查看我的这篇文章。\n\n[Redis对象——列表(List)](https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8(List)/)\n### 四、集合(标签系统我在行)\n\n集合对象 (Set) 是一个无序并唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储。与列表所不同的是它存储的数据是无序且不重复的。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88.png)\n\n集合对象的内部编码也有两种：intset(整数集合)与hashtable(哈希表)。当满足下面两个条件的时候集合对象使用intset来实现。\n\n* 集合中的元素都是整数\n* 集合中的元素个数小于set-maxintset-entries配置（默认512个）\n\n不满足上面两个条件时集合对象使用hashtable来实现。\n\n集合对象的主要几个特性就是，无序、不可重复、支持并交差，因此可以用来做标签系统。\n\n而集合的 [SPOP(随机移除并返回集合中一个或多个元素)](https://blog.laoyu.site/2020/redis_command/set/spop/) 和 [SRANDMEMBER(随机返回集合中一个或多个元素)](https://blog.laoyu.site/2020/redis_command/set/srandmember/) 命令可以帮助我们实现一个抽奖系统。\n\n有关Redis集合对象的更详细的介绍，可以查看我的这篇文章。\n\n[Redis对象——集合(Set)](https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E9%9B%86%E5%90%88(Set)/)\n\n### 五、有序集合(排起名来我最棒)\n\n有序集合类型 (Sorted Set或ZSet) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88.png)\n\n有序集合是由 [ziplist (压缩列表)](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/) 或 [skiplist (跳跃表)](https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/) 组成的。\n\n当数据比较少时，有序集合使用的是 ziplist 存储的，有序集合使用 ziplist 格式存储必须满足以下两个条件：\n\n- 有序集合保存的元素个数要小于 128 个；\n- 有序集合保存的所有元素成员的长度都必须小于 64 字节。\n\n如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。\n\n有序集合比较典型的使用场景就是排行榜系统例如学生成绩的排名。某视频(博客等)网站的用户点赞、播放排名、电商系统中商品的销量排名等\n\n有关Redis有序集合对象的更详细的介绍，可以查看我的这篇文章。\n\n[Redis对象——有序集合(ZSet)](https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88(ZSet)/)\n\n### 小结\n\nRedis提供了五种最基础也是最常用的对象(数据类型)：String、Hash、List、Set、ZSet。了解这五种对象的有助于我们更好的在日常开发中对Redis进行使用。而通过这篇文章我们可以看到每种对象都是通过多种数据结构来实现的，大家可以思考一下为什么。\n\n### -----END-----\n\n","source":"_posts/技术实践/redis/一文回顾Reids五大对象(数据类型).md","raw":"---\n\ntitle: 一文回顾Reids五大对象(数据类型)\ncopyright: true\ndate: 2020-04-07 10:45:38\ntags: \n- Redis\ncategories: Redis\nkeywords: Redis,String,Hash,List,Set,ZSet\naside: redis\n---\nRedis 是一个高性能的分布式内存型数据库，在国内外各大互联网公司中都有着广泛的使用，即使是一些非互联网公司中也有着非常重要的适用场景，所以对 Redis 的掌握也成为后端工程师必备的基础技能，在面试中，Redis早已成为老生常谈的话题，而在实际工作中，我们更是每时每刻都需要和 Redis 打交道。因此熟练的掌握Redis技术栈的各种武功秘籍至关重要！\n\n<!--more-->\n\nRedis提供了五种主要的对象(数据类型)供开发者使用，它提供了强大且实用的功能。然而实际开发中有大多数的开发者仅简单会用Redis String的Get与Set。这就好比降龙十八掌，你只学会了一掌。在真正实战对敌之时不免略显单薄！这篇文章我们将回顾Redis这五大对象，以便于我们能够在实战中真正做到游刃有余。\n\n### 一、字符串(终究是我扛下了所有)\n\n字符串类型是Redis最基础的数据结构，其他几种数据结构都是在字符串类型基础上构建的。字符串类型的值是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字（整数、浮点数），甚至是二进制（图片、音频、视频）等\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2.png)\n\n字符串对象的内部编码有3种 ：`int`、`raw`和`embstr`。Redis会根据当前值的类型和长度来决定使用哪种编码来实现。\n\n* int:如果一个字符串对象保存的是整数值,并且这个整数值可以用`long`类型来表示\n* raw:如果字符串对象保存的是一个字符串值,并且这个字符串值的长度大于32字节\n* embstr:如果字符串对象保存的是一个字符串值,并且这个字符申值的长度小于等于32字节\n\n&nbsp;reids字符串的使用场景是最为广泛的，甚至有些对redis其它几种对象不太熟悉的人，基本所有场景都会使用字符串(序列化一下直接扔进去),这让本身很单纯的字符串承受了它这个年纪本不该承受的重量。其实Redis的主要使用场景主要有以下几种:\n\n1. 作为缓存层,缓存热点数据\n2. Redis字符串可以自增自减的特性可以用来做计数器、限速器、自增ID生成等\n3. 分布式系统的Session共享\n4. 二进制数据的存储\n\n有关Redis字符串的更详细的介绍，可以查看我的这篇文章。\n\n[Redis对象——字符串(String)](https://blog.laoyu.site/2019/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2(String)/)\n\n### 二、哈希(存储对象我也行)\n\n哈希对象用来存储一组数据对。每个数据对又包含键值两部分。\n\n![Redis-Hash](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash.png)\n\n哈希对象也有两种实现方式。[ziplist(压缩列表)](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/),[hashtable(哈希表)](http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/)\n\n同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现哈希对象。具体需要满足两个条件：\n\n* 字典中保存的键和值的大小都要小于 64 字节；\n* 字典中键值对的个数要小于 512 个。\n\n当不能同时满足上面两个条件的时候，Redis 就使用哈希表来实现哈希对象。\n\n当存储的内容是对象的时候，Redis 字符串对象的很多功能使用Redis 哈希对象也可以实现。如缓存用户信息的时候，使用Redis哈希对象存储，简单直观，如果使用合理可以减少内存空间的使用。但也有其缺点，就是要要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。\n\n此外，Redis 哈希对象还可以实现购物车、计数器等功能。\n\n有关Redis哈希对象的更详细的介绍，可以查看我的这篇文章。\n\n[Redis对象——哈希(Hash)](https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C(Hash)/)\n\n### 三、列表(栈和队列我都行)\n\n列表这种对象支持存储一组有序的、不重复的数据。因为其有序性，它可以获取指定范围的元素列表、可以在O(1)的时间复杂度获取指定索引下标的元素等。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/Redis%20List.png)\n\n在Redis3.2版本以前列表类型的内部编码有两种。当满足下面两个条件的时候，Redis 列表对象使用ziplist（压缩列表）来实现。\n\n* 当列表的元素个数小于list-max-ziplist-entries配置（默认512个）\n\n* 当列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节）\n\n当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。\n\n而在Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.\n\n由于列表对象的有序且不可重复的特性，它比较适合用来做文章、商品等列表的存储。\n\n列表类型可以 lpush (左侧push)，同时又可以使用 rpop (右侧弹出)（查询并删除）第一个元素，所以列表类型具有先进先出的特性，可以用来实现消息队列。也可以lpush(左侧push)->lpop(左侧弹出)，具有后进先出的特性，因此开发中需要使用栈的时候，我们也可以借助列表对象来实现。\n有关Redis列表对象的更详细的介绍，可以查看我的这篇文章。\n\n[Redis对象——列表(List)](https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8(List)/)\n### 四、集合(标签系统我在行)\n\n集合对象 (Set) 是一个无序并唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储。与列表所不同的是它存储的数据是无序且不重复的。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88.png)\n\n集合对象的内部编码也有两种：intset(整数集合)与hashtable(哈希表)。当满足下面两个条件的时候集合对象使用intset来实现。\n\n* 集合中的元素都是整数\n* 集合中的元素个数小于set-maxintset-entries配置（默认512个）\n\n不满足上面两个条件时集合对象使用hashtable来实现。\n\n集合对象的主要几个特性就是，无序、不可重复、支持并交差，因此可以用来做标签系统。\n\n而集合的 [SPOP(随机移除并返回集合中一个或多个元素)](https://blog.laoyu.site/2020/redis_command/set/spop/) 和 [SRANDMEMBER(随机返回集合中一个或多个元素)](https://blog.laoyu.site/2020/redis_command/set/srandmember/) 命令可以帮助我们实现一个抽奖系统。\n\n有关Redis集合对象的更详细的介绍，可以查看我的这篇文章。\n\n[Redis对象——集合(Set)](https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E9%9B%86%E5%90%88(Set)/)\n\n### 五、有序集合(排起名来我最棒)\n\n有序集合类型 (Sorted Set或ZSet) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88.png)\n\n有序集合是由 [ziplist (压缩列表)](http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/) 或 [skiplist (跳跃表)](https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/) 组成的。\n\n当数据比较少时，有序集合使用的是 ziplist 存储的，有序集合使用 ziplist 格式存储必须满足以下两个条件：\n\n- 有序集合保存的元素个数要小于 128 个；\n- 有序集合保存的所有元素成员的长度都必须小于 64 字节。\n\n如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。\n\n有序集合比较典型的使用场景就是排行榜系统例如学生成绩的排名。某视频(博客等)网站的用户点赞、播放排名、电商系统中商品的销量排名等\n\n有关Redis有序集合对象的更详细的介绍，可以查看我的这篇文章。\n\n[Redis对象——有序集合(ZSet)](https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88(ZSet)/)\n\n### 小结\n\nRedis提供了五种最基础也是最常用的对象(数据类型)：String、Hash、List、Set、ZSet。了解这五种对象的有助于我们更好的在日常开发中对Redis进行使用。而通过这篇文章我们可以看到每种对象都是通过多种数据结构来实现的，大家可以思考一下为什么。\n\n### -----END-----\n\n","slug":"技术实践/redis/一文回顾Reids五大对象(数据类型)","published":1,"updated":"2021-03-14T03:04:50.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzt00evhyjfttt0t9h8","content":"<p>Redis 是一个高性能的分布式内存型数据库，在国内外各大互联网公司中都有着广泛的使用，即使是一些非互联网公司中也有着非常重要的适用场景，所以对 Redis 的掌握也成为后端工程师必备的基础技能，在面试中，Redis早已成为老生常谈的话题，而在实际工作中，我们更是每时每刻都需要和 Redis 打交道。因此熟练的掌握Redis技术栈的各种武功秘籍至关重要！</p>\n<a id=\"more\"></a>\n<p>Redis提供了五种主要的对象(数据类型)供开发者使用，它提供了强大且实用的功能。然而实际开发中有大多数的开发者仅简单会用Redis String的Get与Set。这就好比降龙十八掌，你只学会了一掌。在真正实战对敌之时不免略显单薄！这篇文章我们将回顾Redis这五大对象，以便于我们能够在实战中真正做到游刃有余。</p>\n<h3 id=\"一、字符串-终究是我扛下了所有\"><a href=\"#一、字符串-终究是我扛下了所有\" class=\"headerlink\" title=\"一、字符串(终究是我扛下了所有)\"></a>一、字符串(终究是我扛下了所有)</h3><p>字符串类型是Redis最基础的数据结构，其他几种数据结构都是在字符串类型基础上构建的。字符串类型的值是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字（整数、浮点数），甚至是二进制（图片、音频、视频）等</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2.png\" alt></p>\n<p>字符串对象的内部编码有3种 ：<code>int</code>、<code>raw</code>和<code>embstr</code>。Redis会根据当前值的类型和长度来决定使用哪种编码来实现。</p>\n<ul>\n<li>int:如果一个字符串对象保存的是整数值,并且这个整数值可以用<code>long</code>类型来表示</li>\n<li>raw:如果字符串对象保存的是一个字符串值,并且这个字符串值的长度大于32字节</li>\n<li>embstr:如果字符串对象保存的是一个字符串值,并且这个字符申值的长度小于等于32字节</li>\n</ul>\n<p>&nbsp;reids字符串的使用场景是最为广泛的，甚至有些对redis其它几种对象不太熟悉的人，基本所有场景都会使用字符串(序列化一下直接扔进去),这让本身很单纯的字符串承受了它这个年纪本不该承受的重量。其实Redis的主要使用场景主要有以下几种:</p>\n<ol>\n<li>作为缓存层,缓存热点数据</li>\n<li>Redis字符串可以自增自减的特性可以用来做计数器、限速器、自增ID生成等</li>\n<li>分布式系统的Session共享</li>\n<li>二进制数据的存储</li>\n</ol>\n<p>有关Redis字符串的更详细的介绍，可以查看我的这篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2019/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2(String\">Redis对象——字符串(String)</a>/)</p>\n<h3 id=\"二、哈希-存储对象我也行\"><a href=\"#二、哈希-存储对象我也行\" class=\"headerlink\" title=\"二、哈希(存储对象我也行)\"></a>二、哈希(存储对象我也行)</h3><p>哈希对象用来存储一组数据对。每个数据对又包含键值两部分。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash.png\" alt=\"Redis-Hash\"></p>\n<p>哈希对象也有两种实现方式。<a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">ziplist(压缩列表)</a>,<a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/\">hashtable(哈希表)</a></p>\n<p>同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现哈希对象。具体需要满足两个条件：</p>\n<ul>\n<li>字典中保存的键和值的大小都要小于 64 字节；</li>\n<li>字典中键值对的个数要小于 512 个。</li>\n</ul>\n<p>当不能同时满足上面两个条件的时候，Redis 就使用哈希表来实现哈希对象。</p>\n<p>当存储的内容是对象的时候，Redis 字符串对象的很多功能使用Redis 哈希对象也可以实现。如缓存用户信息的时候，使用Redis哈希对象存储，简单直观，如果使用合理可以减少内存空间的使用。但也有其缺点，就是要要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</p>\n<p>此外，Redis 哈希对象还可以实现购物车、计数器等功能。</p>\n<p>有关Redis哈希对象的更详细的介绍，可以查看我的这篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C(Hash\">Redis对象——哈希(Hash)</a>/)</p>\n<h3 id=\"三、列表-栈和队列我都行\"><a href=\"#三、列表-栈和队列我都行\" class=\"headerlink\" title=\"三、列表(栈和队列我都行)\"></a>三、列表(栈和队列我都行)</h3><p>列表这种对象支持存储一组有序的、不重复的数据。因为其有序性，它可以获取指定范围的元素列表、可以在O(1)的时间复杂度获取指定索引下标的元素等。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/Redis%20List.png\" alt></p>\n<p>在Redis3.2版本以前列表类型的内部编码有两种。当满足下面两个条件的时候，Redis 列表对象使用ziplist（压缩列表）来实现。</p>\n<ul>\n<li><p>当列表的元素个数小于list-max-ziplist-entries配置（默认512个）</p>\n</li>\n<li><p>当列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节）</p>\n</li>\n</ul>\n<p>当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</p>\n<p>而在Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.</p>\n<p>由于列表对象的有序且不可重复的特性，它比较适合用来做文章、商品等列表的存储。</p>\n<p>列表类型可以 lpush (左侧push)，同时又可以使用 rpop (右侧弹出)（查询并删除）第一个元素，所以列表类型具有先进先出的特性，可以用来实现消息队列。也可以lpush(左侧push)-&gt;lpop(左侧弹出)，具有后进先出的特性，因此开发中需要使用栈的时候，我们也可以借助列表对象来实现。<br>有关Redis列表对象的更详细的介绍，可以查看我的这篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8(List\">Redis对象——列表(List)</a>/)</p>\n<h3 id=\"四、集合-标签系统我在行\"><a href=\"#四、集合-标签系统我在行\" class=\"headerlink\" title=\"四、集合(标签系统我在行)\"></a>四、集合(标签系统我在行)</h3><p>集合对象 (Set) 是一个无序并唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储。与列表所不同的是它存储的数据是无序且不重复的。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88.png\" alt></p>\n<p>集合对象的内部编码也有两种：intset(整数集合)与hashtable(哈希表)。当满足下面两个条件的时候集合对象使用intset来实现。</p>\n<ul>\n<li>集合中的元素都是整数</li>\n<li>集合中的元素个数小于set-maxintset-entries配置（默认512个）</li>\n</ul>\n<p>不满足上面两个条件时集合对象使用hashtable来实现。</p>\n<p>集合对象的主要几个特性就是，无序、不可重复、支持并交差，因此可以用来做标签系统。</p>\n<p>而集合的 <a href=\"https://blog.laoyu.site/2020/redis_command/set/spop/\">SPOP(随机移除并返回集合中一个或多个元素)</a> 和 <a href=\"https://blog.laoyu.site/2020/redis_command/set/srandmember/\">SRANDMEMBER(随机返回集合中一个或多个元素)</a> 命令可以帮助我们实现一个抽奖系统。</p>\n<p>有关Redis集合对象的更详细的介绍，可以查看我的这篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E9%9B%86%E5%90%88(Set\">Redis对象——集合(Set)</a>/)</p>\n<h3 id=\"五、有序集合-排起名来我最棒\"><a href=\"#五、有序集合-排起名来我最棒\" class=\"headerlink\" title=\"五、有序集合(排起名来我最棒)\"></a>五、有序集合(排起名来我最棒)</h3><p>有序集合类型 (Sorted Set或ZSet) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88.png\" alt></p>\n<p>有序集合是由 <a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">ziplist (压缩列表)</a> 或 <a href=\"https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/\">skiplist (跳跃表)</a> 组成的。</p>\n<p>当数据比较少时，有序集合使用的是 ziplist 存储的，有序集合使用 ziplist 格式存储必须满足以下两个条件：</p>\n<ul>\n<li>有序集合保存的元素个数要小于 128 个；</li>\n<li>有序集合保存的所有元素成员的长度都必须小于 64 字节。</li>\n</ul>\n<p>如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。</p>\n<p>有序集合比较典型的使用场景就是排行榜系统例如学生成绩的排名。某视频(博客等)网站的用户点赞、播放排名、电商系统中商品的销量排名等</p>\n<p>有关Redis有序集合对象的更详细的介绍，可以查看我的这篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88(ZSet\">Redis对象——有序集合(ZSet)</a>/)</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>Redis提供了五种最基础也是最常用的对象(数据类型)：String、Hash、List、Set、ZSet。了解这五种对象的有助于我们更好的在日常开发中对Redis进行使用。而通过这篇文章我们可以看到每种对象都是通过多种数据结构来实现的，大家可以思考一下为什么。</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>","site":{"data":{}},"excerpt":"<p>Redis 是一个高性能的分布式内存型数据库，在国内外各大互联网公司中都有着广泛的使用，即使是一些非互联网公司中也有着非常重要的适用场景，所以对 Redis 的掌握也成为后端工程师必备的基础技能，在面试中，Redis早已成为老生常谈的话题，而在实际工作中，我们更是每时每刻都需要和 Redis 打交道。因此熟练的掌握Redis技术栈的各种武功秘籍至关重要！</p>","more":"<p>Redis提供了五种主要的对象(数据类型)供开发者使用，它提供了强大且实用的功能。然而实际开发中有大多数的开发者仅简单会用Redis String的Get与Set。这就好比降龙十八掌，你只学会了一掌。在真正实战对敌之时不免略显单薄！这篇文章我们将回顾Redis这五大对象，以便于我们能够在实战中真正做到游刃有余。</p>\n<h3 id=\"一、字符串-终究是我扛下了所有\"><a href=\"#一、字符串-终究是我扛下了所有\" class=\"headerlink\" title=\"一、字符串(终究是我扛下了所有)\"></a>一、字符串(终究是我扛下了所有)</h3><p>字符串类型是Redis最基础的数据结构，其他几种数据结构都是在字符串类型基础上构建的。字符串类型的值是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字（整数、浮点数），甚至是二进制（图片、音频、视频）等</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%AD%97%E7%AC%A6%E4%B8%B2/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2.png\" alt></p>\n<p>字符串对象的内部编码有3种 ：<code>int</code>、<code>raw</code>和<code>embstr</code>。Redis会根据当前值的类型和长度来决定使用哪种编码来实现。</p>\n<ul>\n<li>int:如果一个字符串对象保存的是整数值,并且这个整数值可以用<code>long</code>类型来表示</li>\n<li>raw:如果字符串对象保存的是一个字符串值,并且这个字符串值的长度大于32字节</li>\n<li>embstr:如果字符串对象保存的是一个字符串值,并且这个字符申值的长度小于等于32字节</li>\n</ul>\n<p>&nbsp;reids字符串的使用场景是最为广泛的，甚至有些对redis其它几种对象不太熟悉的人，基本所有场景都会使用字符串(序列化一下直接扔进去),这让本身很单纯的字符串承受了它这个年纪本不该承受的重量。其实Redis的主要使用场景主要有以下几种:</p>\n<ol>\n<li>作为缓存层,缓存热点数据</li>\n<li>Redis字符串可以自增自减的特性可以用来做计数器、限速器、自增ID生成等</li>\n<li>分布式系统的Session共享</li>\n<li>二进制数据的存储</li>\n</ol>\n<p>有关Redis字符串的更详细的介绍，可以查看我的这篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2019/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2(String\">Redis对象——字符串(String)</a>/)</p>\n<h3 id=\"二、哈希-存储对象我也行\"><a href=\"#二、哈希-存储对象我也行\" class=\"headerlink\" title=\"二、哈希(存储对象我也行)\"></a>二、哈希(存储对象我也行)</h3><p>哈希对象用来存储一组数据对。每个数据对又包含键值两部分。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%93%88%E5%B8%8C/Redis-Hash.png\" alt=\"Redis-Hash\"></p>\n<p>哈希对象也有两种实现方式。<a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">ziplist(压缩列表)</a>,<a href=\"http://blog.laoyu.site/2018/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/\">hashtable(哈希表)</a></p>\n<p>同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现哈希对象。具体需要满足两个条件：</p>\n<ul>\n<li>字典中保存的键和值的大小都要小于 64 字节；</li>\n<li>字典中键值对的个数要小于 512 个。</li>\n</ul>\n<p>当不能同时满足上面两个条件的时候，Redis 就使用哈希表来实现哈希对象。</p>\n<p>当存储的内容是对象的时候，Redis 字符串对象的很多功能使用Redis 哈希对象也可以实现。如缓存用户信息的时候，使用Redis哈希对象存储，简单直观，如果使用合理可以减少内存空间的使用。但也有其缺点，就是要要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</p>\n<p>此外，Redis 哈希对象还可以实现购物车、计数器等功能。</p>\n<p>有关Redis哈希对象的更详细的介绍，可以查看我的这篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C(Hash\">Redis对象——哈希(Hash)</a>/)</p>\n<h3 id=\"三、列表-栈和队列我都行\"><a href=\"#三、列表-栈和队列我都行\" class=\"headerlink\" title=\"三、列表(栈和队列我都行)\"></a>三、列表(栈和队列我都行)</h3><p>列表这种对象支持存储一组有序的、不重复的数据。因为其有序性，它可以获取指定范围的元素列表、可以在O(1)的时间复杂度获取指定索引下标的元素等。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E5%88%97%E8%A1%A8/Redis%20List.png\" alt></p>\n<p>在Redis3.2版本以前列表类型的内部编码有两种。当满足下面两个条件的时候，Redis 列表对象使用ziplist（压缩列表）来实现。</p>\n<ul>\n<li><p>当列表的元素个数小于list-max-ziplist-entries配置（默认512个）</p>\n</li>\n<li><p>当列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节）</p>\n</li>\n</ul>\n<p>当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</p>\n<p>而在Redis3.2版本开始对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist.</p>\n<p>由于列表对象的有序且不可重复的特性，它比较适合用来做文章、商品等列表的存储。</p>\n<p>列表类型可以 lpush (左侧push)，同时又可以使用 rpop (右侧弹出)（查询并删除）第一个元素，所以列表类型具有先进先出的特性，可以用来实现消息队列。也可以lpush(左侧push)-&gt;lpop(左侧弹出)，具有后进先出的特性，因此开发中需要使用栈的时候，我们也可以借助列表对象来实现。<br>有关Redis列表对象的更详细的介绍，可以查看我的这篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8(List\">Redis对象——列表(List)</a>/)</p>\n<h3 id=\"四、集合-标签系统我在行\"><a href=\"#四、集合-标签系统我在行\" class=\"headerlink\" title=\"四、集合(标签系统我在行)\"></a>四、集合(标签系统我在行)</h3><p>集合对象 (Set) 是一个无序并唯一的键值集合。它的存储顺序不会按照插入的先后顺序进行存储。与列表所不同的是它存储的数据是无序且不重复的。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88.png\" alt></p>\n<p>集合对象的内部编码也有两种：intset(整数集合)与hashtable(哈希表)。当满足下面两个条件的时候集合对象使用intset来实现。</p>\n<ul>\n<li>集合中的元素都是整数</li>\n<li>集合中的元素个数小于set-maxintset-entries配置（默认512个）</li>\n</ul>\n<p>不满足上面两个条件时集合对象使用hashtable来实现。</p>\n<p>集合对象的主要几个特性就是，无序、不可重复、支持并交差，因此可以用来做标签系统。</p>\n<p>而集合的 <a href=\"https://blog.laoyu.site/2020/redis_command/set/spop/\">SPOP(随机移除并返回集合中一个或多个元素)</a> 和 <a href=\"https://blog.laoyu.site/2020/redis_command/set/srandmember/\">SRANDMEMBER(随机返回集合中一个或多个元素)</a> 命令可以帮助我们实现一个抽奖系统。</p>\n<p>有关Redis集合对象的更详细的介绍，可以查看我的这篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E9%9B%86%E5%90%88(Set\">Redis对象——集合(Set)</a>/)</p>\n<h3 id=\"五、有序集合-排起名来我最棒\"><a href=\"#五、有序集合-排起名来我最棒\" class=\"headerlink\" title=\"五、有序集合(排起名来我最棒)\"></a>五、有序集合(排起名来我最棒)</h3><p>有序集合类型 (Sorted Set或ZSet) 相比于集合类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/%E5%AF%B9%E8%B1%A1%E7%AF%87/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88.png\" alt></p>\n<p>有序集合是由 <a href=\"http://blog.laoyu.site/2019/redis/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/\">ziplist (压缩列表)</a> 或 <a href=\"https://blog.laoyu.site/2019/redis/Redi%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/\">skiplist (跳跃表)</a> 组成的。</p>\n<p>当数据比较少时，有序集合使用的是 ziplist 存储的，有序集合使用 ziplist 格式存储必须满足以下两个条件：</p>\n<ul>\n<li>有序集合保存的元素个数要小于 128 个；</li>\n<li>有序集合保存的所有元素成员的长度都必须小于 64 字节。</li>\n</ul>\n<p>如果不能满足以上两个条件中的任意一个，有序集合将会使用 skiplist 结构进行存储。</p>\n<p>有序集合比较典型的使用场景就是排行榜系统例如学生成绩的排名。某视频(博客等)网站的用户点赞、播放排名、电商系统中商品的销量排名等</p>\n<p>有关Redis有序集合对象的更详细的介绍，可以查看我的这篇文章。</p>\n<p><a href=\"https://blog.laoyu.site/2020/redis/Redis%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88(ZSet\">Redis对象——有序集合(ZSet)</a>/)</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>Redis提供了五种最基础也是最常用的对象(数据类型)：String、Hash、List、Set、ZSet。了解这五种对象的有助于我们更好的在日常开发中对Redis进行使用。而通过这篇文章我们可以看到每种对象都是通过多种数据结构来实现的，大家可以思考一下为什么。</p>\n<h3 id=\"——-END——\"><a href=\"#——-END——\" class=\"headerlink\" title=\"——-END——-\"></a>——-END——-</h3>"},{"title":"Spring Boot(四) Mybatis-MySql","copyright":true,"date":"2020-03-20T10:23:18.000Z","keywords":"Spring Boot","aside":"SpringBoot","_content":"### 0.准备数据库表\n\n<!--more-->\n\n```mysql\n\n-- ----------------------------\n-- Table structure for person\n-- ----------------------------\nDROP TABLE IF EXISTS `person`;\nCREATE TABLE `person` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) NOT NULL,\n  `age` int(11) DEFAULT NULL,\n  `gender` char(255) DEFAULT NULL,\n  `remark` varchar(200) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n-- ----------------------------\n-- Records of person\n-- ----------------------------\nINSERT INTO `person` VALUES ('1', '法师', '25', '男', null);\nINSERT INTO `person` VALUES ('2', '锤子', '28', '男', null);\nINSERT INTO `person` VALUES ('3', '土豆', '18', '女', null);\nINSERT INTO `person` VALUES ('4', '甜心', '19', '女', null);\n```\n\n### 一.pom.xml文件添加maven依赖\n\n```xml\n \t    <!--mybatis-->\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.17</version>\n        </dependency>\n        <!--集成druid，使用连接池-->\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.1.0</version>\n        </dependency>\n    \n```\n\n注意：[druid](https://druid.apache.org/)是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是“目前最好的连接池”。\n\n### 二.修改配置文件`application.properties`\n\n```java\nserver.port=9997\n# 数据库连接配置\nspring.datasource.name=spring-boot-mybatis-mysql\nspring.datasource.url=jdbc:mysql://47.105.66.132:3307/demo\nspring.datasource.username=root\nspring.datasource.password=xingying\n# mybatis 配置\nmybatis.mapper-locations=classpath:mapping/*.xml\nmybatis.type-aliases-package=spring.boot.mybatis.mysql.model\n# 使用druid数据源\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n\n```\n\n### 三.MyBatis配置\n\n1. 在resources目录下面新建2个目录：generator和mapping，用于存放mybatis的配置文件和映射文件\n\n2. 在包`spring.boot.mybatis.mysql`下新建包mapper和model，用于存放mybatis生成的代码\n\n3. 在generator目录下，新建文件generatorConfig.xml，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n<generatorConfiguration>\n    <!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包-->\n    <classPathEntry  location=\"D:\\Software\\apache-maven-3.6.0-bin\\repository\\mysql\\mysql-connector-java\\8.0.17\\mysql-connector-java-8.0.17.jar\"/>\n    <context id=\"DB2Tables\"  targetRuntime=\"MyBatis3\">\n        <commentGenerator>\n            <property name=\"suppressDate\" value=\"true\"/>\n            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->\n            <property name=\"suppressAllComments\" value=\"true\"/>\n        </commentGenerator>\n        <!--数据库链接URL，用户名、密码 -->\n        <jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://127.0.0.1:3306/demo\" userId=\"root\" password=\"xingying\">\n        </jdbcConnection>\n        <javaTypeResolver>\n            <property name=\"forceBigDecimals\" value=\"false\"/>\n        </javaTypeResolver>\n        <!-- 生成模型的包名和位置-->\n        <javaModelGenerator targetPackage=\"spring.boot.mybatis.mysql.model\" targetProject=\"src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n            <property name=\"trimStrings\" value=\"true\"/>\n        </javaModelGenerator>\n        <!-- 生成映射文件的包名和位置-->\n        <sqlMapGenerator targetPackage=\"mapping\" targetProject=\"src/main/resources\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </sqlMapGenerator>\n        <!-- 生成DAO的包名和位置-->\n        <javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"spring.boot.mybatis.mysql.mapper\" targetProject=\"src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </javaClientGenerator>\n        <!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名-->\n        <table tableName=\"person\" domainObjectName=\"Person\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" selectByExampleQueryId=\"false\"></table>\n    </context>\n</generatorConfiguration>修改pom添加mybatis的maven插件\n```\n\n```xml\n  <!-- mybatis generator 自动生成代码插件 -->\n            <plugin>\n                <groupId>org.mybatis.generator</groupId>\n                <artifactId>mybatis-generator-maven-plugin</artifactId>\n                <version>1.3.2</version>\n                <configuration>\n                    <configurationFile>                        \t\t\t\t  \t ${basedir}/src/main/resources/generator/generatorConfig.xml\n                    </configurationFile>\n                    <overwrite>true</overwrite>\n                    <verbose>true</verbose>\n                </configuration>\n            </plugin>\n```\n\n4. 添加并导入包后打开View->Tool Windows->Maven Projects可看到如下插件\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/1.png)\n\n5. 双击运行，运行完后项目目录将会自动生成如下几个文件：\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/2.png)\n\n6. 打开`PersonMapper.xml`就是Mybatis的映射文件，里面的内容其实就是Sql。\n\n   **注意：使用这个插件的时候,生成的的映射文件可能会有多个ResultMap，导致启动的时候会报错**\n\n   `Result Maps collection already contains value for...`\n\n   这是因为数据库中可能有多个schema中都有同样名字的一张表。这个时候简单的办法就是打开这个文件删除掉多余的配置即可。\n\n   打开`PersonMapper`\n\n```java\n//自动生成的没有下面这个注解，如果在依赖注入的时候报错，记得加上这个注解\n//@Component\npublic interface PersonMapper {\n    int deleteByPrimaryKey(Integer id);\n\n    int insert(Person record);\n\n    int insertSelective(Person record);\n\n    Person selectByPrimaryKey(Integer id);\n\n    int updateByPrimaryKeySelective(Person record);\n\n    int updateByPrimaryKey(Person record);\n}\n```\n\n7. 添加我们的service和controller\n\n```java\n/*\nService 接口\n */\npublic interface IPerson {\n    int deleteByPrimaryKey(Integer id);\n\n    int insert(Person record);\n\n    int insertSelective(Person record);\n\n    Person selectByPrimaryKey(Integer id);\n\n    int updateByPrimaryKeySelective(Person record);\n\n    int updateByPrimaryKey(Person record);\n}\n\n/*\nPerson Service\n */\n@Service\npublic class PersonImpl implements IPerson {\n\n    /*\n    注入 personMapper\n     */\n    @Autowired\n    private PersonMapper personMapper;\n\n    @Override\n    public int deleteByPrimaryKey(Integer id) {\n        return personMapper.deleteByPrimaryKey(id);\n    }\n\n    @Override\n    public int insert(Person record) {\n        return personMapper.insert(record);\n    }\n\n    @Override\n    public int insertSelective(Person record) {\n        return personMapper.insertSelective(record);\n    }\n\n    @Override\n    public Person selectByPrimaryKey(Integer id) {\n        return personMapper.selectByPrimaryKey(id);\n    }\n\n    @Override\n    public int updateByPrimaryKeySelective(Person record) {\n        return personMapper.updateByPrimaryKeySelective(record);\n    }\n\n    @Override\n    public int updateByPrimaryKey(Person record) {\n        return personMapper.updateByPrimaryKey(record);\n    }\n}\n\n@RestController\n@RequestMapping(\"/person\")\npublic class PersonController {\n\n    @Autowired\n    public IPerson person;\n\n    @RequestMapping(method = RequestMethod.GET)\n    public Person get(@RequestParam Integer id) {\n        return person.selectByPrimaryKey(id);\n    }\n}\n```\n\n注意：如果personMapper下方红线报错，是因为PersonMapper没有配置依赖注入扫描注解，可在类上方增加`@Component`注解。当然也可以修改idea的错误提示，降低Autowired检测的级别，将Severity的级别由之前的error改成warning或其它可以忽略的级别。\n\n8. 启动类新增注解`@MapperScan(\"spring.boot.mybatis.mysql.mapper\")`\n\n9. 测试运行\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/3.png)\n\n### 四、更优雅的方式\n\n&nbsp;&nbsp;&nbsp;&nbsp;通过上面的过程，可以发现又出现了一系列的配置文件，如果我们想更优雅一点的编码，Mybatis为此也提供了，不需要配置文件的方式。注意，是更优雅一些不是更好一些，至于哪种方式更好要结合实际。\n\n只需要在`PersonMapper`接口的方法上添加相应的SQL注解即可\n\n```java\npackage spring.boot.mybatis.mysql.annotate.mapper;\n\nimport org.apache.ibatis.annotations.*;\nimport org.springframework.stereotype.Component;\nimport spring.boot.mybatis.mysql.annotate.model.Person;\n\n@Component\npublic interface PersonMapper {\n\n    @Delete(\"DELETE FROM person WHERE id =#{id}\")\n    int deleteByPrimaryKey(Integer id);\n\n    @Insert(\"INSERT INTO person(name,age,gender,remark) VALUES(#{name}, #{age}, #{gender},#{remark})\")\n    int insert(Person record);\n\n    @Select(\"SELECT * FROM person WHERE id = #{id}\")\n    @Results({\n            @Result(property = \"id\",  column = \"id\"),\n            @Result(property = \"name\", column = \"name\"),\n            @Result(property = \"age\", column = \"age\"),\n            @Result(property = \"gender\", column = \"gender\"),\n            @Result(property = \"remark\", column = \"remark\")\n    })\n    Person selectByPrimaryKey(Integer id);\n\n    @Update(\"UPDATE person SET name=#{name},age=#{age} WHERE id =#{id}\")\n    int updateByPrimaryKey(Person record);\n}\n\n```\n\n- @Select 是查询类的注解，所有的查询均使用这个\n- @Result 修饰返回的结果集，关联实体类属性和数据库字段一一对应，如果实体类属性和数据库属性名保持一致，就不需要这个属性来修饰。\n- @Insert 插入数据库使用，直接传入实体类会自动解析属性到对应的值\n- @Update 负责修改，也可以直接传入对象\n- @delete 负责删除\n\n想要了解更多特性，可以参考[Mybatis官网](https://mybatis.org/mybatis-3/zh/java-api.html)\n\n### 五、踩坑记\n\n1. Service中注入personMapper报错\n\n   PersonMapper类上加注解`@Component`\n\n2. 启动的时候报错\n\n   `Result Maps collection already contains value for...`\n\n   这是因为数据库中可能有多个schema中都有同样名字的一张表。这个时候简单的办法就是打开这个文件删除掉多余的配置即可。\n\n\n\n**[示例代码](https://github.com/hunter-droid/spring-boot-examples)**","source":"_posts/技术实践/spring-boot/Spring Boot(四) Mybatis-MySql.md","raw":"---\ntitle: Spring Boot(四) Mybatis-MySql\ncopyright: true\ndate: 2020-03-20 18:23:18\ncategories: \n- Spring Boot\nkeywords: Spring Boot\naside: SpringBoot\n---\n### 0.准备数据库表\n\n<!--more-->\n\n```mysql\n\n-- ----------------------------\n-- Table structure for person\n-- ----------------------------\nDROP TABLE IF EXISTS `person`;\nCREATE TABLE `person` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) NOT NULL,\n  `age` int(11) DEFAULT NULL,\n  `gender` char(255) DEFAULT NULL,\n  `remark` varchar(200) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n-- ----------------------------\n-- Records of person\n-- ----------------------------\nINSERT INTO `person` VALUES ('1', '法师', '25', '男', null);\nINSERT INTO `person` VALUES ('2', '锤子', '28', '男', null);\nINSERT INTO `person` VALUES ('3', '土豆', '18', '女', null);\nINSERT INTO `person` VALUES ('4', '甜心', '19', '女', null);\n```\n\n### 一.pom.xml文件添加maven依赖\n\n```xml\n \t    <!--mybatis-->\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.17</version>\n        </dependency>\n        <!--集成druid，使用连接池-->\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.1.0</version>\n        </dependency>\n    \n```\n\n注意：[druid](https://druid.apache.org/)是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是“目前最好的连接池”。\n\n### 二.修改配置文件`application.properties`\n\n```java\nserver.port=9997\n# 数据库连接配置\nspring.datasource.name=spring-boot-mybatis-mysql\nspring.datasource.url=jdbc:mysql://47.105.66.132:3307/demo\nspring.datasource.username=root\nspring.datasource.password=xingying\n# mybatis 配置\nmybatis.mapper-locations=classpath:mapping/*.xml\nmybatis.type-aliases-package=spring.boot.mybatis.mysql.model\n# 使用druid数据源\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n\n```\n\n### 三.MyBatis配置\n\n1. 在resources目录下面新建2个目录：generator和mapping，用于存放mybatis的配置文件和映射文件\n\n2. 在包`spring.boot.mybatis.mysql`下新建包mapper和model，用于存放mybatis生成的代码\n\n3. 在generator目录下，新建文件generatorConfig.xml，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n<generatorConfiguration>\n    <!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包-->\n    <classPathEntry  location=\"D:\\Software\\apache-maven-3.6.0-bin\\repository\\mysql\\mysql-connector-java\\8.0.17\\mysql-connector-java-8.0.17.jar\"/>\n    <context id=\"DB2Tables\"  targetRuntime=\"MyBatis3\">\n        <commentGenerator>\n            <property name=\"suppressDate\" value=\"true\"/>\n            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->\n            <property name=\"suppressAllComments\" value=\"true\"/>\n        </commentGenerator>\n        <!--数据库链接URL，用户名、密码 -->\n        <jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://127.0.0.1:3306/demo\" userId=\"root\" password=\"xingying\">\n        </jdbcConnection>\n        <javaTypeResolver>\n            <property name=\"forceBigDecimals\" value=\"false\"/>\n        </javaTypeResolver>\n        <!-- 生成模型的包名和位置-->\n        <javaModelGenerator targetPackage=\"spring.boot.mybatis.mysql.model\" targetProject=\"src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n            <property name=\"trimStrings\" value=\"true\"/>\n        </javaModelGenerator>\n        <!-- 生成映射文件的包名和位置-->\n        <sqlMapGenerator targetPackage=\"mapping\" targetProject=\"src/main/resources\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </sqlMapGenerator>\n        <!-- 生成DAO的包名和位置-->\n        <javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"spring.boot.mybatis.mysql.mapper\" targetProject=\"src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </javaClientGenerator>\n        <!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名-->\n        <table tableName=\"person\" domainObjectName=\"Person\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" selectByExampleQueryId=\"false\"></table>\n    </context>\n</generatorConfiguration>修改pom添加mybatis的maven插件\n```\n\n```xml\n  <!-- mybatis generator 自动生成代码插件 -->\n            <plugin>\n                <groupId>org.mybatis.generator</groupId>\n                <artifactId>mybatis-generator-maven-plugin</artifactId>\n                <version>1.3.2</version>\n                <configuration>\n                    <configurationFile>                        \t\t\t\t  \t ${basedir}/src/main/resources/generator/generatorConfig.xml\n                    </configurationFile>\n                    <overwrite>true</overwrite>\n                    <verbose>true</verbose>\n                </configuration>\n            </plugin>\n```\n\n4. 添加并导入包后打开View->Tool Windows->Maven Projects可看到如下插件\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/1.png)\n\n5. 双击运行，运行完后项目目录将会自动生成如下几个文件：\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/2.png)\n\n6. 打开`PersonMapper.xml`就是Mybatis的映射文件，里面的内容其实就是Sql。\n\n   **注意：使用这个插件的时候,生成的的映射文件可能会有多个ResultMap，导致启动的时候会报错**\n\n   `Result Maps collection already contains value for...`\n\n   这是因为数据库中可能有多个schema中都有同样名字的一张表。这个时候简单的办法就是打开这个文件删除掉多余的配置即可。\n\n   打开`PersonMapper`\n\n```java\n//自动生成的没有下面这个注解，如果在依赖注入的时候报错，记得加上这个注解\n//@Component\npublic interface PersonMapper {\n    int deleteByPrimaryKey(Integer id);\n\n    int insert(Person record);\n\n    int insertSelective(Person record);\n\n    Person selectByPrimaryKey(Integer id);\n\n    int updateByPrimaryKeySelective(Person record);\n\n    int updateByPrimaryKey(Person record);\n}\n```\n\n7. 添加我们的service和controller\n\n```java\n/*\nService 接口\n */\npublic interface IPerson {\n    int deleteByPrimaryKey(Integer id);\n\n    int insert(Person record);\n\n    int insertSelective(Person record);\n\n    Person selectByPrimaryKey(Integer id);\n\n    int updateByPrimaryKeySelective(Person record);\n\n    int updateByPrimaryKey(Person record);\n}\n\n/*\nPerson Service\n */\n@Service\npublic class PersonImpl implements IPerson {\n\n    /*\n    注入 personMapper\n     */\n    @Autowired\n    private PersonMapper personMapper;\n\n    @Override\n    public int deleteByPrimaryKey(Integer id) {\n        return personMapper.deleteByPrimaryKey(id);\n    }\n\n    @Override\n    public int insert(Person record) {\n        return personMapper.insert(record);\n    }\n\n    @Override\n    public int insertSelective(Person record) {\n        return personMapper.insertSelective(record);\n    }\n\n    @Override\n    public Person selectByPrimaryKey(Integer id) {\n        return personMapper.selectByPrimaryKey(id);\n    }\n\n    @Override\n    public int updateByPrimaryKeySelective(Person record) {\n        return personMapper.updateByPrimaryKeySelective(record);\n    }\n\n    @Override\n    public int updateByPrimaryKey(Person record) {\n        return personMapper.updateByPrimaryKey(record);\n    }\n}\n\n@RestController\n@RequestMapping(\"/person\")\npublic class PersonController {\n\n    @Autowired\n    public IPerson person;\n\n    @RequestMapping(method = RequestMethod.GET)\n    public Person get(@RequestParam Integer id) {\n        return person.selectByPrimaryKey(id);\n    }\n}\n```\n\n注意：如果personMapper下方红线报错，是因为PersonMapper没有配置依赖注入扫描注解，可在类上方增加`@Component`注解。当然也可以修改idea的错误提示，降低Autowired检测的级别，将Severity的级别由之前的error改成warning或其它可以忽略的级别。\n\n8. 启动类新增注解`@MapperScan(\"spring.boot.mybatis.mysql.mapper\")`\n\n9. 测试运行\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/3.png)\n\n### 四、更优雅的方式\n\n&nbsp;&nbsp;&nbsp;&nbsp;通过上面的过程，可以发现又出现了一系列的配置文件，如果我们想更优雅一点的编码，Mybatis为此也提供了，不需要配置文件的方式。注意，是更优雅一些不是更好一些，至于哪种方式更好要结合实际。\n\n只需要在`PersonMapper`接口的方法上添加相应的SQL注解即可\n\n```java\npackage spring.boot.mybatis.mysql.annotate.mapper;\n\nimport org.apache.ibatis.annotations.*;\nimport org.springframework.stereotype.Component;\nimport spring.boot.mybatis.mysql.annotate.model.Person;\n\n@Component\npublic interface PersonMapper {\n\n    @Delete(\"DELETE FROM person WHERE id =#{id}\")\n    int deleteByPrimaryKey(Integer id);\n\n    @Insert(\"INSERT INTO person(name,age,gender,remark) VALUES(#{name}, #{age}, #{gender},#{remark})\")\n    int insert(Person record);\n\n    @Select(\"SELECT * FROM person WHERE id = #{id}\")\n    @Results({\n            @Result(property = \"id\",  column = \"id\"),\n            @Result(property = \"name\", column = \"name\"),\n            @Result(property = \"age\", column = \"age\"),\n            @Result(property = \"gender\", column = \"gender\"),\n            @Result(property = \"remark\", column = \"remark\")\n    })\n    Person selectByPrimaryKey(Integer id);\n\n    @Update(\"UPDATE person SET name=#{name},age=#{age} WHERE id =#{id}\")\n    int updateByPrimaryKey(Person record);\n}\n\n```\n\n- @Select 是查询类的注解，所有的查询均使用这个\n- @Result 修饰返回的结果集，关联实体类属性和数据库字段一一对应，如果实体类属性和数据库属性名保持一致，就不需要这个属性来修饰。\n- @Insert 插入数据库使用，直接传入实体类会自动解析属性到对应的值\n- @Update 负责修改，也可以直接传入对象\n- @delete 负责删除\n\n想要了解更多特性，可以参考[Mybatis官网](https://mybatis.org/mybatis-3/zh/java-api.html)\n\n### 五、踩坑记\n\n1. Service中注入personMapper报错\n\n   PersonMapper类上加注解`@Component`\n\n2. 启动的时候报错\n\n   `Result Maps collection already contains value for...`\n\n   这是因为数据库中可能有多个schema中都有同样名字的一张表。这个时候简单的办法就是打开这个文件删除掉多余的配置即可。\n\n\n\n**[示例代码](https://github.com/hunter-droid/spring-boot-examples)**","slug":"技术实践/spring-boot/Spring Boot(四) Mybatis-MySql","published":1,"updated":"2021-03-14T03:04:50.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzu00ezhyjflane9jw0","content":"<h3 id=\"0-准备数据库表\"><a href=\"#0-准备数据库表\" class=\"headerlink\" title=\"0.准备数据库表\"></a>0.准备数据库表</h3><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">-- Table structure for person</span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">DROP TABLE IF EXISTS `person`;</span><br><span class=\"line\">CREATE TABLE `person` (</span><br><span class=\"line\">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  `name` varchar(20) NOT NULL,</span><br><span class=\"line\">  `age` int(11) DEFAULT NULL,</span><br><span class=\"line\">  `gender` char(255) DEFAULT NULL,</span><br><span class=\"line\">  `remark` varchar(200) DEFAULT NULL,</span><br><span class=\"line\">  PRIMARY KEY (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</span><br><span class=\"line\"></span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">-- Records of person</span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">INSERT INTO `person` VALUES (&apos;1&apos;, &apos;法师&apos;, &apos;25&apos;, &apos;男&apos;, null);</span><br><span class=\"line\">INSERT INTO `person` VALUES (&apos;2&apos;, &apos;锤子&apos;, &apos;28&apos;, &apos;男&apos;, null);</span><br><span class=\"line\">INSERT INTO `person` VALUES (&apos;3&apos;, &apos;土豆&apos;, &apos;18&apos;, &apos;女&apos;, null);</span><br><span class=\"line\">INSERT INTO `person` VALUES (&apos;4&apos;, &apos;甜心&apos;, &apos;19&apos;, &apos;女&apos;, null);</span><br></pre></td></tr></table></figure>\n<h3 id=\"一-pom-xml文件添加maven依赖\"><a href=\"#一-pom-xml文件添加maven依赖\" class=\"headerlink\" title=\"一.pom.xml文件添加maven依赖\"></a>一.pom.xml文件添加maven依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--mybatis--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.spring.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>8.0.17<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--集成druid，使用连接池--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>druid<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>注意：<a href=\"https://druid.apache.org/\" target=\"_blank\" rel=\"noopener\">druid</a>是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是“目前最好的连接池”。</p>\n<h3 id=\"二-修改配置文件application-properties\"><a href=\"#二-修改配置文件application-properties\" class=\"headerlink\" title=\"二.修改配置文件application.properties\"></a>二.修改配置文件<code>application.properties</code></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">9997</span></span><br><span class=\"line\"># 数据库连接配置</span><br><span class=\"line\">spring.datasource.name=spring-boot-mybatis-mysql</span><br><span class=\"line\">spring.datasource.url=jdbc:mysql:<span class=\"comment\">//47.105.66.132:3307/demo</span></span><br><span class=\"line\">spring.datasource.username=root</span><br><span class=\"line\">spring.datasource.password=xingying</span><br><span class=\"line\"># mybatis 配置</span><br><span class=\"line\">mybatis.mapper-locations=classpath:mapping<span class=\"comment\">/*.xml</span></span><br><span class=\"line\"><span class=\"comment\">mybatis.type-aliases-package=spring.boot.mybatis.mysql.model</span></span><br><span class=\"line\"><span class=\"comment\"># 使用druid数据源</span></span><br><span class=\"line\"><span class=\"comment\">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\"><span class=\"comment\">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"三-MyBatis配置\"><a href=\"#三-MyBatis配置\" class=\"headerlink\" title=\"三.MyBatis配置\"></a>三.MyBatis配置</h3><ol>\n<li><p>在resources目录下面新建2个目录：generator和mapping，用于存放mybatis的配置文件和映射文件</p>\n</li>\n<li><p>在包<code>spring.boot.mybatis.mysql</code>下新建包mapper和model，用于存放mybatis生成的代码</p>\n</li>\n<li><p>在generator目录下，新建文件generatorConfig.xml，代码如下：</p>\n</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">generatorConfiguration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">classPathEntry</span>  <span class=\"attr\">location</span>=<span class=\"string\">\"D:\\Software\\apache-maven-3.6.0-bin\\repository\\mysql\\mysql-connector-java\\8.0.17\\mysql-connector-java-8.0.17.jar\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context</span> <span class=\"attr\">id</span>=<span class=\"string\">\"DB2Tables\"</span>  <span class=\"attr\">targetRuntime</span>=<span class=\"string\">\"MyBatis3\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">commentGenerator</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suppressDate\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suppressAllComments\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">commentGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--数据库链接URL，用户名、密码 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">jdbcConnection</span> <span class=\"attr\">driverClass</span>=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span> <span class=\"attr\">connectionURL</span>=<span class=\"string\">\"jdbc:mysql://127.0.0.1:3306/demo\"</span> <span class=\"attr\">userId</span>=<span class=\"string\">\"root\"</span> <span class=\"attr\">password</span>=<span class=\"string\">\"xingying\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">jdbcConnection</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaTypeResolver</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"forceBigDecimals\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaTypeResolver</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 生成模型的包名和位置--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaModelGenerator</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"spring.boot.mybatis.mysql.model\"</span> <span class=\"attr\">targetProject</span>=<span class=\"string\">\"src/main/java\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"trimStrings\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaModelGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 生成映射文件的包名和位置--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sqlMapGenerator</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"mapping\"</span> <span class=\"attr\">targetProject</span>=<span class=\"string\">\"src/main/resources\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">sqlMapGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 生成DAO的包名和位置--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaClientGenerator</span> <span class=\"attr\">type</span>=<span class=\"string\">\"XMLMAPPER\"</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"spring.boot.mybatis.mysql.mapper\"</span> <span class=\"attr\">targetProject</span>=<span class=\"string\">\"src/main/java\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaClientGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"person\"</span> <span class=\"attr\">domainObjectName</span>=<span class=\"string\">\"Person\"</span> <span class=\"attr\">enableCountByExample</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">enableUpdateByExample</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">enableDeleteByExample</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">enableSelectByExample</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">selectByExampleQueryId</span>=<span class=\"string\">\"false\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">generatorConfiguration</span>&gt;</span>修改pom添加mybatis的maven插件</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- mybatis generator 自动生成代码插件 --&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.generator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">configurationFile</span>&gt;</span>                        \t\t\t\t  \t $&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml</span><br><span class=\"line\">                  <span class=\"tag\">&lt;/<span class=\"name\">configurationFile</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">overwrite</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">overwrite</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>添加并导入包后打开View-&gt;Tool Windows-&gt;Maven Projects可看到如下插件</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/1.png\" alt></p>\n<ol>\n<li>双击运行，运行完后项目目录将会自动生成如下几个文件：</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/2.png\" alt></p>\n<ol>\n<li><p>打开<code>PersonMapper.xml</code>就是Mybatis的映射文件，里面的内容其实就是Sql。</p>\n<p><strong>注意：使用这个插件的时候,生成的的映射文件可能会有多个ResultMap，导致启动的时候会报错</strong></p>\n<p><code>Result Maps collection already contains value for...</code></p>\n<p>这是因为数据库中可能有多个schema中都有同样名字的一张表。这个时候简单的办法就是打开这个文件删除掉多余的配置即可。</p>\n<p>打开<code>PersonMapper</code></p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//自动生成的没有下面这个注解，如果在依赖注入的时候报错，记得加上这个注解</span></span><br><span class=\"line\"><span class=\"comment\">//@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonMapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insert</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insertSelective</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">selectByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKeySelective</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKey</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>添加我们的service和controller</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Service 接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IPerson</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insert</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insertSelective</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">selectByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKeySelective</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKey</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Person Service</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">IPerson</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    注入 personMapper</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PersonMapper personMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">deleteByPrimaryKey</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.deleteByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">insert</span><span class=\"params\">(Person record)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.insert(record);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">insertSelective</span><span class=\"params\">(Person record)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.insertSelective(record);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">selectByPrimaryKey</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.selectByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKeySelective</span><span class=\"params\">(Person record)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.updateByPrimaryKeySelective(record);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKey</span><span class=\"params\">(Person record)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.updateByPrimaryKey(record);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/person\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> IPerson person;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">get</span><span class=\"params\">(@RequestParam Integer id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> person.selectByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：如果personMapper下方红线报错，是因为PersonMapper没有配置依赖注入扫描注解，可在类上方增加<code>@Component</code>注解。当然也可以修改idea的错误提示，降低Autowired检测的级别，将Severity的级别由之前的error改成warning或其它可以忽略的级别。</p>\n<ol>\n<li><p>启动类新增注解<code>@MapperScan(&quot;spring.boot.mybatis.mysql.mapper&quot;)</code></p>\n</li>\n<li><p>测试运行</p>\n</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/3.png\" alt></p>\n<h3 id=\"四、更优雅的方式\"><a href=\"#四、更优雅的方式\" class=\"headerlink\" title=\"四、更优雅的方式\"></a>四、更优雅的方式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;通过上面的过程，可以发现又出现了一系列的配置文件，如果我们想更优雅一点的编码，Mybatis为此也提供了，不需要配置文件的方式。注意，是更优雅一些不是更好一些，至于哪种方式更好要结合实际。</p>\n<p>只需要在<code>PersonMapper</code>接口的方法上添加相应的SQL注解即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.mybatis.mysql.annotate.mapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.annotations.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"><span class=\"keyword\">import</span> spring.boot.mybatis.mysql.annotate.model.Person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Delete</span>(<span class=\"string\">\"DELETE FROM person WHERE id =#&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span>(<span class=\"string\">\"INSERT INTO person(name,age,gender,remark) VALUES(#&#123;name&#125;, #&#123;age&#125;, #&#123;gender&#125;,#&#123;remark&#125;)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insert</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Select</span>(<span class=\"string\">\"SELECT * FROM person WHERE id = #&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Results</span>(&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Result</span>(property = <span class=\"string\">\"id\"</span>,  column = <span class=\"string\">\"id\"</span>),</span><br><span class=\"line\">            <span class=\"meta\">@Result</span>(property = <span class=\"string\">\"name\"</span>, column = <span class=\"string\">\"name\"</span>),</span><br><span class=\"line\">            <span class=\"meta\">@Result</span>(property = <span class=\"string\">\"age\"</span>, column = <span class=\"string\">\"age\"</span>),</span><br><span class=\"line\">            <span class=\"meta\">@Result</span>(property = <span class=\"string\">\"gender\"</span>, column = <span class=\"string\">\"gender\"</span>),</span><br><span class=\"line\">            <span class=\"meta\">@Result</span>(property = <span class=\"string\">\"remark\"</span>, column = <span class=\"string\">\"remark\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">selectByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Update</span>(<span class=\"string\">\"UPDATE person SET name=#&#123;name&#125;,age=#&#123;age&#125; WHERE id =#&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKey</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@Select 是查询类的注解，所有的查询均使用这个</li>\n<li>@Result 修饰返回的结果集，关联实体类属性和数据库字段一一对应，如果实体类属性和数据库属性名保持一致，就不需要这个属性来修饰。</li>\n<li>@Insert 插入数据库使用，直接传入实体类会自动解析属性到对应的值</li>\n<li>@Update 负责修改，也可以直接传入对象</li>\n<li>@delete 负责删除</li>\n</ul>\n<p>想要了解更多特性，可以参考<a href=\"https://mybatis.org/mybatis-3/zh/java-api.html\" target=\"_blank\" rel=\"noopener\">Mybatis官网</a></p>\n<h3 id=\"五、踩坑记\"><a href=\"#五、踩坑记\" class=\"headerlink\" title=\"五、踩坑记\"></a>五、踩坑记</h3><ol>\n<li><p>Service中注入personMapper报错</p>\n<p>PersonMapper类上加注解<code>@Component</code></p>\n</li>\n<li><p>启动的时候报错</p>\n<p><code>Result Maps collection already contains value for...</code></p>\n<p>这是因为数据库中可能有多个schema中都有同样名字的一张表。这个时候简单的办法就是打开这个文件删除掉多余的配置即可。</p>\n</li>\n</ol>\n<p><strong><a href=\"https://github.com/hunter-droid/spring-boot-examples\" target=\"_blank\" rel=\"noopener\">示例代码</a></strong></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"0-准备数据库表\"><a href=\"#0-准备数据库表\" class=\"headerlink\" title=\"0.准备数据库表\"></a>0.准备数据库表</h3>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">-- Table structure for person</span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">DROP TABLE IF EXISTS `person`;</span><br><span class=\"line\">CREATE TABLE `person` (</span><br><span class=\"line\">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  `name` varchar(20) NOT NULL,</span><br><span class=\"line\">  `age` int(11) DEFAULT NULL,</span><br><span class=\"line\">  `gender` char(255) DEFAULT NULL,</span><br><span class=\"line\">  `remark` varchar(200) DEFAULT NULL,</span><br><span class=\"line\">  PRIMARY KEY (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</span><br><span class=\"line\"></span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">-- Records of person</span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">INSERT INTO `person` VALUES (&apos;1&apos;, &apos;法师&apos;, &apos;25&apos;, &apos;男&apos;, null);</span><br><span class=\"line\">INSERT INTO `person` VALUES (&apos;2&apos;, &apos;锤子&apos;, &apos;28&apos;, &apos;男&apos;, null);</span><br><span class=\"line\">INSERT INTO `person` VALUES (&apos;3&apos;, &apos;土豆&apos;, &apos;18&apos;, &apos;女&apos;, null);</span><br><span class=\"line\">INSERT INTO `person` VALUES (&apos;4&apos;, &apos;甜心&apos;, &apos;19&apos;, &apos;女&apos;, null);</span><br></pre></td></tr></table></figure>\n<h3 id=\"一-pom-xml文件添加maven依赖\"><a href=\"#一-pom-xml文件添加maven依赖\" class=\"headerlink\" title=\"一.pom.xml文件添加maven依赖\"></a>一.pom.xml文件添加maven依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--mybatis--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.spring.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>8.0.17<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--集成druid，使用连接池--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>druid<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>注意：<a href=\"https://druid.apache.org/\" target=\"_blank\" rel=\"noopener\">druid</a>是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是“目前最好的连接池”。</p>\n<h3 id=\"二-修改配置文件application-properties\"><a href=\"#二-修改配置文件application-properties\" class=\"headerlink\" title=\"二.修改配置文件application.properties\"></a>二.修改配置文件<code>application.properties</code></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">9997</span></span><br><span class=\"line\"># 数据库连接配置</span><br><span class=\"line\">spring.datasource.name=spring-boot-mybatis-mysql</span><br><span class=\"line\">spring.datasource.url=jdbc:mysql:<span class=\"comment\">//47.105.66.132:3307/demo</span></span><br><span class=\"line\">spring.datasource.username=root</span><br><span class=\"line\">spring.datasource.password=xingying</span><br><span class=\"line\"># mybatis 配置</span><br><span class=\"line\">mybatis.mapper-locations=classpath:mapping<span class=\"comment\">/*.xml</span></span><br><span class=\"line\"><span class=\"comment\">mybatis.type-aliases-package=spring.boot.mybatis.mysql.model</span></span><br><span class=\"line\"><span class=\"comment\"># 使用druid数据源</span></span><br><span class=\"line\"><span class=\"comment\">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span></span><br><span class=\"line\"><span class=\"comment\">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"三-MyBatis配置\"><a href=\"#三-MyBatis配置\" class=\"headerlink\" title=\"三.MyBatis配置\"></a>三.MyBatis配置</h3><ol>\n<li><p>在resources目录下面新建2个目录：generator和mapping，用于存放mybatis的配置文件和映射文件</p>\n</li>\n<li><p>在包<code>spring.boot.mybatis.mysql</code>下新建包mapper和model，用于存放mybatis生成的代码</p>\n</li>\n<li><p>在generator目录下，新建文件generatorConfig.xml，代码如下：</p>\n</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">generatorConfiguration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">classPathEntry</span>  <span class=\"attr\">location</span>=<span class=\"string\">\"D:\\Software\\apache-maven-3.6.0-bin\\repository\\mysql\\mysql-connector-java\\8.0.17\\mysql-connector-java-8.0.17.jar\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context</span> <span class=\"attr\">id</span>=<span class=\"string\">\"DB2Tables\"</span>  <span class=\"attr\">targetRuntime</span>=<span class=\"string\">\"MyBatis3\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">commentGenerator</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suppressDate\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suppressAllComments\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">commentGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--数据库链接URL，用户名、密码 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">jdbcConnection</span> <span class=\"attr\">driverClass</span>=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span> <span class=\"attr\">connectionURL</span>=<span class=\"string\">\"jdbc:mysql://127.0.0.1:3306/demo\"</span> <span class=\"attr\">userId</span>=<span class=\"string\">\"root\"</span> <span class=\"attr\">password</span>=<span class=\"string\">\"xingying\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">jdbcConnection</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaTypeResolver</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"forceBigDecimals\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaTypeResolver</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 生成模型的包名和位置--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaModelGenerator</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"spring.boot.mybatis.mysql.model\"</span> <span class=\"attr\">targetProject</span>=<span class=\"string\">\"src/main/java\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"trimStrings\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaModelGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 生成映射文件的包名和位置--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sqlMapGenerator</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"mapping\"</span> <span class=\"attr\">targetProject</span>=<span class=\"string\">\"src/main/resources\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">sqlMapGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 生成DAO的包名和位置--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaClientGenerator</span> <span class=\"attr\">type</span>=<span class=\"string\">\"XMLMAPPER\"</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"spring.boot.mybatis.mysql.mapper\"</span> <span class=\"attr\">targetProject</span>=<span class=\"string\">\"src/main/java\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaClientGenerator</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"person\"</span> <span class=\"attr\">domainObjectName</span>=<span class=\"string\">\"Person\"</span> <span class=\"attr\">enableCountByExample</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">enableUpdateByExample</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">enableDeleteByExample</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">enableSelectByExample</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">selectByExampleQueryId</span>=<span class=\"string\">\"false\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">generatorConfiguration</span>&gt;</span>修改pom添加mybatis的maven插件</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- mybatis generator 自动生成代码插件 --&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.generator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">configurationFile</span>&gt;</span>                        \t\t\t\t  \t $&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml</span><br><span class=\"line\">                  <span class=\"tag\">&lt;/<span class=\"name\">configurationFile</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">overwrite</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">overwrite</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>添加并导入包后打开View-&gt;Tool Windows-&gt;Maven Projects可看到如下插件</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/1.png\" alt></p>\n<ol>\n<li>双击运行，运行完后项目目录将会自动生成如下几个文件：</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/2.png\" alt></p>\n<ol>\n<li><p>打开<code>PersonMapper.xml</code>就是Mybatis的映射文件，里面的内容其实就是Sql。</p>\n<p><strong>注意：使用这个插件的时候,生成的的映射文件可能会有多个ResultMap，导致启动的时候会报错</strong></p>\n<p><code>Result Maps collection already contains value for...</code></p>\n<p>这是因为数据库中可能有多个schema中都有同样名字的一张表。这个时候简单的办法就是打开这个文件删除掉多余的配置即可。</p>\n<p>打开<code>PersonMapper</code></p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//自动生成的没有下面这个注解，如果在依赖注入的时候报错，记得加上这个注解</span></span><br><span class=\"line\"><span class=\"comment\">//@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonMapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insert</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insertSelective</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">selectByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKeySelective</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKey</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>添加我们的service和controller</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Service 接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IPerson</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insert</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insertSelective</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">selectByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKeySelective</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKey</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Person Service</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">IPerson</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    注入 personMapper</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PersonMapper personMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">deleteByPrimaryKey</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.deleteByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">insert</span><span class=\"params\">(Person record)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.insert(record);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">insertSelective</span><span class=\"params\">(Person record)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.insertSelective(record);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">selectByPrimaryKey</span><span class=\"params\">(Integer id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.selectByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKeySelective</span><span class=\"params\">(Person record)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.updateByPrimaryKeySelective(record);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKey</span><span class=\"params\">(Person record)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> personMapper.updateByPrimaryKey(record);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/person\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> IPerson person;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">get</span><span class=\"params\">(@RequestParam Integer id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> person.selectByPrimaryKey(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意：如果personMapper下方红线报错，是因为PersonMapper没有配置依赖注入扫描注解，可在类上方增加<code>@Component</code>注解。当然也可以修改idea的错误提示，降低Autowired检测的级别，将Severity的级别由之前的error改成warning或其它可以忽略的级别。</p>\n<ol>\n<li><p>启动类新增注解<code>@MapperScan(&quot;spring.boot.mybatis.mysql.mapper&quot;)</code></p>\n</li>\n<li><p>测试运行</p>\n</li>\n</ol>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/spring-boot/Spring%20Boot%28%E5%9B%9B%29%20Mybatis-MySql/3.png\" alt></p>\n<h3 id=\"四、更优雅的方式\"><a href=\"#四、更优雅的方式\" class=\"headerlink\" title=\"四、更优雅的方式\"></a>四、更优雅的方式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;通过上面的过程，可以发现又出现了一系列的配置文件，如果我们想更优雅一点的编码，Mybatis为此也提供了，不需要配置文件的方式。注意，是更优雅一些不是更好一些，至于哪种方式更好要结合实际。</p>\n<p>只需要在<code>PersonMapper</code>接口的方法上添加相应的SQL注解即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> spring.boot.mybatis.mysql.annotate.mapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.annotations.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"><span class=\"keyword\">import</span> spring.boot.mybatis.mysql.annotate.model.Person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PersonMapper</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Delete</span>(<span class=\"string\">\"DELETE FROM person WHERE id =#&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">deleteByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Insert</span>(<span class=\"string\">\"INSERT INTO person(name,age,gender,remark) VALUES(#&#123;name&#125;, #&#123;age&#125;, #&#123;gender&#125;,#&#123;remark&#125;)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">insert</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Select</span>(<span class=\"string\">\"SELECT * FROM person WHERE id = #&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Results</span>(&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Result</span>(property = <span class=\"string\">\"id\"</span>,  column = <span class=\"string\">\"id\"</span>),</span><br><span class=\"line\">            <span class=\"meta\">@Result</span>(property = <span class=\"string\">\"name\"</span>, column = <span class=\"string\">\"name\"</span>),</span><br><span class=\"line\">            <span class=\"meta\">@Result</span>(property = <span class=\"string\">\"age\"</span>, column = <span class=\"string\">\"age\"</span>),</span><br><span class=\"line\">            <span class=\"meta\">@Result</span>(property = <span class=\"string\">\"gender\"</span>, column = <span class=\"string\">\"gender\"</span>),</span><br><span class=\"line\">            <span class=\"meta\">@Result</span>(property = <span class=\"string\">\"remark\"</span>, column = <span class=\"string\">\"remark\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">selectByPrimaryKey</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Update</span>(<span class=\"string\">\"UPDATE person SET name=#&#123;name&#125;,age=#&#123;age&#125; WHERE id =#&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">updateByPrimaryKey</span><span class=\"params\">(Person record)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@Select 是查询类的注解，所有的查询均使用这个</li>\n<li>@Result 修饰返回的结果集，关联实体类属性和数据库字段一一对应，如果实体类属性和数据库属性名保持一致，就不需要这个属性来修饰。</li>\n<li>@Insert 插入数据库使用，直接传入实体类会自动解析属性到对应的值</li>\n<li>@Update 负责修改，也可以直接传入对象</li>\n<li>@delete 负责删除</li>\n</ul>\n<p>想要了解更多特性，可以参考<a href=\"https://mybatis.org/mybatis-3/zh/java-api.html\" target=\"_blank\" rel=\"noopener\">Mybatis官网</a></p>\n<h3 id=\"五、踩坑记\"><a href=\"#五、踩坑记\" class=\"headerlink\" title=\"五、踩坑记\"></a>五、踩坑记</h3><ol>\n<li><p>Service中注入personMapper报错</p>\n<p>PersonMapper类上加注解<code>@Component</code></p>\n</li>\n<li><p>启动的时候报错</p>\n<p><code>Result Maps collection already contains value for...</code></p>\n<p>这是因为数据库中可能有多个schema中都有同样名字的一张表。这个时候简单的办法就是打开这个文件删除掉多余的配置即可。</p>\n</li>\n</ol>\n<p><strong><a href=\"https://github.com/hunter-droid/spring-boot-examples\" target=\"_blank\" rel=\"noopener\">示例代码</a></strong></p>"},{"title":"恪尽职守，行分内之事——高质量代码","copyright":true,"date":"2021-01-07T05:29:26.000Z","keywords":"高质量代码","password":"1234qwer","aside":"Notes-LargeSite","_content":"# 恪尽职守，行分内之事——高质量代码\n\n### 为什么要写高质量代码\n恪尽职守，行分内之事，职场之中，各行各业，最重要的事情就是把分内之事最好。而程序员最重要的分内之事便是把代码写好，这也是我们的立身之本。正如字如其人，一个人的代码也是最能诠释一个程序员的名片。\n<!--more-->\n我见过许多工作不久的程序员，就早已不再满足于简单的CRUD，而开始追求所谓高大上的技术，也见过许多工作年限很久的程序员却仍然写着“十年如一日”的代码。由于近些年互联网公司的崛起，越来越多的人崇尚着高并发、大流量，迫不及待的去学习一些最新最时髦的技术，而对于一些编码规范、重构技巧却弃如敝履。\n熟不知，守正方能出奇，作为程序员最重要的是，就是首先要把自己的代码写好。\n### 什么是高质量代码\n在日常开发中，我们常常会听到一些抱怨“这代码写的真烂”，但到底如何烂，烂在哪里，应该怎么改造却说不出所以然。那么到底什么是好的代码呢。一万个人心中或许有一万个答案。\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1608252226760-be647e7b-9b35-4ae8-a915-d35d82987b74.png#align=left&display=inline&height=450&margin=%5Bobject%20Object%5D&name=image.png&originHeight=588&originWidth=789&size=54730&status=done&style=none&width=604)\n在我看来，一段代码的好坏，应该从多维度去综合考量。最常用的评价标准我认为有如下几种\n#### 1. 可读性\n你的代码是写给机器运行的，却是给人来读的。人与机器不同，同样的代码今天它能够运行，明天甚至十年后依然可以运行，换一台机器也可以运行。而人不行，你今天写的代码或许今年能看懂，但是一个月后呢，甚至一年十年后呢？绝大多数情况下，你的代码都不是一锤子买卖，绝大多数团队也不是只有一个人的团队。你的代码也有极大的可能会有其他人来维护。我们常常抱怨前任留下的坑，却不知自己也正在给后人挖坑。因此代码的可读性至关重要。\n那么又如何去评判一段代码的可读性呢？\n在我看来，可读性主要可以从是否符合业界或者团队的编码规范、注释是否恰到好处，命名是否词能答意，方法长短是否合适，层次结构、模块划分是否清晰等等。\n而保持可读性的一个很好的实践就是Code Review，如果你的代码能够很轻松的被同事读懂，没有太多疑问，那么就说明这段代码的可读性是可以的。\n\n#### 2. 可扩展易维护\n可扩展易维护性也是一个评价代码质量非常重要的标准。软件开发并非是一朝功成的事。需要我们不断的对其进行维护与扩展。随着需求的不断迭代，我们需要不停的对其修改老功能、增加新功能。而在实际工作中，我们维护代码的时间也远远大于编码的时间，大部分的时间都花在修bug、改改老的功能逻辑，增加一些新的功能逻辑之类的工作。因此代码是否可维护易扩展就显得十分重要。\n而可维护易扩展的评判标准同样是多种因素结合的结果。如果一段代码可读性好，分层清晰。模块化好。能够遵循一些设计思想与原则就会更容易维护，而在此基础上如果能够预留一些扩展点，可以用插拔的方式对新功能进行添加与删除。那么这段代码的可扩展性就是很好的。\n#### 3. 可复用性\n可复用性即尽量减少重复代码的编写，复用已有的代码。人类文明的发展源于人类偷懒的心态。代码中同样如此，可复用性好的代码，会大大提高我们的可扩展性，也会大大提高我们的编码效率。也许是同样的功能代码，如果你的代码可复用性好，那么会大大缩短你编码以及修bug的时间。\n对于可复用的评判标准，主是看一段代码是否满足单一职责，是否耦合性低，以及模块是否清晰，通用代码是否下沉......\n而可复用性的实践源于我们对业务的理解以及大量经验的沉淀，以及合理的遵循一些设计原则，利用一些设计模式\n#### 4. 简单优雅\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1608255320050-1dc2cb91-5f51-4705-b4c0-20bceeaf8c7b.png#align=left&display=inline&height=394&margin=%5Bobject%20Object%5D&name=image.png&originHeight=455&originWidth=609&size=416236&status=done&style=none&width=527)\n真正的高手总能风轻云淡的用最简单的方法解决最复杂的问题，简洁而优雅。不自信的人却总认为简单的代码缺乏技术含量，喜欢在项目中引入一些复杂的方案来彰显自己的技术水平。\n如人月神话一书所说软件行业没有“银弹”，在代码中更是如此，我们永远不要试图去寻找最好的解决方案。而应该用最合适的解决方案，尽量保持代码简单，逻辑清晰，解决问题一针见血，简单有效！\n\n#### 5. 可测试性\n可测试性是一个经常被大多数人所忽略的特性，但它同样是代码质量的一个重要的评判标准之一。可测试性好的代码更有利于我们对代码进行单元测试以保证我们的代码的质量。可测试性的好坏也能侧面的反映代码的好坏。如果你发在一段代码难以进行单元测试那么极大可能说明代码本身的设计存在问题。\n### 如何去写出高质量代码\n我们知道了好的代码具有可读性好、可扩展易维护、可复用性好、简单优雅以及易于测试。那么应该如何去写出高质量的代码呢。总结起来就是八个字“内外兼修、全面发展”。\n我们在金庸的武侠小说中可以看到高手总是有着深厚的内容，以及各种强大对敌招式。在代码中同样如此。要想写出高质量的代码，我们不仅要有强大的内功心法作为基础，使我们首先利于不败之地，还要学习各种优秀的招式秘籍，使我们在对敌实战中游刃有余。\n内功心法便是一些编程思想和设计原则，而招式秘籍则是在大量实践中经验总结出来的，编程规范、重构技巧、设计模式等。\n##### 内功心法\n#### 1. 编程思想\n编程思想主要是指面向对象的编程思想，因为具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。\n#### 2. 设计原则\n设计原则是指导我们代码设计的一些经验总结。如果说设计模式是编程中的招式秘籍，那么设计原则则是内容心法。只有掌握好了内容心法方能把招式秘籍运用自如。常见的设计原则主要有公认的SOLID原则，也有一些根据经验总结出来的DRY、KISS、YAGNI原则等\n##### 招式秘籍\n#### 3. 编程规范\n编码规范指的是针对特定编程语言约定的一系列规则，通常包括文件组织、缩进、注释、声明、语句、空格、命名约定、编程实践、编程原则和最佳实践等。\n规范的代码，可以降低代码出错的几率，可以提高编码的效率，可以降低软件维护成本。\n#### 4. 重构技巧\n在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。\n#### 5. 设计模式\n鲁迅先生曾说，世界上本没有路,走的人多了,也便成了路。设计模式便是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。与设计原则比,设计模式更加具体、更加可执行。而设计模式的应用我们应该先充分的掌握编程思想、设计原则以及一些重构技巧。设计模式的形成是一件水到渠成的事情，通常应该是在重构的过程中自然而然的形成了模式，而不是学到一个设计模式之后就生搬硬套到我们的代码中！\n","source":"_posts/技术实践/代码的艺术/恪尽职守，行分内之事——高质量代码.md","raw":"---\ntitle: 恪尽职守，行分内之事——高质量代码\ncopyright: true\ndate: 2021-01-07 13:29:26\ntags: \n- 代码的艺术\ncategories: 代码的艺术\nkeywords: 高质量代码\npassword: 1234qwer\naside: Notes-LargeSite\n---\n# 恪尽职守，行分内之事——高质量代码\n\n### 为什么要写高质量代码\n恪尽职守，行分内之事，职场之中，各行各业，最重要的事情就是把分内之事最好。而程序员最重要的分内之事便是把代码写好，这也是我们的立身之本。正如字如其人，一个人的代码也是最能诠释一个程序员的名片。\n<!--more-->\n我见过许多工作不久的程序员，就早已不再满足于简单的CRUD，而开始追求所谓高大上的技术，也见过许多工作年限很久的程序员却仍然写着“十年如一日”的代码。由于近些年互联网公司的崛起，越来越多的人崇尚着高并发、大流量，迫不及待的去学习一些最新最时髦的技术，而对于一些编码规范、重构技巧却弃如敝履。\n熟不知，守正方能出奇，作为程序员最重要的是，就是首先要把自己的代码写好。\n### 什么是高质量代码\n在日常开发中，我们常常会听到一些抱怨“这代码写的真烂”，但到底如何烂，烂在哪里，应该怎么改造却说不出所以然。那么到底什么是好的代码呢。一万个人心中或许有一万个答案。\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1608252226760-be647e7b-9b35-4ae8-a915-d35d82987b74.png#align=left&display=inline&height=450&margin=%5Bobject%20Object%5D&name=image.png&originHeight=588&originWidth=789&size=54730&status=done&style=none&width=604)\n在我看来，一段代码的好坏，应该从多维度去综合考量。最常用的评价标准我认为有如下几种\n#### 1. 可读性\n你的代码是写给机器运行的，却是给人来读的。人与机器不同，同样的代码今天它能够运行，明天甚至十年后依然可以运行，换一台机器也可以运行。而人不行，你今天写的代码或许今年能看懂，但是一个月后呢，甚至一年十年后呢？绝大多数情况下，你的代码都不是一锤子买卖，绝大多数团队也不是只有一个人的团队。你的代码也有极大的可能会有其他人来维护。我们常常抱怨前任留下的坑，却不知自己也正在给后人挖坑。因此代码的可读性至关重要。\n那么又如何去评判一段代码的可读性呢？\n在我看来，可读性主要可以从是否符合业界或者团队的编码规范、注释是否恰到好处，命名是否词能答意，方法长短是否合适，层次结构、模块划分是否清晰等等。\n而保持可读性的一个很好的实践就是Code Review，如果你的代码能够很轻松的被同事读懂，没有太多疑问，那么就说明这段代码的可读性是可以的。\n\n#### 2. 可扩展易维护\n可扩展易维护性也是一个评价代码质量非常重要的标准。软件开发并非是一朝功成的事。需要我们不断的对其进行维护与扩展。随着需求的不断迭代，我们需要不停的对其修改老功能、增加新功能。而在实际工作中，我们维护代码的时间也远远大于编码的时间，大部分的时间都花在修bug、改改老的功能逻辑，增加一些新的功能逻辑之类的工作。因此代码是否可维护易扩展就显得十分重要。\n而可维护易扩展的评判标准同样是多种因素结合的结果。如果一段代码可读性好，分层清晰。模块化好。能够遵循一些设计思想与原则就会更容易维护，而在此基础上如果能够预留一些扩展点，可以用插拔的方式对新功能进行添加与删除。那么这段代码的可扩展性就是很好的。\n#### 3. 可复用性\n可复用性即尽量减少重复代码的编写，复用已有的代码。人类文明的发展源于人类偷懒的心态。代码中同样如此，可复用性好的代码，会大大提高我们的可扩展性，也会大大提高我们的编码效率。也许是同样的功能代码，如果你的代码可复用性好，那么会大大缩短你编码以及修bug的时间。\n对于可复用的评判标准，主是看一段代码是否满足单一职责，是否耦合性低，以及模块是否清晰，通用代码是否下沉......\n而可复用性的实践源于我们对业务的理解以及大量经验的沉淀，以及合理的遵循一些设计原则，利用一些设计模式\n#### 4. 简单优雅\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1608255320050-1dc2cb91-5f51-4705-b4c0-20bceeaf8c7b.png#align=left&display=inline&height=394&margin=%5Bobject%20Object%5D&name=image.png&originHeight=455&originWidth=609&size=416236&status=done&style=none&width=527)\n真正的高手总能风轻云淡的用最简单的方法解决最复杂的问题，简洁而优雅。不自信的人却总认为简单的代码缺乏技术含量，喜欢在项目中引入一些复杂的方案来彰显自己的技术水平。\n如人月神话一书所说软件行业没有“银弹”，在代码中更是如此，我们永远不要试图去寻找最好的解决方案。而应该用最合适的解决方案，尽量保持代码简单，逻辑清晰，解决问题一针见血，简单有效！\n\n#### 5. 可测试性\n可测试性是一个经常被大多数人所忽略的特性，但它同样是代码质量的一个重要的评判标准之一。可测试性好的代码更有利于我们对代码进行单元测试以保证我们的代码的质量。可测试性的好坏也能侧面的反映代码的好坏。如果你发在一段代码难以进行单元测试那么极大可能说明代码本身的设计存在问题。\n### 如何去写出高质量代码\n我们知道了好的代码具有可读性好、可扩展易维护、可复用性好、简单优雅以及易于测试。那么应该如何去写出高质量的代码呢。总结起来就是八个字“内外兼修、全面发展”。\n我们在金庸的武侠小说中可以看到高手总是有着深厚的内容，以及各种强大对敌招式。在代码中同样如此。要想写出高质量的代码，我们不仅要有强大的内功心法作为基础，使我们首先利于不败之地，还要学习各种优秀的招式秘籍，使我们在对敌实战中游刃有余。\n内功心法便是一些编程思想和设计原则，而招式秘籍则是在大量实践中经验总结出来的，编程规范、重构技巧、设计模式等。\n##### 内功心法\n#### 1. 编程思想\n编程思想主要是指面向对象的编程思想，因为具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。\n#### 2. 设计原则\n设计原则是指导我们代码设计的一些经验总结。如果说设计模式是编程中的招式秘籍，那么设计原则则是内容心法。只有掌握好了内容心法方能把招式秘籍运用自如。常见的设计原则主要有公认的SOLID原则，也有一些根据经验总结出来的DRY、KISS、YAGNI原则等\n##### 招式秘籍\n#### 3. 编程规范\n编码规范指的是针对特定编程语言约定的一系列规则，通常包括文件组织、缩进、注释、声明、语句、空格、命名约定、编程实践、编程原则和最佳实践等。\n规范的代码，可以降低代码出错的几率，可以提高编码的效率，可以降低软件维护成本。\n#### 4. 重构技巧\n在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。\n#### 5. 设计模式\n鲁迅先生曾说，世界上本没有路,走的人多了,也便成了路。设计模式便是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。与设计原则比,设计模式更加具体、更加可执行。而设计模式的应用我们应该先充分的掌握编程思想、设计原则以及一些重构技巧。设计模式的形成是一件水到渠成的事情，通常应该是在重构的过程中自然而然的形成了模式，而不是学到一个设计模式之后就生搬硬套到我们的代码中！\n","slug":"技术实践/代码的艺术/恪尽职守，行分内之事——高质量代码","published":1,"updated":"2021-03-14T03:04:50.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzw00f2hyjfyzaok49b","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以扫描下方二维码，关注公众号，回复“密码”，即可解锁本站所有文章。</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"641cf66b8164c5f0eb04a3c26ae27b271e32d753cd2d67b42aba7791426856f4\">2ac508f2e109650c514088da22f043dd4b0969425996af8173e282c7f12371a39d9b2bb1b45548f7fb202b2cab662d763b45685958952d2feb1dd31de2474815510670dcac6eb4102eb899335f0811ab01387dbc1e59339b7e04089c22770334e2cc53a53a2d8fa7038f86cdbbde842b0bd014f13e09de7aa13c55be229803125bf21cae013195c340942cdbe81fce5aeb2c4a205cb0445b9a8bbf11cfb19bd26e2ff8238d125558e7507e8368ab473be1a6a50ad11cdc18f89d7c4445deef1ae1d898863d620c141a26e93739e0d7d06b15683583a16ad2135a915d5730ccc1aa7e1c9fa8648ef864628fb6156ccf8d1e24c4e6e70a97333044a461e8ed673dfe9959429672617ab646ad377a96a67d0a91132d4bafb872f8d0b39bcf47778dade74d8dcf47b363536110e7c31c3e25549fcdeee748a0c48ceb15d249a181e22fce6f552fd75cfbabf6c7269575cea5997911b95c418ed533c28b258b9aba000814f9a1c635f2fc89f55db9532a1ead3f6ee2a50e839a29c8c6988b1b7a3e3fb961de611b2c607c2745df9713293057913928a8391ace26500680e7574b2ac1b6a845d8e4a61eda0391ec8a33e25ba05671356ed0a57f1a69e36fd468ac13cec2b16c9d9f560c82c818e438f6d3de5138b66cbf6493cc860d49eb231c53006c70ab625361767cd79aad59087a4fbb6ed20e881a2b27a91d39ed854e22e0b6f94fccbd38049889ae2566f3a44280ee3e07f303a86e0efaf7484385c3e3f5400822d254db0c0d99b5afd07aae39fdc0f9977b0429270a441f8f136175eb3db715fff3f27d57c5161d1b20092fc6b791ea2e6cd2ddaad2e4b748bf140e0331216b383314926ec20530e194d107efac5208d93b628e13c0801d5fa5b40601d57641d308a7761973be810e628895d447cf95cc5d64d656280f2cf975a1f23e0586285d06f31a6c4105c3059bc6d81cb7ad695c34e2351a32e652b72feff5e6e818d7a72a234c9f328b93668dcfc3127994b94a2411f9f34cad17b924e5c0e924170c5f2122b0c17bd0aec0b1eea3596f02919310994465fa5694efb0cfe7b09c45259e5ecec6c663e081c1f2add3566542752129f94d168d05fdf4e9cc9c44996fc5cb4eb2dc931ffc4f634e9ff7c1501128db0da0f50c54aaf138f8ca80b5d8c453d240f606e0575660a762e6cee563ab69be0d88346e5c3f82621126b58dae98c8c812bf24b715383bacc23bc6777c3472c01f47c6266ed59b84cb0b93036833489f760bcc4f4cb0b7e1bc159113d2123c26bc59d1e61d6783cb46234b097f09b81f5954bfd7cfcfcdf1536efced5bad5569c6b117c8b1164a21b13e6b8ebcd1a446e4b082413e845e801816f0955f4e29269a2a57ebfa4e5cc8d86bbc9a7ddf015539e6419fbcb1fffff020489ff88290b7bc692d9ffcdc387fc049e64963300a0245e49f76da7a83bca3d11978d79b9ecc03cc511d7b79412555a0e45e8d91d42e1edbbf271f08b26188017426fec0f1cffa737fef85c3f2eb886207ded1489f0cf0c5c7eef11ff005cd312c353591446d69a47e38c671633c142576e93c3bbeed3863efcc2976be59bdb1edcf901eacfaa96faa89229335155e5beb0eb91d4d8cf720e901a520d8b55309a0879d5fb9bfb4e2b10cf1b82b9be6acdbb69ec23761082a459fd20d10b9fe8e71c55786995937cec3a3c99633deeca4e3e34ac7481ab7f4908f87b1b0a006c8da4c1907cc84b245527069345499c042d2af9099c659c5fbe9a5501e42bdd2872e79df7d9b886a8e7dc3463a98c612b88e08183d57f7dce1bcff37bf4f4cba40ef98cf9b8f23c826d37f5505a5a42d2ce6687c905559e654bea958c9cadd514d7e0e775b7d44aa677c82dc014e9e212e1e7de22a0d44fd3d4bfd843bd58cf4884c60ddecd349eb2cd06055de6cba89701908f6eaf45605574c41d300f9875d1d64cbdb60b45069902eaeb3c05773f5de8a98f71c7bb57ddc8f5f12d9f98da34c74f1a4f13756078a4290edb2038412dfe4b77f4985c82098fedea6bcd1e43d352e6ff2998c44b2ba244546787e703a20772f293744c3662242bc2dac04b75a0b8eb0e4218d5f04b4ccbeb5083abd98eda496d33296e77abcbfa610890863058a5944ef508c02b762f294b69121d84bc0fff7f5f1133d426ef7c21b41acfe624c02762d6e34e6a40a1a4b850eb5547a8e248c52a08306eed677ccde4616d8e087792f444f8a9509c3b4258b60ba3f14925a4f39fb579c3c11d7fb1a0ee920be15bc466eeda9024c10432330460b472c6c964dd9f90a42fa71678e2e9848a4f7d6d29d52fff0309506fe7257762db4143c7e598ce963a161f3e9809e3a9191a06460e175eb49e82a5dd16cf9904cd4669079e336bdff04c7e58856ad9e8ada0e42335ff0b55faed78b25c285fcb4ef1ec8552709716f39c5b804ddbce3ddfd3ec8ac0103a5ad3d23c0285cc6a298e8b10eddac54414489e841c8ccaf715a3c3e6fb5c3c468fdb4acc5684073df88ea51c6a2bcfd2b23c6bb20899732b4f2de138fbd1b46b17c111c90e5b0f41ee99241a87e6e3d754705d61cac9d66d1bfe4e6eb2ec4a6a213cf14dd058f7f7f8891e927b5d6852f26a84e8d92c054cecc0f1918c308a7f32147d3cb392f46c08f13997648973d6be081a1773d27654fdd1141e3a8f96a80ba415321a94c77f093714a1829d9a107add27aa17bc247441d318404a79207d3f65ef40e3e4a6c2e5c34307027b09de0b079a2ced3d64d121ffa095280be080fc11ebd9558c58ec4b04d6b8a0ff4c943281b3a85f777c504137c0ca9c7a079500fca0e8f747fd5751161525ed73c4c566910fb2368cf9666a283655e4d31e9ff24985178d3f894df0eb5c4a651ecdb6c9eafed30031fb578f7fee2bb654c3b53ae0c12077e6beccf01f04c87b6bf5f1394f71905c153e7a4a02b1f22456fc2635ae98b80db2f57cf87c25158e702767284607f8ea49859a9b614f1479c7835590fa85191ebdbc06b8a14151f3101d4caa1a7c07ec15ffc889ea9a06aedbee82d8095516c86576cfc82e2c3be64c32f50bff978702515dbb913d520051961d1cd0fde0f1a62f0f5e48b84f0cb9b2e1ce0391b173530f529edbb797e0a3305a42aef6ae09727a45488f14c6b4c5f65104d33af60259d858f4782458ac7f51d06cd4e03673a446997ab99cd32180a8ceaee4351eebbd7c8da52f526eaf095f62998d5f9f7636beaa9a85fcb0f6d2b9bc379a6037086733a8a9ee20a13fc759ab4480a125e53f7735a596def9304e7fa90311848f7a63161c534b797f897cd34e681ee11a012039bdaab7d10c81b490dad31a3c3ed8af57ec6ffc193e82733b4c8aad3cd32705276437c649ef90ee1157281c8b989f9c6dcb16e0a72cb084b39401b10406234d68234d4155f3935c009d28c6bf7715ff17b26a3e88b300a04a5aafd302b7237d729072b6f4ed2b010b1779f75770c26a2f7c5c9655f90de865ab77de2da0f6007f81aa13f70516cc6344b346e9b2d05cab93790f568a24281fd1c4628081708c3babf4a02d49a5c3ea342da847f11007256800a9d493301f9fcfd5557fd2155bb70b51fa2748e105b00609db83911300087163a269f349d93f1cfa7d56cb0a051b855f492fc6289ecbc8bd6444004dc9160eebebbbe3a32b26a7b86655f549886acb8c6f8c70287f721fa593f8ac3c5aa8b211008d3a1cae4070cb304366ce1760ff63cd5dfbea8bbf60b32da9b11a041cdb517f2674407fe5d316a04fafac3149867dfc160ffea6007219a4e1c2983e249c2dc4018a2bb4bcbda53f6b915f92f23ca6d67ffa7748e1072b14c8cb6f3e47fe4badd87cd99b4b4640c45be3cc0440be9b013921e248f7b08ffe68b99d207f3ee306c3674789d852af31b0fa15059c78dffac574523b57fe4d1febccb068da3bd3baf2bddd289e23493cac8554a9bee10a940566e7bdd6595ed091147cc477bf566b79978aa841d15910c8db27e820bb4c7ba6a3c9d8d06bd1ee14428dba43a3efd8a4258852998fd3a060673315e67a98f27dadecdf4502a571ee73d46c27cb12cca6f689487b644490a191eea6e4dd18433690218601c507b103e3c24d4505a9936b2a92a5e5b45a2c480a2b6f83921593841b5dda7e4f70d7df8283163a191e3d3b802443a07c5ef9d9f19eaf444bc862d796391d6e2f4163aa390d7fcd50613466c3cfc2ca6d41910d0153d6130eb65f46245cf476999010d8ed26b3051a728c42abc4170d1685540dd4d13af174f0349b7f896753a5144f17b9f80f48e1ffdd557dfcf5ebc89b9218b8fe52634544ecdf2995d5df29f0bf0cd778ae0fb042ef40cbf1fc39e40a6edb63a0672c178740d1fcbb9b16407df48f8c01effb42b8cc3dafb5ae21f93cb9ef6dfba3f57319d53acb5b769a10db5683ddfa65f1766293bb63121b70aa8f9a4a4def0d37c63308359dc2c6d912fa4bc141a16de490ee5cb3ca0f6dcc3ffaee4cbe46a748772fc1686c1beb822358978878beec759efa78be40e1a0487a4acdcbcd07e8e5709aef669b0f99ac3fb95e781f329d3ea96a5cd7590ed4bd962de2aea7c6e3743b4ff0363923fc87de97ebdf5ef7599704b201260bb47309b3a6988b6cd768d7663e9e3570315585c807e772da881a61e5d488b2e5d6d535be9d3018d53898fb61050b75d971ebf8c449e34a6d7aa8d8847bbb6197b22ed6aa62597115c4fe6c347cb163431eb75ec05d2dc8c572549f9a45648a89ea7f49143850c1aac5e23bc66334b6ab4ed5f3133752ca03ec09126777fd896a6d0c45980da2df0bfc80ab0393f3b7c27df939412ee55c1a767dcff48fe385c39960d0811284dcbe522f4c03a437cb52f9240b74687d1e441af1721199227ebdfeae46c1738c3108c588fe5d61ab35777c4b30a843d3d7008a3f2cf10bd68672763745e84d88781cf3b450785733a4235fefc1969f244070ba8039eaabd561944672b1841b9489e2c7e2d43dd3e164283890e5d290b1a23ee5030b2126766ff9662b1cd3b35c41781f2495f4d7d3e8995d8ee29c86157bde84bf73007170dc5de764932d63ac2c2ded76fc476f38f2d6379c35751cae4c1be89b43e8b1cd0c2bc2c45be39163c33e4c67b0b5b997a7abb756fa4ffc9c7c4b1caadc86194ba44a189303dd7c86c3db70815e4b6f6190babb1f9b13bcffbb4de305b7389722e6b908f192128d2c678e58efe991a1b30d16f3b4ef80d43f12c24d94b312ba177f5ae66b6fc1f5f288eb98a60f976e6963802954c28a4a632368c7e26abd2fc17c9d265ab4357e7c4f1671d956dac70e8e82cd30511cb2e247f5e1ee54554b1c9f9f2b7b864607901eab7bacee6a6cd145322934f8b3f33b2796af229214d090d7bce0e0f56946339bc01c49690fc7a2cfd7b0e0518da2d259001a426ec6574a544b9a517d6459237a4d3ec89e9d5b9668201c7297c714cfd7ed7d10a1794b89e6a2bfc147bbbac1d4b76019edbc877b07f71589f21549e41d4807d0f8e33b6778b604ddc87077fdaccdcae0a15122b3195e2c06e9e0b18c73009b72dd9168985468b4c3c917c4a07585ab85aa129f6d846f8f72f70cb7ffebdf658566a9b58e201e8e7bc009a082e7bf0978390524a8716b1592bcda3c48f59229fd0f609f38d3569fb08a8575af7c6a1fde6389db00bb86b77889834280f90aef4172c02c3430f0a91d0aebd9f5293cd9d8a5682a304ee50b0c4aaeaabce20275bd4b9a1867b28974da781ffe9510a1ac65f3c07145e17d421b47aceff8fe8962174e8540efdcfc8e800bbc48078e641612606bd1205030bffa3dd37cc3ac2641b8490dce77305bca33bd718977033baec7046ab38d5d5989802cf09b7ec82d4a18c62bd310319f08614530a07f88187facab17e847f01a9c8bdc9e786f0375a41e72a1ba73af3209d92d484b6fbb4fbb143f3b4920db31e1d813520434a8f2935665022dec973246fa17c74b49fde0003630e41a793ce7c3104c33120c8b170a9a1bf8157b8763d95a99db07e5b7c2c51bc34cd95f139999cc93553dbb7c34d5d4df7d360df76dc9d3de8e5997488a3fa1fa59a0a84314865354db4a343ffc1c498292da073375d967106fc923250e77b7a7117ac506078fd9ddc5b92da5d666e84c4fead67e8cce931bda9a265d1b5cb49d9978cb14e1ab446806d0d166e6a93e998647bd6c2ceab63cf93379d60185e989e152bfa8efef85702c393799307984ad0f039ea856a5005837c0287f1d3240bc339e0d7b7019e66bba354b22ab616dbe75039a56292ca90ed2bde1f63899f78afdff189718920b65290214585a950158a5d9d126acbf5241086f91d09b82aaa46d85ca414a81ac5e3a6486c0dd37f4510cb601df133d83935c33d3eac566749a30fee4f4d1bbb1ae04ec446fd9a8f97ca729fd6ee9d39f252dd7716768dd115c66df7803bb612a65876215da16c134f4c685f6bae253153c50fb941be0ee1c0242c50ab80ea45695184aa63887a362931d6407bdf96cecfc71b900e6fbc8ed8baf4a7fd31414788dfd3d73200044a4a4d2f7afdb58f858c54acdf742c444a2151e344719165afd5a066d3e5d8eaf82521ec5f37fe3276bd5416206ea9ccaa8f38c6cc1ab64da449f0172d1aba68703e015f4564397e03c5906bab8e9ba62dc7dc9df9147d15a0e23537104002cf636942448ff7e93eeb33139efcd1395b8a7547e5d824dd777b4b5af08d569112da5729a793fc797868301cca88a69c065e36e866941512f818be3b22c14db46b2aa349526cfeb7fcbb2d81c67c56c0024a3de9802bc072ed86a82c84971664f835e514a052bd7a1b4dd58f928aa495fa17c16ef1b3dfbc435b0b382f10a4b9ae2c56f223d14cc1021c3e50b9c076b388090b025b760cb1fd472cbdb96a29ddb4449c094488ae910f162ea62075316237a150db727104c21b548f28f54bf1c3e9337d059dd38266caaba517c5e987aeafe299d7c56c75bbf8a5997838d111896cecbccb1c2c3620826690977176e6fa415cf4520c640ea3b8db26190e2830fe76574ecc1dc23018b5cb842e9a019f404306a7b16cff689a67eeb33d20ce5d89aec14cbeec5a0973c762f3c569d1ab5ef758f24e0cfe84230e723435a6b20a40661d07872c2c34272dcb23b4ae2123c22e02617b639c106a40cbfd226e3a4013297f28baa1539d0fab15566ad4284ed227c4fda408da8708db277cd36d7bed999b991dc5a3515be580ad756080d121efb19f37fe519ff31f7e25d02e375a3c114313233bbeb7f3c2ad5c1ea3063def051bfeea18e88cf062c2795e171495d14b626f6d5bbc5f6831d62983ee32d45b0e678d05a2765a9b3e30eb71dae8ee8333ca556fe2f57cd51b83849e60f0fab6fcd7fd1b3d20f8ed409a29e7d98999202d533533b141e92c64a596cd26c148a49e26444f453ede83539950e41d9a62cdc654aeaed30a1271dfd6a752bf48089274e15271e6bb7ca190ced8588a65ce9c29429615138d66803573345d79a0ea77aaa4f2913d63c8e0d89438ea020ee51ea965ec9ecd662d7a62a66e5ae55570ddd463c98669febb7a49bc4345688c80e41f8ae8b98861b981b53d8d799a1cabea38717c3e863912240057a547845e2d808d79f7fd1a066c2d92f6ac543cf7353dda9b968a0c75ed96cbdae05540c9842341a587142c18d197aa6f14ed72e7362ea76c7cb9d46463f61a71fd77868ca533558910de507818a25bc24e61bf202f2203228c90948eee4f95c73d34d7417a820971d396e06f0bf01ed92296251e548b398a61cfc9bccd8d4f784d412917d9e073721196db48fa973a8d9d601667b7a109fac0082151ae45077bf7081141a1c421a069a7a01bb74392ade856f2f8e59f7246cf37dde46631f479275fd105378e596479362b066ef0fadac5bbffb8ec0bdcb91d3bb1ef2d4fd8bec5a1811f6b5bc8dadb0de5570b90bdcf3a3fa4b9077bdaa880cd782d293f209c87f0be1f2ae17062540adc4b4d7cf48689763dc6378e7a5c00c70d12a8b8cb7b1496eaf2dbd2287588bde4c590f670ecbd0e2ae2b31b23b33f42c43a55d585491f0a008383bbda61fecdbef8f254b30f96ce8bb3e19bcb417efc9ff9827a40e955c54944040ef107018f22a1b72005dcf6a17eff09092a907c59b1808d7f4bd44b5c380f5c9840eaddc522052f7bc55cb9fcd65bde140275fba6714555d6c0364e07cb0612c9053285564c35fed10cd26386c521b5365c58db98fc31308e1e2b73da61194bbbb329a5de85a9a913b271af9ee7dd5d32e7183c4f8c1ac9ce939d150330b81e423dfcb521640479332e2b566457d70f2b61cf8fb3a4e34c586053fc727c194bd39f27808274c273725ab2e5aaad664bbf7e41e32e214ce2d5ea19804698a8cb9263584a648f21c9c469b9e7f4c59f20a8487a394a3476b85cf4248f29117a965a57a789676fc407eae4be804f1ee4b597a5aace964022010bacc294da3781c73d640765bfa2ff77074b6a4b35d91cd75826ab4a79f01a9e678416d5481ceb78a5f7ee85114a0177a1d393d0fa9a111fdafda196c4ff45586c5f5aac62de52f028f57bcf0a56202387f4ef41e6cf78ef3b413516d903e63e9fb39f275d28e8c6b05c2427033c015247624e1910a2b6330a99cd250723b0a9821a4f81579158ae864a3f023aa1b67279e6a493dc347d75a5a4c17f2f2f00ef1761869324804188a5fd89fae44b7786acfa7c20e32b01a24f9be0310de585e0ca4295a612f6c13888ffc0e343329a6eb79cad4ff8f01c0aa4d5f0bceb9adab64c5c446c2b7561467c40520afa62efb1e67c5e7c1fa1e9178b5e7ea5ee042d0de7955f9515a02ca057489aef0c9c20939bc638098691b51f0364e9608321a4ddcbf869477bf0b0e0db316cefe2ab7adad3e040ac566b5640ccfd68d623a13868aae7c7ad83f5b13ddb2b2f784b621555d748e1f1637c7cfe658d552c6f788af1a177e2c64e291917161206768abe62dcf50ae42f573528e4670db0a25ce9deb8aa56eff79f7426fc1a1d195dda9e8552cba68385efd1aec19f1bc800b208d2afbd7d5f41d8cdb70f29fb43bc28363bdb4f2f1edb7147f794a06108c077bf756055d38e94b64df95230dd6a7c45cdd6e31d4875fd5fe6c782491d33b8f779c9a19bab13a3d41decce2aea22c8482ab4c7d74320ffedd7bf191cffeb397099a145dbf46028f9c7c3f4745bb5e03937385997e0054236535733d0ec23721c7fdae317e8f9a38349e8e2bf89d4c6c61b4b19addbffd9ec94d13fd358efb9cd142ca440f15163a4aa80e5a27d5c927cee430ff0f98a2ba3bc8c8e509662f7451496357263165a810d3a02ce7e94fddfa31a17623d9945eb80d0512a5a70b785c31e5fd8e8dd7873a403bf1d6a33a3215bb5d7045a033463612ba2baf27be488dce2b6a5e5f94550c422f6ad5e2b8bbe8391af84f5a8d670f21a3a0189cb887c190473a15d591b10401890f3fb98edaa99d2b069115dfe3ec72f4ef959fe853f52007c6315fcb5510719a8850ba1f25a899e03f46a838cae0afe8e44ca1d65d98d2e7f9f31772558d47ffe405df1905d8cadee45797342a8006bff48bf5301b1dcc07b934b3e318b3704d3b9b97613b26e1eda4b97d158b92acf766a189d4f26181ae96fa775b1bbef56ea32b31ee0d39885c78de5f6e88a5748d00017692b93d2ea8610f7f4e2930aefc2e900698c63bf1ad48dda81221a1a2e23d768bc2d5689b2531e922c32b78de4abb800430b560430e9a64860591a7f2155010fdbb4b3799d179850a33d30d829bb0eea4bd0f3c7b49a95d82792499c569ad0abe7422b7c5e25be29e15085f82c5e9b2442b0ca13ff9ae45e161132f56317060ecc9f8b599e2c2b43d51332c0848422bce226ad6488d5dec986fd7ab07970a1ec49a3b66354561efada7374448d1fe4b90173317296fcb78af085b2add0c40417050047c0afb4e6da8622536673fbb0ca1cebd78728ee5eba7724f520b8ef6d4018fcdfab8f7a48ec79f5345a0d374dea4152786ce570c681ea9212e6676f175cc0ccd15f286d24c3bbcab77c833f8d7e8865447bf121f70460909c6f79c32e08ff2320a9fcb612473c4d4d04f67b810aa82b0d5b2e3e944352d5b8195cccaaf46a00c31b234b8b78466d75a514ad96c6715a0cb00a38bcab679aa662d1d6109e60c1a329f002d2b5164dd4f6bffd039d291a728db470d0b44b9cc484e439842daa68ec5290e6d06a64980466727e7b08ca8cdf42aeeeec03e364e3a8f7f10bf328c2609049bbcc6199dc4ba527febc9292af02949b5a8d3b15189e12824be5e6c86a703195f2ddd0b0ad61819dc6dc846dd6cddc3fa9296058fb181e1947de3ce3e408a2cb1a99c2ffae6a74f977bde7f9a81a1d98d4bc78b459c064e65c6037555a666a10663cb3afdfedf48d2a4611fba483edd80503f0d95c762ea85d21a3967d2aa3ce848dd585eca2105d0f356f2974b41e9a23d6a2102dc8ad7f57ebfaadf096d1d6c43ed24fc1cf2c1a2ae8bfb69645d76fbef41b4bcb4934cfed4cbfa97dc963bb8f557acf317edf34ba9db019ba89f3bf947e2cb85bc491f6904e46ebe4c8e08831474c8d6cb1ce22a4f1a937c63545f97f4a66d6f40e10ea28e826ca681212548ed876bfcc015d7506a8c261b9c7fdf8af636ec35b5821b1f88da775c776c2b2a8968d33d7700cc6a316cc66a3e3ea886efcf0abb5aeaa69eab269363c276bc33b614c4a93a438b26da5bc33035b92d5a0f3853d430bec6c9439ba2f64db5fdeb5b3cecbfd6cb11baf3f01235148e117ea4d94370ab02ad4f3f0671267e44b32bdc1f730c65ac507e6626aae3eb160ecea7c6b30e63623eeef7b5704ca0e5cf7309f314580d3ff7d157042edb75e698206e36d1de0be78597d80ca801e27037e5da4e4421f432a73e71d1f8ede7a5b565403f2a4690687c3068bf51264ded937481675df12859ea8d3478370289ea91097fc8fa45127d932c7905f06cb38d83d32c745d34f4640fad680fd4dd01520eb36828394a04b2ae37f93238dee513d119c752c776851cb0f69eae8b3189b51afafe85792c8cd3dacb6a4bcc43d8f9ec7be999e697a90689a854f755216cedc67b3f90fbe24c9faebf86360d98a6b06c6220d72b8e35f54764e618310af4546ac5c67554a846255560bb14e47be23b77622ef171cc20b816ebf15a3081d0debe1aa0e45d98fa1d471d92925a7cfc4588b7413d3c5a1d92d5d653725462bc45a5704daa2c8ab368487c44ad807cb66c0a0629535cd3319885e836d866f56e6e10c61d96ba4e2d8f3b7f8d41e667ef0611624bb76199121e6ed42ed4b644c8de77b86765c14d56eba4a01559f7039857dc99187198cd87188516a92bbdab752f05565242ffb379f4bb2fe9f816def38e9f02ea2e57c00f63241c89b30709c29dcf544be0f24106dd80e8561d7d4a45d5361ec43a014495076b982a3711365edc7dd5d9e9ba6bc5847375779513af3204fe62faf200a6d568a574be6e850525bf4fbd9e54a3ec9ce1971678f24752ad0006f23e15c640b2bd07f7aea6e1960f186d9b5c0c9f25e6a8356c338722fd6ec84df737d65a1dc46d5db8f1adbe17809911ba46a628e65f9cd5f781a37ee371db3dc904b27d52902744aec4a51571b252550f489e47b4645625927b9dc8b81bf4927fe5a06e74d9d26fcc6e14ca398378e02eef9af2679e716c47314bd55bf6d86f5b975c29a7f87c1a0fc9b8663b3e7e6ade9226b6b494b45751d837e23bb556aa8aed9cc9d290f938c30f67f64d3226008ec70e388a7cb3b936a2a68071605eb3a87feb312f96e396872108041e32b9253d3574e3920afce312be04780bd2b2d11b16359d437842aaeaf08a18bbb26ddf625751a951163a9178f9aa29e161ccef5a4009e5bf44ea8358f190a19bb2312ec9195914b347b111daf9fdbbddde7bace10f4e3720c20c7dc079b8d41490385c43c37031e06c66962169192a727faac5a90d3247825214712b81c6d961e214fde57d590fe2f108c905d1d9f28435f87b8b3c5ea439e2e8a9a4ccf332023f99021ce5191331170e51619f0838fcbc9fe8b06fca708edb46d28aa724afa993b8321a848a2234d5bd9240f082b1882f8fcdb23a28d281b163412b5ed916809246427a281b31cd1b1accc0a6cb9b00c244b425bb626247f31b7b8373582839ededefbde132c8b7d6ecd808bd4f0e8b7ae419a8d6cfd77501e5996a9eff7c58cbc617dc0a18bc804ec38b878976ec3f2c9f487886f9d774292f532f6dd9dff3d039bf7f6639a6e191c8db0afba722c7286e5037f13b8748e4d76106e6e9229d1faadcd0a705d4434c05e5e63c1f22764cb64f5b80f4d44b7f156f2ed182b341d30110d8d3c9d5a2b4836f979e833b68434398d9b8720b7425436fbf0d6dfe47f50d22ecda6b2d63ce5c94bf086c507593f8b8ea99dc05ff1d9fb3394d17bb04896fa310e3c0d28ed0d439a7283fe6ed110d5ea6c9a686f04c41723e5da999e71f160c2f06e4b41103f3b38601485f23d0cd0ae22ca65a51b50eecae172c5ca5533f4368782bf029d414794d0a53b457237883fcf3750753d133a00b6125514cfda7c6844457b4de205e1e9d70353a6b6171bae91a9969198b3323fcdb7eff0a741b6b5ad3a565eb11c27f53911631d7d6e5bfa9e8dcb650cbbb29b99c90dae27efab540a5c4b19c9890865103929345afd91d15e2feb546b74ee46c1ae9ba27b3fb7a72ba25f720a6f76ad3ab82f790ee0f1e3b660630b1cfca41ce7685c37784553210163031c800c50dc75e330651e0f4677fc4f6011a86bfa9c805937471b078fb6fa0338aa17dbba975b4ecc3d9ce3dc3a6f365eb2a79cec4a46095627b44bf3cf4f3105cf86afc696cb8f082498c678baba47640ee9ca56b0e1cb72d85a2d2fb286e4cb7ec14d5d793a0122629e77b0344656c85e8d8bdba99314f17fcd56c1f764511b4404887dc3428ec5d1565e0e31c2e9fb8077d6a2ef57f0bfc37b6f709d434cfddb8ebeafbfeae1174031a542f927b90e91c9318fb23def3d5dcaa449166e3f185fe2e97d61a1fb1d09c5301ae85ffed11ce1f7d72ae5eb8bdf6c7d6367d613c8543e04ad65a2da951e9e78addb3913009b0331c18db4e15d2220b4487673138864f2173093d65d1b562bc4536b19640fc083e03370759d52d73ecaebbe71df3daed05f573169323ab1845ed10c6a68dcf842390b02eca92712efb8d8fe67df7cdbdfed20627e7c680727c7b4d8f40f32584714641920f2b21da4785baf45d86ef27889ff43133c3231572d969198a9f50bbf47b3925f06a70461ca1e5d42afa5083ea09a6ea10ac1619ca471047f14abfcdd23c28999850de027b7647d6335c6658e8581452cbd3c0feea29ad6b678811c9ae07f3c60abdeabb7e84d5c17da5cdd430fe54cb06f5e21898bbf9aede73557b2768d479f81cf322cdb2f05a76d45334d20defa58d3f5cab7335c6fac21457c10593b8a6f25bb75292f2c6a9104e05660a49bac4b898736eeba375d8450109007ac75cc01f17887a4cca43c3b98b07eb4e3e3f282fe6bed1e1ad6c8c6b7d6df9eae4b38401f8b787518ad3a743c9cfee5973aa4c9de4a3f52a3def3413e4a70de202e6dddac2949f99aeb1e8382bd4305649f22b530f043750e729d66480459c2c4f29b9e0e4143cfa55a468b1ae0f631906a184fd4ed41c0d66581b510d6fa04ca78237757e9e52efa72175cbb4fd926277b555fae287409fb261409c4f1c199054003aa5f4372792be69a519380cda9cdf6bf8b980cd56b51ecdc080831a1688840eff1c4cb6a6868672438cd1860b82a06e29593e7e352e3b51e8962c4abcf7585488c7a2380bc680ae7c74f57bf78988c31644adfbdf52cfdd9e966c30cb752b2e3b3d37c2343f599ab3d8afa2478510c3834f8d0084ac4ff710ea06c51281b95414feb623085c1a0dd89ce092e3248727351eda34e0f710cfb0e908fcedb4bd6ae239aa9699943014a34e2c3f372d5c7ad045cabbd4a5a71e86b1d29426548ac6c746f8b41756de1584f33fd89992dc04eeb44f5d302b0da40464394c7a3537e8b68146576e5dedea50257aa8e7e4f2853e45d4998ac8c8a2c3ae6ce8e233dd00c70cbe0b581c569733729310145d660300f16150c5df905a751cc7c91c6c9919998ef94bc66ab521fa5bd97de99a3da803f4267b1c0ab8b9850b658c7c24bee03183ff49e032e4ee992f4ca47dc0e3661926d1e18469a7b7b1cf0a4211e3175aa2e522d62fcdcbfee23cd9ce9bf7674f58b50f0712b0bf07f78d74af1d8e9811b6258917a3c32f492db5a6dd3784a9f4942c455af62da9a474d3fcd1dee430a2d210d407ed01ed14695ef5cccba63c0e27e11cf5ad3e53149bc5dceca82a73714a309739eaf84a779f01a21220fe9928c865c4c3bd36486c177a01d3c77ad27565e25bbb4bc4ed8843babfb1002ca8dfa6a7a04533514c994160721179740c2b121d83b11c4be3f16bbbc31c34706e2fe56f42ba39188fed73b028a5cdc182bbc4a16aeeca9b5fab04bb36c2a95e627dd9cf11a1c038e18047041758d7caecc30b8a3a7506c488bdde9678bc682838934af832aa6223a5755bdfe95cf908331490c1434ea1a400894451e45fada1e34ffd20a3b0da23f38a09e8e9e97473370e80294510b5bb4077d61b8267950e4321f6f1524ca6cbefbc745acd7cc93cc65501306a57bea780e31ef9243de3305e429adaa0a04df31af6a3f1748824da9f1b312f7</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","more":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","origin":"<h1 id=\"恪尽职守，行分内之事——高质量代码\"><a href=\"#恪尽职守，行分内之事——高质量代码\" class=\"headerlink\" title=\"恪尽职守，行分内之事——高质量代码\"></a>恪尽职守，行分内之事——高质量代码</h1><h3 id=\"为什么要写高质量代码\"><a href=\"#为什么要写高质量代码\" class=\"headerlink\" title=\"为什么要写高质量代码\"></a>为什么要写高质量代码</h3><p>恪尽职守，行分内之事，职场之中，各行各业，最重要的事情就是把分内之事最好。而程序员最重要的分内之事便是把代码写好，这也是我们的立身之本。正如字如其人，一个人的代码也是最能诠释一个程序员的名片。<br><a id=\"more\"></a><br>我见过许多工作不久的程序员，就早已不再满足于简单的CRUD，而开始追求所谓高大上的技术，也见过许多工作年限很久的程序员却仍然写着“十年如一日”的代码。由于近些年互联网公司的崛起，越来越多的人崇尚着高并发、大流量，迫不及待的去学习一些最新最时髦的技术，而对于一些编码规范、重构技巧却弃如敝履。<br>熟不知，守正方能出奇，作为程序员最重要的是，就是首先要把自己的代码写好。</p>\n<h3 id=\"什么是高质量代码\"><a href=\"#什么是高质量代码\" class=\"headerlink\" title=\"什么是高质量代码\"></a>什么是高质量代码</h3><p>在日常开发中，我们常常会听到一些抱怨“这代码写的真烂”，但到底如何烂，烂在哪里，应该怎么改造却说不出所以然。那么到底什么是好的代码呢。一万个人心中或许有一万个答案。<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1608252226760-be647e7b-9b35-4ae8-a915-d35d82987b74.png#align=left&amp;display=inline&amp;height=450&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=588&amp;originWidth=789&amp;size=54730&amp;status=done&amp;style=none&amp;width=604\" alt=\"image.png\"><br>在我看来，一段代码的好坏，应该从多维度去综合考量。最常用的评价标准我认为有如下几种</p>\n<h4 id=\"1-可读性\"><a href=\"#1-可读性\" class=\"headerlink\" title=\"1. 可读性\"></a>1. 可读性</h4><p>你的代码是写给机器运行的，却是给人来读的。人与机器不同，同样的代码今天它能够运行，明天甚至十年后依然可以运行，换一台机器也可以运行。而人不行，你今天写的代码或许今年能看懂，但是一个月后呢，甚至一年十年后呢？绝大多数情况下，你的代码都不是一锤子买卖，绝大多数团队也不是只有一个人的团队。你的代码也有极大的可能会有其他人来维护。我们常常抱怨前任留下的坑，却不知自己也正在给后人挖坑。因此代码的可读性至关重要。<br>那么又如何去评判一段代码的可读性呢？<br>在我看来，可读性主要可以从是否符合业界或者团队的编码规范、注释是否恰到好处，命名是否词能答意，方法长短是否合适，层次结构、模块划分是否清晰等等。<br>而保持可读性的一个很好的实践就是Code Review，如果你的代码能够很轻松的被同事读懂，没有太多疑问，那么就说明这段代码的可读性是可以的。</p>\n<h4 id=\"2-可扩展易维护\"><a href=\"#2-可扩展易维护\" class=\"headerlink\" title=\"2. 可扩展易维护\"></a>2. 可扩展易维护</h4><p>可扩展易维护性也是一个评价代码质量非常重要的标准。软件开发并非是一朝功成的事。需要我们不断的对其进行维护与扩展。随着需求的不断迭代，我们需要不停的对其修改老功能、增加新功能。而在实际工作中，我们维护代码的时间也远远大于编码的时间，大部分的时间都花在修bug、改改老的功能逻辑，增加一些新的功能逻辑之类的工作。因此代码是否可维护易扩展就显得十分重要。<br>而可维护易扩展的评判标准同样是多种因素结合的结果。如果一段代码可读性好，分层清晰。模块化好。能够遵循一些设计思想与原则就会更容易维护，而在此基础上如果能够预留一些扩展点，可以用插拔的方式对新功能进行添加与删除。那么这段代码的可扩展性就是很好的。</p>\n<h4 id=\"3-可复用性\"><a href=\"#3-可复用性\" class=\"headerlink\" title=\"3. 可复用性\"></a>3. 可复用性</h4><p>可复用性即尽量减少重复代码的编写，复用已有的代码。人类文明的发展源于人类偷懒的心态。代码中同样如此，可复用性好的代码，会大大提高我们的可扩展性，也会大大提高我们的编码效率。也许是同样的功能代码，如果你的代码可复用性好，那么会大大缩短你编码以及修bug的时间。<br>对于可复用的评判标准，主是看一段代码是否满足单一职责，是否耦合性低，以及模块是否清晰，通用代码是否下沉……<br>而可复用性的实践源于我们对业务的理解以及大量经验的沉淀，以及合理的遵循一些设计原则，利用一些设计模式</p>\n<h4 id=\"4-简单优雅\"><a href=\"#4-简单优雅\" class=\"headerlink\" title=\"4. 简单优雅\"></a>4. 简单优雅</h4><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1608255320050-1dc2cb91-5f51-4705-b4c0-20bceeaf8c7b.png#align=left&amp;display=inline&amp;height=394&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=455&amp;originWidth=609&amp;size=416236&amp;status=done&amp;style=none&amp;width=527\" alt=\"image.png\"><br>真正的高手总能风轻云淡的用最简单的方法解决最复杂的问题，简洁而优雅。不自信的人却总认为简单的代码缺乏技术含量，喜欢在项目中引入一些复杂的方案来彰显自己的技术水平。<br>如人月神话一书所说软件行业没有“银弹”，在代码中更是如此，我们永远不要试图去寻找最好的解决方案。而应该用最合适的解决方案，尽量保持代码简单，逻辑清晰，解决问题一针见血，简单有效！</p>\n<h4 id=\"5-可测试性\"><a href=\"#5-可测试性\" class=\"headerlink\" title=\"5. 可测试性\"></a>5. 可测试性</h4><p>可测试性是一个经常被大多数人所忽略的特性，但它同样是代码质量的一个重要的评判标准之一。可测试性好的代码更有利于我们对代码进行单元测试以保证我们的代码的质量。可测试性的好坏也能侧面的反映代码的好坏。如果你发在一段代码难以进行单元测试那么极大可能说明代码本身的设计存在问题。</p>\n<h3 id=\"如何去写出高质量代码\"><a href=\"#如何去写出高质量代码\" class=\"headerlink\" title=\"如何去写出高质量代码\"></a>如何去写出高质量代码</h3><p>我们知道了好的代码具有可读性好、可扩展易维护、可复用性好、简单优雅以及易于测试。那么应该如何去写出高质量的代码呢。总结起来就是八个字“内外兼修、全面发展”。<br>我们在金庸的武侠小说中可以看到高手总是有着深厚的内容，以及各种强大对敌招式。在代码中同样如此。要想写出高质量的代码，我们不仅要有强大的内功心法作为基础，使我们首先利于不败之地，还要学习各种优秀的招式秘籍，使我们在对敌实战中游刃有余。<br>内功心法便是一些编程思想和设计原则，而招式秘籍则是在大量实践中经验总结出来的，编程规范、重构技巧、设计模式等。</p>\n<h5 id=\"内功心法\"><a href=\"#内功心法\" class=\"headerlink\" title=\"内功心法\"></a>内功心法</h5><h4 id=\"1-编程思想\"><a href=\"#1-编程思想\" class=\"headerlink\" title=\"1. 编程思想\"></a>1. 编程思想</h4><p>编程思想主要是指面向对象的编程思想，因为具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p>\n<h4 id=\"2-设计原则\"><a href=\"#2-设计原则\" class=\"headerlink\" title=\"2. 设计原则\"></a>2. 设计原则</h4><p>设计原则是指导我们代码设计的一些经验总结。如果说设计模式是编程中的招式秘籍，那么设计原则则是内容心法。只有掌握好了内容心法方能把招式秘籍运用自如。常见的设计原则主要有公认的SOLID原则，也有一些根据经验总结出来的DRY、KISS、YAGNI原则等</p>\n<h5 id=\"招式秘籍\"><a href=\"#招式秘籍\" class=\"headerlink\" title=\"招式秘籍\"></a>招式秘籍</h5><h4 id=\"3-编程规范\"><a href=\"#3-编程规范\" class=\"headerlink\" title=\"3. 编程规范\"></a>3. 编程规范</h4><p>编码规范指的是针对特定编程语言约定的一系列规则，通常包括文件组织、缩进、注释、声明、语句、空格、命名约定、编程实践、编程原则和最佳实践等。<br>规范的代码，可以降低代码出错的几率，可以提高编码的效率，可以降低软件维护成本。</p>\n<h4 id=\"4-重构技巧\"><a href=\"#4-重构技巧\" class=\"headerlink\" title=\"4. 重构技巧\"></a>4. 重构技巧</h4><p>在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。</p>\n<h4 id=\"5-设计模式\"><a href=\"#5-设计模式\" class=\"headerlink\" title=\"5. 设计模式\"></a>5. 设计模式</h4><p>鲁迅先生曾说，世界上本没有路,走的人多了,也便成了路。设计模式便是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。与设计原则比,设计模式更加具体、更加可执行。而设计模式的应用我们应该先充分的掌握编程思想、设计原则以及一些重构技巧。设计模式的形成是一件水到渠成的事情，通常应该是在重构的过程中自然而然的形成了模式，而不是学到一个设计模式之后就生搬硬套到我们的代码中！</p>\n","encrypt":true},{"title":"理解RESTful API","copyright":true,"date":"2020-04-14T03:29:26.000Z","keywords":"RESTful API","_content":"\n近日妹子向我求助RESTful API到底是个什么东西。原因是她们公司一个新启动的项目因为RESTful API起了争执。服务端同学坚持要用RESTful API，而前端同学则认为服务端用RESTful API就会让前端的调用变得更麻烦。最终争议了一下午还是不了了之。有趣的是他们组的大部分人都不太了解REST是个什么东西。\n\n<!--more-->\n\n实际上一些抽象的东西是不如一些具体的技术好讲解的，就像你给新人讲面向对象一样，这东西得靠时间，靠悟。我之前做过开放平台API的项目。对于RESTful API还算有些了解。万幸没有丢人，口干舌燥之后总算讲明白一些。但这东西真正理解还得多悟、多思考、多练习。当然，如果你有更好的理解，可在评论区与我留言分享！我会第一时间反馈！\n\n### 一、REST\n\nREST，即Representational State Transfer的缩写，翻译过来就是\"表现层状态转化\"。不得不承认，我在刚开始看到这个名词的时候是一脸懵逼。好了，现在我们放弃对这个名词的理解。\n\n实际上，REST只是一种软件架构风格。注意了，它并不是一种具体的技术。而更像是一种约束与规范性的东西，它包含了很多原则与限制。而如果一个架构符合REST的原则，就可以称它为RESTful架构。\n\n#### 1.1 资源\n\n在REST中最重要的一个概念就是**资源**。在面向对象的世界里，我们提倡万物皆对象，而在REST的世界里则是万物皆资源。**所谓\"资源\"，就是网络上的一个实体，或者说是网络上的一个具体信息。**它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。\n\n#### 1.2 表现层\n\n\"资源\"是一种信息实体，它可以有多种外在表现形式。**我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层\"**\n\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\n\n#### 1.3 状态转化\n\n访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\n\n当下的互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，**如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化\"（State Transfer）。而这种转化是建立在表现层之上的，所以就是\"表现层状态转化\"。**\n\n在HTTP协议里面，就可以使用HTTP动词来对服务器端资源进行操作，实现“表现层状态转化”。如：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。\n\n以网站中常见的用户CRUD操作为例：\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/REST/RESTful%20API.png)\n\n现在，我们再回过头来理解REST(表现层状态转化)——REST是一种通过**表现层**来操作改变**资源**的**状态**的软件架构**风格**。\n\n### 二、RESTful API\n\nRESTful API 就是REST风格的API。它**使用URI来描述资源，使用Html、Json、XML等格式表现，通过HTTP动词来操作资源来实现状态转化，使用HTTP状态码反映处理结果**。\n\n#### 2.1 URI\n\nURI通常由三部分组成：\n\n1. 访问资源的命名机制；\n\n2. 存放资源的主机名；\n\n3. 资源自身的名称。\n\n例如:https://localhost/post/1 (对应URLhttps://localhost/post/1.html)\n\n我们可以这样解释它：\n\n1. 这是一个可以通过https协议访问的资源，\n\n2. 位于主机 localhost上，\n\n3. 通过“post/1”可以对该资源进行唯一标识（注意，这个不一定是完整的路径）\n\n注意：以上三点只不过是对实例的解释，以上三点并不是URI的必要条件，URI只是一种概念，怎样实现无所谓，只要它唯一标识一个资源就可以了。URI只代表资源的实体，不代表它的形式。严格地说，如上面网址最后的\".html\"后缀名是不必要的，因为这个后缀名表示格式，属于\"表现层\"范畴，而URI应该只代表\"资源\"的位置。\n\n#### 2.2 HTTP动词\n\n常用的HTTP动词有下面这些\n\n - GET：从服务器取出资源（一项或多项）。——幂等\n - POST：在服务器新建一个资源。——非幂等\n - PUT：在服务器更新资源（客户端提供改变后的完整资源）。——幂等\n - PATCH：在服务器更新资源（客户端提供改变的属性）。——幂等\n - DELETE：从服务器删除资源。——幂等\n\n- HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n#### 2.3 HTTP状态码\n\nHTTP协议本身就给我们提供了丰富的状态码，以用来反映服务器端处理的结果。而在真正使用中绝大对数人仅仅了解会使用200,404,500之流。这就好比36板斧，你始终是会那三板斧。而RESTful Api规范的HTTP状态码的使用，使HTTP协议的优点发挥到了极致。\n\n例如:\n\n* 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n* 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n* 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n* 204 NO CONTENT - [DELETE]：用户删除数据成功。\n* 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n* 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n* 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n* 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n注意:当状态码是4或5开头的时候就应该像用户返回错误信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n```\n{\n    error: \"Invalid API key\"\n}\n```\n\n如下表是常用的HTTP状态码和描述\n\n| CODE | HTTP Operation            | Body Contents  | Decription                         |\n| ---- | ------------------------- | -------------- | ---------------------------------- |\n| 200  | GET,PUT                   | 资源           | 操作成功                           |\n| 201  | POST                      | 资源,元数据    | 对象创建成功                       |\n| 202  | POST,PUT,DELETE,PATCH     | N/A            | 请求已被接受                       |\n| 204  | DELETE,PUT,PATCH          | N/A            | 操作已经执行成功，但是没有返回结果 |\n| 301  | GET                       | link           | 资源已被移除                       |\n| 303  | GET                       | link           | 重定向                             |\n| 304  | GET                       | N/A            | 资源没有被修改                     |\n| 400  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 参数列表错误(缺少，格式不匹配)     |\n| 401  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 未授权                             |\n| 403  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 访问受限，授权过期                 |\n| 404  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 资源，服务未找到                   |\n| 405  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 不允许的HTTP方法                   |\n| 409  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 资源冲突，或资源被锁定             |\n| 415  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 不支持的数据(媒体)类型             |\n| 429  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 请求过多被限制                     |\n| 500  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 系统内部错误                       |\n| 501  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 接口未实现                         |\n\n#### 2.4.示例\n\n我们以Web网站中常用的用户增删查改为例。设计普通的API接口完成增删查改大致如下:\n\n```\n//添加用户\nhttp://localhost/createuser\n//删除id为1的用户\nhttp://localhost/deleteuser?userid=1\n//获取用户列表\nhttp://localhost/getuser\n//获取id为1的用户\nhttp://localhost/getuser?userid=1\n//更新id为1的用户\nhttp://localhost/updateuser?userid=1\n```\n\n我们通过调用上面不同的url传递响应的参数来完成用户的增删查改。\n\n而使用RESTful 风格的api该如何完成呢？\n\n在这个例子中很明显，用户就是我们的资源，使用uri来描述资源就是\n\n```\nhttp://localhost/user\n```\n\n表现层可以是Json也可以是xml或者其它。\n\n我们使用HTTP的动词来操作用户这个资源。\n\n* 使用GET的方式请求`http://localhost/user`代表查询用户列表\n* 使用GET的方式请求`http://localhost/user/1`代表查询id为1的用户\n* 使用POST的方式请求`http://localhost/user`代表创建一个用户\n* 使用PUT的方式请求`http://localhost/user/1`代表修改id为1的用户\n* 使用DELETE的方式请求`http://localhost/user/1`代表删除id为1的用户。\n\n可以看到这种风格看起来要更为优雅与简洁，面向资源，一目了然，具有自解释性，充分的发挥了HTTP协议的优点。\n\n#### 2.5 设计上的难点和误区\n\n##### 2.5.1 URI 包含动词\n\n因为\"资源\"表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。\n\n举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。\n\n如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：\n\n```\nPOST /accounts/1/transfer/500/to/2\n```\n\n正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：\n```\nPOST /transaction HTTP/1.1\nHost: 127.0.0.1\n 　　\nfrom=1&to=2&amount=500.00\n```\n##### 2.5.2 URI中加入版本号\n\n**另一个设计误区，就是在URI中加入版本号**：\n```\nhttp://localhost/app/1.0/foo\n\nhttp://localhost/app/1.1/foo\n\nhttp://localhost/app/2.0/foo\n```\n因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见[Versioning REST Services](http://www.informit.com/articles/article.aspx?p=1566460)）：\n```\nAccept: localhost.foo+json; version=1.0\n\nAccept: localhost.foo+json; version=1.1\n\nAccept: localhostfoo+json; version=2.0\n```\n##### 2.5.3 面向资源≠面向单表操作\n\n注意,面向资源不等于面向单表操作。不知道为什么很多人会把资源对应到数据库里的单张表。其实他们没有任何关系。资源可以是一个文件，可以是缓存里的数据，也可以是数据库里多张表聚合的结果。比如用户这个资源。通常我们设计数据库的时候出于性能或范式的考虑用户的信息不会放在一张表里。但是在API设计的时候用户就是一个资源，这个资源的数据有可能来自一张表也有可能是多张表，甚至缓存。\n\n##### 2.5.4 复杂与特殊的场景如何设计\n\n跟万物皆对象一样，使用「万物皆资源」的思想设计实际项目中的API时，经常会遇到一个问题就是「这玩意到底是个什么资源？………………算了，我就直接写吧，不管什么风格了」 \n\n- 比如，登录(login)和登出(logout)应该怎么REST化？ \n- 比如，多条件复合搜索条件太多在GET里写不下怎么办？ \n- 比如，批量资源的操作id躲到URL都写不下，难道要写几千个UPDATE或DELETE？  \n\n其实在真正理解了REST后，这些都不是什么无解的难题，如果无解，那只能说明你还没真正理解，抽象成资源的能力还不到家： \n\n- 登录(login)和登出(logout)其实本质上只是对session资源的创建和删除； \n\n  ```\n  //登录——使用HTTP POST请求\n  POST /localhost/session\n  //登出——使用HTTP DELETE请求\n  DELETE /localhost/session\n  ```\n\n- 我们可以把search本身抽象成资源，使用POST创建，如果不需持久化，可以直接在Response中返回结果，如果需要（如翻页、长期缓存等），直接保存搜索结果并303跳转到资源地址就行了；\n\n   ```\n  //HTTP POST创建资源search\n  POST /localhost/search\n  ```\n\n- 批量操作id多到连url都写不下的请求，应该创建task，用GET返回task状态甚至执行进度；\n\n  ```\n  //HTTP POST创建Task \n  POST /localhost/task\n  \n  //HTTP GET获取TASK执行结果\n  GET /localhost/task\n  ```\n\n#### 2.6 优缺点与适用场景\n\n任何一门技术或者思想都有其优缺点，虽然其诞生的初衷都是为了解决我们的问题，而不是带来更大的灾难。REST同样如此。它的优点很明显，优雅、规范，行为和资源分离，更容易理解。\n\n但是也有其缺点，它面向资源，这种设计思路是反程序员直觉的，因为在本地业务代码中仍然是一个个的函数，是动作，但表现在接口形式上则完全是资源的形式，对于后端开发人员要求高，有些业务逻辑难以被抽象为资源的增删改查。甚至有些时候RESTful其实是个效率很低的东西，为了实现一个资源，你需要定义它的一套方式，如果要联合查询又会要求对其衍生或定义一个新的资源。它提供的接口一般是“粗”粒度的，它通常返回的都是完整的数据模型，难以查询符合特殊要求的数据，有些特殊的业务要比普通的API需要更多次HTTP请求。\n\nREST面对的疑问跟当年刚开始流行面向对象时的情况是一样的。它适合很多情况，但并不适合所有情况。它更适合与一些开放平台API，如新浪微博、GitHub、京东、淘宝开放平台等，开放API之所以开放，就是因为它不知道你到底需要什么返回结果，既然不知道，那么我干脆都返回给你，有客户端自由组合成自己想要的数据。而对于内部开发，有其局限性，内部开发由于需求非常明确，有些时候出于性能或灵活性的考虑，服务端简单粗暴的丢出来完整的数据模型由客户端自己处理显然是不合适的。\n\n对于一些内部的开发，适合用RESTful API的我们仍然可以用，对于一些不合适的，我们仍然可以借鉴一些RESTFul中的优点，来设计我们的API。比如简洁的URI(每个人看到一坨超长的API地址，内心都是拒绝的)，充分利用HTTP状态码等。\n\n### 最后\n\nRESTful API是REST风格的API，它是一种API设计风格，规范了API设计中的一些原则。它让我们的API更加优雅、规范。但也尤其缺点，在实际使用过程中我们应该充分的取理解它，综合考量其使用场景。\n\n如果大家想要取学习并使用它，建议可以参考[Github开放API](https://developer.github.com/v3/) 或者[Elasticsearch API](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs.html),看一看他们是如何设计的API，对于自己项目中的每一个场景多思考，去网上一些开源RESTful API找一找有没有相同场景的例子。\n\n很多人会盲目追新，又对REST的概念和理念一知半解，最后搞出一个半吊子的怪胎，不仅没有设计出优雅规范的API，甚至还引起了更大的麻烦，最后还自我标榜用了流行的RESTful API。\n\n其实REST规范最终还是为了开发者和软件产品服务的，如果它能带来便利、减少混乱，就值得用；反之，如果带来的麻烦比解决的还多，跟风追流行就不可取了。其它任何技术也是如此！\n\n\n\n\n\n\n\n\n\n","source":"_posts/技术实践/代码的艺术/理解RESTful API.md","raw":"---\ntitle: 理解RESTful API\ncopyright: true\ndate: 2020-04-14 11:29:26\ntags: \n- 代码的艺术\n- RESTful\ncategories: 代码的艺术\nkeywords: RESTful API\n---\n\n近日妹子向我求助RESTful API到底是个什么东西。原因是她们公司一个新启动的项目因为RESTful API起了争执。服务端同学坚持要用RESTful API，而前端同学则认为服务端用RESTful API就会让前端的调用变得更麻烦。最终争议了一下午还是不了了之。有趣的是他们组的大部分人都不太了解REST是个什么东西。\n\n<!--more-->\n\n实际上一些抽象的东西是不如一些具体的技术好讲解的，就像你给新人讲面向对象一样，这东西得靠时间，靠悟。我之前做过开放平台API的项目。对于RESTful API还算有些了解。万幸没有丢人，口干舌燥之后总算讲明白一些。但这东西真正理解还得多悟、多思考、多练习。当然，如果你有更好的理解，可在评论区与我留言分享！我会第一时间反馈！\n\n### 一、REST\n\nREST，即Representational State Transfer的缩写，翻译过来就是\"表现层状态转化\"。不得不承认，我在刚开始看到这个名词的时候是一脸懵逼。好了，现在我们放弃对这个名词的理解。\n\n实际上，REST只是一种软件架构风格。注意了，它并不是一种具体的技术。而更像是一种约束与规范性的东西，它包含了很多原则与限制。而如果一个架构符合REST的原则，就可以称它为RESTful架构。\n\n#### 1.1 资源\n\n在REST中最重要的一个概念就是**资源**。在面向对象的世界里，我们提倡万物皆对象，而在REST的世界里则是万物皆资源。**所谓\"资源\"，就是网络上的一个实体，或者说是网络上的一个具体信息。**它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。\n\n#### 1.2 表现层\n\n\"资源\"是一种信息实体，它可以有多种外在表现形式。**我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层\"**\n\n比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。\n\n#### 1.3 状态转化\n\n访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。\n\n当下的互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，**如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化\"（State Transfer）。而这种转化是建立在表现层之上的，所以就是\"表现层状态转化\"。**\n\n在HTTP协议里面，就可以使用HTTP动词来对服务器端资源进行操作，实现“表现层状态转化”。如：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。\n\n以网站中常见的用户CRUD操作为例：\n\n![](https://hunter-image.oss-cn-beijing.aliyuncs.com/REST/RESTful%20API.png)\n\n现在，我们再回过头来理解REST(表现层状态转化)——REST是一种通过**表现层**来操作改变**资源**的**状态**的软件架构**风格**。\n\n### 二、RESTful API\n\nRESTful API 就是REST风格的API。它**使用URI来描述资源，使用Html、Json、XML等格式表现，通过HTTP动词来操作资源来实现状态转化，使用HTTP状态码反映处理结果**。\n\n#### 2.1 URI\n\nURI通常由三部分组成：\n\n1. 访问资源的命名机制；\n\n2. 存放资源的主机名；\n\n3. 资源自身的名称。\n\n例如:https://localhost/post/1 (对应URLhttps://localhost/post/1.html)\n\n我们可以这样解释它：\n\n1. 这是一个可以通过https协议访问的资源，\n\n2. 位于主机 localhost上，\n\n3. 通过“post/1”可以对该资源进行唯一标识（注意，这个不一定是完整的路径）\n\n注意：以上三点只不过是对实例的解释，以上三点并不是URI的必要条件，URI只是一种概念，怎样实现无所谓，只要它唯一标识一个资源就可以了。URI只代表资源的实体，不代表它的形式。严格地说，如上面网址最后的\".html\"后缀名是不必要的，因为这个后缀名表示格式，属于\"表现层\"范畴，而URI应该只代表\"资源\"的位置。\n\n#### 2.2 HTTP动词\n\n常用的HTTP动词有下面这些\n\n - GET：从服务器取出资源（一项或多项）。——幂等\n - POST：在服务器新建一个资源。——非幂等\n - PUT：在服务器更新资源（客户端提供改变后的完整资源）。——幂等\n - PATCH：在服务器更新资源（客户端提供改变的属性）。——幂等\n - DELETE：从服务器删除资源。——幂等\n\n- HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n#### 2.3 HTTP状态码\n\nHTTP协议本身就给我们提供了丰富的状态码，以用来反映服务器端处理的结果。而在真正使用中绝大对数人仅仅了解会使用200,404,500之流。这就好比36板斧，你始终是会那三板斧。而RESTful Api规范的HTTP状态码的使用，使HTTP协议的优点发挥到了极致。\n\n例如:\n\n* 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n* 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n* 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n* 204 NO CONTENT - [DELETE]：用户删除数据成功。\n* 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n* 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n* 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n* 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n注意:当状态码是4或5开头的时候就应该像用户返回错误信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n```\n{\n    error: \"Invalid API key\"\n}\n```\n\n如下表是常用的HTTP状态码和描述\n\n| CODE | HTTP Operation            | Body Contents  | Decription                         |\n| ---- | ------------------------- | -------------- | ---------------------------------- |\n| 200  | GET,PUT                   | 资源           | 操作成功                           |\n| 201  | POST                      | 资源,元数据    | 对象创建成功                       |\n| 202  | POST,PUT,DELETE,PATCH     | N/A            | 请求已被接受                       |\n| 204  | DELETE,PUT,PATCH          | N/A            | 操作已经执行成功，但是没有返回结果 |\n| 301  | GET                       | link           | 资源已被移除                       |\n| 303  | GET                       | link           | 重定向                             |\n| 304  | GET                       | N/A            | 资源没有被修改                     |\n| 400  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 参数列表错误(缺少，格式不匹配)     |\n| 401  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 未授权                             |\n| 403  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 访问受限，授权过期                 |\n| 404  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 资源，服务未找到                   |\n| 405  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 不允许的HTTP方法                   |\n| 409  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 资源冲突，或资源被锁定             |\n| 415  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 不支持的数据(媒体)类型             |\n| 429  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 请求过多被限制                     |\n| 500  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 系统内部错误                       |\n| 501  | GET,POST,PUT,DELETE,PATCH | 错误提示(消息) | 接口未实现                         |\n\n#### 2.4.示例\n\n我们以Web网站中常用的用户增删查改为例。设计普通的API接口完成增删查改大致如下:\n\n```\n//添加用户\nhttp://localhost/createuser\n//删除id为1的用户\nhttp://localhost/deleteuser?userid=1\n//获取用户列表\nhttp://localhost/getuser\n//获取id为1的用户\nhttp://localhost/getuser?userid=1\n//更新id为1的用户\nhttp://localhost/updateuser?userid=1\n```\n\n我们通过调用上面不同的url传递响应的参数来完成用户的增删查改。\n\n而使用RESTful 风格的api该如何完成呢？\n\n在这个例子中很明显，用户就是我们的资源，使用uri来描述资源就是\n\n```\nhttp://localhost/user\n```\n\n表现层可以是Json也可以是xml或者其它。\n\n我们使用HTTP的动词来操作用户这个资源。\n\n* 使用GET的方式请求`http://localhost/user`代表查询用户列表\n* 使用GET的方式请求`http://localhost/user/1`代表查询id为1的用户\n* 使用POST的方式请求`http://localhost/user`代表创建一个用户\n* 使用PUT的方式请求`http://localhost/user/1`代表修改id为1的用户\n* 使用DELETE的方式请求`http://localhost/user/1`代表删除id为1的用户。\n\n可以看到这种风格看起来要更为优雅与简洁，面向资源，一目了然，具有自解释性，充分的发挥了HTTP协议的优点。\n\n#### 2.5 设计上的难点和误区\n\n##### 2.5.1 URI 包含动词\n\n因为\"资源\"表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。\n\n举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。\n\n如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：\n\n```\nPOST /accounts/1/transfer/500/to/2\n```\n\n正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：\n```\nPOST /transaction HTTP/1.1\nHost: 127.0.0.1\n 　　\nfrom=1&to=2&amount=500.00\n```\n##### 2.5.2 URI中加入版本号\n\n**另一个设计误区，就是在URI中加入版本号**：\n```\nhttp://localhost/app/1.0/foo\n\nhttp://localhost/app/1.1/foo\n\nhttp://localhost/app/2.0/foo\n```\n因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见[Versioning REST Services](http://www.informit.com/articles/article.aspx?p=1566460)）：\n```\nAccept: localhost.foo+json; version=1.0\n\nAccept: localhost.foo+json; version=1.1\n\nAccept: localhostfoo+json; version=2.0\n```\n##### 2.5.3 面向资源≠面向单表操作\n\n注意,面向资源不等于面向单表操作。不知道为什么很多人会把资源对应到数据库里的单张表。其实他们没有任何关系。资源可以是一个文件，可以是缓存里的数据，也可以是数据库里多张表聚合的结果。比如用户这个资源。通常我们设计数据库的时候出于性能或范式的考虑用户的信息不会放在一张表里。但是在API设计的时候用户就是一个资源，这个资源的数据有可能来自一张表也有可能是多张表，甚至缓存。\n\n##### 2.5.4 复杂与特殊的场景如何设计\n\n跟万物皆对象一样，使用「万物皆资源」的思想设计实际项目中的API时，经常会遇到一个问题就是「这玩意到底是个什么资源？………………算了，我就直接写吧，不管什么风格了」 \n\n- 比如，登录(login)和登出(logout)应该怎么REST化？ \n- 比如，多条件复合搜索条件太多在GET里写不下怎么办？ \n- 比如，批量资源的操作id躲到URL都写不下，难道要写几千个UPDATE或DELETE？  \n\n其实在真正理解了REST后，这些都不是什么无解的难题，如果无解，那只能说明你还没真正理解，抽象成资源的能力还不到家： \n\n- 登录(login)和登出(logout)其实本质上只是对session资源的创建和删除； \n\n  ```\n  //登录——使用HTTP POST请求\n  POST /localhost/session\n  //登出——使用HTTP DELETE请求\n  DELETE /localhost/session\n  ```\n\n- 我们可以把search本身抽象成资源，使用POST创建，如果不需持久化，可以直接在Response中返回结果，如果需要（如翻页、长期缓存等），直接保存搜索结果并303跳转到资源地址就行了；\n\n   ```\n  //HTTP POST创建资源search\n  POST /localhost/search\n  ```\n\n- 批量操作id多到连url都写不下的请求，应该创建task，用GET返回task状态甚至执行进度；\n\n  ```\n  //HTTP POST创建Task \n  POST /localhost/task\n  \n  //HTTP GET获取TASK执行结果\n  GET /localhost/task\n  ```\n\n#### 2.6 优缺点与适用场景\n\n任何一门技术或者思想都有其优缺点，虽然其诞生的初衷都是为了解决我们的问题，而不是带来更大的灾难。REST同样如此。它的优点很明显，优雅、规范，行为和资源分离，更容易理解。\n\n但是也有其缺点，它面向资源，这种设计思路是反程序员直觉的，因为在本地业务代码中仍然是一个个的函数，是动作，但表现在接口形式上则完全是资源的形式，对于后端开发人员要求高，有些业务逻辑难以被抽象为资源的增删改查。甚至有些时候RESTful其实是个效率很低的东西，为了实现一个资源，你需要定义它的一套方式，如果要联合查询又会要求对其衍生或定义一个新的资源。它提供的接口一般是“粗”粒度的，它通常返回的都是完整的数据模型，难以查询符合特殊要求的数据，有些特殊的业务要比普通的API需要更多次HTTP请求。\n\nREST面对的疑问跟当年刚开始流行面向对象时的情况是一样的。它适合很多情况，但并不适合所有情况。它更适合与一些开放平台API，如新浪微博、GitHub、京东、淘宝开放平台等，开放API之所以开放，就是因为它不知道你到底需要什么返回结果，既然不知道，那么我干脆都返回给你，有客户端自由组合成自己想要的数据。而对于内部开发，有其局限性，内部开发由于需求非常明确，有些时候出于性能或灵活性的考虑，服务端简单粗暴的丢出来完整的数据模型由客户端自己处理显然是不合适的。\n\n对于一些内部的开发，适合用RESTful API的我们仍然可以用，对于一些不合适的，我们仍然可以借鉴一些RESTFul中的优点，来设计我们的API。比如简洁的URI(每个人看到一坨超长的API地址，内心都是拒绝的)，充分利用HTTP状态码等。\n\n### 最后\n\nRESTful API是REST风格的API，它是一种API设计风格，规范了API设计中的一些原则。它让我们的API更加优雅、规范。但也尤其缺点，在实际使用过程中我们应该充分的取理解它，综合考量其使用场景。\n\n如果大家想要取学习并使用它，建议可以参考[Github开放API](https://developer.github.com/v3/) 或者[Elasticsearch API](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs.html),看一看他们是如何设计的API，对于自己项目中的每一个场景多思考，去网上一些开源RESTful API找一找有没有相同场景的例子。\n\n很多人会盲目追新，又对REST的概念和理念一知半解，最后搞出一个半吊子的怪胎，不仅没有设计出优雅规范的API，甚至还引起了更大的麻烦，最后还自我标榜用了流行的RESTful API。\n\n其实REST规范最终还是为了开发者和软件产品服务的，如果它能带来便利、减少混乱，就值得用；反之，如果带来的麻烦比解决的还多，跟风追流行就不可取了。其它任何技术也是如此！\n\n\n\n\n\n\n\n\n\n","slug":"技术实践/代码的艺术/理解RESTful API","published":1,"updated":"2021-03-14T03:04:50.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfpzz00f6hyjfvukgkk43","content":"<p>近日妹子向我求助RESTful API到底是个什么东西。原因是她们公司一个新启动的项目因为RESTful API起了争执。服务端同学坚持要用RESTful API，而前端同学则认为服务端用RESTful API就会让前端的调用变得更麻烦。最终争议了一下午还是不了了之。有趣的是他们组的大部分人都不太了解REST是个什么东西。</p>\n<a id=\"more\"></a>\n<p>实际上一些抽象的东西是不如一些具体的技术好讲解的，就像你给新人讲面向对象一样，这东西得靠时间，靠悟。我之前做过开放平台API的项目。对于RESTful API还算有些了解。万幸没有丢人，口干舌燥之后总算讲明白一些。但这东西真正理解还得多悟、多思考、多练习。当然，如果你有更好的理解，可在评论区与我留言分享！我会第一时间反馈！</p>\n<h3 id=\"一、REST\"><a href=\"#一、REST\" class=\"headerlink\" title=\"一、REST\"></a>一、REST</h3><p>REST，即Representational State Transfer的缩写，翻译过来就是”表现层状态转化”。不得不承认，我在刚开始看到这个名词的时候是一脸懵逼。好了，现在我们放弃对这个名词的理解。</p>\n<p>实际上，REST只是一种软件架构风格。注意了，它并不是一种具体的技术。而更像是一种约束与规范性的东西，它包含了很多原则与限制。而如果一个架构符合REST的原则，就可以称它为RESTful架构。</p>\n<h4 id=\"1-1-资源\"><a href=\"#1-1-资源\" class=\"headerlink\" title=\"1.1 资源\"></a>1.1 资源</h4><p>在REST中最重要的一个概念就是<strong>资源</strong>。在面向对象的世界里，我们提倡万物皆对象，而在REST的世界里则是万物皆资源。<strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。</strong>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。</p>\n<h4 id=\"1-2-表现层\"><a href=\"#1-2-表现层\" class=\"headerlink\" title=\"1.2 表现层\"></a>1.2 表现层</h4><p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”</strong></p>\n<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>\n<h4 id=\"1-3-状态转化\"><a href=\"#1-3-状态转化\" class=\"headerlink\" title=\"1.3 状态转化\"></a>1.3 状态转化</h4><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>\n<p>当下的互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p>\n<p>在HTTP协议里面，就可以使用HTTP动词来对服务器端资源进行操作，实现“表现层状态转化”。如：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>\n<p>以网站中常见的用户CRUD操作为例：</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/REST/RESTful%20API.png\" alt></p>\n<p>现在，我们再回过头来理解REST(表现层状态转化)——REST是一种通过<strong>表现层</strong>来操作改变<strong>资源</strong>的<strong>状态</strong>的软件架构<strong>风格</strong>。</p>\n<h3 id=\"二、RESTful-API\"><a href=\"#二、RESTful-API\" class=\"headerlink\" title=\"二、RESTful API\"></a>二、RESTful API</h3><p>RESTful API 就是REST风格的API。它<strong>使用URI来描述资源，使用Html、Json、XML等格式表现，通过HTTP动词来操作资源来实现状态转化，使用HTTP状态码反映处理结果</strong>。</p>\n<h4 id=\"2-1-URI\"><a href=\"#2-1-URI\" class=\"headerlink\" title=\"2.1 URI\"></a>2.1 URI</h4><p>URI通常由三部分组成：</p>\n<ol>\n<li><p>访问资源的命名机制；</p>\n</li>\n<li><p>存放资源的主机名；</p>\n</li>\n<li><p>资源自身的名称。</p>\n</li>\n</ol>\n<p>例如:<a href=\"https://localhost/post/1\" target=\"_blank\" rel=\"noopener\">https://localhost/post/1</a> (对应URL<a href=\"https://localhost/post/1.html\" target=\"_blank\" rel=\"noopener\">https://localhost/post/1.html</a>)</p>\n<p>我们可以这样解释它：</p>\n<ol>\n<li><p>这是一个可以通过https协议访问的资源，</p>\n</li>\n<li><p>位于主机 localhost上，</p>\n</li>\n<li><p>通过“post/1”可以对该资源进行唯一标识（注意，这个不一定是完整的路径）</p>\n</li>\n</ol>\n<p>注意：以上三点只不过是对实例的解释，以上三点并不是URI的必要条件，URI只是一种概念，怎样实现无所谓，只要它唯一标识一个资源就可以了。URI只代表资源的实体，不代表它的形式。严格地说，如上面网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。</p>\n<h4 id=\"2-2-HTTP动词\"><a href=\"#2-2-HTTP动词\" class=\"headerlink\" title=\"2.2 HTTP动词\"></a>2.2 HTTP动词</h4><p>常用的HTTP动词有下面这些</p>\n<ul>\n<li>GET：从服务器取出资源（一项或多项）。——幂等</li>\n<li>POST：在服务器新建一个资源。——非幂等</li>\n<li>PUT：在服务器更新资源（客户端提供改变后的完整资源）。——幂等</li>\n<li>PATCH：在服务器更新资源（客户端提供改变的属性）。——幂等</li>\n<li>DELETE：从服务器删除资源。——幂等</li>\n</ul>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n<h4 id=\"2-3-HTTP状态码\"><a href=\"#2-3-HTTP状态码\" class=\"headerlink\" title=\"2.3 HTTP状态码\"></a>2.3 HTTP状态码</h4><p>HTTP协议本身就给我们提供了丰富的状态码，以用来反映服务器端处理的结果。而在真正使用中绝大对数人仅仅了解会使用200,404,500之流。这就好比36板斧，你始终是会那三板斧。而RESTful Api规范的HTTP状态码的使用，使HTTP协议的优点发挥到了极致。</p>\n<p>例如:</p>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n<p>注意:当状态码是4或5开头的时候就应该像用户返回错误信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    error: &quot;Invalid API key&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如下表是常用的HTTP状态码和描述</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>CODE</th>\n<th>HTTP Operation</th>\n<th>Body Contents</th>\n<th>Decription</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>GET,PUT</td>\n<td>资源</td>\n<td>操作成功</td>\n</tr>\n<tr>\n<td>201</td>\n<td>POST</td>\n<td>资源,元数据</td>\n<td>对象创建成功</td>\n</tr>\n<tr>\n<td>202</td>\n<td>POST,PUT,DELETE,PATCH</td>\n<td>N/A</td>\n<td>请求已被接受</td>\n</tr>\n<tr>\n<td>204</td>\n<td>DELETE,PUT,PATCH</td>\n<td>N/A</td>\n<td>操作已经执行成功，但是没有返回结果</td>\n</tr>\n<tr>\n<td>301</td>\n<td>GET</td>\n<td>link</td>\n<td>资源已被移除</td>\n</tr>\n<tr>\n<td>303</td>\n<td>GET</td>\n<td>link</td>\n<td>重定向</td>\n</tr>\n<tr>\n<td>304</td>\n<td>GET</td>\n<td>N/A</td>\n<td>资源没有被修改</td>\n</tr>\n<tr>\n<td>400</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>参数列表错误(缺少，格式不匹配)</td>\n</tr>\n<tr>\n<td>401</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>未授权</td>\n</tr>\n<tr>\n<td>403</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>访问受限，授权过期</td>\n</tr>\n<tr>\n<td>404</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>资源，服务未找到</td>\n</tr>\n<tr>\n<td>405</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>不允许的HTTP方法</td>\n</tr>\n<tr>\n<td>409</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>资源冲突，或资源被锁定</td>\n</tr>\n<tr>\n<td>415</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>不支持的数据(媒体)类型</td>\n</tr>\n<tr>\n<td>429</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>请求过多被限制</td>\n</tr>\n<tr>\n<td>500</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>系统内部错误</td>\n</tr>\n<tr>\n<td>501</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>接口未实现</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"2-4-示例\"><a href=\"#2-4-示例\" class=\"headerlink\" title=\"2.4.示例\"></a>2.4.示例</h4><p>我们以Web网站中常用的用户增删查改为例。设计普通的API接口完成增删查改大致如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//添加用户</span><br><span class=\"line\">http://localhost/createuser</span><br><span class=\"line\">//删除id为1的用户</span><br><span class=\"line\">http://localhost/deleteuser?userid=1</span><br><span class=\"line\">//获取用户列表</span><br><span class=\"line\">http://localhost/getuser</span><br><span class=\"line\">//获取id为1的用户</span><br><span class=\"line\">http://localhost/getuser?userid=1</span><br><span class=\"line\">//更新id为1的用户</span><br><span class=\"line\">http://localhost/updateuser?userid=1</span><br></pre></td></tr></table></figure>\n<p>我们通过调用上面不同的url传递响应的参数来完成用户的增删查改。</p>\n<p>而使用RESTful 风格的api该如何完成呢？</p>\n<p>在这个例子中很明显，用户就是我们的资源，使用uri来描述资源就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost/user</span><br></pre></td></tr></table></figure>\n<p>表现层可以是Json也可以是xml或者其它。</p>\n<p>我们使用HTTP的动词来操作用户这个资源。</p>\n<ul>\n<li>使用GET的方式请求<code>http://localhost/user</code>代表查询用户列表</li>\n<li>使用GET的方式请求<code>http://localhost/user/1</code>代表查询id为1的用户</li>\n<li>使用POST的方式请求<code>http://localhost/user</code>代表创建一个用户</li>\n<li>使用PUT的方式请求<code>http://localhost/user/1</code>代表修改id为1的用户</li>\n<li>使用DELETE的方式请求<code>http://localhost/user/1</code>代表删除id为1的用户。</li>\n</ul>\n<p>可以看到这种风格看起来要更为优雅与简洁，面向资源，一目了然，具有自解释性，充分的发挥了HTTP协议的优点。</p>\n<h4 id=\"2-5-设计上的难点和误区\"><a href=\"#2-5-设计上的难点和误区\" class=\"headerlink\" title=\"2.5 设计上的难点和误区\"></a>2.5 设计上的难点和误区</h4><h5 id=\"2-5-1-URI-包含动词\"><a href=\"#2-5-1-URI-包含动词\" class=\"headerlink\" title=\"2.5.1 URI 包含动词\"></a>2.5.1 URI 包含动词</h5><p>因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p>\n<p>举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p>\n<p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /accounts/1/transfer/500/to/2</span><br></pre></td></tr></table></figure>\n<p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /transaction HTTP/1.1</span><br><span class=\"line\">Host: 127.0.0.1</span><br><span class=\"line\"> 　　</span><br><span class=\"line\">from=1&amp;to=2&amp;amount=500.00</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-5-2-URI中加入版本号\"><a href=\"#2-5-2-URI中加入版本号\" class=\"headerlink\" title=\"2.5.2 URI中加入版本号\"></a>2.5.2 URI中加入版本号</h5><p><strong>另一个设计误区，就是在URI中加入版本号</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost/app/1.0/foo</span><br><span class=\"line\"></span><br><span class=\"line\">http://localhost/app/1.1/foo</span><br><span class=\"line\"></span><br><span class=\"line\">http://localhost/app/2.0/foo</span><br></pre></td></tr></table></figure></p>\n<p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href=\"http://www.informit.com/articles/article.aspx?p=1566460\" target=\"_blank\" rel=\"noopener\">Versioning REST Services</a>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept: localhost.foo+json; version=1.0</span><br><span class=\"line\"></span><br><span class=\"line\">Accept: localhost.foo+json; version=1.1</span><br><span class=\"line\"></span><br><span class=\"line\">Accept: localhostfoo+json; version=2.0</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-5-3-面向资源≠面向单表操作\"><a href=\"#2-5-3-面向资源≠面向单表操作\" class=\"headerlink\" title=\"2.5.3 面向资源≠面向单表操作\"></a>2.5.3 面向资源≠面向单表操作</h5><p>注意,面向资源不等于面向单表操作。不知道为什么很多人会把资源对应到数据库里的单张表。其实他们没有任何关系。资源可以是一个文件，可以是缓存里的数据，也可以是数据库里多张表聚合的结果。比如用户这个资源。通常我们设计数据库的时候出于性能或范式的考虑用户的信息不会放在一张表里。但是在API设计的时候用户就是一个资源，这个资源的数据有可能来自一张表也有可能是多张表，甚至缓存。</p>\n<h5 id=\"2-5-4-复杂与特殊的场景如何设计\"><a href=\"#2-5-4-复杂与特殊的场景如何设计\" class=\"headerlink\" title=\"2.5.4 复杂与特殊的场景如何设计\"></a>2.5.4 复杂与特殊的场景如何设计</h5><p>跟万物皆对象一样，使用「万物皆资源」的思想设计实际项目中的API时，经常会遇到一个问题就是「这玩意到底是个什么资源？………………算了，我就直接写吧，不管什么风格了」 </p>\n<ul>\n<li>比如，登录(login)和登出(logout)应该怎么REST化？ </li>\n<li>比如，多条件复合搜索条件太多在GET里写不下怎么办？ </li>\n<li>比如，批量资源的操作id躲到URL都写不下，难道要写几千个UPDATE或DELETE？  </li>\n</ul>\n<p>其实在真正理解了REST后，这些都不是什么无解的难题，如果无解，那只能说明你还没真正理解，抽象成资源的能力还不到家： </p>\n<ul>\n<li><p>登录(login)和登出(logout)其实本质上只是对session资源的创建和删除； </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//登录——使用HTTP POST请求</span><br><span class=\"line\">POST /localhost/session</span><br><span class=\"line\">//登出——使用HTTP DELETE请求</span><br><span class=\"line\">DELETE /localhost/session</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我们可以把search本身抽象成资源，使用POST创建，如果不需持久化，可以直接在Response中返回结果，如果需要（如翻页、长期缓存等），直接保存搜索结果并303跳转到资源地址就行了；</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//HTTP POST创建资源search</span><br><span class=\"line\">POST /localhost/search</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>批量操作id多到连url都写不下的请求，应该创建task，用GET返回task状态甚至执行进度；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//HTTP POST创建Task </span><br><span class=\"line\">POST /localhost/task</span><br><span class=\"line\"></span><br><span class=\"line\">//HTTP GET获取TASK执行结果</span><br><span class=\"line\">GET /localhost/task</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-6-优缺点与适用场景\"><a href=\"#2-6-优缺点与适用场景\" class=\"headerlink\" title=\"2.6 优缺点与适用场景\"></a>2.6 优缺点与适用场景</h4><p>任何一门技术或者思想都有其优缺点，虽然其诞生的初衷都是为了解决我们的问题，而不是带来更大的灾难。REST同样如此。它的优点很明显，优雅、规范，行为和资源分离，更容易理解。</p>\n<p>但是也有其缺点，它面向资源，这种设计思路是反程序员直觉的，因为在本地业务代码中仍然是一个个的函数，是动作，但表现在接口形式上则完全是资源的形式，对于后端开发人员要求高，有些业务逻辑难以被抽象为资源的增删改查。甚至有些时候RESTful其实是个效率很低的东西，为了实现一个资源，你需要定义它的一套方式，如果要联合查询又会要求对其衍生或定义一个新的资源。它提供的接口一般是“粗”粒度的，它通常返回的都是完整的数据模型，难以查询符合特殊要求的数据，有些特殊的业务要比普通的API需要更多次HTTP请求。</p>\n<p>REST面对的疑问跟当年刚开始流行面向对象时的情况是一样的。它适合很多情况，但并不适合所有情况。它更适合与一些开放平台API，如新浪微博、GitHub、京东、淘宝开放平台等，开放API之所以开放，就是因为它不知道你到底需要什么返回结果，既然不知道，那么我干脆都返回给你，有客户端自由组合成自己想要的数据。而对于内部开发，有其局限性，内部开发由于需求非常明确，有些时候出于性能或灵活性的考虑，服务端简单粗暴的丢出来完整的数据模型由客户端自己处理显然是不合适的。</p>\n<p>对于一些内部的开发，适合用RESTful API的我们仍然可以用，对于一些不合适的，我们仍然可以借鉴一些RESTFul中的优点，来设计我们的API。比如简洁的URI(每个人看到一坨超长的API地址，内心都是拒绝的)，充分利用HTTP状态码等。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>RESTful API是REST风格的API，它是一种API设计风格，规范了API设计中的一些原则。它让我们的API更加优雅、规范。但也尤其缺点，在实际使用过程中我们应该充分的取理解它，综合考量其使用场景。</p>\n<p>如果大家想要取学习并使用它，建议可以参考<a href=\"https://developer.github.com/v3/\" target=\"_blank\" rel=\"noopener\">Github开放API</a> 或者<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs.html\" target=\"_blank\" rel=\"noopener\">Elasticsearch API</a>,看一看他们是如何设计的API，对于自己项目中的每一个场景多思考，去网上一些开源RESTful API找一找有没有相同场景的例子。</p>\n<p>很多人会盲目追新，又对REST的概念和理念一知半解，最后搞出一个半吊子的怪胎，不仅没有设计出优雅规范的API，甚至还引起了更大的麻烦，最后还自我标榜用了流行的RESTful API。</p>\n<p>其实REST规范最终还是为了开发者和软件产品服务的，如果它能带来便利、减少混乱，就值得用；反之，如果带来的麻烦比解决的还多，跟风追流行就不可取了。其它任何技术也是如此！</p>\n","site":{"data":{}},"excerpt":"<p>近日妹子向我求助RESTful API到底是个什么东西。原因是她们公司一个新启动的项目因为RESTful API起了争执。服务端同学坚持要用RESTful API，而前端同学则认为服务端用RESTful API就会让前端的调用变得更麻烦。最终争议了一下午还是不了了之。有趣的是他们组的大部分人都不太了解REST是个什么东西。</p>","more":"<p>实际上一些抽象的东西是不如一些具体的技术好讲解的，就像你给新人讲面向对象一样，这东西得靠时间，靠悟。我之前做过开放平台API的项目。对于RESTful API还算有些了解。万幸没有丢人，口干舌燥之后总算讲明白一些。但这东西真正理解还得多悟、多思考、多练习。当然，如果你有更好的理解，可在评论区与我留言分享！我会第一时间反馈！</p>\n<h3 id=\"一、REST\"><a href=\"#一、REST\" class=\"headerlink\" title=\"一、REST\"></a>一、REST</h3><p>REST，即Representational State Transfer的缩写，翻译过来就是”表现层状态转化”。不得不承认，我在刚开始看到这个名词的时候是一脸懵逼。好了，现在我们放弃对这个名词的理解。</p>\n<p>实际上，REST只是一种软件架构风格。注意了，它并不是一种具体的技术。而更像是一种约束与规范性的东西，它包含了很多原则与限制。而如果一个架构符合REST的原则，就可以称它为RESTful架构。</p>\n<h4 id=\"1-1-资源\"><a href=\"#1-1-资源\" class=\"headerlink\" title=\"1.1 资源\"></a>1.1 资源</h4><p>在REST中最重要的一个概念就是<strong>资源</strong>。在面向对象的世界里，我们提倡万物皆对象，而在REST的世界里则是万物皆资源。<strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。</strong>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。</p>\n<h4 id=\"1-2-表现层\"><a href=\"#1-2-表现层\" class=\"headerlink\" title=\"1.2 表现层\"></a>1.2 表现层</h4><p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”</strong></p>\n<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>\n<h4 id=\"1-3-状态转化\"><a href=\"#1-3-状态转化\" class=\"headerlink\" title=\"1.3 状态转化\"></a>1.3 状态转化</h4><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>\n<p>当下的互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p>\n<p>在HTTP协议里面，就可以使用HTTP动词来对服务器端资源进行操作，实现“表现层状态转化”。如：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>\n<p>以网站中常见的用户CRUD操作为例：</p>\n<p><img src=\"https://hunter-image.oss-cn-beijing.aliyuncs.com/REST/RESTful%20API.png\" alt></p>\n<p>现在，我们再回过头来理解REST(表现层状态转化)——REST是一种通过<strong>表现层</strong>来操作改变<strong>资源</strong>的<strong>状态</strong>的软件架构<strong>风格</strong>。</p>\n<h3 id=\"二、RESTful-API\"><a href=\"#二、RESTful-API\" class=\"headerlink\" title=\"二、RESTful API\"></a>二、RESTful API</h3><p>RESTful API 就是REST风格的API。它<strong>使用URI来描述资源，使用Html、Json、XML等格式表现，通过HTTP动词来操作资源来实现状态转化，使用HTTP状态码反映处理结果</strong>。</p>\n<h4 id=\"2-1-URI\"><a href=\"#2-1-URI\" class=\"headerlink\" title=\"2.1 URI\"></a>2.1 URI</h4><p>URI通常由三部分组成：</p>\n<ol>\n<li><p>访问资源的命名机制；</p>\n</li>\n<li><p>存放资源的主机名；</p>\n</li>\n<li><p>资源自身的名称。</p>\n</li>\n</ol>\n<p>例如:<a href=\"https://localhost/post/1\" target=\"_blank\" rel=\"noopener\">https://localhost/post/1</a> (对应URL<a href=\"https://localhost/post/1.html\" target=\"_blank\" rel=\"noopener\">https://localhost/post/1.html</a>)</p>\n<p>我们可以这样解释它：</p>\n<ol>\n<li><p>这是一个可以通过https协议访问的资源，</p>\n</li>\n<li><p>位于主机 localhost上，</p>\n</li>\n<li><p>通过“post/1”可以对该资源进行唯一标识（注意，这个不一定是完整的路径）</p>\n</li>\n</ol>\n<p>注意：以上三点只不过是对实例的解释，以上三点并不是URI的必要条件，URI只是一种概念，怎样实现无所谓，只要它唯一标识一个资源就可以了。URI只代表资源的实体，不代表它的形式。严格地说，如上面网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。</p>\n<h4 id=\"2-2-HTTP动词\"><a href=\"#2-2-HTTP动词\" class=\"headerlink\" title=\"2.2 HTTP动词\"></a>2.2 HTTP动词</h4><p>常用的HTTP动词有下面这些</p>\n<ul>\n<li>GET：从服务器取出资源（一项或多项）。——幂等</li>\n<li>POST：在服务器新建一个资源。——非幂等</li>\n<li>PUT：在服务器更新资源（客户端提供改变后的完整资源）。——幂等</li>\n<li>PATCH：在服务器更新资源（客户端提供改变的属性）。——幂等</li>\n<li>DELETE：从服务器删除资源。——幂等</li>\n</ul>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n<h4 id=\"2-3-HTTP状态码\"><a href=\"#2-3-HTTP状态码\" class=\"headerlink\" title=\"2.3 HTTP状态码\"></a>2.3 HTTP状态码</h4><p>HTTP协议本身就给我们提供了丰富的状态码，以用来反映服务器端处理的结果。而在真正使用中绝大对数人仅仅了解会使用200,404,500之流。这就好比36板斧，你始终是会那三板斧。而RESTful Api规范的HTTP状态码的使用，使HTTP协议的优点发挥到了极致。</p>\n<p>例如:</p>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n<p>注意:当状态码是4或5开头的时候就应该像用户返回错误信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    error: &quot;Invalid API key&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如下表是常用的HTTP状态码和描述</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>CODE</th>\n<th>HTTP Operation</th>\n<th>Body Contents</th>\n<th>Decription</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>GET,PUT</td>\n<td>资源</td>\n<td>操作成功</td>\n</tr>\n<tr>\n<td>201</td>\n<td>POST</td>\n<td>资源,元数据</td>\n<td>对象创建成功</td>\n</tr>\n<tr>\n<td>202</td>\n<td>POST,PUT,DELETE,PATCH</td>\n<td>N/A</td>\n<td>请求已被接受</td>\n</tr>\n<tr>\n<td>204</td>\n<td>DELETE,PUT,PATCH</td>\n<td>N/A</td>\n<td>操作已经执行成功，但是没有返回结果</td>\n</tr>\n<tr>\n<td>301</td>\n<td>GET</td>\n<td>link</td>\n<td>资源已被移除</td>\n</tr>\n<tr>\n<td>303</td>\n<td>GET</td>\n<td>link</td>\n<td>重定向</td>\n</tr>\n<tr>\n<td>304</td>\n<td>GET</td>\n<td>N/A</td>\n<td>资源没有被修改</td>\n</tr>\n<tr>\n<td>400</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>参数列表错误(缺少，格式不匹配)</td>\n</tr>\n<tr>\n<td>401</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>未授权</td>\n</tr>\n<tr>\n<td>403</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>访问受限，授权过期</td>\n</tr>\n<tr>\n<td>404</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>资源，服务未找到</td>\n</tr>\n<tr>\n<td>405</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>不允许的HTTP方法</td>\n</tr>\n<tr>\n<td>409</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>资源冲突，或资源被锁定</td>\n</tr>\n<tr>\n<td>415</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>不支持的数据(媒体)类型</td>\n</tr>\n<tr>\n<td>429</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>请求过多被限制</td>\n</tr>\n<tr>\n<td>500</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>系统内部错误</td>\n</tr>\n<tr>\n<td>501</td>\n<td>GET,POST,PUT,DELETE,PATCH</td>\n<td>错误提示(消息)</td>\n<td>接口未实现</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"2-4-示例\"><a href=\"#2-4-示例\" class=\"headerlink\" title=\"2.4.示例\"></a>2.4.示例</h4><p>我们以Web网站中常用的用户增删查改为例。设计普通的API接口完成增删查改大致如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//添加用户</span><br><span class=\"line\">http://localhost/createuser</span><br><span class=\"line\">//删除id为1的用户</span><br><span class=\"line\">http://localhost/deleteuser?userid=1</span><br><span class=\"line\">//获取用户列表</span><br><span class=\"line\">http://localhost/getuser</span><br><span class=\"line\">//获取id为1的用户</span><br><span class=\"line\">http://localhost/getuser?userid=1</span><br><span class=\"line\">//更新id为1的用户</span><br><span class=\"line\">http://localhost/updateuser?userid=1</span><br></pre></td></tr></table></figure>\n<p>我们通过调用上面不同的url传递响应的参数来完成用户的增删查改。</p>\n<p>而使用RESTful 风格的api该如何完成呢？</p>\n<p>在这个例子中很明显，用户就是我们的资源，使用uri来描述资源就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost/user</span><br></pre></td></tr></table></figure>\n<p>表现层可以是Json也可以是xml或者其它。</p>\n<p>我们使用HTTP的动词来操作用户这个资源。</p>\n<ul>\n<li>使用GET的方式请求<code>http://localhost/user</code>代表查询用户列表</li>\n<li>使用GET的方式请求<code>http://localhost/user/1</code>代表查询id为1的用户</li>\n<li>使用POST的方式请求<code>http://localhost/user</code>代表创建一个用户</li>\n<li>使用PUT的方式请求<code>http://localhost/user/1</code>代表修改id为1的用户</li>\n<li>使用DELETE的方式请求<code>http://localhost/user/1</code>代表删除id为1的用户。</li>\n</ul>\n<p>可以看到这种风格看起来要更为优雅与简洁，面向资源，一目了然，具有自解释性，充分的发挥了HTTP协议的优点。</p>\n<h4 id=\"2-5-设计上的难点和误区\"><a href=\"#2-5-设计上的难点和误区\" class=\"headerlink\" title=\"2.5 设计上的难点和误区\"></a>2.5 设计上的难点和误区</h4><h5 id=\"2-5-1-URI-包含动词\"><a href=\"#2-5-1-URI-包含动词\" class=\"headerlink\" title=\"2.5.1 URI 包含动词\"></a>2.5.1 URI 包含动词</h5><p>因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p>\n<p>举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p>\n<p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /accounts/1/transfer/500/to/2</span><br></pre></td></tr></table></figure>\n<p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /transaction HTTP/1.1</span><br><span class=\"line\">Host: 127.0.0.1</span><br><span class=\"line\"> 　　</span><br><span class=\"line\">from=1&amp;to=2&amp;amount=500.00</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-5-2-URI中加入版本号\"><a href=\"#2-5-2-URI中加入版本号\" class=\"headerlink\" title=\"2.5.2 URI中加入版本号\"></a>2.5.2 URI中加入版本号</h5><p><strong>另一个设计误区，就是在URI中加入版本号</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost/app/1.0/foo</span><br><span class=\"line\"></span><br><span class=\"line\">http://localhost/app/1.1/foo</span><br><span class=\"line\"></span><br><span class=\"line\">http://localhost/app/2.0/foo</span><br></pre></td></tr></table></figure></p>\n<p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href=\"http://www.informit.com/articles/article.aspx?p=1566460\" target=\"_blank\" rel=\"noopener\">Versioning REST Services</a>）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept: localhost.foo+json; version=1.0</span><br><span class=\"line\"></span><br><span class=\"line\">Accept: localhost.foo+json; version=1.1</span><br><span class=\"line\"></span><br><span class=\"line\">Accept: localhostfoo+json; version=2.0</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-5-3-面向资源≠面向单表操作\"><a href=\"#2-5-3-面向资源≠面向单表操作\" class=\"headerlink\" title=\"2.5.3 面向资源≠面向单表操作\"></a>2.5.3 面向资源≠面向单表操作</h5><p>注意,面向资源不等于面向单表操作。不知道为什么很多人会把资源对应到数据库里的单张表。其实他们没有任何关系。资源可以是一个文件，可以是缓存里的数据，也可以是数据库里多张表聚合的结果。比如用户这个资源。通常我们设计数据库的时候出于性能或范式的考虑用户的信息不会放在一张表里。但是在API设计的时候用户就是一个资源，这个资源的数据有可能来自一张表也有可能是多张表，甚至缓存。</p>\n<h5 id=\"2-5-4-复杂与特殊的场景如何设计\"><a href=\"#2-5-4-复杂与特殊的场景如何设计\" class=\"headerlink\" title=\"2.5.4 复杂与特殊的场景如何设计\"></a>2.5.4 复杂与特殊的场景如何设计</h5><p>跟万物皆对象一样，使用「万物皆资源」的思想设计实际项目中的API时，经常会遇到一个问题就是「这玩意到底是个什么资源？………………算了，我就直接写吧，不管什么风格了」 </p>\n<ul>\n<li>比如，登录(login)和登出(logout)应该怎么REST化？ </li>\n<li>比如，多条件复合搜索条件太多在GET里写不下怎么办？ </li>\n<li>比如，批量资源的操作id躲到URL都写不下，难道要写几千个UPDATE或DELETE？  </li>\n</ul>\n<p>其实在真正理解了REST后，这些都不是什么无解的难题，如果无解，那只能说明你还没真正理解，抽象成资源的能力还不到家： </p>\n<ul>\n<li><p>登录(login)和登出(logout)其实本质上只是对session资源的创建和删除； </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//登录——使用HTTP POST请求</span><br><span class=\"line\">POST /localhost/session</span><br><span class=\"line\">//登出——使用HTTP DELETE请求</span><br><span class=\"line\">DELETE /localhost/session</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我们可以把search本身抽象成资源，使用POST创建，如果不需持久化，可以直接在Response中返回结果，如果需要（如翻页、长期缓存等），直接保存搜索结果并303跳转到资源地址就行了；</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//HTTP POST创建资源search</span><br><span class=\"line\">POST /localhost/search</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>批量操作id多到连url都写不下的请求，应该创建task，用GET返回task状态甚至执行进度；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//HTTP POST创建Task </span><br><span class=\"line\">POST /localhost/task</span><br><span class=\"line\"></span><br><span class=\"line\">//HTTP GET获取TASK执行结果</span><br><span class=\"line\">GET /localhost/task</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-6-优缺点与适用场景\"><a href=\"#2-6-优缺点与适用场景\" class=\"headerlink\" title=\"2.6 优缺点与适用场景\"></a>2.6 优缺点与适用场景</h4><p>任何一门技术或者思想都有其优缺点，虽然其诞生的初衷都是为了解决我们的问题，而不是带来更大的灾难。REST同样如此。它的优点很明显，优雅、规范，行为和资源分离，更容易理解。</p>\n<p>但是也有其缺点，它面向资源，这种设计思路是反程序员直觉的，因为在本地业务代码中仍然是一个个的函数，是动作，但表现在接口形式上则完全是资源的形式，对于后端开发人员要求高，有些业务逻辑难以被抽象为资源的增删改查。甚至有些时候RESTful其实是个效率很低的东西，为了实现一个资源，你需要定义它的一套方式，如果要联合查询又会要求对其衍生或定义一个新的资源。它提供的接口一般是“粗”粒度的，它通常返回的都是完整的数据模型，难以查询符合特殊要求的数据，有些特殊的业务要比普通的API需要更多次HTTP请求。</p>\n<p>REST面对的疑问跟当年刚开始流行面向对象时的情况是一样的。它适合很多情况，但并不适合所有情况。它更适合与一些开放平台API，如新浪微博、GitHub、京东、淘宝开放平台等，开放API之所以开放，就是因为它不知道你到底需要什么返回结果，既然不知道，那么我干脆都返回给你，有客户端自由组合成自己想要的数据。而对于内部开发，有其局限性，内部开发由于需求非常明确，有些时候出于性能或灵活性的考虑，服务端简单粗暴的丢出来完整的数据模型由客户端自己处理显然是不合适的。</p>\n<p>对于一些内部的开发，适合用RESTful API的我们仍然可以用，对于一些不合适的，我们仍然可以借鉴一些RESTFul中的优点，来设计我们的API。比如简洁的URI(每个人看到一坨超长的API地址，内心都是拒绝的)，充分利用HTTP状态码等。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>RESTful API是REST风格的API，它是一种API设计风格，规范了API设计中的一些原则。它让我们的API更加优雅、规范。但也尤其缺点，在实际使用过程中我们应该充分的取理解它，综合考量其使用场景。</p>\n<p>如果大家想要取学习并使用它，建议可以参考<a href=\"https://developer.github.com/v3/\" target=\"_blank\" rel=\"noopener\">Github开放API</a> 或者<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs.html\" target=\"_blank\" rel=\"noopener\">Elasticsearch API</a>,看一看他们是如何设计的API，对于自己项目中的每一个场景多思考，去网上一些开源RESTful API找一找有没有相同场景的例子。</p>\n<p>很多人会盲目追新，又对REST的概念和理念一知半解，最后搞出一个半吊子的怪胎，不仅没有设计出优雅规范的API，甚至还引起了更大的麻烦，最后还自我标榜用了流行的RESTful API。</p>\n<p>其实REST规范最终还是为了开发者和软件产品服务的，如果它能带来便利、减少混乱，就值得用；反之，如果带来的麻烦比解决的还多，跟风追流行就不可取了。其它任何技术也是如此！</p>"},{"title":"单元测试基础","copyright":true,"date":"2021-01-06T01:29:26.000Z","keywords":"单元测试","_content":"### 1.什么是单元测试\n#### 1.1单元测试的定义\n单元测试就是针对一个工作单元设计的测试，这里的“工作单元”是指对一个工作方法的要求。\n单元测试是开发者编写的一小段代码，用于检测被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试用于判断某个特定条件(或场景)下某个特定函数的行为。\n\n<!--more-->\n\n例：\n你可能把一个很大的值放入一个有序list中去，然后确认该值出现在list的尾部。或者，你可能会从字符串中删除匹配某种模式的字符，然后确认字符串确实不再包含这些字符了。\n**执行单元测试，就是为了证明某段代码的行为和开发者所期望的一致！**\n\n```csharp\n  //被测方法\n  public double Add(double a, double b)\n  {\n      return a + b;\n  }      \n  \n  //测试方法\n  [Test]\n  public void AddTest()\n  {\n      double result = new Calculator().Add(14, 15);\n      Assert.AreEqual(30,result);\n  }    \n```\n#### 1.2工作单元\n调用系统的一个公共方法到产生一个测试可见的最终结果,其间这个系统发生的行为总称为一个工作单元。我们通过系统的公共AP和行为就可以观察到一个可见的最终结果,无需查看系统的内部状态。一个最终结果可以是以下任何一种形式。\n\n1. 被调用的公共方法回一个值(一个返回值不为空的函数)\n1. 在方法调用的前后,系统的状态或行为有可见的变化,这种变化无需查询私有状态即可判断。(例如:一个以前不存在的用户可以登入系统,或者一个状态机系统的属性发生变化。)\n1. 调用了一个不受测试控制的第三方系统,这个第三方系统不返回任何值,或者返回值都被忽略。(例如:调用一个第三方日志系统,这个系统不是你编写的,而且你也没有源代码。)\n\n\n\n很多人觉得被测试的工作单元应该尽可能的小。我却不这么看，我认为工作单元这个概念意味着一个单元既可以小到只包含一个方法,也可以大到包括实现某个功能的多个类和函数。如果你的工作单元很大，却但是其最终结果对用户可见度高，易于维护也未尝不是好的测试，相反如果试图把工作单元缩到最小,最后会不得不伪造一堆东西反而会增加测试的复杂度，适得其反。\n### 2.什么不是单元测试\n单元测试其实是一门很基础也很简单的技术，然而在单元测试实践过程中，往往会对单元测试产生一些误区，进而写出一些不是单元测试的\"单元测试\" ，其中常见的主要有以下三种。\n#### 2.1 跨边界的测试\n单元测试背后的思想是，仅测试这个方法中的内容，测试失败时不希望必须穿过基层代码、数据库表或者第三方产品的文档去寻找可能的答案！\n当测试开始渗透到其他类、服务或系统时，此时测试便跨越了边界，失败时会很难找到缺陷的代码。\n测试跨边界时还会产生另一个问题，当边界是一个共享资源时，如数据库。与团队的其他开发人员共享资源时，可能会污染他们的测试结果！\n#### 2.2 不具有针对性的测试\n如果发现所编写的测试对一件以上的事情进行了测试，就可能违反了“单一职责原则”。从单元测试的角度来看，这意味着这些测试是难以理解的非针对性测试。随着时间的推移，向类或方法种添加了更多的不恰当的功能后，这些测试可能会变的非常脆弱。诊断问题也将变得极具有挑战性。\n如：StringUtility中计算一个特定字符在字符串中出现的次数，它没有说明这个字符在字符串中处于什么位置也没有说明除了这个字符出现多少次之外的其他任何信息，那么这些功能就应该由StringUtility类的其它方法提供！同样，StringUtility类也不应该处理数字、日期或复杂数据类型的功能！\n#### 2.3 不可预测的测试\n单元测试应当是可预测的。在针对一组给定的输入参数调用一个类的方法时，其结果应当总是一致的。有时，这一原则可能看起来很难遵守。例如：正在编写一个日用品交易程序，黄金的价格可能上午九时是一个值，14时就会变成另一个值。\n而好的设计原则就是将不可预测的数据的功能抽象到一个可以在单元测试中模拟(Mock)的类或方法中\n\n#### 2.4 集成测试\n其实上面三种测试已经到了集成测试的领域。任何测试,如果它运行速度不快,结果不稳定,或者要用到被测试单元的一个或多个真实依赖物,我们就认为它是集成测试。\n集成测试是对一个工作单元进行的测试,这个测试对被测试的工作单元没有完全的控制,并使用该单元的一个或多个真实依赖物,例如时间、网络、数据库、线程或随机数产生器等。\n集成测试本身并不是一种坏事，反而其具有和单元测试一样高的地位，但是在实践过程中我们把集成测试和单元测试分离开来还是很重要的。\n### 3.优秀的单元测试有哪些特性\n单元测试是非常有魔力的魔法，也是一把双刃剑。使用得当，可以很有效的提高我们的编码质量，提升研发效率，但是如果使用不恰当亦会浪费大量的时间在测试编码、维护和调试上从而影响代码和整个项目，徒劳而无功！\n因此做好单元测试至关重要！而想要做好单元测试，我们首先应该知道优秀的单元测试有哪些特性。\n一个好的单元测试一定是有以下几个特性的\n•  自动化  \n•  彻底的\n•  可重复的\n•  独立的\n•  专业的\n回顾一下自己以前写过的单元测试问自己几个问题。\n\n1. 它是不是可以自动化一键运行、并且可以重复运行\n\n1. 几个月后它是不是仍可以运行、并且得到期望的结果\n\n1. 它是否可以在几分钟内运行结束\n\n1. 在运行之前你是否不需要需要进行一系列的配置\n\n1. 每次运行是否能够得到相同的结果\n\n1. 外部的系统因素是否不会影响你的测试结果\n\n1. 测试代码是否很简单就可以编写完成\n\n如果针对以上问题有任何一个的回答是“否”，那么你应该好好的思考一下到底如何去做好单元测试。\n### 4. 如何进行单元测试\n对于一个方法或者类，乍一看就能找出其隐藏深处的bug是很不容易的，因此在bug挖掘方面通常会有一些经验和套路，来指导我们更好的进行单元测试。\n#### 3.1 测试哪些内容\n 一般来说有六个值得测试的具体方面，可以把这六个方面统称为Right-BICEP:\n\n- Right——结果\n对于单元测试测试而言,首要的也是最明显的任务就是查看所期望的结果是否正确，例如判断一个方法的返回值是否为序列中的最大值...... \n- B——边界条件\n找边界条件是做单元测试中最有价值的工作之一,因为bug一般就出现在边界上。关于边界条件2会有详细总结\n- I——检查反向关联\n对于一些方法,我们可以使用反向的逻辑关系来验证它们。例如,你可以用对结果进行平方的方式来检查一个计算平方根的函数,然后测试结果是否和原数据很接近\n- C——交叉检查\n有些时候我们实现一个问题会有不同的算法，在生产系统中我们使用一种算法，而在测试中我们可以使用另一种算法来验证其结果是否一致。\n- E——强制产生错误条件\n在实际运行过程中,有时候会发生一些意外的难以避免的错误，例如磁盘会满,网络连线会断开.....从而导致程序崩溃。我们应该在测试中强制引发错误,来测试代码是否能够按照预期处理这些异常。\n- P——是否满足性能条件\n性能同样是我们测试过程中需要验证的指标\n#### 3.2 注意边界条件\n    代码中的许多Bug经常出现在边界条件附近，对于边界条件的测试我们可以从CORRECT七个方面进行考虑\n\n- 一致性----值是否满足预期的格式\n- 有序性----一组值是否满足预期的排序要求\n- 区间性----值是否在一个合理的最大值最小值范围内\n- 引用、耦合性----代码是否引用了一些不受代码本身直接控制的外部因素\n- 存在性----值是否存在（例如：非Null，非零，存在于某个集合中）\n- 基数性----是否恰好具有足够的值\n- 时间性----所有事情是否都按照顺序发生的？是否在正确的时间、是否及时\n\n#### 3.3 使用Mock对象\n   单元测试的目标是验证我们的工作单元，但是如果这个工作单元依赖一些其他的对象或是一些难以操控的东西，比如网络、数据库等。这时我们就要使用mock对象，使得在运行UT的时候使用的那些难以操控的东西实际上是我们mock的对象，而我们mock的对象则可以按照我们的意愿返回一些值用于测试。通俗来讲，Mock对象就是真实对象在我们调试期间的测试品。**对于外部对象内的逻辑我们并不关心，我们只需要让它给我们返回我们想要的值，来验证我们的业务逻辑即可**\n```csharp\nIFileExtensionManager fileManager;\n\npublic bool IsValidFileName(){\n    //获取文件扩展名\n    string extName=fileManager.GetExtName();\n    if(extName==\"jpg\"){\n        return true;\n    }\n    return false;\n}\n```\n如上示例，假设从文件系统中读取一个文件，获取文件的扩展名，如果扩展名是jpg就返回true，否则返回false。\n注意，这里我们要测试的逻辑是如果扩展名是jpg就返回true，否则返回false。而对于fileManager.GetExtName()方法内部的逻辑是什么样的的我们是不关心的，我们只需要mock这个方法使其返回我们想要的值就可以了。\n关于具体如何去mock工作单元中的一些外部依赖，会在存根与模拟对象里面详细进行总结。\n### 总结\n本文总结了什么是单元测试、什么不是单元测试以及优秀的单元测试有哪些特性，简单介绍了如何进行单元测试。\n编写差劲的单元测试是没有意义的，我看到过很多公司尝试去实践单元测试，但最终要么在某个阶段放弃了,要么并没有真正执行单元测试。最终还是依赖集成测试或者人工测试来发现问题，不得不以失败而告终，并堂而皇之的认为单元测试是一个耗时好力而无功的鸡肋东西。\n因此如果你想要真正的去实践单元测试，那么必须充分的理解到底什么是单元测试，已经如何去更好的进行实践优秀的单元测试。\n而对于如何更好的去实践单元测试，后续会结合实践用更多的篇幅去总结分享。\n","source":"_posts/技术实践/单元测试/单元测试基础.md","raw":"---\ntitle: 单元测试基础\ncopyright: true\ndate: 2021-01-06 09:29:26\ntags: \n- 单元测试\ncategories: \n- 单元测试\nkeywords: 单元测试\n---\n### 1.什么是单元测试\n#### 1.1单元测试的定义\n单元测试就是针对一个工作单元设计的测试，这里的“工作单元”是指对一个工作方法的要求。\n单元测试是开发者编写的一小段代码，用于检测被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试用于判断某个特定条件(或场景)下某个特定函数的行为。\n\n<!--more-->\n\n例：\n你可能把一个很大的值放入一个有序list中去，然后确认该值出现在list的尾部。或者，你可能会从字符串中删除匹配某种模式的字符，然后确认字符串确实不再包含这些字符了。\n**执行单元测试，就是为了证明某段代码的行为和开发者所期望的一致！**\n\n```csharp\n  //被测方法\n  public double Add(double a, double b)\n  {\n      return a + b;\n  }      \n  \n  //测试方法\n  [Test]\n  public void AddTest()\n  {\n      double result = new Calculator().Add(14, 15);\n      Assert.AreEqual(30,result);\n  }    \n```\n#### 1.2工作单元\n调用系统的一个公共方法到产生一个测试可见的最终结果,其间这个系统发生的行为总称为一个工作单元。我们通过系统的公共AP和行为就可以观察到一个可见的最终结果,无需查看系统的内部状态。一个最终结果可以是以下任何一种形式。\n\n1. 被调用的公共方法回一个值(一个返回值不为空的函数)\n1. 在方法调用的前后,系统的状态或行为有可见的变化,这种变化无需查询私有状态即可判断。(例如:一个以前不存在的用户可以登入系统,或者一个状态机系统的属性发生变化。)\n1. 调用了一个不受测试控制的第三方系统,这个第三方系统不返回任何值,或者返回值都被忽略。(例如:调用一个第三方日志系统,这个系统不是你编写的,而且你也没有源代码。)\n\n\n\n很多人觉得被测试的工作单元应该尽可能的小。我却不这么看，我认为工作单元这个概念意味着一个单元既可以小到只包含一个方法,也可以大到包括实现某个功能的多个类和函数。如果你的工作单元很大，却但是其最终结果对用户可见度高，易于维护也未尝不是好的测试，相反如果试图把工作单元缩到最小,最后会不得不伪造一堆东西反而会增加测试的复杂度，适得其反。\n### 2.什么不是单元测试\n单元测试其实是一门很基础也很简单的技术，然而在单元测试实践过程中，往往会对单元测试产生一些误区，进而写出一些不是单元测试的\"单元测试\" ，其中常见的主要有以下三种。\n#### 2.1 跨边界的测试\n单元测试背后的思想是，仅测试这个方法中的内容，测试失败时不希望必须穿过基层代码、数据库表或者第三方产品的文档去寻找可能的答案！\n当测试开始渗透到其他类、服务或系统时，此时测试便跨越了边界，失败时会很难找到缺陷的代码。\n测试跨边界时还会产生另一个问题，当边界是一个共享资源时，如数据库。与团队的其他开发人员共享资源时，可能会污染他们的测试结果！\n#### 2.2 不具有针对性的测试\n如果发现所编写的测试对一件以上的事情进行了测试，就可能违反了“单一职责原则”。从单元测试的角度来看，这意味着这些测试是难以理解的非针对性测试。随着时间的推移，向类或方法种添加了更多的不恰当的功能后，这些测试可能会变的非常脆弱。诊断问题也将变得极具有挑战性。\n如：StringUtility中计算一个特定字符在字符串中出现的次数，它没有说明这个字符在字符串中处于什么位置也没有说明除了这个字符出现多少次之外的其他任何信息，那么这些功能就应该由StringUtility类的其它方法提供！同样，StringUtility类也不应该处理数字、日期或复杂数据类型的功能！\n#### 2.3 不可预测的测试\n单元测试应当是可预测的。在针对一组给定的输入参数调用一个类的方法时，其结果应当总是一致的。有时，这一原则可能看起来很难遵守。例如：正在编写一个日用品交易程序，黄金的价格可能上午九时是一个值，14时就会变成另一个值。\n而好的设计原则就是将不可预测的数据的功能抽象到一个可以在单元测试中模拟(Mock)的类或方法中\n\n#### 2.4 集成测试\n其实上面三种测试已经到了集成测试的领域。任何测试,如果它运行速度不快,结果不稳定,或者要用到被测试单元的一个或多个真实依赖物,我们就认为它是集成测试。\n集成测试是对一个工作单元进行的测试,这个测试对被测试的工作单元没有完全的控制,并使用该单元的一个或多个真实依赖物,例如时间、网络、数据库、线程或随机数产生器等。\n集成测试本身并不是一种坏事，反而其具有和单元测试一样高的地位，但是在实践过程中我们把集成测试和单元测试分离开来还是很重要的。\n### 3.优秀的单元测试有哪些特性\n单元测试是非常有魔力的魔法，也是一把双刃剑。使用得当，可以很有效的提高我们的编码质量，提升研发效率，但是如果使用不恰当亦会浪费大量的时间在测试编码、维护和调试上从而影响代码和整个项目，徒劳而无功！\n因此做好单元测试至关重要！而想要做好单元测试，我们首先应该知道优秀的单元测试有哪些特性。\n一个好的单元测试一定是有以下几个特性的\n•  自动化  \n•  彻底的\n•  可重复的\n•  独立的\n•  专业的\n回顾一下自己以前写过的单元测试问自己几个问题。\n\n1. 它是不是可以自动化一键运行、并且可以重复运行\n\n1. 几个月后它是不是仍可以运行、并且得到期望的结果\n\n1. 它是否可以在几分钟内运行结束\n\n1. 在运行之前你是否不需要需要进行一系列的配置\n\n1. 每次运行是否能够得到相同的结果\n\n1. 外部的系统因素是否不会影响你的测试结果\n\n1. 测试代码是否很简单就可以编写完成\n\n如果针对以上问题有任何一个的回答是“否”，那么你应该好好的思考一下到底如何去做好单元测试。\n### 4. 如何进行单元测试\n对于一个方法或者类，乍一看就能找出其隐藏深处的bug是很不容易的，因此在bug挖掘方面通常会有一些经验和套路，来指导我们更好的进行单元测试。\n#### 3.1 测试哪些内容\n 一般来说有六个值得测试的具体方面，可以把这六个方面统称为Right-BICEP:\n\n- Right——结果\n对于单元测试测试而言,首要的也是最明显的任务就是查看所期望的结果是否正确，例如判断一个方法的返回值是否为序列中的最大值...... \n- B——边界条件\n找边界条件是做单元测试中最有价值的工作之一,因为bug一般就出现在边界上。关于边界条件2会有详细总结\n- I——检查反向关联\n对于一些方法,我们可以使用反向的逻辑关系来验证它们。例如,你可以用对结果进行平方的方式来检查一个计算平方根的函数,然后测试结果是否和原数据很接近\n- C——交叉检查\n有些时候我们实现一个问题会有不同的算法，在生产系统中我们使用一种算法，而在测试中我们可以使用另一种算法来验证其结果是否一致。\n- E——强制产生错误条件\n在实际运行过程中,有时候会发生一些意外的难以避免的错误，例如磁盘会满,网络连线会断开.....从而导致程序崩溃。我们应该在测试中强制引发错误,来测试代码是否能够按照预期处理这些异常。\n- P——是否满足性能条件\n性能同样是我们测试过程中需要验证的指标\n#### 3.2 注意边界条件\n    代码中的许多Bug经常出现在边界条件附近，对于边界条件的测试我们可以从CORRECT七个方面进行考虑\n\n- 一致性----值是否满足预期的格式\n- 有序性----一组值是否满足预期的排序要求\n- 区间性----值是否在一个合理的最大值最小值范围内\n- 引用、耦合性----代码是否引用了一些不受代码本身直接控制的外部因素\n- 存在性----值是否存在（例如：非Null，非零，存在于某个集合中）\n- 基数性----是否恰好具有足够的值\n- 时间性----所有事情是否都按照顺序发生的？是否在正确的时间、是否及时\n\n#### 3.3 使用Mock对象\n   单元测试的目标是验证我们的工作单元，但是如果这个工作单元依赖一些其他的对象或是一些难以操控的东西，比如网络、数据库等。这时我们就要使用mock对象，使得在运行UT的时候使用的那些难以操控的东西实际上是我们mock的对象，而我们mock的对象则可以按照我们的意愿返回一些值用于测试。通俗来讲，Mock对象就是真实对象在我们调试期间的测试品。**对于外部对象内的逻辑我们并不关心，我们只需要让它给我们返回我们想要的值，来验证我们的业务逻辑即可**\n```csharp\nIFileExtensionManager fileManager;\n\npublic bool IsValidFileName(){\n    //获取文件扩展名\n    string extName=fileManager.GetExtName();\n    if(extName==\"jpg\"){\n        return true;\n    }\n    return false;\n}\n```\n如上示例，假设从文件系统中读取一个文件，获取文件的扩展名，如果扩展名是jpg就返回true，否则返回false。\n注意，这里我们要测试的逻辑是如果扩展名是jpg就返回true，否则返回false。而对于fileManager.GetExtName()方法内部的逻辑是什么样的的我们是不关心的，我们只需要mock这个方法使其返回我们想要的值就可以了。\n关于具体如何去mock工作单元中的一些外部依赖，会在存根与模拟对象里面详细进行总结。\n### 总结\n本文总结了什么是单元测试、什么不是单元测试以及优秀的单元测试有哪些特性，简单介绍了如何进行单元测试。\n编写差劲的单元测试是没有意义的，我看到过很多公司尝试去实践单元测试，但最终要么在某个阶段放弃了,要么并没有真正执行单元测试。最终还是依赖集成测试或者人工测试来发现问题，不得不以失败而告终，并堂而皇之的认为单元测试是一个耗时好力而无功的鸡肋东西。\n因此如果你想要真正的去实践单元测试，那么必须充分的理解到底什么是单元测试，已经如何去更好的进行实践优秀的单元测试。\n而对于如何更好的去实践单元测试，后续会结合实践用更多的篇幅去总结分享。\n","slug":"技术实践/单元测试/单元测试基础","published":1,"updated":"2021-03-21T08:32:18.639Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfq0000f9hyjfueho52d7","content":"<h3 id=\"1-什么是单元测试\"><a href=\"#1-什么是单元测试\" class=\"headerlink\" title=\"1.什么是单元测试\"></a>1.什么是单元测试</h3><h4 id=\"1-1单元测试的定义\"><a href=\"#1-1单元测试的定义\" class=\"headerlink\" title=\"1.1单元测试的定义\"></a>1.1单元测试的定义</h4><p>单元测试就是针对一个工作单元设计的测试，这里的“工作单元”是指对一个工作方法的要求。<br>单元测试是开发者编写的一小段代码，用于检测被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试用于判断某个特定条件(或场景)下某个特定函数的行为。</p>\n<a id=\"more\"></a>\n<p>例：<br>你可能把一个很大的值放入一个有序list中去，然后确认该值出现在list的尾部。或者，你可能会从字符串中删除匹配某种模式的字符，然后确认字符串确实不再包含这些字符了。<br><strong>执行单元测试，就是为了证明某段代码的行为和开发者所期望的一致！</strong></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//被测方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">Add</span>(<span class=\"params\"><span class=\"keyword\">double</span> a, <span class=\"keyword\">double</span> b</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试方法</span></span><br><span class=\"line\">[<span class=\"meta\">Test</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AddTest</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> result = <span class=\"keyword\">new</span> Calculator().Add(<span class=\"number\">14</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">    Assert.AreEqual(<span class=\"number\">30</span>,result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-2工作单元\"><a href=\"#1-2工作单元\" class=\"headerlink\" title=\"1.2工作单元\"></a>1.2工作单元</h4><p>调用系统的一个公共方法到产生一个测试可见的最终结果,其间这个系统发生的行为总称为一个工作单元。我们通过系统的公共AP和行为就可以观察到一个可见的最终结果,无需查看系统的内部状态。一个最终结果可以是以下任何一种形式。</p>\n<ol>\n<li>被调用的公共方法回一个值(一个返回值不为空的函数)</li>\n<li>在方法调用的前后,系统的状态或行为有可见的变化,这种变化无需查询私有状态即可判断。(例如:一个以前不存在的用户可以登入系统,或者一个状态机系统的属性发生变化。)</li>\n<li>调用了一个不受测试控制的第三方系统,这个第三方系统不返回任何值,或者返回值都被忽略。(例如:调用一个第三方日志系统,这个系统不是你编写的,而且你也没有源代码。)</li>\n</ol>\n<p>很多人觉得被测试的工作单元应该尽可能的小。我却不这么看，我认为工作单元这个概念意味着一个单元既可以小到只包含一个方法,也可以大到包括实现某个功能的多个类和函数。如果你的工作单元很大，却但是其最终结果对用户可见度高，易于维护也未尝不是好的测试，相反如果试图把工作单元缩到最小,最后会不得不伪造一堆东西反而会增加测试的复杂度，适得其反。</p>\n<h3 id=\"2-什么不是单元测试\"><a href=\"#2-什么不是单元测试\" class=\"headerlink\" title=\"2.什么不是单元测试\"></a>2.什么不是单元测试</h3><p>单元测试其实是一门很基础也很简单的技术，然而在单元测试实践过程中，往往会对单元测试产生一些误区，进而写出一些不是单元测试的”单元测试” ，其中常见的主要有以下三种。</p>\n<h4 id=\"2-1-跨边界的测试\"><a href=\"#2-1-跨边界的测试\" class=\"headerlink\" title=\"2.1 跨边界的测试\"></a>2.1 跨边界的测试</h4><p>单元测试背后的思想是，仅测试这个方法中的内容，测试失败时不希望必须穿过基层代码、数据库表或者第三方产品的文档去寻找可能的答案！<br>当测试开始渗透到其他类、服务或系统时，此时测试便跨越了边界，失败时会很难找到缺陷的代码。<br>测试跨边界时还会产生另一个问题，当边界是一个共享资源时，如数据库。与团队的其他开发人员共享资源时，可能会污染他们的测试结果！</p>\n<h4 id=\"2-2-不具有针对性的测试\"><a href=\"#2-2-不具有针对性的测试\" class=\"headerlink\" title=\"2.2 不具有针对性的测试\"></a>2.2 不具有针对性的测试</h4><p>如果发现所编写的测试对一件以上的事情进行了测试，就可能违反了“单一职责原则”。从单元测试的角度来看，这意味着这些测试是难以理解的非针对性测试。随着时间的推移，向类或方法种添加了更多的不恰当的功能后，这些测试可能会变的非常脆弱。诊断问题也将变得极具有挑战性。<br>如：StringUtility中计算一个特定字符在字符串中出现的次数，它没有说明这个字符在字符串中处于什么位置也没有说明除了这个字符出现多少次之外的其他任何信息，那么这些功能就应该由StringUtility类的其它方法提供！同样，StringUtility类也不应该处理数字、日期或复杂数据类型的功能！</p>\n<h4 id=\"2-3-不可预测的测试\"><a href=\"#2-3-不可预测的测试\" class=\"headerlink\" title=\"2.3 不可预测的测试\"></a>2.3 不可预测的测试</h4><p>单元测试应当是可预测的。在针对一组给定的输入参数调用一个类的方法时，其结果应当总是一致的。有时，这一原则可能看起来很难遵守。例如：正在编写一个日用品交易程序，黄金的价格可能上午九时是一个值，14时就会变成另一个值。<br>而好的设计原则就是将不可预测的数据的功能抽象到一个可以在单元测试中模拟(Mock)的类或方法中</p>\n<h4 id=\"2-4-集成测试\"><a href=\"#2-4-集成测试\" class=\"headerlink\" title=\"2.4 集成测试\"></a>2.4 集成测试</h4><p>其实上面三种测试已经到了集成测试的领域。任何测试,如果它运行速度不快,结果不稳定,或者要用到被测试单元的一个或多个真实依赖物,我们就认为它是集成测试。<br>集成测试是对一个工作单元进行的测试,这个测试对被测试的工作单元没有完全的控制,并使用该单元的一个或多个真实依赖物,例如时间、网络、数据库、线程或随机数产生器等。<br>集成测试本身并不是一种坏事，反而其具有和单元测试一样高的地位，但是在实践过程中我们把集成测试和单元测试分离开来还是很重要的。</p>\n<h3 id=\"3-优秀的单元测试有哪些特性\"><a href=\"#3-优秀的单元测试有哪些特性\" class=\"headerlink\" title=\"3.优秀的单元测试有哪些特性\"></a>3.优秀的单元测试有哪些特性</h3><p>单元测试是非常有魔力的魔法，也是一把双刃剑。使用得当，可以很有效的提高我们的编码质量，提升研发效率，但是如果使用不恰当亦会浪费大量的时间在测试编码、维护和调试上从而影响代码和整个项目，徒劳而无功！<br>因此做好单元测试至关重要！而想要做好单元测试，我们首先应该知道优秀的单元测试有哪些特性。<br>一个好的单元测试一定是有以下几个特性的<br>•  自动化<br>•  彻底的<br>•  可重复的<br>•  独立的<br>•  专业的<br>回顾一下自己以前写过的单元测试问自己几个问题。</p>\n<ol>\n<li><p>它是不是可以自动化一键运行、并且可以重复运行</p>\n</li>\n<li><p>几个月后它是不是仍可以运行、并且得到期望的结果</p>\n</li>\n<li><p>它是否可以在几分钟内运行结束</p>\n</li>\n<li><p>在运行之前你是否不需要需要进行一系列的配置</p>\n</li>\n<li><p>每次运行是否能够得到相同的结果</p>\n</li>\n<li><p>外部的系统因素是否不会影响你的测试结果</p>\n</li>\n<li><p>测试代码是否很简单就可以编写完成</p>\n</li>\n</ol>\n<p>如果针对以上问题有任何一个的回答是“否”，那么你应该好好的思考一下到底如何去做好单元测试。</p>\n<h3 id=\"4-如何进行单元测试\"><a href=\"#4-如何进行单元测试\" class=\"headerlink\" title=\"4. 如何进行单元测试\"></a>4. 如何进行单元测试</h3><p>对于一个方法或者类，乍一看就能找出其隐藏深处的bug是很不容易的，因此在bug挖掘方面通常会有一些经验和套路，来指导我们更好的进行单元测试。</p>\n<h4 id=\"3-1-测试哪些内容\"><a href=\"#3-1-测试哪些内容\" class=\"headerlink\" title=\"3.1 测试哪些内容\"></a>3.1 测试哪些内容</h4><p> 一般来说有六个值得测试的具体方面，可以把这六个方面统称为Right-BICEP:</p>\n<ul>\n<li>Right——结果<br>对于单元测试测试而言,首要的也是最明显的任务就是查看所期望的结果是否正确，例如判断一个方法的返回值是否为序列中的最大值…… </li>\n<li>B——边界条件<br>找边界条件是做单元测试中最有价值的工作之一,因为bug一般就出现在边界上。关于边界条件2会有详细总结</li>\n<li>I——检查反向关联<br>对于一些方法,我们可以使用反向的逻辑关系来验证它们。例如,你可以用对结果进行平方的方式来检查一个计算平方根的函数,然后测试结果是否和原数据很接近</li>\n<li>C——交叉检查<br>有些时候我们实现一个问题会有不同的算法，在生产系统中我们使用一种算法，而在测试中我们可以使用另一种算法来验证其结果是否一致。</li>\n<li>E——强制产生错误条件<br>在实际运行过程中,有时候会发生一些意外的难以避免的错误，例如磁盘会满,网络连线会断开…..从而导致程序崩溃。我们应该在测试中强制引发错误,来测试代码是否能够按照预期处理这些异常。</li>\n<li><p>P——是否满足性能条件<br>性能同样是我们测试过程中需要验证的指标</p>\n<h4 id=\"3-2-注意边界条件\"><a href=\"#3-2-注意边界条件\" class=\"headerlink\" title=\"3.2 注意边界条件\"></a>3.2 注意边界条件</h4><p>  代码中的许多Bug经常出现在边界条件附近，对于边界条件的测试我们可以从CORRECT七个方面进行考虑</p>\n</li>\n<li><p>一致性——值是否满足预期的格式</p>\n</li>\n<li>有序性——一组值是否满足预期的排序要求</li>\n<li>区间性——值是否在一个合理的最大值最小值范围内</li>\n<li>引用、耦合性——代码是否引用了一些不受代码本身直接控制的外部因素</li>\n<li>存在性——值是否存在（例如：非Null，非零，存在于某个集合中）</li>\n<li>基数性——是否恰好具有足够的值</li>\n<li>时间性——所有事情是否都按照顺序发生的？是否在正确的时间、是否及时</li>\n</ul>\n<h4 id=\"3-3-使用Mock对象\"><a href=\"#3-3-使用Mock对象\" class=\"headerlink\" title=\"3.3 使用Mock对象\"></a>3.3 使用Mock对象</h4><p>   单元测试的目标是验证我们的工作单元，但是如果这个工作单元依赖一些其他的对象或是一些难以操控的东西，比如网络、数据库等。这时我们就要使用mock对象，使得在运行UT的时候使用的那些难以操控的东西实际上是我们mock的对象，而我们mock的对象则可以按照我们的意愿返回一些值用于测试。通俗来讲，Mock对象就是真实对象在我们调试期间的测试品。<strong>对于外部对象内的逻辑我们并不关心，我们只需要让它给我们返回我们想要的值，来验证我们的业务逻辑即可</strong><br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFileExtensionManager fileManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">IsValidFileName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取文件扩展名</span></span><br><span class=\"line\">    <span class=\"keyword\">string</span> extName=fileManager.GetExtName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(extName==<span class=\"string\">\"jpg\"</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上示例，假设从文件系统中读取一个文件，获取文件的扩展名，如果扩展名是jpg就返回true，否则返回false。<br>注意，这里我们要测试的逻辑是如果扩展名是jpg就返回true，否则返回false。而对于fileManager.GetExtName()方法内部的逻辑是什么样的的我们是不关心的，我们只需要mock这个方法使其返回我们想要的值就可以了。<br>关于具体如何去mock工作单元中的一些外部依赖，会在存根与模拟对象里面详细进行总结。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文总结了什么是单元测试、什么不是单元测试以及优秀的单元测试有哪些特性，简单介绍了如何进行单元测试。<br>编写差劲的单元测试是没有意义的，我看到过很多公司尝试去实践单元测试，但最终要么在某个阶段放弃了,要么并没有真正执行单元测试。最终还是依赖集成测试或者人工测试来发现问题，不得不以失败而告终，并堂而皇之的认为单元测试是一个耗时好力而无功的鸡肋东西。<br>因此如果你想要真正的去实践单元测试，那么必须充分的理解到底什么是单元测试，已经如何去更好的进行实践优秀的单元测试。<br>而对于如何更好的去实践单元测试，后续会结合实践用更多的篇幅去总结分享。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-什么是单元测试\"><a href=\"#1-什么是单元测试\" class=\"headerlink\" title=\"1.什么是单元测试\"></a>1.什么是单元测试</h3><h4 id=\"1-1单元测试的定义\"><a href=\"#1-1单元测试的定义\" class=\"headerlink\" title=\"1.1单元测试的定义\"></a>1.1单元测试的定义</h4><p>单元测试就是针对一个工作单元设计的测试，这里的“工作单元”是指对一个工作方法的要求。<br>单元测试是开发者编写的一小段代码，用于检测被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试用于判断某个特定条件(或场景)下某个特定函数的行为。</p>","more":"<p>例：<br>你可能把一个很大的值放入一个有序list中去，然后确认该值出现在list的尾部。或者，你可能会从字符串中删除匹配某种模式的字符，然后确认字符串确实不再包含这些字符了。<br><strong>执行单元测试，就是为了证明某段代码的行为和开发者所期望的一致！</strong></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//被测方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">Add</span>(<span class=\"params\"><span class=\"keyword\">double</span> a, <span class=\"keyword\">double</span> b</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;      </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试方法</span></span><br><span class=\"line\">[<span class=\"meta\">Test</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">AddTest</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> result = <span class=\"keyword\">new</span> Calculator().Add(<span class=\"number\">14</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">    Assert.AreEqual(<span class=\"number\">30</span>,result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-2工作单元\"><a href=\"#1-2工作单元\" class=\"headerlink\" title=\"1.2工作单元\"></a>1.2工作单元</h4><p>调用系统的一个公共方法到产生一个测试可见的最终结果,其间这个系统发生的行为总称为一个工作单元。我们通过系统的公共AP和行为就可以观察到一个可见的最终结果,无需查看系统的内部状态。一个最终结果可以是以下任何一种形式。</p>\n<ol>\n<li>被调用的公共方法回一个值(一个返回值不为空的函数)</li>\n<li>在方法调用的前后,系统的状态或行为有可见的变化,这种变化无需查询私有状态即可判断。(例如:一个以前不存在的用户可以登入系统,或者一个状态机系统的属性发生变化。)</li>\n<li>调用了一个不受测试控制的第三方系统,这个第三方系统不返回任何值,或者返回值都被忽略。(例如:调用一个第三方日志系统,这个系统不是你编写的,而且你也没有源代码。)</li>\n</ol>\n<p>很多人觉得被测试的工作单元应该尽可能的小。我却不这么看，我认为工作单元这个概念意味着一个单元既可以小到只包含一个方法,也可以大到包括实现某个功能的多个类和函数。如果你的工作单元很大，却但是其最终结果对用户可见度高，易于维护也未尝不是好的测试，相反如果试图把工作单元缩到最小,最后会不得不伪造一堆东西反而会增加测试的复杂度，适得其反。</p>\n<h3 id=\"2-什么不是单元测试\"><a href=\"#2-什么不是单元测试\" class=\"headerlink\" title=\"2.什么不是单元测试\"></a>2.什么不是单元测试</h3><p>单元测试其实是一门很基础也很简单的技术，然而在单元测试实践过程中，往往会对单元测试产生一些误区，进而写出一些不是单元测试的”单元测试” ，其中常见的主要有以下三种。</p>\n<h4 id=\"2-1-跨边界的测试\"><a href=\"#2-1-跨边界的测试\" class=\"headerlink\" title=\"2.1 跨边界的测试\"></a>2.1 跨边界的测试</h4><p>单元测试背后的思想是，仅测试这个方法中的内容，测试失败时不希望必须穿过基层代码、数据库表或者第三方产品的文档去寻找可能的答案！<br>当测试开始渗透到其他类、服务或系统时，此时测试便跨越了边界，失败时会很难找到缺陷的代码。<br>测试跨边界时还会产生另一个问题，当边界是一个共享资源时，如数据库。与团队的其他开发人员共享资源时，可能会污染他们的测试结果！</p>\n<h4 id=\"2-2-不具有针对性的测试\"><a href=\"#2-2-不具有针对性的测试\" class=\"headerlink\" title=\"2.2 不具有针对性的测试\"></a>2.2 不具有针对性的测试</h4><p>如果发现所编写的测试对一件以上的事情进行了测试，就可能违反了“单一职责原则”。从单元测试的角度来看，这意味着这些测试是难以理解的非针对性测试。随着时间的推移，向类或方法种添加了更多的不恰当的功能后，这些测试可能会变的非常脆弱。诊断问题也将变得极具有挑战性。<br>如：StringUtility中计算一个特定字符在字符串中出现的次数，它没有说明这个字符在字符串中处于什么位置也没有说明除了这个字符出现多少次之外的其他任何信息，那么这些功能就应该由StringUtility类的其它方法提供！同样，StringUtility类也不应该处理数字、日期或复杂数据类型的功能！</p>\n<h4 id=\"2-3-不可预测的测试\"><a href=\"#2-3-不可预测的测试\" class=\"headerlink\" title=\"2.3 不可预测的测试\"></a>2.3 不可预测的测试</h4><p>单元测试应当是可预测的。在针对一组给定的输入参数调用一个类的方法时，其结果应当总是一致的。有时，这一原则可能看起来很难遵守。例如：正在编写一个日用品交易程序，黄金的价格可能上午九时是一个值，14时就会变成另一个值。<br>而好的设计原则就是将不可预测的数据的功能抽象到一个可以在单元测试中模拟(Mock)的类或方法中</p>\n<h4 id=\"2-4-集成测试\"><a href=\"#2-4-集成测试\" class=\"headerlink\" title=\"2.4 集成测试\"></a>2.4 集成测试</h4><p>其实上面三种测试已经到了集成测试的领域。任何测试,如果它运行速度不快,结果不稳定,或者要用到被测试单元的一个或多个真实依赖物,我们就认为它是集成测试。<br>集成测试是对一个工作单元进行的测试,这个测试对被测试的工作单元没有完全的控制,并使用该单元的一个或多个真实依赖物,例如时间、网络、数据库、线程或随机数产生器等。<br>集成测试本身并不是一种坏事，反而其具有和单元测试一样高的地位，但是在实践过程中我们把集成测试和单元测试分离开来还是很重要的。</p>\n<h3 id=\"3-优秀的单元测试有哪些特性\"><a href=\"#3-优秀的单元测试有哪些特性\" class=\"headerlink\" title=\"3.优秀的单元测试有哪些特性\"></a>3.优秀的单元测试有哪些特性</h3><p>单元测试是非常有魔力的魔法，也是一把双刃剑。使用得当，可以很有效的提高我们的编码质量，提升研发效率，但是如果使用不恰当亦会浪费大量的时间在测试编码、维护和调试上从而影响代码和整个项目，徒劳而无功！<br>因此做好单元测试至关重要！而想要做好单元测试，我们首先应该知道优秀的单元测试有哪些特性。<br>一个好的单元测试一定是有以下几个特性的<br>•  自动化<br>•  彻底的<br>•  可重复的<br>•  独立的<br>•  专业的<br>回顾一下自己以前写过的单元测试问自己几个问题。</p>\n<ol>\n<li><p>它是不是可以自动化一键运行、并且可以重复运行</p>\n</li>\n<li><p>几个月后它是不是仍可以运行、并且得到期望的结果</p>\n</li>\n<li><p>它是否可以在几分钟内运行结束</p>\n</li>\n<li><p>在运行之前你是否不需要需要进行一系列的配置</p>\n</li>\n<li><p>每次运行是否能够得到相同的结果</p>\n</li>\n<li><p>外部的系统因素是否不会影响你的测试结果</p>\n</li>\n<li><p>测试代码是否很简单就可以编写完成</p>\n</li>\n</ol>\n<p>如果针对以上问题有任何一个的回答是“否”，那么你应该好好的思考一下到底如何去做好单元测试。</p>\n<h3 id=\"4-如何进行单元测试\"><a href=\"#4-如何进行单元测试\" class=\"headerlink\" title=\"4. 如何进行单元测试\"></a>4. 如何进行单元测试</h3><p>对于一个方法或者类，乍一看就能找出其隐藏深处的bug是很不容易的，因此在bug挖掘方面通常会有一些经验和套路，来指导我们更好的进行单元测试。</p>\n<h4 id=\"3-1-测试哪些内容\"><a href=\"#3-1-测试哪些内容\" class=\"headerlink\" title=\"3.1 测试哪些内容\"></a>3.1 测试哪些内容</h4><p> 一般来说有六个值得测试的具体方面，可以把这六个方面统称为Right-BICEP:</p>\n<ul>\n<li>Right——结果<br>对于单元测试测试而言,首要的也是最明显的任务就是查看所期望的结果是否正确，例如判断一个方法的返回值是否为序列中的最大值…… </li>\n<li>B——边界条件<br>找边界条件是做单元测试中最有价值的工作之一,因为bug一般就出现在边界上。关于边界条件2会有详细总结</li>\n<li>I——检查反向关联<br>对于一些方法,我们可以使用反向的逻辑关系来验证它们。例如,你可以用对结果进行平方的方式来检查一个计算平方根的函数,然后测试结果是否和原数据很接近</li>\n<li>C——交叉检查<br>有些时候我们实现一个问题会有不同的算法，在生产系统中我们使用一种算法，而在测试中我们可以使用另一种算法来验证其结果是否一致。</li>\n<li>E——强制产生错误条件<br>在实际运行过程中,有时候会发生一些意外的难以避免的错误，例如磁盘会满,网络连线会断开…..从而导致程序崩溃。我们应该在测试中强制引发错误,来测试代码是否能够按照预期处理这些异常。</li>\n<li><p>P——是否满足性能条件<br>性能同样是我们测试过程中需要验证的指标</p>\n<h4 id=\"3-2-注意边界条件\"><a href=\"#3-2-注意边界条件\" class=\"headerlink\" title=\"3.2 注意边界条件\"></a>3.2 注意边界条件</h4><p>  代码中的许多Bug经常出现在边界条件附近，对于边界条件的测试我们可以从CORRECT七个方面进行考虑</p>\n</li>\n<li><p>一致性——值是否满足预期的格式</p>\n</li>\n<li>有序性——一组值是否满足预期的排序要求</li>\n<li>区间性——值是否在一个合理的最大值最小值范围内</li>\n<li>引用、耦合性——代码是否引用了一些不受代码本身直接控制的外部因素</li>\n<li>存在性——值是否存在（例如：非Null，非零，存在于某个集合中）</li>\n<li>基数性——是否恰好具有足够的值</li>\n<li>时间性——所有事情是否都按照顺序发生的？是否在正确的时间、是否及时</li>\n</ul>\n<h4 id=\"3-3-使用Mock对象\"><a href=\"#3-3-使用Mock对象\" class=\"headerlink\" title=\"3.3 使用Mock对象\"></a>3.3 使用Mock对象</h4><p>   单元测试的目标是验证我们的工作单元，但是如果这个工作单元依赖一些其他的对象或是一些难以操控的东西，比如网络、数据库等。这时我们就要使用mock对象，使得在运行UT的时候使用的那些难以操控的东西实际上是我们mock的对象，而我们mock的对象则可以按照我们的意愿返回一些值用于测试。通俗来讲，Mock对象就是真实对象在我们调试期间的测试品。<strong>对于外部对象内的逻辑我们并不关心，我们只需要让它给我们返回我们想要的值，来验证我们的业务逻辑即可</strong><br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFileExtensionManager fileManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">IsValidFileName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取文件扩展名</span></span><br><span class=\"line\">    <span class=\"keyword\">string</span> extName=fileManager.GetExtName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(extName==<span class=\"string\">\"jpg\"</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上示例，假设从文件系统中读取一个文件，获取文件的扩展名，如果扩展名是jpg就返回true，否则返回false。<br>注意，这里我们要测试的逻辑是如果扩展名是jpg就返回true，否则返回false。而对于fileManager.GetExtName()方法内部的逻辑是什么样的的我们是不关心的，我们只需要mock这个方法使其返回我们想要的值就可以了。<br>关于具体如何去mock工作单元中的一些外部依赖，会在存根与模拟对象里面详细进行总结。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文总结了什么是单元测试、什么不是单元测试以及优秀的单元测试有哪些特性，简单介绍了如何进行单元测试。<br>编写差劲的单元测试是没有意义的，我看到过很多公司尝试去实践单元测试，但最终要么在某个阶段放弃了,要么并没有真正执行单元测试。最终还是依赖集成测试或者人工测试来发现问题，不得不以失败而告终，并堂而皇之的认为单元测试是一个耗时好力而无功的鸡肋东西。<br>因此如果你想要真正的去实践单元测试，那么必须充分的理解到底什么是单元测试，已经如何去更好的进行实践优秀的单元测试。<br>而对于如何更好的去实践单元测试，后续会结合实践用更多的篇幅去总结分享。</p>"},{"title":"伪对象、桩对象、模拟对象","copyright":true,"date":"2021-01-06T02:29:26.000Z","keywords":"单元测试","_content":"\n在我们单元测试的实践中，常常会发现一个方法依赖一个无法控制的对象，我们称其为外部依赖项。\n一个外部依赖项——是系统中的一个对象,被测试代码与这个对象发生交互,但**你不能控制这个对象**。(常见的外部依赖项包括文件系统、线程、内存以及时间等。)\n而单元测试背后的思想是，仅测试这个方法中的内容，当测试开始渗透到其他类、服务或系统时，此时测试便跨越了边界。而一旦测试跨了边界就变成了集成测试。进而也带来了所有与集成测试相关的问题——运行速度较慢,需要配置,一次测试多个内容......\n<!--more-->\n### 1 桩对象(存根)\n#### 什么是桩对象(存根)\n一个**存根(桩对象)(stub)**是对系统中存在的一个依赖项(或者协作者)的可控制的替代物。通过使用存根,你在测试代码时无需直接处理这个依赖项。\n#### 如何使用桩对象(存根)破除依赖\n#### 示例1\n假设我们有下面这样一个方法，从文件系统中读取一个文件，获取文件的扩展名，如果扩展名是jpg就返回true，否则返回false。\n```csharp\nIFileExtensionManager fileManager;\n\npublic bool IsValidFileName(){\n    //获取文件扩展名\n    string extName=fileManager.GetExtName();\n    if(extName==\"jpg\"){\n    \treturn true;\n    }\n    return false;\n}\n\npublic class FileExtensionManager:IFileExtensionManager{\n\n    public string GetExtName(){\n    \t//调用真实的文件系统获取文件\n        return file.GetExtension();\n    }\n}\n```\n很明显在这个方法中，我们要测的逻辑是扩展名是jpg就返回true，否则返回false。这个方法我们依赖一个外部方法FileExtensionManage.GetExtName()(获取文件的扩展名)。\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1606785041078-040a98de-e470-48a7-b0f4-cb98a7eb887c.png#align=left&display=inline&height=325&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=580&size=26293&status=done&style=none&width=580)\n使用存根破除依赖一般有下面几个步骤\n\n1. 找到被测试对象使用的外部接口\n1. 把这个接口的底层实现替换成你能控制的东西。\n```csharp\nIFileExtensionManager fileManager;\n\npublic bool IsValidFileName(){\n    //获取文件扩展名\n    string extName=fileManager.GetExtName();\n    if(extName==\"jpg\"){\n    \treturn true;\n    }\n    return false;\n}\n\npublic class StubFileExtensionManager:IFileExtensionManager{\n\n    public string GetExtName(){\n    \t// 模拟文件系统的返回结果\n        return \"jpg\";\n    }\n}\n```\n我们所创造的替代实例StubFileExtensionManager根本不会访问文件系统,这样就破除了对文件系统的依赖性。因为要测试的不是访问文件系统的类,而是调用这个类的代码，这个时候我们的的依赖关系就变成了下面这样\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1606784771047-b1f0f10d-ba66-4efc-8bf8-c5bd27f9daa0.png#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=847&size=39206&status=done&style=none&width=847)\n#### 示例2\n在上面的示例中，我们的被测试类与文件系统帮助类并非是强依赖的，而是依赖倒置的(通过接口IFileExtensionManager解耦)，而在有些系统中，对于文件系统的访问类可能是下面这样的\n```csharp\npublic bool IsValidFileName(){\n    //获取文件扩展名\n    string extName=new FileExtensionManager().GetExtName();\n    if(extName==\"jpg\"){\n    \treturn true;\n    }\n    return false;\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1606785453312-6b272254-d86a-44ee-87e7-e4f4b1c2acf0.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=266&size=10174&status=done&style=none&width=266)\n这种情况下由于代码的不可测试性，我们就需要先对代码进行重构。使其更具有可测试性(注意:可测试性同样是我们编码所需要注意的原则之一)\n\n1. 找到被测试的工作单元依赖的外部对象。\n1. 如果这个外部对象与被测试工作单元直接相连(本例中,你直接读取文件系统),就在代码中添加一个间接层。\n1. 把这个交互接口的底层实現替换成你可以控制的代码。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1606785690750-3ca66988-9e18-4193-a667-bba43f7f03bc.png#align=left&display=inline&height=635&margin=%5Bobject%20Object%5D&name=image.png&originHeight=635&originWidth=868&size=69946&status=done&style=none&width=868)\n此时变成了示例1的情况，就可以进行测试。\n而在实践过程中，我们还会遇到许多难以测试的代码，这时就需要通过重构来提高其可测试性。关于如何是代码变得更加容易测试，后续文章继续总结。\n\n### 2 模拟对象\n#### 什么是模拟对象\n模拟对象可以验证被测试对象是否接预期的方式调用了这个伪对象,因此导致单元测试通过或是失败。\n模拟对象主要用来做交互性测试，例如:调用一个第三方日志系统,你所调用的方法并不会返回任何东西，我们如何判断是否调用正确，甚至是否发生了调用。\n#### 如何利用模拟对象进行交互测试\n如下示例，在我们的业务方法中如果文件名的长度大于8就要记录一个warn日志。这个方法不返回任何值，其所调用的日志系统的方法也不返回任何值。这个时候我们要验证是否如期调用了日志系统的warn方法。\n```csharp\npublic class FlieService{\n\t\n    ILogger logger;\n    \n    public FlieService(ILogger logger){\n    \tthis.logger=logger;\n    }\n    \n\t// 被测方法\n\tpublic void LogValidResult(string fileName){\n\t\tif(fileName.length>8){\n\t\t\tlogger.warn(\"invalid ...\",obj);\n\t\t}\n\t}\n}\n\n//测试方法\n[Test]\npublic void LogValidResult_Valid_Logger(){\n    string fileName=\"hello world\"\n    var logger=new MockLogger();\n    new FileService(logger).LogValidResult();\n    string expect=\"invalid ...\";    \n    string actual=logger.Title;\n    Assert.AreEqual(expect,actual);\n}\n\n// 模拟对象\npublic class MockLogger:ILogger{\n\t\n    public string Title{get;set;}\n    \n    public void info(string title,object obj){\n    \t\n    }\n}\n```\n### ![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1608166710216-cd91a302-94c4-46f7-84d3-957ab0d7f12c.png#align=left&display=inline&height=405&margin=%5Bobject%20Object%5D&name=image.png&originHeight=405&originWidth=855&size=30617&status=done&style=none&width=855)\n### 3 伪对象、模拟对象与桩对象\n#### 伪对象\n伪对象是通用的术语,可以描述一个存根或者模拟对象(手工或非手工編写),因为存根和模拟对象看上去都很像真实对象。一个伪对象究竟是存根还是模拟对象取决于它在当前测试中的使用方式:如果这个伪对象用来检验一个交互(对其进行断言),它就是模拟对象,否则就是存根\n#### 模拟对象与桩对象的区别\n乍一看模拟对象与桩对象很相似,或者根本不存在区别。但区分二者又很重要,因为会使用这两个词来描述框架的各种不同行为。\n二者最根本的区别是存根不会导致测试失败,而模拟对象可以\n要辨别你是否使用了存根,最简单的方法是:存根永远不会导致测试失败。测试总是对被测试类进行断言\n另一方面,测试会使用模拟对象验证測试是否失败。下图展示了测试和模拟对象之前的交互。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1608166109962-b4b5d2c2-ebf3-49aa-a131-d508df3df37b.png#align=left&display=inline&height=256&margin=%5Bobject%20Object%5D&name=image.png&originHeight=256&originWidth=812&size=21832&status=done&style=none&width=812)\n#### 4 小结\n本文简单总结了，当单元测试遇到外部依赖对象的时候我们通过桩对象来破除依赖，而在涉及验证是否正确调用一个外部对象的时候，我们可以使用模拟对象来进行交互测试。\n可以看到这里我们用来创造伪对象都是通过自己手写代码的方式，而真实项目中有时候可能需要多个伪对象，那么又有什么好的方式呢。实际上现在无论是.net和java为了更好的单测已经产生了许多好用的单测框架与模拟框架。弄明白单测的一些基本思想，再熟练的运用好这些框架，将会让我们的单元测试进行的更加如鱼得水。\n而关于一些常用的单元测试框架和模拟框架将下篇文章继续总结。\n\n\n","source":"_posts/技术实践/单元测试/伪对象、桩对象、模拟对象.md","raw":"---\ntitle: 伪对象、桩对象、模拟对象\ncopyright: true\ndate: 2021-01-06 10:29:26\ntags: \n- 单元测试\ncategories: \n- 单元测试\nkeywords: 单元测试\n---\n\n在我们单元测试的实践中，常常会发现一个方法依赖一个无法控制的对象，我们称其为外部依赖项。\n一个外部依赖项——是系统中的一个对象,被测试代码与这个对象发生交互,但**你不能控制这个对象**。(常见的外部依赖项包括文件系统、线程、内存以及时间等。)\n而单元测试背后的思想是，仅测试这个方法中的内容，当测试开始渗透到其他类、服务或系统时，此时测试便跨越了边界。而一旦测试跨了边界就变成了集成测试。进而也带来了所有与集成测试相关的问题——运行速度较慢,需要配置,一次测试多个内容......\n<!--more-->\n### 1 桩对象(存根)\n#### 什么是桩对象(存根)\n一个**存根(桩对象)(stub)**是对系统中存在的一个依赖项(或者协作者)的可控制的替代物。通过使用存根,你在测试代码时无需直接处理这个依赖项。\n#### 如何使用桩对象(存根)破除依赖\n#### 示例1\n假设我们有下面这样一个方法，从文件系统中读取一个文件，获取文件的扩展名，如果扩展名是jpg就返回true，否则返回false。\n```csharp\nIFileExtensionManager fileManager;\n\npublic bool IsValidFileName(){\n    //获取文件扩展名\n    string extName=fileManager.GetExtName();\n    if(extName==\"jpg\"){\n    \treturn true;\n    }\n    return false;\n}\n\npublic class FileExtensionManager:IFileExtensionManager{\n\n    public string GetExtName(){\n    \t//调用真实的文件系统获取文件\n        return file.GetExtension();\n    }\n}\n```\n很明显在这个方法中，我们要测的逻辑是扩展名是jpg就返回true，否则返回false。这个方法我们依赖一个外部方法FileExtensionManage.GetExtName()(获取文件的扩展名)。\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1606785041078-040a98de-e470-48a7-b0f4-cb98a7eb887c.png#align=left&display=inline&height=325&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=580&size=26293&status=done&style=none&width=580)\n使用存根破除依赖一般有下面几个步骤\n\n1. 找到被测试对象使用的外部接口\n1. 把这个接口的底层实现替换成你能控制的东西。\n```csharp\nIFileExtensionManager fileManager;\n\npublic bool IsValidFileName(){\n    //获取文件扩展名\n    string extName=fileManager.GetExtName();\n    if(extName==\"jpg\"){\n    \treturn true;\n    }\n    return false;\n}\n\npublic class StubFileExtensionManager:IFileExtensionManager{\n\n    public string GetExtName(){\n    \t// 模拟文件系统的返回结果\n        return \"jpg\";\n    }\n}\n```\n我们所创造的替代实例StubFileExtensionManager根本不会访问文件系统,这样就破除了对文件系统的依赖性。因为要测试的不是访问文件系统的类,而是调用这个类的代码，这个时候我们的的依赖关系就变成了下面这样\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1606784771047-b1f0f10d-ba66-4efc-8bf8-c5bd27f9daa0.png#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=847&size=39206&status=done&style=none&width=847)\n#### 示例2\n在上面的示例中，我们的被测试类与文件系统帮助类并非是强依赖的，而是依赖倒置的(通过接口IFileExtensionManager解耦)，而在有些系统中，对于文件系统的访问类可能是下面这样的\n```csharp\npublic bool IsValidFileName(){\n    //获取文件扩展名\n    string extName=new FileExtensionManager().GetExtName();\n    if(extName==\"jpg\"){\n    \treturn true;\n    }\n    return false;\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1606785453312-6b272254-d86a-44ee-87e7-e4f4b1c2acf0.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=266&size=10174&status=done&style=none&width=266)\n这种情况下由于代码的不可测试性，我们就需要先对代码进行重构。使其更具有可测试性(注意:可测试性同样是我们编码所需要注意的原则之一)\n\n1. 找到被测试的工作单元依赖的外部对象。\n1. 如果这个外部对象与被测试工作单元直接相连(本例中,你直接读取文件系统),就在代码中添加一个间接层。\n1. 把这个交互接口的底层实現替换成你可以控制的代码。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1606785690750-3ca66988-9e18-4193-a667-bba43f7f03bc.png#align=left&display=inline&height=635&margin=%5Bobject%20Object%5D&name=image.png&originHeight=635&originWidth=868&size=69946&status=done&style=none&width=868)\n此时变成了示例1的情况，就可以进行测试。\n而在实践过程中，我们还会遇到许多难以测试的代码，这时就需要通过重构来提高其可测试性。关于如何是代码变得更加容易测试，后续文章继续总结。\n\n### 2 模拟对象\n#### 什么是模拟对象\n模拟对象可以验证被测试对象是否接预期的方式调用了这个伪对象,因此导致单元测试通过或是失败。\n模拟对象主要用来做交互性测试，例如:调用一个第三方日志系统,你所调用的方法并不会返回任何东西，我们如何判断是否调用正确，甚至是否发生了调用。\n#### 如何利用模拟对象进行交互测试\n如下示例，在我们的业务方法中如果文件名的长度大于8就要记录一个warn日志。这个方法不返回任何值，其所调用的日志系统的方法也不返回任何值。这个时候我们要验证是否如期调用了日志系统的warn方法。\n```csharp\npublic class FlieService{\n\t\n    ILogger logger;\n    \n    public FlieService(ILogger logger){\n    \tthis.logger=logger;\n    }\n    \n\t// 被测方法\n\tpublic void LogValidResult(string fileName){\n\t\tif(fileName.length>8){\n\t\t\tlogger.warn(\"invalid ...\",obj);\n\t\t}\n\t}\n}\n\n//测试方法\n[Test]\npublic void LogValidResult_Valid_Logger(){\n    string fileName=\"hello world\"\n    var logger=new MockLogger();\n    new FileService(logger).LogValidResult();\n    string expect=\"invalid ...\";    \n    string actual=logger.Title;\n    Assert.AreEqual(expect,actual);\n}\n\n// 模拟对象\npublic class MockLogger:ILogger{\n\t\n    public string Title{get;set;}\n    \n    public void info(string title,object obj){\n    \t\n    }\n}\n```\n### ![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1608166710216-cd91a302-94c4-46f7-84d3-957ab0d7f12c.png#align=left&display=inline&height=405&margin=%5Bobject%20Object%5D&name=image.png&originHeight=405&originWidth=855&size=30617&status=done&style=none&width=855)\n### 3 伪对象、模拟对象与桩对象\n#### 伪对象\n伪对象是通用的术语,可以描述一个存根或者模拟对象(手工或非手工編写),因为存根和模拟对象看上去都很像真实对象。一个伪对象究竟是存根还是模拟对象取决于它在当前测试中的使用方式:如果这个伪对象用来检验一个交互(对其进行断言),它就是模拟对象,否则就是存根\n#### 模拟对象与桩对象的区别\n乍一看模拟对象与桩对象很相似,或者根本不存在区别。但区分二者又很重要,因为会使用这两个词来描述框架的各种不同行为。\n二者最根本的区别是存根不会导致测试失败,而模拟对象可以\n要辨别你是否使用了存根,最简单的方法是:存根永远不会导致测试失败。测试总是对被测试类进行断言\n另一方面,测试会使用模拟对象验证測试是否失败。下图展示了测试和模拟对象之前的交互。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/479376/1608166109962-b4b5d2c2-ebf3-49aa-a131-d508df3df37b.png#align=left&display=inline&height=256&margin=%5Bobject%20Object%5D&name=image.png&originHeight=256&originWidth=812&size=21832&status=done&style=none&width=812)\n#### 4 小结\n本文简单总结了，当单元测试遇到外部依赖对象的时候我们通过桩对象来破除依赖，而在涉及验证是否正确调用一个外部对象的时候，我们可以使用模拟对象来进行交互测试。\n可以看到这里我们用来创造伪对象都是通过自己手写代码的方式，而真实项目中有时候可能需要多个伪对象，那么又有什么好的方式呢。实际上现在无论是.net和java为了更好的单测已经产生了许多好用的单测框架与模拟框架。弄明白单测的一些基本思想，再熟练的运用好这些框架，将会让我们的单元测试进行的更加如鱼得水。\n而关于一些常用的单元测试框架和模拟框架将下篇文章继续总结。\n\n\n","slug":"技术实践/单元测试/伪对象、桩对象、模拟对象","published":1,"updated":"2021-03-21T08:32:44.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfq0100fdhyjfe4s0es05","content":"<p>在我们单元测试的实践中，常常会发现一个方法依赖一个无法控制的对象，我们称其为外部依赖项。<br>一个外部依赖项——是系统中的一个对象,被测试代码与这个对象发生交互,但<strong>你不能控制这个对象</strong>。(常见的外部依赖项包括文件系统、线程、内存以及时间等。)<br>而单元测试背后的思想是，仅测试这个方法中的内容，当测试开始渗透到其他类、服务或系统时，此时测试便跨越了边界。而一旦测试跨了边界就变成了集成测试。进而也带来了所有与集成测试相关的问题——运行速度较慢,需要配置,一次测试多个内容……<br><a id=\"more\"></a></p>\n<h3 id=\"1-桩对象-存根\"><a href=\"#1-桩对象-存根\" class=\"headerlink\" title=\"1 桩对象(存根)\"></a>1 桩对象(存根)</h3><h4 id=\"什么是桩对象-存根\"><a href=\"#什么是桩对象-存根\" class=\"headerlink\" title=\"什么是桩对象(存根)\"></a>什么是桩对象(存根)</h4><p>一个<strong>存根(桩对象)(stub)</strong>是对系统中存在的一个依赖项(或者协作者)的可控制的替代物。通过使用存根,你在测试代码时无需直接处理这个依赖项。</p>\n<h4 id=\"如何使用桩对象-存根-破除依赖\"><a href=\"#如何使用桩对象-存根-破除依赖\" class=\"headerlink\" title=\"如何使用桩对象(存根)破除依赖\"></a>如何使用桩对象(存根)破除依赖</h4><h4 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h4><p>假设我们有下面这样一个方法，从文件系统中读取一个文件，获取文件的扩展名，如果扩展名是jpg就返回true，否则返回false。<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFileExtensionManager fileManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">IsValidFileName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取文件扩展名</span></span><br><span class=\"line\">    <span class=\"keyword\">string</span> extName=fileManager.GetExtName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(extName==<span class=\"string\">\"jpg\"</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FileExtensionManager</span>:<span class=\"title\">IFileExtensionManager</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">string</span> <span class=\"title\">GetExtName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//调用真实的文件系统获取文件</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> file.GetExtension();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>很明显在这个方法中，我们要测的逻辑是扩展名是jpg就返回true，否则返回false。这个方法我们依赖一个外部方法FileExtensionManage.GetExtName()(获取文件的扩展名)。<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1606785041078-040a98de-e470-48a7-b0f4-cb98a7eb887c.png#align=left&amp;display=inline&amp;height=325&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=325&amp;originWidth=580&amp;size=26293&amp;status=done&amp;style=none&amp;width=580\" alt=\"image.png\"><br>使用存根破除依赖一般有下面几个步骤</p>\n<ol>\n<li>找到被测试对象使用的外部接口</li>\n<li>把这个接口的底层实现替换成你能控制的东西。<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFileExtensionManager fileManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">IsValidFileName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取文件扩展名</span></span><br><span class=\"line\">    <span class=\"keyword\">string</span> extName=fileManager.GetExtName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(extName==<span class=\"string\">\"jpg\"</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">StubFileExtensionManager</span>:<span class=\"title\">IFileExtensionManager</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">string</span> <span class=\"title\">GetExtName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 模拟文件系统的返回结果</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"jpg\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我们所创造的替代实例StubFileExtensionManager根本不会访问文件系统,这样就破除了对文件系统的依赖性。因为要测试的不是访问文件系统的类,而是调用这个类的代码，这个时候我们的的依赖关系就变成了下面这样<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1606784771047-b1f0f10d-ba66-4efc-8bf8-c5bd27f9daa0.png#align=left&amp;display=inline&amp;height=302&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=302&amp;originWidth=847&amp;size=39206&amp;status=done&amp;style=none&amp;width=847\" alt=\"image.png\"></p>\n<h4 id=\"示例2\"><a href=\"#示例2\" class=\"headerlink\" title=\"示例2\"></a>示例2</h4><p>在上面的示例中，我们的被测试类与文件系统帮助类并非是强依赖的，而是依赖倒置的(通过接口IFileExtensionManager解耦)，而在有些系统中，对于文件系统的访问类可能是下面这样的<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">IsValidFileName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取文件扩展名</span></span><br><span class=\"line\">    <span class=\"keyword\">string</span> extName=<span class=\"keyword\">new</span> FileExtensionManager().GetExtName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(extName==<span class=\"string\">\"jpg\"</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1606785453312-6b272254-d86a-44ee-87e7-e4f4b1c2acf0.png#align=left&amp;display=inline&amp;height=250&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=250&amp;originWidth=266&amp;size=10174&amp;status=done&amp;style=none&amp;width=266\" alt=\"image.png\"><br>这种情况下由于代码的不可测试性，我们就需要先对代码进行重构。使其更具有可测试性(注意:可测试性同样是我们编码所需要注意的原则之一)</p>\n<ol>\n<li>找到被测试的工作单元依赖的外部对象。</li>\n<li>如果这个外部对象与被测试工作单元直接相连(本例中,你直接读取文件系统),就在代码中添加一个间接层。</li>\n<li>把这个交互接口的底层实現替换成你可以控制的代码。</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1606785690750-3ca66988-9e18-4193-a667-bba43f7f03bc.png#align=left&amp;display=inline&amp;height=635&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=635&amp;originWidth=868&amp;size=69946&amp;status=done&amp;style=none&amp;width=868\" alt=\"image.png\"><br>此时变成了示例1的情况，就可以进行测试。<br>而在实践过程中，我们还会遇到许多难以测试的代码，这时就需要通过重构来提高其可测试性。关于如何是代码变得更加容易测试，后续文章继续总结。</p>\n<h3 id=\"2-模拟对象\"><a href=\"#2-模拟对象\" class=\"headerlink\" title=\"2 模拟对象\"></a>2 模拟对象</h3><h4 id=\"什么是模拟对象\"><a href=\"#什么是模拟对象\" class=\"headerlink\" title=\"什么是模拟对象\"></a>什么是模拟对象</h4><p>模拟对象可以验证被测试对象是否接预期的方式调用了这个伪对象,因此导致单元测试通过或是失败。<br>模拟对象主要用来做交互性测试，例如:调用一个第三方日志系统,你所调用的方法并不会返回任何东西，我们如何判断是否调用正确，甚至是否发生了调用。</p>\n<h4 id=\"如何利用模拟对象进行交互测试\"><a href=\"#如何利用模拟对象进行交互测试\" class=\"headerlink\" title=\"如何利用模拟对象进行交互测试\"></a>如何利用模拟对象进行交互测试</h4><p>如下示例，在我们的业务方法中如果文件名的长度大于8就要记录一个warn日志。这个方法不返回任何值，其所调用的日志系统的方法也不返回任何值。这个时候我们要验证是否如期调用了日志系统的warn方法。<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FlieService</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    ILogger logger;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlieService</span>(<span class=\"params\">ILogger logger</span>)</span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">this</span>.logger=logger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">// 被测方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">LogValidResult</span>(<span class=\"params\"><span class=\"keyword\">string</span> fileName</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(fileName.length&gt;<span class=\"number\">8</span>)&#123;</span><br><span class=\"line\">\t\t\tlogger.warn(<span class=\"string\">\"invalid ...\"</span>,obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试方法</span></span><br><span class=\"line\">[<span class=\"meta\">Test</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">LogValidResult_Valid_Logger</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">string</span> fileName=<span class=\"string\">\"hello world\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> logger=<span class=\"keyword\">new</span> MockLogger();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> FileService(logger).LogValidResult();</span><br><span class=\"line\">    <span class=\"keyword\">string</span> expect=<span class=\"string\">\"invalid ...\"</span>;    </span><br><span class=\"line\">    <span class=\"keyword\">string</span> actual=logger.Title;</span><br><span class=\"line\">    Assert.AreEqual(expect,actual);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MockLogger</span>:<span class=\"title\">ILogger</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Title&#123;<span class=\"keyword\">get</span>;<span class=\"keyword\">set</span>;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">info</span>(<span class=\"params\"><span class=\"keyword\">string</span> title,<span class=\"keyword\">object</span> obj</span>)</span>&#123;</span><br><span class=\"line\">    \t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1608166710216-cd91a302-94c4-46f7-84d3-957ab0d7f12c.png#align=left&amp;display=inline&amp;height=405&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=405&amp;originWidth=855&amp;size=30617&amp;status=done&amp;style=none&amp;width=855\" alt=\"image.png\"></h3><h3 id=\"3-伪对象、模拟对象与桩对象\"><a href=\"#3-伪对象、模拟对象与桩对象\" class=\"headerlink\" title=\"3 伪对象、模拟对象与桩对象\"></a>3 伪对象、模拟对象与桩对象</h3><h4 id=\"伪对象\"><a href=\"#伪对象\" class=\"headerlink\" title=\"伪对象\"></a>伪对象</h4><p>伪对象是通用的术语,可以描述一个存根或者模拟对象(手工或非手工編写),因为存根和模拟对象看上去都很像真实对象。一个伪对象究竟是存根还是模拟对象取决于它在当前测试中的使用方式:如果这个伪对象用来检验一个交互(对其进行断言),它就是模拟对象,否则就是存根</p>\n<h4 id=\"模拟对象与桩对象的区别\"><a href=\"#模拟对象与桩对象的区别\" class=\"headerlink\" title=\"模拟对象与桩对象的区别\"></a>模拟对象与桩对象的区别</h4><p>乍一看模拟对象与桩对象很相似,或者根本不存在区别。但区分二者又很重要,因为会使用这两个词来描述框架的各种不同行为。<br>二者最根本的区别是存根不会导致测试失败,而模拟对象可以<br>要辨别你是否使用了存根,最简单的方法是:存根永远不会导致测试失败。测试总是对被测试类进行断言<br>另一方面,测试会使用模拟对象验证測试是否失败。下图展示了测试和模拟对象之前的交互。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1608166109962-b4b5d2c2-ebf3-49aa-a131-d508df3df37b.png#align=left&amp;display=inline&amp;height=256&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=256&amp;originWidth=812&amp;size=21832&amp;status=done&amp;style=none&amp;width=812\" alt=\"image.png\"></p>\n<h4 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4 小结\"></a>4 小结</h4><p>本文简单总结了，当单元测试遇到外部依赖对象的时候我们通过桩对象来破除依赖，而在涉及验证是否正确调用一个外部对象的时候，我们可以使用模拟对象来进行交互测试。<br>可以看到这里我们用来创造伪对象都是通过自己手写代码的方式，而真实项目中有时候可能需要多个伪对象，那么又有什么好的方式呢。实际上现在无论是.net和java为了更好的单测已经产生了许多好用的单测框架与模拟框架。弄明白单测的一些基本思想，再熟练的运用好这些框架，将会让我们的单元测试进行的更加如鱼得水。<br>而关于一些常用的单元测试框架和模拟框架将下篇文章继续总结。</p>\n","site":{"data":{}},"excerpt":"<p>在我们单元测试的实践中，常常会发现一个方法依赖一个无法控制的对象，我们称其为外部依赖项。<br>一个外部依赖项——是系统中的一个对象,被测试代码与这个对象发生交互,但<strong>你不能控制这个对象</strong>。(常见的外部依赖项包括文件系统、线程、内存以及时间等。)<br>而单元测试背后的思想是，仅测试这个方法中的内容，当测试开始渗透到其他类、服务或系统时，此时测试便跨越了边界。而一旦测试跨了边界就变成了集成测试。进而也带来了所有与集成测试相关的问题——运行速度较慢,需要配置,一次测试多个内容……<br>","more":"</p>\n<h3 id=\"1-桩对象-存根\"><a href=\"#1-桩对象-存根\" class=\"headerlink\" title=\"1 桩对象(存根)\"></a>1 桩对象(存根)</h3><h4 id=\"什么是桩对象-存根\"><a href=\"#什么是桩对象-存根\" class=\"headerlink\" title=\"什么是桩对象(存根)\"></a>什么是桩对象(存根)</h4><p>一个<strong>存根(桩对象)(stub)</strong>是对系统中存在的一个依赖项(或者协作者)的可控制的替代物。通过使用存根,你在测试代码时无需直接处理这个依赖项。</p>\n<h4 id=\"如何使用桩对象-存根-破除依赖\"><a href=\"#如何使用桩对象-存根-破除依赖\" class=\"headerlink\" title=\"如何使用桩对象(存根)破除依赖\"></a>如何使用桩对象(存根)破除依赖</h4><h4 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h4><p>假设我们有下面这样一个方法，从文件系统中读取一个文件，获取文件的扩展名，如果扩展名是jpg就返回true，否则返回false。<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFileExtensionManager fileManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">IsValidFileName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取文件扩展名</span></span><br><span class=\"line\">    <span class=\"keyword\">string</span> extName=fileManager.GetExtName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(extName==<span class=\"string\">\"jpg\"</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FileExtensionManager</span>:<span class=\"title\">IFileExtensionManager</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">string</span> <span class=\"title\">GetExtName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//调用真实的文件系统获取文件</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> file.GetExtension();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>很明显在这个方法中，我们要测的逻辑是扩展名是jpg就返回true，否则返回false。这个方法我们依赖一个外部方法FileExtensionManage.GetExtName()(获取文件的扩展名)。<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1606785041078-040a98de-e470-48a7-b0f4-cb98a7eb887c.png#align=left&amp;display=inline&amp;height=325&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=325&amp;originWidth=580&amp;size=26293&amp;status=done&amp;style=none&amp;width=580\" alt=\"image.png\"><br>使用存根破除依赖一般有下面几个步骤</p>\n<ol>\n<li>找到被测试对象使用的外部接口</li>\n<li>把这个接口的底层实现替换成你能控制的东西。<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFileExtensionManager fileManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">IsValidFileName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取文件扩展名</span></span><br><span class=\"line\">    <span class=\"keyword\">string</span> extName=fileManager.GetExtName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(extName==<span class=\"string\">\"jpg\"</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">StubFileExtensionManager</span>:<span class=\"title\">IFileExtensionManager</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">string</span> <span class=\"title\">GetExtName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 模拟文件系统的返回结果</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"jpg\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我们所创造的替代实例StubFileExtensionManager根本不会访问文件系统,这样就破除了对文件系统的依赖性。因为要测试的不是访问文件系统的类,而是调用这个类的代码，这个时候我们的的依赖关系就变成了下面这样<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1606784771047-b1f0f10d-ba66-4efc-8bf8-c5bd27f9daa0.png#align=left&amp;display=inline&amp;height=302&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=302&amp;originWidth=847&amp;size=39206&amp;status=done&amp;style=none&amp;width=847\" alt=\"image.png\"></p>\n<h4 id=\"示例2\"><a href=\"#示例2\" class=\"headerlink\" title=\"示例2\"></a>示例2</h4><p>在上面的示例中，我们的被测试类与文件系统帮助类并非是强依赖的，而是依赖倒置的(通过接口IFileExtensionManager解耦)，而在有些系统中，对于文件系统的访问类可能是下面这样的<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">IsValidFileName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取文件扩展名</span></span><br><span class=\"line\">    <span class=\"keyword\">string</span> extName=<span class=\"keyword\">new</span> FileExtensionManager().GetExtName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(extName==<span class=\"string\">\"jpg\"</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1606785453312-6b272254-d86a-44ee-87e7-e4f4b1c2acf0.png#align=left&amp;display=inline&amp;height=250&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=250&amp;originWidth=266&amp;size=10174&amp;status=done&amp;style=none&amp;width=266\" alt=\"image.png\"><br>这种情况下由于代码的不可测试性，我们就需要先对代码进行重构。使其更具有可测试性(注意:可测试性同样是我们编码所需要注意的原则之一)</p>\n<ol>\n<li>找到被测试的工作单元依赖的外部对象。</li>\n<li>如果这个外部对象与被测试工作单元直接相连(本例中,你直接读取文件系统),就在代码中添加一个间接层。</li>\n<li>把这个交互接口的底层实現替换成你可以控制的代码。</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1606785690750-3ca66988-9e18-4193-a667-bba43f7f03bc.png#align=left&amp;display=inline&amp;height=635&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=635&amp;originWidth=868&amp;size=69946&amp;status=done&amp;style=none&amp;width=868\" alt=\"image.png\"><br>此时变成了示例1的情况，就可以进行测试。<br>而在实践过程中，我们还会遇到许多难以测试的代码，这时就需要通过重构来提高其可测试性。关于如何是代码变得更加容易测试，后续文章继续总结。</p>\n<h3 id=\"2-模拟对象\"><a href=\"#2-模拟对象\" class=\"headerlink\" title=\"2 模拟对象\"></a>2 模拟对象</h3><h4 id=\"什么是模拟对象\"><a href=\"#什么是模拟对象\" class=\"headerlink\" title=\"什么是模拟对象\"></a>什么是模拟对象</h4><p>模拟对象可以验证被测试对象是否接预期的方式调用了这个伪对象,因此导致单元测试通过或是失败。<br>模拟对象主要用来做交互性测试，例如:调用一个第三方日志系统,你所调用的方法并不会返回任何东西，我们如何判断是否调用正确，甚至是否发生了调用。</p>\n<h4 id=\"如何利用模拟对象进行交互测试\"><a href=\"#如何利用模拟对象进行交互测试\" class=\"headerlink\" title=\"如何利用模拟对象进行交互测试\"></a>如何利用模拟对象进行交互测试</h4><p>如下示例，在我们的业务方法中如果文件名的长度大于8就要记录一个warn日志。这个方法不返回任何值，其所调用的日志系统的方法也不返回任何值。这个时候我们要验证是否如期调用了日志系统的warn方法。<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FlieService</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    ILogger logger;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlieService</span>(<span class=\"params\">ILogger logger</span>)</span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">this</span>.logger=logger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"comment\">// 被测方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">LogValidResult</span>(<span class=\"params\"><span class=\"keyword\">string</span> fileName</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(fileName.length&gt;<span class=\"number\">8</span>)&#123;</span><br><span class=\"line\">\t\t\tlogger.warn(<span class=\"string\">\"invalid ...\"</span>,obj);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试方法</span></span><br><span class=\"line\">[<span class=\"meta\">Test</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">LogValidResult_Valid_Logger</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">string</span> fileName=<span class=\"string\">\"hello world\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> logger=<span class=\"keyword\">new</span> MockLogger();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> FileService(logger).LogValidResult();</span><br><span class=\"line\">    <span class=\"keyword\">string</span> expect=<span class=\"string\">\"invalid ...\"</span>;    </span><br><span class=\"line\">    <span class=\"keyword\">string</span> actual=logger.Title;</span><br><span class=\"line\">    Assert.AreEqual(expect,actual);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MockLogger</span>:<span class=\"title\">ILogger</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">string</span> Title&#123;<span class=\"keyword\">get</span>;<span class=\"keyword\">set</span>;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">info</span>(<span class=\"params\"><span class=\"keyword\">string</span> title,<span class=\"keyword\">object</span> obj</span>)</span>&#123;</span><br><span class=\"line\">    \t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1608166710216-cd91a302-94c4-46f7-84d3-957ab0d7f12c.png#align=left&amp;display=inline&amp;height=405&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=405&amp;originWidth=855&amp;size=30617&amp;status=done&amp;style=none&amp;width=855\" alt=\"image.png\"></h3><h3 id=\"3-伪对象、模拟对象与桩对象\"><a href=\"#3-伪对象、模拟对象与桩对象\" class=\"headerlink\" title=\"3 伪对象、模拟对象与桩对象\"></a>3 伪对象、模拟对象与桩对象</h3><h4 id=\"伪对象\"><a href=\"#伪对象\" class=\"headerlink\" title=\"伪对象\"></a>伪对象</h4><p>伪对象是通用的术语,可以描述一个存根或者模拟对象(手工或非手工編写),因为存根和模拟对象看上去都很像真实对象。一个伪对象究竟是存根还是模拟对象取决于它在当前测试中的使用方式:如果这个伪对象用来检验一个交互(对其进行断言),它就是模拟对象,否则就是存根</p>\n<h4 id=\"模拟对象与桩对象的区别\"><a href=\"#模拟对象与桩对象的区别\" class=\"headerlink\" title=\"模拟对象与桩对象的区别\"></a>模拟对象与桩对象的区别</h4><p>乍一看模拟对象与桩对象很相似,或者根本不存在区别。但区分二者又很重要,因为会使用这两个词来描述框架的各种不同行为。<br>二者最根本的区别是存根不会导致测试失败,而模拟对象可以<br>要辨别你是否使用了存根,最简单的方法是:存根永远不会导致测试失败。测试总是对被测试类进行断言<br>另一方面,测试会使用模拟对象验证測试是否失败。下图展示了测试和模拟对象之前的交互。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/479376/1608166109962-b4b5d2c2-ebf3-49aa-a131-d508df3df37b.png#align=left&amp;display=inline&amp;height=256&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=256&amp;originWidth=812&amp;size=21832&amp;status=done&amp;style=none&amp;width=812\" alt=\"image.png\"></p>\n<h4 id=\"4-小结\"><a href=\"#4-小结\" class=\"headerlink\" title=\"4 小结\"></a>4 小结</h4><p>本文简单总结了，当单元测试遇到外部依赖对象的时候我们通过桩对象来破除依赖，而在涉及验证是否正确调用一个外部对象的时候，我们可以使用模拟对象来进行交互测试。<br>可以看到这里我们用来创造伪对象都是通过自己手写代码的方式，而真实项目中有时候可能需要多个伪对象，那么又有什么好的方式呢。实际上现在无论是.net和java为了更好的单测已经产生了许多好用的单测框架与模拟框架。弄明白单测的一些基本思想，再熟练的运用好这些框架，将会让我们的单元测试进行的更加如鱼得水。<br>而关于一些常用的单元测试框架和模拟框架将下篇文章继续总结。</p>"},{"title":"如何编写优秀的测试代码","copyright":true,"date":"2021-01-06T01:29:26.000Z","keywords":"单元测试","_content":"\n无论如何组织测试,无论有多少测试,如果你不能信任、维护以及阅读它们,这些测试就几乎没有价值。要成为优秀的测试,它们应该同时具有如下三个属性。\n<!--more-->\n\n1. **可靠性****。**开发人员希望运行的測试可靠,能够对测试结果有信心。可靠的测试没有缺陷而且测试正确的事情\n1. **可维护**。性无法维护的測试是梦,它们会拖延项目计划,或者当项目日程紧张时被搁置一旁。如果修改测试花费时间过多,或者经常需要为很小的产品代码频繁变更修改测试,开发人员会直接停止测试的维护和修复工作\n1. **可读性**。人们不仅要能够阅读测试,还要在测试出问题时找出症结所在。失去可读性另外两个支柱很快也会倒塌。如果无法理解测试,测试的维护工作就会变得困难,也无法得到人们的信任。\n### 1. 可靠性\n#### 1.1 及时维护测试代码\n测试代码与产品代码一样需要不断进行维护，一旦测试写好了并且通过了,通常是不应该修改或删除这些测试的。这些测试是你的保护网告诉你修改的代码是否破坏了已有的功能。虽说如此,有时可能还是需要修改或者删除已有的测试。要理解什么情况下修改或删除测试会带来问题,什么情况下这么做是合理的。\n删除一个测试的主要的理由是这个测试失败了。如果一个测试突然开始失败,可能有如下原因\n\n- 产品缺陷    被测试的产品代码有缺陷。\n- 测试缺陷    测试中有缺陷。\n- 语义或者AP变更    被测试代码的语义发生变化,但是功能不变\n- 冲突或者无效的测试    和测试相关的产品需求发生变化,产品代码随之变更\n\n如果测试或代码没有任何问题,修改或删除测试的原因有:\n\n- 重命名或者重构测试\n\n不可读的测试带来的麻烦比解决的问题更多。它会影响代码的可读性,妨碍你理解测试发现的问题\n如果你看到测试名含义不清或者令人误解,或者测试的可维护性有待提高,就应该修改测试代码(但是不要改变测试的基本功能)\n\n- 去除重复代码\n\n#### 1.2 避免测试代码中的逻辑\n如果单元测试中有下列任何一种语句,你的测试就包含了不应该有的逻辑:*\n\n-  switch、if或e1se语句;*\n-  foreach、for或whi1e循环。\n\n包含逻辑的测试通常会一次测试多个东西,我们不推荐这种做法,因为这样的测试可读性较也比较脆弱。而且测试逻辑也增加了代码复杂度,可能包含隐藏的缺陷通常来说,一个单元测试应该是一系列的方法调用和断言,但是不包含控制流语句,甚至不应将断言语句包含在try- catch中。任何更复杂的语句都可能导致如下问题。\n\n- 测试难以阅读和理解\n- 测试难以重现。(设想一下,如果一个多线程测试或者使用随机数的测试突然失败了,该如何处理。)\n- 测试较容易包含缺陷或者测试错误的事情\n- 难以命名测试,因为它执行多件任务\n#### 1.3 只测一个关注点\n如前所述,一个关注点是一个工作单元的一个最终结果:一个返回值、系统状态的一个改变或者对第三方对象的一个调用。例如:如果你的单元测试对多个对象进行了断言,那么这个测试有可能测试了多个关注点。另一种情况是,它既测试了一个对象返回正确的值,又验证系统状态改变导致这个对象的行为发生变化,那么这个测试也可能测试了多个关注点。\n测试多个关注点听起来没什么,但是等到你要命名测试,或者考虑第一个对象的断言失败该如何处理时,就会遇到问题。\n命名测试看似简单,但是如果同时测试了多个东西,就几乎不可能给测试起一个能说明测试内容的好名字。你最后起的名字可能非常通用,使得读者不得不去阅读测试代码(本章的可读性节详细对此进行讨论)。如果一次只测试一个关注点,测试命名就很简单\n#### 1.4 单元测试与集成测试分离\n把集成混在单元测试里放在测试项目中会导致很多方面的问题。这种测试难以运行,会让人们误以为代码有问题,浪费时间和精力进行检查,最后导致开发人员不再信任这组测试。混在单元测试里的集成测试就像筐里的烂苹果连累了其他的测试。如果下一次再发生类似的事情,开发人员甚至都不会去调查失败原因,直接就说:“哦,那个测试有时候就是会失败,没事的。”要避免这样的事情发生,就要建一个绿色安全区把集成测试和单元测试分开。\n绿色安全区里只包含单元测试。运行绿色安全区里的所有测试测试结果应该全部是绿色的，如果有测试失败，就说明出现了真正的代码问题，而不是因为某些配置或外部依赖倒置的假警报。\n#### 1.5 代码审查与覆盖率结合\n代码覆盖率100%说明什么呢?如果没有做代码审查,这个覆盖率不能说明什么。你的团队可能会要求所有人的测试“达到95%以上的代码覆盖率”,大家可能也确实做到了。但是也许这些测试连断言都没有。人们通常会选择做最少的事情达到某个指定的目标。\n那么代码覆盖率100%再加上测试和代码审查能说明什么呢?这说明整个世界都是你的。如果你做了代码审查和测试审查,确保测试优秀而且覆盖了所有代码,那么你就拥有了一个安全网,可以避免愚蠢的错误,同时团队也获得了分享的知识,从持续的学习中获益\n### 2. 可维护性\n#### 2.1 去除重复(Extract Method)\n作为开发者,单元测试中的重复代码和产品代码中的重复一样(如果不是更加)有害。DRY原则应该同样适用于测试代码。重复代码意味测试对象某方面改变时要修改更多的测试代码。如果测试中有大量重复代码,构造函数变更或者使用类的语义变化会产生极大的影响\n#### 2.2 测试隔离\n测试隔离的基本概念是:一个测试应该总是在它自己的小世界中运行,与其他进行类似或不同的工作的测试隔离甚至不知道其他测试的存在。\n如果没有很好地隔离测试,它们会互相影响,使你非常悲惨,后悔在项目中尝试单元测试决心以后再也不做单元测试了。我见过这种情况。开发人员不愿费心检查测试中的问题,因此当出现问题时,需要花很多时间才能找到原因有些测试同样存在着一些坏味道能够提示测试隔离可能有问题。\n\n- 强制的测试顺序    测试需要以某种特定顺序执行,或者需要来自其他测试结果的信息\n- 隐藏的测试调用    测试调用其他测试。\n- 共享状态损坏    测试共享内存里的状态,却没有回滚状态。\n- 外部共享状态损坏    集成测试共享资源,却没有回滚资源。\n#### 2.3 避免对不同的关注点多次断言(使用参数化测试)\n```csharp\nAssert.AreEqual(2,Sum(1,2));\nAssert.AreEqual(5,Sum(2,2));\nAssert.AreEqual(6,Sum(5,2));\n```\n如上示例，这个测试方法中使用了三个断言，进行了三个测试。这样看起来在实际过程中会节省一些写代码的时间，但会有一些问题。如果第一个断言失败，则后续断言就不会在执行。而在这个示例中我们是进行了三个测试。第一个断言失败就会导致我们无法得知另外两个测试的测试结果。对于这种情况我们可以采取别的方式进行测试\n\n1. 给每个断言创建一个单独的测试\n1. 使用参数化测试\n1. 把断言代码放在一个try-catch块中\n\n#### 2.4 避免过度指定\n过度指定的测试对一个具体的被测试单元如何实现其内部行为进行了假设,而不是只检查其最终行为的正确性单元测试中过度指定主要有以下几种情况\n\n- 测试对一个被测试对象的纯内部状态进行了断言\n- 测试使用多个模拟对象\n- 测试在需要存根时使用模拟对象\n- 测试在不必要的情况下指定顺序或使用了精确匹配。\n\n### 3. 可读性\n不可读的测试几乎没有任何意义。可读性这条线连接着编写测试的人和几个月后阅读测试的人。测试是你向项目的下一代开发者讲述的故事,帮助开发者理解一个应用程序的组成及其开端。\n测试可读性有如下几个方面\n\n- 命名单元测试\n- 命名变量\n- 使用好的断言信息\n- 把断言和操作分离\n#### 3.1 单元测试命名\n命名标准非常重要,提供了合理的规则和模板,列出应该包括的测试信息。测试名一般包括三部分。\n\n- **被测试方法名    **非常关键,指明了被测试逻辑的位置。把被测试方法名放在测试方法开头,可以很容易地在测试类中浏览测试和使用智能感知(如果IDE支持)\n- **测试场景**     说明了测试使用的条件:“如果我用一个nu11值调用方法x,那么它应该执行Y。”\n- **预期行为**    基于当前场景,方法应该产生的行为结果或者返回值,或者行为方式:“如果用一个null值调用方法X,那么它应该执行Y。”如果测试名缺少上面列出的任何一部分,测试的读者就会疑惑测试究竟在做什么,需要阅读测试代码。合理地命名测试,主要目的就是为了使后来的开发者从为了理解测试而阅读代码的负担中解脱出来。\n```csharp\npublic void IsValidFileName(){\n\t...\n}\n\n[Test]\npublic void IsValidFileName_WhenPNG_ReturnFalse(){\n\t...\n}\n```\n如上示例，通过测试的方法命名我们就可以大概知道要测试的是方法是IsValidFileName当输入参数是PNG的时候，预期返回False。\n\n当然，你的团队也可以有适合自己的命名方式，但重要的是如果一个团队中都有统一的有意义命名规范，那么单元测试的可读性将大大提升，并且有利于后来者快速进入项目，理解测试。\n#### 3.2 变量命名\n测试中的变量命名和产品代码中的命名规范同样重要，通过合理的变量命名，我们可以确保阅读测试的人可以尽快的理解你要验证什么。\n```csharp\n// 反例\nAssert.AreEqual(100,actual);\n```\n如上示例，我们经常会看到测试中出现\"100\"这样的魔法数字。因为测试中没有描述性的名字，也许你在刚刚写完的时候还知道它是什么意思，但是一周后，一月后，一年后呢？甚至你未来的继任者看到这样的测试代码也是一头雾水。\n\n#### 3.4 断言和操作分离\n很多人为了“偷懒”经常会把断言和方法调用卸载同一行里，但这是一个很不好的习惯，它会大大降低代码的可读性。\n```csharp\n// 反例\n    Assert.AreEqual(true,fileManger.IsValidName())\n\n// 正例\n    bool expect=true;\n    bool actual=fileManger.IsValidName();\n    Assert.AreEqual(expect,actual)\n\n```\n\n\n","source":"_posts/技术实践/单元测试/如何编写优秀的测试代码.md","raw":"---\ntitle: 如何编写优秀的测试代码\ncopyright: true\ndate: 2021-01-06 09:29:26\ntags: \n- 单元测试\ncategories: \n- 单元测试\nkeywords: 单元测试\n---\n\n无论如何组织测试,无论有多少测试,如果你不能信任、维护以及阅读它们,这些测试就几乎没有价值。要成为优秀的测试,它们应该同时具有如下三个属性。\n<!--more-->\n\n1. **可靠性****。**开发人员希望运行的測试可靠,能够对测试结果有信心。可靠的测试没有缺陷而且测试正确的事情\n1. **可维护**。性无法维护的測试是梦,它们会拖延项目计划,或者当项目日程紧张时被搁置一旁。如果修改测试花费时间过多,或者经常需要为很小的产品代码频繁变更修改测试,开发人员会直接停止测试的维护和修复工作\n1. **可读性**。人们不仅要能够阅读测试,还要在测试出问题时找出症结所在。失去可读性另外两个支柱很快也会倒塌。如果无法理解测试,测试的维护工作就会变得困难,也无法得到人们的信任。\n### 1. 可靠性\n#### 1.1 及时维护测试代码\n测试代码与产品代码一样需要不断进行维护，一旦测试写好了并且通过了,通常是不应该修改或删除这些测试的。这些测试是你的保护网告诉你修改的代码是否破坏了已有的功能。虽说如此,有时可能还是需要修改或者删除已有的测试。要理解什么情况下修改或删除测试会带来问题,什么情况下这么做是合理的。\n删除一个测试的主要的理由是这个测试失败了。如果一个测试突然开始失败,可能有如下原因\n\n- 产品缺陷    被测试的产品代码有缺陷。\n- 测试缺陷    测试中有缺陷。\n- 语义或者AP变更    被测试代码的语义发生变化,但是功能不变\n- 冲突或者无效的测试    和测试相关的产品需求发生变化,产品代码随之变更\n\n如果测试或代码没有任何问题,修改或删除测试的原因有:\n\n- 重命名或者重构测试\n\n不可读的测试带来的麻烦比解决的问题更多。它会影响代码的可读性,妨碍你理解测试发现的问题\n如果你看到测试名含义不清或者令人误解,或者测试的可维护性有待提高,就应该修改测试代码(但是不要改变测试的基本功能)\n\n- 去除重复代码\n\n#### 1.2 避免测试代码中的逻辑\n如果单元测试中有下列任何一种语句,你的测试就包含了不应该有的逻辑:*\n\n-  switch、if或e1se语句;*\n-  foreach、for或whi1e循环。\n\n包含逻辑的测试通常会一次测试多个东西,我们不推荐这种做法,因为这样的测试可读性较也比较脆弱。而且测试逻辑也增加了代码复杂度,可能包含隐藏的缺陷通常来说,一个单元测试应该是一系列的方法调用和断言,但是不包含控制流语句,甚至不应将断言语句包含在try- catch中。任何更复杂的语句都可能导致如下问题。\n\n- 测试难以阅读和理解\n- 测试难以重现。(设想一下,如果一个多线程测试或者使用随机数的测试突然失败了,该如何处理。)\n- 测试较容易包含缺陷或者测试错误的事情\n- 难以命名测试,因为它执行多件任务\n#### 1.3 只测一个关注点\n如前所述,一个关注点是一个工作单元的一个最终结果:一个返回值、系统状态的一个改变或者对第三方对象的一个调用。例如:如果你的单元测试对多个对象进行了断言,那么这个测试有可能测试了多个关注点。另一种情况是,它既测试了一个对象返回正确的值,又验证系统状态改变导致这个对象的行为发生变化,那么这个测试也可能测试了多个关注点。\n测试多个关注点听起来没什么,但是等到你要命名测试,或者考虑第一个对象的断言失败该如何处理时,就会遇到问题。\n命名测试看似简单,但是如果同时测试了多个东西,就几乎不可能给测试起一个能说明测试内容的好名字。你最后起的名字可能非常通用,使得读者不得不去阅读测试代码(本章的可读性节详细对此进行讨论)。如果一次只测试一个关注点,测试命名就很简单\n#### 1.4 单元测试与集成测试分离\n把集成混在单元测试里放在测试项目中会导致很多方面的问题。这种测试难以运行,会让人们误以为代码有问题,浪费时间和精力进行检查,最后导致开发人员不再信任这组测试。混在单元测试里的集成测试就像筐里的烂苹果连累了其他的测试。如果下一次再发生类似的事情,开发人员甚至都不会去调查失败原因,直接就说:“哦,那个测试有时候就是会失败,没事的。”要避免这样的事情发生,就要建一个绿色安全区把集成测试和单元测试分开。\n绿色安全区里只包含单元测试。运行绿色安全区里的所有测试测试结果应该全部是绿色的，如果有测试失败，就说明出现了真正的代码问题，而不是因为某些配置或外部依赖倒置的假警报。\n#### 1.5 代码审查与覆盖率结合\n代码覆盖率100%说明什么呢?如果没有做代码审查,这个覆盖率不能说明什么。你的团队可能会要求所有人的测试“达到95%以上的代码覆盖率”,大家可能也确实做到了。但是也许这些测试连断言都没有。人们通常会选择做最少的事情达到某个指定的目标。\n那么代码覆盖率100%再加上测试和代码审查能说明什么呢?这说明整个世界都是你的。如果你做了代码审查和测试审查,确保测试优秀而且覆盖了所有代码,那么你就拥有了一个安全网,可以避免愚蠢的错误,同时团队也获得了分享的知识,从持续的学习中获益\n### 2. 可维护性\n#### 2.1 去除重复(Extract Method)\n作为开发者,单元测试中的重复代码和产品代码中的重复一样(如果不是更加)有害。DRY原则应该同样适用于测试代码。重复代码意味测试对象某方面改变时要修改更多的测试代码。如果测试中有大量重复代码,构造函数变更或者使用类的语义变化会产生极大的影响\n#### 2.2 测试隔离\n测试隔离的基本概念是:一个测试应该总是在它自己的小世界中运行,与其他进行类似或不同的工作的测试隔离甚至不知道其他测试的存在。\n如果没有很好地隔离测试,它们会互相影响,使你非常悲惨,后悔在项目中尝试单元测试决心以后再也不做单元测试了。我见过这种情况。开发人员不愿费心检查测试中的问题,因此当出现问题时,需要花很多时间才能找到原因有些测试同样存在着一些坏味道能够提示测试隔离可能有问题。\n\n- 强制的测试顺序    测试需要以某种特定顺序执行,或者需要来自其他测试结果的信息\n- 隐藏的测试调用    测试调用其他测试。\n- 共享状态损坏    测试共享内存里的状态,却没有回滚状态。\n- 外部共享状态损坏    集成测试共享资源,却没有回滚资源。\n#### 2.3 避免对不同的关注点多次断言(使用参数化测试)\n```csharp\nAssert.AreEqual(2,Sum(1,2));\nAssert.AreEqual(5,Sum(2,2));\nAssert.AreEqual(6,Sum(5,2));\n```\n如上示例，这个测试方法中使用了三个断言，进行了三个测试。这样看起来在实际过程中会节省一些写代码的时间，但会有一些问题。如果第一个断言失败，则后续断言就不会在执行。而在这个示例中我们是进行了三个测试。第一个断言失败就会导致我们无法得知另外两个测试的测试结果。对于这种情况我们可以采取别的方式进行测试\n\n1. 给每个断言创建一个单独的测试\n1. 使用参数化测试\n1. 把断言代码放在一个try-catch块中\n\n#### 2.4 避免过度指定\n过度指定的测试对一个具体的被测试单元如何实现其内部行为进行了假设,而不是只检查其最终行为的正确性单元测试中过度指定主要有以下几种情况\n\n- 测试对一个被测试对象的纯内部状态进行了断言\n- 测试使用多个模拟对象\n- 测试在需要存根时使用模拟对象\n- 测试在不必要的情况下指定顺序或使用了精确匹配。\n\n### 3. 可读性\n不可读的测试几乎没有任何意义。可读性这条线连接着编写测试的人和几个月后阅读测试的人。测试是你向项目的下一代开发者讲述的故事,帮助开发者理解一个应用程序的组成及其开端。\n测试可读性有如下几个方面\n\n- 命名单元测试\n- 命名变量\n- 使用好的断言信息\n- 把断言和操作分离\n#### 3.1 单元测试命名\n命名标准非常重要,提供了合理的规则和模板,列出应该包括的测试信息。测试名一般包括三部分。\n\n- **被测试方法名    **非常关键,指明了被测试逻辑的位置。把被测试方法名放在测试方法开头,可以很容易地在测试类中浏览测试和使用智能感知(如果IDE支持)\n- **测试场景**     说明了测试使用的条件:“如果我用一个nu11值调用方法x,那么它应该执行Y。”\n- **预期行为**    基于当前场景,方法应该产生的行为结果或者返回值,或者行为方式:“如果用一个null值调用方法X,那么它应该执行Y。”如果测试名缺少上面列出的任何一部分,测试的读者就会疑惑测试究竟在做什么,需要阅读测试代码。合理地命名测试,主要目的就是为了使后来的开发者从为了理解测试而阅读代码的负担中解脱出来。\n```csharp\npublic void IsValidFileName(){\n\t...\n}\n\n[Test]\npublic void IsValidFileName_WhenPNG_ReturnFalse(){\n\t...\n}\n```\n如上示例，通过测试的方法命名我们就可以大概知道要测试的是方法是IsValidFileName当输入参数是PNG的时候，预期返回False。\n\n当然，你的团队也可以有适合自己的命名方式，但重要的是如果一个团队中都有统一的有意义命名规范，那么单元测试的可读性将大大提升，并且有利于后来者快速进入项目，理解测试。\n#### 3.2 变量命名\n测试中的变量命名和产品代码中的命名规范同样重要，通过合理的变量命名，我们可以确保阅读测试的人可以尽快的理解你要验证什么。\n```csharp\n// 反例\nAssert.AreEqual(100,actual);\n```\n如上示例，我们经常会看到测试中出现\"100\"这样的魔法数字。因为测试中没有描述性的名字，也许你在刚刚写完的时候还知道它是什么意思，但是一周后，一月后，一年后呢？甚至你未来的继任者看到这样的测试代码也是一头雾水。\n\n#### 3.4 断言和操作分离\n很多人为了“偷懒”经常会把断言和方法调用卸载同一行里，但这是一个很不好的习惯，它会大大降低代码的可读性。\n```csharp\n// 反例\n    Assert.AreEqual(true,fileManger.IsValidName())\n\n// 正例\n    bool expect=true;\n    bool actual=fileManger.IsValidName();\n    Assert.AreEqual(expect,actual)\n\n```\n\n\n","slug":"技术实践/单元测试/如何编写优秀的测试代码","published":1,"updated":"2021-03-21T08:32:27.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfq0200fghyjfa7bme090","content":"<p>无论如何组织测试,无论有多少测试,如果你不能信任、维护以及阅读它们,这些测试就几乎没有价值。要成为优秀的测试,它们应该同时具有如下三个属性。<br><a id=\"more\"></a></p>\n<ol>\n<li><strong>可靠性**</strong>。**开发人员希望运行的測试可靠,能够对测试结果有信心。可靠的测试没有缺陷而且测试正确的事情</li>\n<li><strong>可维护</strong>。性无法维护的測试是梦,它们会拖延项目计划,或者当项目日程紧张时被搁置一旁。如果修改测试花费时间过多,或者经常需要为很小的产品代码频繁变更修改测试,开发人员会直接停止测试的维护和修复工作</li>\n<li><strong>可读性</strong>。人们不仅要能够阅读测试,还要在测试出问题时找出症结所在。失去可读性另外两个支柱很快也会倒塌。如果无法理解测试,测试的维护工作就会变得困难,也无法得到人们的信任。<h3 id=\"1-可靠性\"><a href=\"#1-可靠性\" class=\"headerlink\" title=\"1. 可靠性\"></a>1. 可靠性</h3><h4 id=\"1-1-及时维护测试代码\"><a href=\"#1-1-及时维护测试代码\" class=\"headerlink\" title=\"1.1 及时维护测试代码\"></a>1.1 及时维护测试代码</h4>测试代码与产品代码一样需要不断进行维护，一旦测试写好了并且通过了,通常是不应该修改或删除这些测试的。这些测试是你的保护网告诉你修改的代码是否破坏了已有的功能。虽说如此,有时可能还是需要修改或者删除已有的测试。要理解什么情况下修改或删除测试会带来问题,什么情况下这么做是合理的。<br>删除一个测试的主要的理由是这个测试失败了。如果一个测试突然开始失败,可能有如下原因</li>\n</ol>\n<ul>\n<li>产品缺陷    被测试的产品代码有缺陷。</li>\n<li>测试缺陷    测试中有缺陷。</li>\n<li>语义或者AP变更    被测试代码的语义发生变化,但是功能不变</li>\n<li>冲突或者无效的测试    和测试相关的产品需求发生变化,产品代码随之变更</li>\n</ul>\n<p>如果测试或代码没有任何问题,修改或删除测试的原因有:</p>\n<ul>\n<li>重命名或者重构测试</li>\n</ul>\n<p>不可读的测试带来的麻烦比解决的问题更多。它会影响代码的可读性,妨碍你理解测试发现的问题<br>如果你看到测试名含义不清或者令人误解,或者测试的可维护性有待提高,就应该修改测试代码(但是不要改变测试的基本功能)</p>\n<ul>\n<li>去除重复代码</li>\n</ul>\n<h4 id=\"1-2-避免测试代码中的逻辑\"><a href=\"#1-2-避免测试代码中的逻辑\" class=\"headerlink\" title=\"1.2 避免测试代码中的逻辑\"></a>1.2 避免测试代码中的逻辑</h4><p>如果单元测试中有下列任何一种语句,你的测试就包含了不应该有的逻辑:*</p>\n<ul>\n<li>switch、if或e1se语句;*</li>\n<li>foreach、for或whi1e循环。</li>\n</ul>\n<p>包含逻辑的测试通常会一次测试多个东西,我们不推荐这种做法,因为这样的测试可读性较也比较脆弱。而且测试逻辑也增加了代码复杂度,可能包含隐藏的缺陷通常来说,一个单元测试应该是一系列的方法调用和断言,但是不包含控制流语句,甚至不应将断言语句包含在try- catch中。任何更复杂的语句都可能导致如下问题。</p>\n<ul>\n<li>测试难以阅读和理解</li>\n<li>测试难以重现。(设想一下,如果一个多线程测试或者使用随机数的测试突然失败了,该如何处理。)</li>\n<li>测试较容易包含缺陷或者测试错误的事情</li>\n<li><p>难以命名测试,因为它执行多件任务</p>\n<h4 id=\"1-3-只测一个关注点\"><a href=\"#1-3-只测一个关注点\" class=\"headerlink\" title=\"1.3 只测一个关注点\"></a>1.3 只测一个关注点</h4><p>如前所述,一个关注点是一个工作单元的一个最终结果:一个返回值、系统状态的一个改变或者对第三方对象的一个调用。例如:如果你的单元测试对多个对象进行了断言,那么这个测试有可能测试了多个关注点。另一种情况是,它既测试了一个对象返回正确的值,又验证系统状态改变导致这个对象的行为发生变化,那么这个测试也可能测试了多个关注点。<br>测试多个关注点听起来没什么,但是等到你要命名测试,或者考虑第一个对象的断言失败该如何处理时,就会遇到问题。<br>命名测试看似简单,但是如果同时测试了多个东西,就几乎不可能给测试起一个能说明测试内容的好名字。你最后起的名字可能非常通用,使得读者不得不去阅读测试代码(本章的可读性节详细对此进行讨论)。如果一次只测试一个关注点,测试命名就很简单</p>\n<h4 id=\"1-4-单元测试与集成测试分离\"><a href=\"#1-4-单元测试与集成测试分离\" class=\"headerlink\" title=\"1.4 单元测试与集成测试分离\"></a>1.4 单元测试与集成测试分离</h4><p>把集成混在单元测试里放在测试项目中会导致很多方面的问题。这种测试难以运行,会让人们误以为代码有问题,浪费时间和精力进行检查,最后导致开发人员不再信任这组测试。混在单元测试里的集成测试就像筐里的烂苹果连累了其他的测试。如果下一次再发生类似的事情,开发人员甚至都不会去调查失败原因,直接就说:“哦,那个测试有时候就是会失败,没事的。”要避免这样的事情发生,就要建一个绿色安全区把集成测试和单元测试分开。<br>绿色安全区里只包含单元测试。运行绿色安全区里的所有测试测试结果应该全部是绿色的，如果有测试失败，就说明出现了真正的代码问题，而不是因为某些配置或外部依赖倒置的假警报。</p>\n<h4 id=\"1-5-代码审查与覆盖率结合\"><a href=\"#1-5-代码审查与覆盖率结合\" class=\"headerlink\" title=\"1.5 代码审查与覆盖率结合\"></a>1.5 代码审查与覆盖率结合</h4><p>代码覆盖率100%说明什么呢?如果没有做代码审查,这个覆盖率不能说明什么。你的团队可能会要求所有人的测试“达到95%以上的代码覆盖率”,大家可能也确实做到了。但是也许这些测试连断言都没有。人们通常会选择做最少的事情达到某个指定的目标。<br>那么代码覆盖率100%再加上测试和代码审查能说明什么呢?这说明整个世界都是你的。如果你做了代码审查和测试审查,确保测试优秀而且覆盖了所有代码,那么你就拥有了一个安全网,可以避免愚蠢的错误,同时团队也获得了分享的知识,从持续的学习中获益</p>\n<h3 id=\"2-可维护性\"><a href=\"#2-可维护性\" class=\"headerlink\" title=\"2. 可维护性\"></a>2. 可维护性</h3><h4 id=\"2-1-去除重复-Extract-Method\"><a href=\"#2-1-去除重复-Extract-Method\" class=\"headerlink\" title=\"2.1 去除重复(Extract Method)\"></a>2.1 去除重复(Extract Method)</h4><p>作为开发者,单元测试中的重复代码和产品代码中的重复一样(如果不是更加)有害。DRY原则应该同样适用于测试代码。重复代码意味测试对象某方面改变时要修改更多的测试代码。如果测试中有大量重复代码,构造函数变更或者使用类的语义变化会产生极大的影响</p>\n<h4 id=\"2-2-测试隔离\"><a href=\"#2-2-测试隔离\" class=\"headerlink\" title=\"2.2 测试隔离\"></a>2.2 测试隔离</h4><p>测试隔离的基本概念是:一个测试应该总是在它自己的小世界中运行,与其他进行类似或不同的工作的测试隔离甚至不知道其他测试的存在。<br>如果没有很好地隔离测试,它们会互相影响,使你非常悲惨,后悔在项目中尝试单元测试决心以后再也不做单元测试了。我见过这种情况。开发人员不愿费心检查测试中的问题,因此当出现问题时,需要花很多时间才能找到原因有些测试同样存在着一些坏味道能够提示测试隔离可能有问题。</p>\n</li>\n<li><p>强制的测试顺序    测试需要以某种特定顺序执行,或者需要来自其他测试结果的信息</p>\n</li>\n<li>隐藏的测试调用    测试调用其他测试。</li>\n<li>共享状态损坏    测试共享内存里的状态,却没有回滚状态。</li>\n<li>外部共享状态损坏    集成测试共享资源,却没有回滚资源。<h4 id=\"2-3-避免对不同的关注点多次断言-使用参数化测试\"><a href=\"#2-3-避免对不同的关注点多次断言-使用参数化测试\" class=\"headerlink\" title=\"2.3 避免对不同的关注点多次断言(使用参数化测试)\"></a>2.3 避免对不同的关注点多次断言(使用参数化测试)</h4><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Assert.AreEqual(<span class=\"number\">2</span>,Sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">Assert.AreEqual(<span class=\"number\">5</span>,Sum(<span class=\"number\">2</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">Assert.AreEqual(<span class=\"number\">6</span>,Sum(<span class=\"number\">5</span>,<span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如上示例，这个测试方法中使用了三个断言，进行了三个测试。这样看起来在实际过程中会节省一些写代码的时间，但会有一些问题。如果第一个断言失败，则后续断言就不会在执行。而在这个示例中我们是进行了三个测试。第一个断言失败就会导致我们无法得知另外两个测试的测试结果。对于这种情况我们可以采取别的方式进行测试</p>\n<ol>\n<li>给每个断言创建一个单独的测试</li>\n<li>使用参数化测试</li>\n<li>把断言代码放在一个try-catch块中</li>\n</ol>\n<h4 id=\"2-4-避免过度指定\"><a href=\"#2-4-避免过度指定\" class=\"headerlink\" title=\"2.4 避免过度指定\"></a>2.4 避免过度指定</h4><p>过度指定的测试对一个具体的被测试单元如何实现其内部行为进行了假设,而不是只检查其最终行为的正确性单元测试中过度指定主要有以下几种情况</p>\n<ul>\n<li>测试对一个被测试对象的纯内部状态进行了断言</li>\n<li>测试使用多个模拟对象</li>\n<li>测试在需要存根时使用模拟对象</li>\n<li>测试在不必要的情况下指定顺序或使用了精确匹配。</li>\n</ul>\n<h3 id=\"3-可读性\"><a href=\"#3-可读性\" class=\"headerlink\" title=\"3. 可读性\"></a>3. 可读性</h3><p>不可读的测试几乎没有任何意义。可读性这条线连接着编写测试的人和几个月后阅读测试的人。测试是你向项目的下一代开发者讲述的故事,帮助开发者理解一个应用程序的组成及其开端。<br>测试可读性有如下几个方面</p>\n<ul>\n<li>命名单元测试</li>\n<li>命名变量</li>\n<li>使用好的断言信息</li>\n<li><p>把断言和操作分离</p>\n<h4 id=\"3-1-单元测试命名\"><a href=\"#3-1-单元测试命名\" class=\"headerlink\" title=\"3.1 单元测试命名\"></a>3.1 单元测试命名</h4><p>命名标准非常重要,提供了合理的规则和模板,列出应该包括的测试信息。测试名一般包括三部分。</p>\n</li>\n<li><p><strong>被测试方法名    </strong>非常关键,指明了被测试逻辑的位置。把被测试方法名放在测试方法开头,可以很容易地在测试类中浏览测试和使用智能感知(如果IDE支持)</p>\n</li>\n<li><strong>测试场景</strong>     说明了测试使用的条件:“如果我用一个nu11值调用方法x,那么它应该执行Y。”</li>\n<li><strong>预期行为</strong>    基于当前场景,方法应该产生的行为结果或者返回值,或者行为方式:“如果用一个null值调用方法X,那么它应该执行Y。”如果测试名缺少上面列出的任何一部分,测试的读者就会疑惑测试究竟在做什么,需要阅读测试代码。合理地命名测试,主要目的就是为了使后来的开发者从为了理解测试而阅读代码的负担中解脱出来。<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">IsValidFileName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">Test</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">IsValidFileName_WhenPNG_ReturnFalse</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如上示例，通过测试的方法命名我们就可以大概知道要测试的是方法是IsValidFileName当输入参数是PNG的时候，预期返回False。</p>\n<p>当然，你的团队也可以有适合自己的命名方式，但重要的是如果一个团队中都有统一的有意义命名规范，那么单元测试的可读性将大大提升，并且有利于后来者快速进入项目，理解测试。</p>\n<h4 id=\"3-2-变量命名\"><a href=\"#3-2-变量命名\" class=\"headerlink\" title=\"3.2 变量命名\"></a>3.2 变量命名</h4><p>测试中的变量命名和产品代码中的命名规范同样重要，通过合理的变量命名，我们可以确保阅读测试的人可以尽快的理解你要验证什么。<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反例</span></span><br><span class=\"line\">Assert.AreEqual(<span class=\"number\">100</span>,actual);</span><br></pre></td></tr></table></figure></p>\n<p>如上示例，我们经常会看到测试中出现”100”这样的魔法数字。因为测试中没有描述性的名字，也许你在刚刚写完的时候还知道它是什么意思，但是一周后，一月后，一年后呢？甚至你未来的继任者看到这样的测试代码也是一头雾水。</p>\n<h4 id=\"3-4-断言和操作分离\"><a href=\"#3-4-断言和操作分离\" class=\"headerlink\" title=\"3.4 断言和操作分离\"></a>3.4 断言和操作分离</h4><p>很多人为了“偷懒”经常会把断言和方法调用卸载同一行里，但这是一个很不好的习惯，它会大大降低代码的可读性。<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反例</span></span><br><span class=\"line\">    Assert.AreEqual(<span class=\"literal\">true</span>,fileManger.IsValidName())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正例</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> expect=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> actual=fileManger.IsValidName();</span><br><span class=\"line\">    Assert.AreEqual(expect,actual)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>无论如何组织测试,无论有多少测试,如果你不能信任、维护以及阅读它们,这些测试就几乎没有价值。要成为优秀的测试,它们应该同时具有如下三个属性。<br>","more":"</p>\n<ol>\n<li><strong>可靠性**</strong>。**开发人员希望运行的測试可靠,能够对测试结果有信心。可靠的测试没有缺陷而且测试正确的事情</li>\n<li><strong>可维护</strong>。性无法维护的測试是梦,它们会拖延项目计划,或者当项目日程紧张时被搁置一旁。如果修改测试花费时间过多,或者经常需要为很小的产品代码频繁变更修改测试,开发人员会直接停止测试的维护和修复工作</li>\n<li><strong>可读性</strong>。人们不仅要能够阅读测试,还要在测试出问题时找出症结所在。失去可读性另外两个支柱很快也会倒塌。如果无法理解测试,测试的维护工作就会变得困难,也无法得到人们的信任。<h3 id=\"1-可靠性\"><a href=\"#1-可靠性\" class=\"headerlink\" title=\"1. 可靠性\"></a>1. 可靠性</h3><h4 id=\"1-1-及时维护测试代码\"><a href=\"#1-1-及时维护测试代码\" class=\"headerlink\" title=\"1.1 及时维护测试代码\"></a>1.1 及时维护测试代码</h4>测试代码与产品代码一样需要不断进行维护，一旦测试写好了并且通过了,通常是不应该修改或删除这些测试的。这些测试是你的保护网告诉你修改的代码是否破坏了已有的功能。虽说如此,有时可能还是需要修改或者删除已有的测试。要理解什么情况下修改或删除测试会带来问题,什么情况下这么做是合理的。<br>删除一个测试的主要的理由是这个测试失败了。如果一个测试突然开始失败,可能有如下原因</li>\n</ol>\n<ul>\n<li>产品缺陷    被测试的产品代码有缺陷。</li>\n<li>测试缺陷    测试中有缺陷。</li>\n<li>语义或者AP变更    被测试代码的语义发生变化,但是功能不变</li>\n<li>冲突或者无效的测试    和测试相关的产品需求发生变化,产品代码随之变更</li>\n</ul>\n<p>如果测试或代码没有任何问题,修改或删除测试的原因有:</p>\n<ul>\n<li>重命名或者重构测试</li>\n</ul>\n<p>不可读的测试带来的麻烦比解决的问题更多。它会影响代码的可读性,妨碍你理解测试发现的问题<br>如果你看到测试名含义不清或者令人误解,或者测试的可维护性有待提高,就应该修改测试代码(但是不要改变测试的基本功能)</p>\n<ul>\n<li>去除重复代码</li>\n</ul>\n<h4 id=\"1-2-避免测试代码中的逻辑\"><a href=\"#1-2-避免测试代码中的逻辑\" class=\"headerlink\" title=\"1.2 避免测试代码中的逻辑\"></a>1.2 避免测试代码中的逻辑</h4><p>如果单元测试中有下列任何一种语句,你的测试就包含了不应该有的逻辑:*</p>\n<ul>\n<li>switch、if或e1se语句;*</li>\n<li>foreach、for或whi1e循环。</li>\n</ul>\n<p>包含逻辑的测试通常会一次测试多个东西,我们不推荐这种做法,因为这样的测试可读性较也比较脆弱。而且测试逻辑也增加了代码复杂度,可能包含隐藏的缺陷通常来说,一个单元测试应该是一系列的方法调用和断言,但是不包含控制流语句,甚至不应将断言语句包含在try- catch中。任何更复杂的语句都可能导致如下问题。</p>\n<ul>\n<li>测试难以阅读和理解</li>\n<li>测试难以重现。(设想一下,如果一个多线程测试或者使用随机数的测试突然失败了,该如何处理。)</li>\n<li>测试较容易包含缺陷或者测试错误的事情</li>\n<li><p>难以命名测试,因为它执行多件任务</p>\n<h4 id=\"1-3-只测一个关注点\"><a href=\"#1-3-只测一个关注点\" class=\"headerlink\" title=\"1.3 只测一个关注点\"></a>1.3 只测一个关注点</h4><p>如前所述,一个关注点是一个工作单元的一个最终结果:一个返回值、系统状态的一个改变或者对第三方对象的一个调用。例如:如果你的单元测试对多个对象进行了断言,那么这个测试有可能测试了多个关注点。另一种情况是,它既测试了一个对象返回正确的值,又验证系统状态改变导致这个对象的行为发生变化,那么这个测试也可能测试了多个关注点。<br>测试多个关注点听起来没什么,但是等到你要命名测试,或者考虑第一个对象的断言失败该如何处理时,就会遇到问题。<br>命名测试看似简单,但是如果同时测试了多个东西,就几乎不可能给测试起一个能说明测试内容的好名字。你最后起的名字可能非常通用,使得读者不得不去阅读测试代码(本章的可读性节详细对此进行讨论)。如果一次只测试一个关注点,测试命名就很简单</p>\n<h4 id=\"1-4-单元测试与集成测试分离\"><a href=\"#1-4-单元测试与集成测试分离\" class=\"headerlink\" title=\"1.4 单元测试与集成测试分离\"></a>1.4 单元测试与集成测试分离</h4><p>把集成混在单元测试里放在测试项目中会导致很多方面的问题。这种测试难以运行,会让人们误以为代码有问题,浪费时间和精力进行检查,最后导致开发人员不再信任这组测试。混在单元测试里的集成测试就像筐里的烂苹果连累了其他的测试。如果下一次再发生类似的事情,开发人员甚至都不会去调查失败原因,直接就说:“哦,那个测试有时候就是会失败,没事的。”要避免这样的事情发生,就要建一个绿色安全区把集成测试和单元测试分开。<br>绿色安全区里只包含单元测试。运行绿色安全区里的所有测试测试结果应该全部是绿色的，如果有测试失败，就说明出现了真正的代码问题，而不是因为某些配置或外部依赖倒置的假警报。</p>\n<h4 id=\"1-5-代码审查与覆盖率结合\"><a href=\"#1-5-代码审查与覆盖率结合\" class=\"headerlink\" title=\"1.5 代码审查与覆盖率结合\"></a>1.5 代码审查与覆盖率结合</h4><p>代码覆盖率100%说明什么呢?如果没有做代码审查,这个覆盖率不能说明什么。你的团队可能会要求所有人的测试“达到95%以上的代码覆盖率”,大家可能也确实做到了。但是也许这些测试连断言都没有。人们通常会选择做最少的事情达到某个指定的目标。<br>那么代码覆盖率100%再加上测试和代码审查能说明什么呢?这说明整个世界都是你的。如果你做了代码审查和测试审查,确保测试优秀而且覆盖了所有代码,那么你就拥有了一个安全网,可以避免愚蠢的错误,同时团队也获得了分享的知识,从持续的学习中获益</p>\n<h3 id=\"2-可维护性\"><a href=\"#2-可维护性\" class=\"headerlink\" title=\"2. 可维护性\"></a>2. 可维护性</h3><h4 id=\"2-1-去除重复-Extract-Method\"><a href=\"#2-1-去除重复-Extract-Method\" class=\"headerlink\" title=\"2.1 去除重复(Extract Method)\"></a>2.1 去除重复(Extract Method)</h4><p>作为开发者,单元测试中的重复代码和产品代码中的重复一样(如果不是更加)有害。DRY原则应该同样适用于测试代码。重复代码意味测试对象某方面改变时要修改更多的测试代码。如果测试中有大量重复代码,构造函数变更或者使用类的语义变化会产生极大的影响</p>\n<h4 id=\"2-2-测试隔离\"><a href=\"#2-2-测试隔离\" class=\"headerlink\" title=\"2.2 测试隔离\"></a>2.2 测试隔离</h4><p>测试隔离的基本概念是:一个测试应该总是在它自己的小世界中运行,与其他进行类似或不同的工作的测试隔离甚至不知道其他测试的存在。<br>如果没有很好地隔离测试,它们会互相影响,使你非常悲惨,后悔在项目中尝试单元测试决心以后再也不做单元测试了。我见过这种情况。开发人员不愿费心检查测试中的问题,因此当出现问题时,需要花很多时间才能找到原因有些测试同样存在着一些坏味道能够提示测试隔离可能有问题。</p>\n</li>\n<li><p>强制的测试顺序    测试需要以某种特定顺序执行,或者需要来自其他测试结果的信息</p>\n</li>\n<li>隐藏的测试调用    测试调用其他测试。</li>\n<li>共享状态损坏    测试共享内存里的状态,却没有回滚状态。</li>\n<li>外部共享状态损坏    集成测试共享资源,却没有回滚资源。<h4 id=\"2-3-避免对不同的关注点多次断言-使用参数化测试\"><a href=\"#2-3-避免对不同的关注点多次断言-使用参数化测试\" class=\"headerlink\" title=\"2.3 避免对不同的关注点多次断言(使用参数化测试)\"></a>2.3 避免对不同的关注点多次断言(使用参数化测试)</h4><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Assert.AreEqual(<span class=\"number\">2</span>,Sum(<span class=\"number\">1</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">Assert.AreEqual(<span class=\"number\">5</span>,Sum(<span class=\"number\">2</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">Assert.AreEqual(<span class=\"number\">6</span>,Sum(<span class=\"number\">5</span>,<span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如上示例，这个测试方法中使用了三个断言，进行了三个测试。这样看起来在实际过程中会节省一些写代码的时间，但会有一些问题。如果第一个断言失败，则后续断言就不会在执行。而在这个示例中我们是进行了三个测试。第一个断言失败就会导致我们无法得知另外两个测试的测试结果。对于这种情况我们可以采取别的方式进行测试</p>\n<ol>\n<li>给每个断言创建一个单独的测试</li>\n<li>使用参数化测试</li>\n<li>把断言代码放在一个try-catch块中</li>\n</ol>\n<h4 id=\"2-4-避免过度指定\"><a href=\"#2-4-避免过度指定\" class=\"headerlink\" title=\"2.4 避免过度指定\"></a>2.4 避免过度指定</h4><p>过度指定的测试对一个具体的被测试单元如何实现其内部行为进行了假设,而不是只检查其最终行为的正确性单元测试中过度指定主要有以下几种情况</p>\n<ul>\n<li>测试对一个被测试对象的纯内部状态进行了断言</li>\n<li>测试使用多个模拟对象</li>\n<li>测试在需要存根时使用模拟对象</li>\n<li>测试在不必要的情况下指定顺序或使用了精确匹配。</li>\n</ul>\n<h3 id=\"3-可读性\"><a href=\"#3-可读性\" class=\"headerlink\" title=\"3. 可读性\"></a>3. 可读性</h3><p>不可读的测试几乎没有任何意义。可读性这条线连接着编写测试的人和几个月后阅读测试的人。测试是你向项目的下一代开发者讲述的故事,帮助开发者理解一个应用程序的组成及其开端。<br>测试可读性有如下几个方面</p>\n<ul>\n<li>命名单元测试</li>\n<li>命名变量</li>\n<li>使用好的断言信息</li>\n<li><p>把断言和操作分离</p>\n<h4 id=\"3-1-单元测试命名\"><a href=\"#3-1-单元测试命名\" class=\"headerlink\" title=\"3.1 单元测试命名\"></a>3.1 单元测试命名</h4><p>命名标准非常重要,提供了合理的规则和模板,列出应该包括的测试信息。测试名一般包括三部分。</p>\n</li>\n<li><p><strong>被测试方法名    </strong>非常关键,指明了被测试逻辑的位置。把被测试方法名放在测试方法开头,可以很容易地在测试类中浏览测试和使用智能感知(如果IDE支持)</p>\n</li>\n<li><strong>测试场景</strong>     说明了测试使用的条件:“如果我用一个nu11值调用方法x,那么它应该执行Y。”</li>\n<li><strong>预期行为</strong>    基于当前场景,方法应该产生的行为结果或者返回值,或者行为方式:“如果用一个null值调用方法X,那么它应该执行Y。”如果测试名缺少上面列出的任何一部分,测试的读者就会疑惑测试究竟在做什么,需要阅读测试代码。合理地命名测试,主要目的就是为了使后来的开发者从为了理解测试而阅读代码的负担中解脱出来。<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">IsValidFileName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">Test</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">IsValidFileName_WhenPNG_ReturnFalse</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如上示例，通过测试的方法命名我们就可以大概知道要测试的是方法是IsValidFileName当输入参数是PNG的时候，预期返回False。</p>\n<p>当然，你的团队也可以有适合自己的命名方式，但重要的是如果一个团队中都有统一的有意义命名规范，那么单元测试的可读性将大大提升，并且有利于后来者快速进入项目，理解测试。</p>\n<h4 id=\"3-2-变量命名\"><a href=\"#3-2-变量命名\" class=\"headerlink\" title=\"3.2 变量命名\"></a>3.2 变量命名</h4><p>测试中的变量命名和产品代码中的命名规范同样重要，通过合理的变量命名，我们可以确保阅读测试的人可以尽快的理解你要验证什么。<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反例</span></span><br><span class=\"line\">Assert.AreEqual(<span class=\"number\">100</span>,actual);</span><br></pre></td></tr></table></figure></p>\n<p>如上示例，我们经常会看到测试中出现”100”这样的魔法数字。因为测试中没有描述性的名字，也许你在刚刚写完的时候还知道它是什么意思，但是一周后，一月后，一年后呢？甚至你未来的继任者看到这样的测试代码也是一头雾水。</p>\n<h4 id=\"3-4-断言和操作分离\"><a href=\"#3-4-断言和操作分离\" class=\"headerlink\" title=\"3.4 断言和操作分离\"></a>3.4 断言和操作分离</h4><p>很多人为了“偷懒”经常会把断言和方法调用卸载同一行里，但这是一个很不好的习惯，它会大大降低代码的可读性。<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反例</span></span><br><span class=\"line\">    Assert.AreEqual(<span class=\"literal\">true</span>,fileManger.IsValidName())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正例</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> expect=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> actual=fileManger.IsValidName();</span><br><span class=\"line\">    Assert.AreEqual(expect,actual)</span><br></pre></td></tr></table></figure></p>"},{"title":"大型网站技术架构(一)大型网站的模式","copyright":true,"date":"2020-05-07T03:29:26.000Z","keywords":"大型网站技术架构","password":"1234qwer","aside":"Notes-LargeSite","_content":"\n鲁迅先生曾说过：世界上本没有路，走的人多了也就成了路。\n\n为了解决大型网站面临的高并发访问、海量数据处理、高可靠运行等一系列问题与挑战，许多大型互联网公司的先辈们在实践中提出了许多解决方案，以实现网站**高性能、高可用、易伸缩、可扩展、安全**等各种技术架构目标。\n\n这些解决方案又被更多网站重复使用，从而逐渐形成大型网站架构模式。那么大型网站发展的道路上有哪些模式供我们使用呢？\n\n#### 1.分层\n\n分层是一种将系统横向切分的方法。将系统在横向维度上切分成几个部分，每个部分负责一部分相对比较单一的职责，然后通过上层对下层的依赖和调用组成一个完整的系统。\n\n分层结构在计算机世界中无处不在，网络的7层通信协议是一种分层结构；计算机硬件、操作系统、应用软件也可以看作是一种分层结构。在大型网站架构中也采用分层结构，一般可以将网站软件系统分为应用层、服务层、数据层。\n\n应用层：负责具体业务和视图展示，如网页首页及搜索输入和结果展示。\n\n服务层：为应用层提供技术支持，如用户管理服务，购物车服务等。\n\n数据层：提供数据存储访问服务，如数据库、缓存、文件、搜索引擎等。\n\n通过分层，可以更好地将一个庞大的软件系统切分成不同的部分，便于分工合作开发和维护；各层之间具有一定的独立性，只要维持调用接口不变，各层可以根据具体问题独立演化发展而不需要其他层必须做出相应调整，\n\n但是分层架构也有一些挑战，就是必须合理规划层次边界和接口，在开发过程中，严格遵循分层架构的约束，禁止跨层次的调用(应用层直接调用数据层)及逆向调用(数据层调用服务层，或者服务层调用应用层)。\n\n在实践中，大的分层结构内部还可以继续分层，如应用层可以再细分为视图层(美工负责)和业务逻辑层(工程师负责);服务层也可以细分为数据接口层(适配各种输入和输出的数据格式)和逻辑处理层。\n\n分层架构是逻辑上的，在物理部署上，三层结构可以部署在同一个物理机器上，但是随着网站业务的发展，必然需要对已经分层的模块分离部署，即三层结构分别部署在不同的服务器上，使网站拥有更多的计算资源以应对越来越多的用户访问。\n\n所以分层的最初目的是规划软件清晰的逻辑结构便于开发维护，但在网站的发展过程中，分层结构对网站支持高并发向分布式方向发展至关重要。因此在网站非常小的时候就应该采用分层架构，这样将来网站做大时才能有更好的应对。\n\n#### 2.分割\n\n如果说分层是将软件在横向方面进行切分，那么分割就是在纵向方面对软件进行切分。\n\n网站越大，功能越复杂服务和数据处理的种类也越多，将这些不同的功能和服务分割开来，包装成高内聚低耦合的模块单元，一方面有利于软件的开发和维护；另一方面便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。\n\n大型网站分割的粒度可能会很小。比如在应用层，将不同的业务进行分割，例如将购物、论坛、搜索、广告分割成不同的应用，由独立的团队负责，部署在不同的服务器上;在同一个应用内部，如果规模庞大业务复杂，会继续进行分割，比如购物业务，可以进一步分割为机票酒店业务、3C业务，小商品业务等更细小的粒度。而即使在这个粒度上，还是可以继续分割成首页、搜索列表、商品详情等模块，这些模块不管是在逻辑上还是物理部署上，都是可以独立的。同样在服务层也可以根据需要将服务分割成合适的模块。\n\n#### 3 分布式\n\n对于大型网站，分层和分割的一个主要目的是为了切分后的模块便于分布式部署，即将不同模块部署在不同服务器上，通过远程调用协同工作。分布式意味着可以使用更多的计算机完成同样的功能，计算机越多，CPU、内存、存储资源也就越多，能够处理的并发访问和数据量就越大，进而能够为更多的用户提供服务。\n\n但分布式在解决网站高并发问题的同时也带来了其它问题。首先，分布式意味着服务调用必须通过网络，这可能会对性能造成严重的影响；其次，服务器越多，服务宕机的概率也就越大，一台服务器宕机造成的服务不可用可能会导致很多应用不可访问，使网站可用性降低；另外，数据在分布式的环境中保持数据一致性也非常困难，分布式服务也难以保证，这对网站业务正确性和业务流程有可能造成很大影响；分布式事务也难以保证，这对网站业务正确性和业务流程有可能造成很大影响；分布式导致网站依赖错综复杂，开发管理维护困难。因此分布式设计要根据具体情况量力而行，切莫为了分布式而分布式。\n\n在网站应用中，常用的分布式方案有以下几种：\n\n**分布式应用和服务:**将分层和分割后的应用和服务模块分布式部署，除了可以改善网站性能和并发性、加快开发速度和发布速度、减少数据库连接资源消耗外；还可以使不同应用复用共同的服务，便于业务功能扩展。\n\n**分布式静态资源:**网站的静态资源如JS,CSS,Logo图片等资源独立分布式部署，并采用独立的域名，即人们常说的动静分离。静态资源分布式部署可以减轻应用服务器的负载压力；通过使用独立域名加快浏览器并发加载速度；由负责用户体验的团队进行开发维护有利于网站分工合作，使不同技术工种术业有专攻。\n\n**分布式数据和存储：**大型网站需要处理以P为单位的海量数据，单台计算机无法提供如此大的存储空间，这些数据需要分布式存储。除了传统的关系型数据库进行分布式部署外，为网站应用而生的NoSQL产品几乎都是分布式的。\n\n**分布式计算:**严格来说，应用、服务、实时数据处理都是计算，网站除了要处理这些在线业务，还有很大一部分用户没有直观感受的后台业务要处理，包括搜索引擎的索引构建、数据仓库的数据分析统计等。这些业务的计算规模非常庞大，目前网站普遍使用Hadoop及其MapReduce分布式计算框架进行此类批处理计算，其特点是移动计算而不是移动数据，将计算程序分发到数据所在位置以加速计算和分布式计算。\n\n此外，还有可以支持网站线上服务器配置实时更新的分布式配置；分布式环境下实现并发和协同的分布式锁；支持云存储的分布式文件系统等。\n\n#### 4 集群\n\n使用分布式虽然已经将分层和分割后的模块独立部署，但是对于用户访问集中的模块(如首页)，还需要将独立部署的服务器集群化，即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。\n\n因为服务器集群有更多服务器提供相同服务，因此可以提供更好的并发特性，当有更多用户访问的时候，只需要向集群中加入新的机器即可。因为同一个应用由多台服务器提供，当某台服务器发生故障时，负载均衡设备或者系统的失效转移机制会将请求转发到集群中其他服务器上，使服务器故障不影响用户使用。所以在网站应用中，即使是访问量很小的分布式应用和服务也至少要部署两台服务器构成一个小的集群，目的就是要提高系统的可用性。\n\n#### 5 缓存\n\n缓存就是将数据存放在距离计算最近的位置以加快处理速度。缓存是改善软件性能的第一手段，现代CPU越来越快的一个重要因素就是使用了更多的缓存，在复杂的软件设计中，缓存几乎是无处不在。大型网站架构设计在很多方面都使用了缓存设计。\n\nCDN：内容分发网络，部署在距离终端用户最近的网络服务商，用户的网络请求总是先到达他的网络服务商那里，在这里缓存网站的一些静态资源(较少变化的数据)，可以就近以最快的速度返回给用户，如视频网站和门户网站会将用户访问量大的热点数据缓存在CDN。\n\n反向代理：反向代理属于网站前端架构的一部分，部署在网站的前端，当用户请求到达网站的数据中心时，最先访问的就是反向代理服务器，这里缓存网站的静态资源，无需将请求继续转发给应用服务器就能返回给用户。\n\n本地缓存：在应用服务器本地缓存着热点数据，应用程序可以再本机内存中直接访问数据，而无需访问数据库。\n\n分布式缓存：大型网站的数据量非常庞大，即使只缓存一小部分，需要的内存空间也不是单机所能承受的，所以除了本地缓存，还需要分布式缓存，将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据。\n\n使用缓存的两个前提条件：一是数据访问热点不均衡，某些数据会被更频繁的访问，这些数据应该放在缓存中；二是数据在某个时间段内有效，不会很快过期，否则缓存的数据就会因已经失效而产生脏读，影响结果的正确性。网站应用中，缓存除了可以加快数据访问速度，还可以减轻后端应用和数据存储的负载压力，这一点对网站数据库架构至关重要，网站数据库几乎都是按照有缓存的前提进行负载能力设计的。\n\n#### 6 异步\n\n计算机软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越小，就越少被彼此影响，越可以独立发展。大型网站架构中，系统解耦和的手段除了分层、分割、分布等，还有一个重要的手段就是异步，业务之间传递消息不再是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步执行协作。\n\n在单一服务器内部可通过多线程共享内存队列的方式实现异步，处在业务操作前面的线程将输出写入到队列，后面的线程从队列中读取数据进行处理；在分布式系统中，多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看作内存队列的分布式部署。\n\n异步架构是典型的生产者消费者模式，两者不存在直接调用，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站扩展新功能非常便利。除此之外，使用异步消息队列还有如下特性：\n\n**提高系统可用性。**消费者服务器发生故障，数据会在消息队列服务器中存储堆积，生产者服务器可以继续处理业务请求，系统整体表现无故障。消费者服务器恢复正常后，继续处理消息队列中的数据。\n\n**加快网站响应速度：**处在业务处理前端的生产者服务器在处理完业务请求后，将数据直接写入消息队列，不需要等待消费者服务器处理就可以返回，响应延迟减少。\n\n**消除并发访问高峰：**用户访问网站是随机的，存在访问高峰和低谷，即使网站按照一般访问高峰进行规划和部署，也依然会出现突发事件，比如购物网站的促销活动，微博上的热点事件，都会造成网站并发访问突然增大，这可能会造成整个网站的负载过重，响应延迟，严重时甚至会出现服务宕机的情况。使用消息队列将突然增加的访问请求数据放入消息队列中，等待消费者服务器依次处理，就不会对整个网站负载造成太大压力。\n\n需要注意的是：使用异步方式处理业务可能会对用户体验、业务流程造成影响，需要网站产品设计方面的支持。\n\n#### 7 冗余\n\n网站需要7x24小时连续运行，但是服务器随时可能出现故障，特别是服务器规模比较大时，出现某台服务器宕机是必然事件。要想保证在服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份，这样，当某台服务器宕机时，可以将其上的服务和数据访问转移到其他机器上。\n\n访问和负载很小的服务也必须部署至少两台服务器构成一个集群，其目的就是通过冗余实现服务高可用。数据库除了定期备份，存档保存，实现冷备份外，为了保证在线业务高可用，还需要对数据库进行主从分离，实现同步实现热备份。\n\n为了抵御地震、海啸等不可抗力导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署灾备数据中心。网站程序和数据实时同步到多个灾备数据中心。\n\n#### 8 自动化\n\n在无人值守的情况下网站可以正常运行，一切都可以自动化是网站的理想状态。目前大型网站的自动化架构设计主要集中在发布运维方面。\n\n发布对网站都是头等大事，许多网站故障处在发布环节，网站工程师经常加班也是因为发布不顺利。通过减少人为干预，使用**发布过程自动化**可以有效减少故障。发布过程包括诸多环节。自**动化代码管理**，代码版本控制、代码分支创建合并等过程自动化，开发工程师只要提交自己参与开发的产品代号，系统就自动为其创建开发分支，后期会自动进行代码合并；**自动化测试**，代码开发完成，提交测试后，系统自动将代码部署到测试环境，启动自动化测试用例进行测试，向相关人员发送测试报告，向系统反馈测试结果；**自动化安全监测**，安全监测工具通过对代码进行静态安全扫描以及部署到安全测试环境进行安全攻击测试，评估其安全性；最后进行**自动化部署**，将工程代码自动部署到线上生产环境。\n\n此外，网站在运行过程中可能会遇到各种问题：服务器宕机、程序Bug、存储空间不足、突然爆发的访问高峰。网站需要对线上生产环境进行**自动化监控**，对服务器进行心跳检测，并监控其各项性能指标和应用程序的关键数据指标。如果发现异常、超出预设的阈值，就进行**自动报警**，向相关人员发送报警信息，警告故障可能会发生。在检测到故障发生后，系统会进行**自动化失效转移**，将失效的服务器从集群中隔离出去，不再处理系统中的应用请求。待故障消除后，系统进行**自动化失效恢复**，重新启动服务，同步数据保证数据一致性。在网站遇到访问高峰，超出网站最大处理能力时，为了保证整个网站的安全可用，还会进行**自动化降级**，通过拒绝部分请求及关闭部分不重要的服务将系统负载降至一个安全的水平，必要时，还需要**自动化分配资源**，将空闲资源分配给重要的服务，扩大其部署规模。\n\n#### 9 安全\n\n互联网的开放特性使得其从诞生起就面对巨大的安全挑战，网站在安全架构方面也积累了许多模式：通过**密码**与**手机校验码**进行身份验证；登录、交易等操作需要对网络通信进行**加密**，网站服务器上存储的敏感数据和用户信息等也进行加密处理；为了防止机器人程序滥用网络资源攻击网站，网站使用**验证码**进行识别；对于常见的用户攻击网站的XSS攻击、SQL注入，进行编码转换等相应处理；对于垃圾信息、敏感信息进行**过滤**；对交易转账等重要操作根据交易模式和交易信息进行**风险控制**。\n\n#### 小结\n\n**在程序设计与架构设计领域，模式正变得越来越受人关注，许多人寄望通过模式一劳永逸地解决自己的问题。正确使用模式可以更好地利用业界和前人的思想与实践，用更少的时间开发出更好的系统，使设计者的水平也达到更高的境界。但是模式受其适用场景限制，对系统的要求和约束也很多，不恰当地使用模式只会画虎不成反类犬，不但没有解决原来的老问题，反而带来了更棘手的问题。**\n\n**好的设计绝对不是模仿，不是生搬硬套某个模式，而是对问题深刻理解之上创造与创新，即使是“微创新”，也是让人耳目一新的似曾相识。山寨与创新的最大区别不在于是否抄袭，是否模仿，而在于对问题和需求是否真正理解与把握。**","source":"_posts/notes/大型网站技术架构/大型网站架构(四)大型网站的模式.md","raw":"---\ntitle: 大型网站技术架构(一)大型网站的模式\ncopyright: true\ndate: 2020-05-07 11:29:26\ntags: \n- 读书笔记\n- 大型网站技术架构\ncategories: \n- 读书笔记\n- 大型网站技术架构\nkeywords: 大型网站技术架构\npassword: 1234qwer\naside: Notes-LargeSite\n---\n\n鲁迅先生曾说过：世界上本没有路，走的人多了也就成了路。\n\n为了解决大型网站面临的高并发访问、海量数据处理、高可靠运行等一系列问题与挑战，许多大型互联网公司的先辈们在实践中提出了许多解决方案，以实现网站**高性能、高可用、易伸缩、可扩展、安全**等各种技术架构目标。\n\n这些解决方案又被更多网站重复使用，从而逐渐形成大型网站架构模式。那么大型网站发展的道路上有哪些模式供我们使用呢？\n\n#### 1.分层\n\n分层是一种将系统横向切分的方法。将系统在横向维度上切分成几个部分，每个部分负责一部分相对比较单一的职责，然后通过上层对下层的依赖和调用组成一个完整的系统。\n\n分层结构在计算机世界中无处不在，网络的7层通信协议是一种分层结构；计算机硬件、操作系统、应用软件也可以看作是一种分层结构。在大型网站架构中也采用分层结构，一般可以将网站软件系统分为应用层、服务层、数据层。\n\n应用层：负责具体业务和视图展示，如网页首页及搜索输入和结果展示。\n\n服务层：为应用层提供技术支持，如用户管理服务，购物车服务等。\n\n数据层：提供数据存储访问服务，如数据库、缓存、文件、搜索引擎等。\n\n通过分层，可以更好地将一个庞大的软件系统切分成不同的部分，便于分工合作开发和维护；各层之间具有一定的独立性，只要维持调用接口不变，各层可以根据具体问题独立演化发展而不需要其他层必须做出相应调整，\n\n但是分层架构也有一些挑战，就是必须合理规划层次边界和接口，在开发过程中，严格遵循分层架构的约束，禁止跨层次的调用(应用层直接调用数据层)及逆向调用(数据层调用服务层，或者服务层调用应用层)。\n\n在实践中，大的分层结构内部还可以继续分层，如应用层可以再细分为视图层(美工负责)和业务逻辑层(工程师负责);服务层也可以细分为数据接口层(适配各种输入和输出的数据格式)和逻辑处理层。\n\n分层架构是逻辑上的，在物理部署上，三层结构可以部署在同一个物理机器上，但是随着网站业务的发展，必然需要对已经分层的模块分离部署，即三层结构分别部署在不同的服务器上，使网站拥有更多的计算资源以应对越来越多的用户访问。\n\n所以分层的最初目的是规划软件清晰的逻辑结构便于开发维护，但在网站的发展过程中，分层结构对网站支持高并发向分布式方向发展至关重要。因此在网站非常小的时候就应该采用分层架构，这样将来网站做大时才能有更好的应对。\n\n#### 2.分割\n\n如果说分层是将软件在横向方面进行切分，那么分割就是在纵向方面对软件进行切分。\n\n网站越大，功能越复杂服务和数据处理的种类也越多，将这些不同的功能和服务分割开来，包装成高内聚低耦合的模块单元，一方面有利于软件的开发和维护；另一方面便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。\n\n大型网站分割的粒度可能会很小。比如在应用层，将不同的业务进行分割，例如将购物、论坛、搜索、广告分割成不同的应用，由独立的团队负责，部署在不同的服务器上;在同一个应用内部，如果规模庞大业务复杂，会继续进行分割，比如购物业务，可以进一步分割为机票酒店业务、3C业务，小商品业务等更细小的粒度。而即使在这个粒度上，还是可以继续分割成首页、搜索列表、商品详情等模块，这些模块不管是在逻辑上还是物理部署上，都是可以独立的。同样在服务层也可以根据需要将服务分割成合适的模块。\n\n#### 3 分布式\n\n对于大型网站，分层和分割的一个主要目的是为了切分后的模块便于分布式部署，即将不同模块部署在不同服务器上，通过远程调用协同工作。分布式意味着可以使用更多的计算机完成同样的功能，计算机越多，CPU、内存、存储资源也就越多，能够处理的并发访问和数据量就越大，进而能够为更多的用户提供服务。\n\n但分布式在解决网站高并发问题的同时也带来了其它问题。首先，分布式意味着服务调用必须通过网络，这可能会对性能造成严重的影响；其次，服务器越多，服务宕机的概率也就越大，一台服务器宕机造成的服务不可用可能会导致很多应用不可访问，使网站可用性降低；另外，数据在分布式的环境中保持数据一致性也非常困难，分布式服务也难以保证，这对网站业务正确性和业务流程有可能造成很大影响；分布式事务也难以保证，这对网站业务正确性和业务流程有可能造成很大影响；分布式导致网站依赖错综复杂，开发管理维护困难。因此分布式设计要根据具体情况量力而行，切莫为了分布式而分布式。\n\n在网站应用中，常用的分布式方案有以下几种：\n\n**分布式应用和服务:**将分层和分割后的应用和服务模块分布式部署，除了可以改善网站性能和并发性、加快开发速度和发布速度、减少数据库连接资源消耗外；还可以使不同应用复用共同的服务，便于业务功能扩展。\n\n**分布式静态资源:**网站的静态资源如JS,CSS,Logo图片等资源独立分布式部署，并采用独立的域名，即人们常说的动静分离。静态资源分布式部署可以减轻应用服务器的负载压力；通过使用独立域名加快浏览器并发加载速度；由负责用户体验的团队进行开发维护有利于网站分工合作，使不同技术工种术业有专攻。\n\n**分布式数据和存储：**大型网站需要处理以P为单位的海量数据，单台计算机无法提供如此大的存储空间，这些数据需要分布式存储。除了传统的关系型数据库进行分布式部署外，为网站应用而生的NoSQL产品几乎都是分布式的。\n\n**分布式计算:**严格来说，应用、服务、实时数据处理都是计算，网站除了要处理这些在线业务，还有很大一部分用户没有直观感受的后台业务要处理，包括搜索引擎的索引构建、数据仓库的数据分析统计等。这些业务的计算规模非常庞大，目前网站普遍使用Hadoop及其MapReduce分布式计算框架进行此类批处理计算，其特点是移动计算而不是移动数据，将计算程序分发到数据所在位置以加速计算和分布式计算。\n\n此外，还有可以支持网站线上服务器配置实时更新的分布式配置；分布式环境下实现并发和协同的分布式锁；支持云存储的分布式文件系统等。\n\n#### 4 集群\n\n使用分布式虽然已经将分层和分割后的模块独立部署，但是对于用户访问集中的模块(如首页)，还需要将独立部署的服务器集群化，即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。\n\n因为服务器集群有更多服务器提供相同服务，因此可以提供更好的并发特性，当有更多用户访问的时候，只需要向集群中加入新的机器即可。因为同一个应用由多台服务器提供，当某台服务器发生故障时，负载均衡设备或者系统的失效转移机制会将请求转发到集群中其他服务器上，使服务器故障不影响用户使用。所以在网站应用中，即使是访问量很小的分布式应用和服务也至少要部署两台服务器构成一个小的集群，目的就是要提高系统的可用性。\n\n#### 5 缓存\n\n缓存就是将数据存放在距离计算最近的位置以加快处理速度。缓存是改善软件性能的第一手段，现代CPU越来越快的一个重要因素就是使用了更多的缓存，在复杂的软件设计中，缓存几乎是无处不在。大型网站架构设计在很多方面都使用了缓存设计。\n\nCDN：内容分发网络，部署在距离终端用户最近的网络服务商，用户的网络请求总是先到达他的网络服务商那里，在这里缓存网站的一些静态资源(较少变化的数据)，可以就近以最快的速度返回给用户，如视频网站和门户网站会将用户访问量大的热点数据缓存在CDN。\n\n反向代理：反向代理属于网站前端架构的一部分，部署在网站的前端，当用户请求到达网站的数据中心时，最先访问的就是反向代理服务器，这里缓存网站的静态资源，无需将请求继续转发给应用服务器就能返回给用户。\n\n本地缓存：在应用服务器本地缓存着热点数据，应用程序可以再本机内存中直接访问数据，而无需访问数据库。\n\n分布式缓存：大型网站的数据量非常庞大，即使只缓存一小部分，需要的内存空间也不是单机所能承受的，所以除了本地缓存，还需要分布式缓存，将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据。\n\n使用缓存的两个前提条件：一是数据访问热点不均衡，某些数据会被更频繁的访问，这些数据应该放在缓存中；二是数据在某个时间段内有效，不会很快过期，否则缓存的数据就会因已经失效而产生脏读，影响结果的正确性。网站应用中，缓存除了可以加快数据访问速度，还可以减轻后端应用和数据存储的负载压力，这一点对网站数据库架构至关重要，网站数据库几乎都是按照有缓存的前提进行负载能力设计的。\n\n#### 6 异步\n\n计算机软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越小，就越少被彼此影响，越可以独立发展。大型网站架构中，系统解耦和的手段除了分层、分割、分布等，还有一个重要的手段就是异步，业务之间传递消息不再是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步执行协作。\n\n在单一服务器内部可通过多线程共享内存队列的方式实现异步，处在业务操作前面的线程将输出写入到队列，后面的线程从队列中读取数据进行处理；在分布式系统中，多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看作内存队列的分布式部署。\n\n异步架构是典型的生产者消费者模式，两者不存在直接调用，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站扩展新功能非常便利。除此之外，使用异步消息队列还有如下特性：\n\n**提高系统可用性。**消费者服务器发生故障，数据会在消息队列服务器中存储堆积，生产者服务器可以继续处理业务请求，系统整体表现无故障。消费者服务器恢复正常后，继续处理消息队列中的数据。\n\n**加快网站响应速度：**处在业务处理前端的生产者服务器在处理完业务请求后，将数据直接写入消息队列，不需要等待消费者服务器处理就可以返回，响应延迟减少。\n\n**消除并发访问高峰：**用户访问网站是随机的，存在访问高峰和低谷，即使网站按照一般访问高峰进行规划和部署，也依然会出现突发事件，比如购物网站的促销活动，微博上的热点事件，都会造成网站并发访问突然增大，这可能会造成整个网站的负载过重，响应延迟，严重时甚至会出现服务宕机的情况。使用消息队列将突然增加的访问请求数据放入消息队列中，等待消费者服务器依次处理，就不会对整个网站负载造成太大压力。\n\n需要注意的是：使用异步方式处理业务可能会对用户体验、业务流程造成影响，需要网站产品设计方面的支持。\n\n#### 7 冗余\n\n网站需要7x24小时连续运行，但是服务器随时可能出现故障，特别是服务器规模比较大时，出现某台服务器宕机是必然事件。要想保证在服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份，这样，当某台服务器宕机时，可以将其上的服务和数据访问转移到其他机器上。\n\n访问和负载很小的服务也必须部署至少两台服务器构成一个集群，其目的就是通过冗余实现服务高可用。数据库除了定期备份，存档保存，实现冷备份外，为了保证在线业务高可用，还需要对数据库进行主从分离，实现同步实现热备份。\n\n为了抵御地震、海啸等不可抗力导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署灾备数据中心。网站程序和数据实时同步到多个灾备数据中心。\n\n#### 8 自动化\n\n在无人值守的情况下网站可以正常运行，一切都可以自动化是网站的理想状态。目前大型网站的自动化架构设计主要集中在发布运维方面。\n\n发布对网站都是头等大事，许多网站故障处在发布环节，网站工程师经常加班也是因为发布不顺利。通过减少人为干预，使用**发布过程自动化**可以有效减少故障。发布过程包括诸多环节。自**动化代码管理**，代码版本控制、代码分支创建合并等过程自动化，开发工程师只要提交自己参与开发的产品代号，系统就自动为其创建开发分支，后期会自动进行代码合并；**自动化测试**，代码开发完成，提交测试后，系统自动将代码部署到测试环境，启动自动化测试用例进行测试，向相关人员发送测试报告，向系统反馈测试结果；**自动化安全监测**，安全监测工具通过对代码进行静态安全扫描以及部署到安全测试环境进行安全攻击测试，评估其安全性；最后进行**自动化部署**，将工程代码自动部署到线上生产环境。\n\n此外，网站在运行过程中可能会遇到各种问题：服务器宕机、程序Bug、存储空间不足、突然爆发的访问高峰。网站需要对线上生产环境进行**自动化监控**，对服务器进行心跳检测，并监控其各项性能指标和应用程序的关键数据指标。如果发现异常、超出预设的阈值，就进行**自动报警**，向相关人员发送报警信息，警告故障可能会发生。在检测到故障发生后，系统会进行**自动化失效转移**，将失效的服务器从集群中隔离出去，不再处理系统中的应用请求。待故障消除后，系统进行**自动化失效恢复**，重新启动服务，同步数据保证数据一致性。在网站遇到访问高峰，超出网站最大处理能力时，为了保证整个网站的安全可用，还会进行**自动化降级**，通过拒绝部分请求及关闭部分不重要的服务将系统负载降至一个安全的水平，必要时，还需要**自动化分配资源**，将空闲资源分配给重要的服务，扩大其部署规模。\n\n#### 9 安全\n\n互联网的开放特性使得其从诞生起就面对巨大的安全挑战，网站在安全架构方面也积累了许多模式：通过**密码**与**手机校验码**进行身份验证；登录、交易等操作需要对网络通信进行**加密**，网站服务器上存储的敏感数据和用户信息等也进行加密处理；为了防止机器人程序滥用网络资源攻击网站，网站使用**验证码**进行识别；对于常见的用户攻击网站的XSS攻击、SQL注入，进行编码转换等相应处理；对于垃圾信息、敏感信息进行**过滤**；对交易转账等重要操作根据交易模式和交易信息进行**风险控制**。\n\n#### 小结\n\n**在程序设计与架构设计领域，模式正变得越来越受人关注，许多人寄望通过模式一劳永逸地解决自己的问题。正确使用模式可以更好地利用业界和前人的思想与实践，用更少的时间开发出更好的系统，使设计者的水平也达到更高的境界。但是模式受其适用场景限制，对系统的要求和约束也很多，不恰当地使用模式只会画虎不成反类犬，不但没有解决原来的老问题，反而带来了更棘手的问题。**\n\n**好的设计绝对不是模仿，不是生搬硬套某个模式，而是对问题深刻理解之上创造与创新，即使是“微创新”，也是让人耳目一新的似曾相识。山寨与创新的最大区别不在于是否抄袭，是否模仿，而在于对问题和需求是否真正理解与把握。**","slug":"notes/大型网站技术架构/大型网站架构(四)大型网站的模式","published":1,"updated":"2021-03-14T03:04:50.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfq0900g4hyjf906x3313","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以扫描下方二维码，关注公众号，回复“密码”，即可解锁本站所有文章。</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"578adff7310c32ac90dd5d46c38d253fe5dd4beaa342f573fcb7077a8d7afa4f\">4a88db7632efbe9d0104ddf0ecaf2bbb226d888c063233a771270765931add2e07c7eacdcf9e8e888d50607e6ff828a4a76fa76fa60a9dc8d7de16d274c28537d12dc71550e1342478e7e212012ffa7c802f32bd2150c74546c4d65200c19f1a3f7764c5ae4da1f8beee5bf162b05abd17a307e62204f27342ddedfd98da3a8da5bf8db92a3237e7b27ccfbc6e92006a5337d68ad71e957518bfcd808c063dffeb711f0662f2967cff604a591d659cd58e18987c80ff55b49d2b9c0b420fad93587d1e8ad7dad8ba886fced040264fc9c47500a949930e28495a38ed7b31d1a34cab71842043d8ff830217ffed0f99ef094e6c461827b7764c1958844529e9f221ee147396ef1a9194606b4b96ab5627266793310c4e0090a117928d39b1665f474b8d7ece677c968788e7d99db29998306147a540ee95dd67ea9644ba6f34ff2b9cee221810fe497aafe6f2f4d82226dc2103740cdac076bcab614535b39b4a1653b21a483603d53fcfdc271e9b3e750775a5a0722c27c543e0019cfac0558428958f1b1de5d91346a96fd30cef7bd95f54004f43d4063cf2c489203484461340cd682e8b99d319bfef4af4f231d2f8774b0c84997ba3450fbe05947dc7949de47c24d7e821445da9d10ece91b2f5169b8b7707b94edf879e8fa19a48b876ab046238123482ac1140c3ed6bb51603dfbe04bbef760725370e94608dda309b869690c31eb87addd7d054bbde70a2821b3f021353fc7a87d349a0ad1723b4fd38e4fe85da6abb994d1d2222b74d45761f8d9a07df53afd9b5eb82ab6a908d437e1045fcb34033b77bcb04e75273548d5faf7f98f42139396eb1c2772d4bee84fee7c2c9a091c89947c2017d3525b9fcaf24293fce056c695c055d033ff4f1d1d3b703d63e9773209238bed206b31a5c3dc2701f89cd7eb05a7761e722096bb3a1779181236fd481d4f4684548a987786d1116746b5060aa44e1f2e4fb4f4335a1bb8941e637a15f5ef4be29eaaef9a17cfa605608b7420b43dab4e0d12e1a3799517db01d58fb382b85d67a1048a9be0988eecc2565a27bbb307adda09cd2f2b50fa16070d6269c3e114f2138a28d5cf942e964b604263e551fe9b652f77d7daa3e99b5f77fbf77e7300885b9083fe6cb939e5e699a831cc1ba6a7153085a7090c665fdbc6cb4434087a33138e1f540618d3aa96527de2ef9bf74400012a76a8d65499f88eab12c9b77404d9ee92a8881ce46652e41ca7c1f50c5862a3bd7004a46b7c34fdf38abe27bd2bdf62a4d40c235424504862872f9ae1fb079b1e186623e721d37d3e88a4afa74d50f9833413c50814db817876af5cd32d1c27345eac739140b01e72753a15840917037ab1b7a3ec3056bb0737c53214bf9c25da7ef28bee04791c59fbf7ee0dcc0f2cf83c5a660cab0075d662475c4fee341aebcb8871d46d48bb234f427810f107f50a28940f1936a7432dba8f01014b9efecc2e0096e8cbfc39a455ee5438e8ac9667876e4969cab80532974433063a621dd02fa76e1a1df8f0ef86b650d10de5cf56e0099d052b84e576f6cb56c2658130a2e94ca241354085df10cdea888a379c37bc0572e04b6d79641776d18a3efde69a2f638515e14192d7672018ee2593e9d474c1748060596dad708b8b71147180e87bf18948a8d282a45804e85770ac0a10b95383f16f3b67f1857c9a0cd13b39ee82b38b30bfccce1af23e9ab40e4f2a1fa93c1956366cf1edd7551f7f78191ceda4fd7ff43c9881d2c961aa55f2d4933637fb9a9d3a1e2fb1c2fe261b10934298085b9d72eb2e15841c57ac3502ce426975b34ed13cd6c7e96c95e255c5a645dd483a6f8c41f09c2e2d408dc8c5f9ab0e012a88047e122e72957441df0f5784dfbff6d7d3c1660cd40b898f61e5f3deb622376be8c7527b9f8686bf7ebc37b57c29561d0394a1c046cbbe5a09e3827dddd25fc9c6a343abcdaf74d6b5f0792975fcb65ac74b86ae8d09e987d5d15da2c159aa5daa08806a1db3f9473b647eae44a6c64df18b6bffa2717209143ad911db095ede3df59d6fa771c071a1f730b91b9b043b2c77e425031347ee98d2c33dba50d776528e1dc8934b9f74c57c73c92e17e765b88905c53c863a676dce8f09ff4c983fb9a949ac8cb5ba5f14f082f1b9d7b8d25948ecdc21eff6bef8c9280325c96cb4d22723f26ab657360932a0210ec8e6585abe1ac865e5be3658742663da86c4673d7a8846be1c986b581d3cad6c25ec4cd3b882163e546b8fe5b62bf646ef9e239c04b9840fb133a89250d0350fd5fbee21bbb1e5df80cc975a21ceac81ef84a9d66e0bfcff7e13aeda2d6ed87aad34b2866f5450fdfee9392ffd028c9a445728f6c48c8e96b67c11ee7ccaeddf848c4194f6d67905c8fe0c2bc523874a69fa56f2eb3a7c9577a5d85675871166a8d2d68e2774012da8589c58a61e1b9e122c38936c0fd91873e8a76f230e8e340a7d0408cc1528608f3941edff77fa60bbf87d4aa3396e491d6231aa00a56ac2fcd29f08c1fcd3ef4bc890a594ce02560318005ed39109c0f491e0339e7a92b32a29660cdc3cb026268c59b41ded7080c537346a38c389a6dd5eb845584504d7916c43071f219c6264b5332d367800524b0363cc7334a6ef291fec137af7dd8994a95e602f0f8f6d605f3ca725d492e8e47f81fe1bb8bcdf4b3287f39fe490446e4088633e6947fc67e345465116b2a77ef80d38501c4faf21ee1333b1f94b28ce0a33178e7e8c1bd879667848497c782ce18116e843ebc31b5ffa1b9d1e874c682012de376aeef56703362f873b9835683b1f0529adddcd8acc0140d56f8727cf598ae13e661d45dddb4c98ab5470dbd3f094344a593c737eabe2ac85069744383a5f38f1efe0030be288f564f748f036d52562e9ac9058cefa0959d71f393e4a71d39e4e9f0cec1aeca5a4572a8e89fffb6743b2b0dbfb60db822461f678e5498686c46a13ceb750c399c48cabb52f2d1ded59a60f29ad6295214f9bcd10fcb59da9843c107a187c9abe7d1c87e5d27648fa34a9fa1236d221be493204848e242bbce697ecc32fc5516c50890384ccfa7ab015e4cfc667ee3b63adcedaa0b9602efd32921ebb5f737302c20b5b4cf7d7ab3a2f92474905299945316ea188dfe98e9ff63fb1277e93ae3690b5ab417725efb724d00e42895d4ee745ea768df733b53b2f21ea691a439a0941fd03d86c9d6822d7a58353d8cfcad07cd162e4041978dddc9ecadae4a36a880da6ddf07d2df8d43fa7e57725e6bb0596380d72028f4c584e26e18ef874e021c8263e3b4e3a322f143cb9c53cde8f630d9e561b2612fe8cd471a1f2c5f59e201f8f063928bea6acb21b89e4c5c52c0a34be61dcd4029c1cb5e4d93339bdd4219dc04c4b4065835008da4ed169e7f17469aed5460cc93b16701010e3fe4104ac5a1ac2317c4a16fbc6e509dfa4722b834dc6e60c1052b27e3437c630205d4f0a6b4a17b2272962f50f271d0e6e962fab3b631046159e7c6390293aecc5000b1dde02d668f593fe231f6277d00c30db4f677dfb7d462fceb0d8e93b1055329fecf28ccd1f7022ca8b88e3866026ddd0bc94216f93ece222671919ee9517d9f922f11f9aaa257815e8c8070848570a111435cd08605c8920259fed2c9b806efd3715cb33867f1560024a3e33e017bc1cd6a4a7259dbfc4e0865835e63293dc8b6301ff5441052f579246e41444c66c56421feedcec8f6f1012004391892d565a42e1b624abe70204498cd05d6bbb94c9a5b6a3a1b1d041fd78f2e7a329e8d046f0957329c12e2c203bda4b5a4bd64a690dd44e9acc58ba4914a95cd146bd98303400182ee8ab83828df8f6dc376ee91e1f8d8bf933b0208d592a568379935a593c20fdaf833817eb24a6778a1710ee8571320131f51318ed17dc46799c0d06742b9469c4507df8533874fde7c4ec7a6a2380f070ca68cfc70b879410d521957c664a68e4515b3ae3ec74aaf88e9b015d0c15d1f12ad266b71ed0bbd8367933e2c6cd73174d9b9db55ca9e0daad0c1f2069b3d4172fdb069fcc22409c78d661eaa60190d312562ccc420816baef736b6785a4cb95263b759ae8b288c8c6c4112bf3994aab8aa3c3ad76c03597f406f100e9c0b0b83e52dfe12c0551ef1cdeb0acb0942ec9d5cb6f8dde1346ae03c08b582fbfa1ec2c11c7d6cf50d2e2490edcb00bf96ac460cb761ac05a9fcf937aec78f96145e23355fd4d0d5dc90a3b107d0f390008c9d88b38a62fa9a8f1c3420d28dbdf3a00fb2e9c954b2573a1b5abf6f39f13acf97e7666d953c716d88890db53252f62313b8ab92cd65067e2991c41e0a2a64999fbcc9a622696e0e29cb89551f906e3c345e0288c303d9d0e088207f42805fbcbf76dbeea9a4c1dce4ec7a1630371bd7b84c15a86b23401a977151ce51dff764fc239d35e658a451b637d3984cb40e088fea72363f9c9842e1fa483889d250b042c128bfb3d6b1ea7eff235a7b53b8083e51dfe99eae0c57dcce8de763ea69fc86e9dbdeb29a635029f6447c1ea3a771087d09713c897f83bf0d2d503245525ce96929c00469ace187d44837e338f7d15ccc9231637adb137733ac08ac189e63925427a9ca8f92eb95265b8180b50ea8f1ab19da5e935e38ff8c6d396017404760a5d5e38d3c340dfff5269e72e398bfb4fe79a72efde2c57189bba9e8d43b138fde5c36df18974862694c0611b831bc00303e3bc59c1f165143b7fa6b1426eb905d84ac3956e76f92ba3162ad3955767be098053d291107e23cea3411a0c20688e6edec3f9d226f0418d6e99e1264e95de9fa21b44fe8eb474c9b34dff7652087c11e33f016a66f40403b4e71852bab2d18d78d9699bfcf5b01dd58588739b789c25e70288cb7012dd2d78fad0c6d3590ac86bead0e65fb50f2f7be03c220afb465ab46e97e2c033a2035834c36cf81ed981236a117f080f25cefbeaa2344bc8b3e448a81d2a3ab357f0c55916a4bf398158e752b126fb0a1de8b6dcef5253e5550f334c2524c3c28daf81177dae157a36fb33575e5df2c0d8b28bacf4392eb26736aa65966a2da588d36d1d0ede0867e78409658946a9a8436fc9cf3a543016cbf7b67cac47fe1128ffa4111b53360a2310294aff342df511746d9abed59bb11ec7bb003c4b7f6b7cc34df3e7cdb1744a2a21f6a26c4058202683c9afba808f8c1155cf8b3fcddde13ba7c058889e2323963aebc341e993e0df5f2c71311c3da56e187a9730290a01528317fa8aa71f7534d73404b2086a8e637dae43233fb939d9b78b05199275ceb4b28123d5a4c5404c5b4293ee7fd546c8205d754c18b4cd60aa8fc35be06e0c51470d6577d61849388b1e23b509964d112baacc979b7e5afc4380c6e5376d8f3909b2158980b5b9f17aa3950b873c93da56182d101bab16c385cd88ef3e0556e47cbcbcb61a012f53503ea95d910ace53a43b22e02a851b74ae606264fe88e03d51af11c17a65382124ab1b5074fa923f64c0bda7b952f296428b69e1acf65e5bfd26ebf25fab2533fb4fae01c0c4aafed4e2bad8cafc7893dbbc18194b443cfbb96dac7656a445399cafe7bce7003f8a38a509cfc4a4b3842b6cd6ecbc8a6e848859a93ec64a6d981b32b007184e3801947a8e49b804e80983d272e614edd58e4d00ab43addb89780bfc5e168b8fc03739620a8711bf211ab1c0d7d842e6775c56951ef798bff7216a35aa1c7d6b23ca6cf50dad124c680f67f6d1e464a8c8846c477931d2e4a60442666502a6de86fc588564cb21f87736f0d44fd2818d281093f9b7810dd8e10def3a20c676c41c30f3e8d4d3983a9ba53ef0da3b7ed0418e3dcd96ffd0d9dd75e9448e9050a71140e240d58ac0262f87a01e3e2a87cb70805e87c2f6e74e5d0ba13b0263f9d41501ce83048fe0d9c0a824bcc57e6ec570661b05ec2fd857012d3da1442621f52c959bcfb9f6e2747c196e0276ca2e9a2cce210dbec87c70497eebdc0d63e1facacabe901cb9382390b2861fb66537cca32f49d5db425c8e5f2c5a3a02142e088aff17a866aea88527993e16add6c248a58521ee7718a561aaae92133fcc96a5f8b103ed599037634481f56808f0749519ee20ccee7218c2d29e4bc0e9d3a8936b7ba89c1f19e9472f148758d0f27e40b47cc61aa6421ddddfdb4495497261a056c0f5cb29028a932b8c85f539fdf5e87761eb9b3db6f0eca313ec37f1befa7def9343f6b5005913702431e6237c345cf7dc56db401e646ae8087364780412295f03dda471a6f42fb10a4439e552eeabc52355508bdec0ef6ab70fd249973b3e115cf8d71f2c5af9e21d8e76e9180db25c20009399e3be4463ed2b41bdf6f4a5b3d643249ef847e5f97350af0fefd48bc661579654793cb68b92974e31f32e14921e2bf5078c6abe43715adf13d5f959841b52fd8c37ffaffa6ec5f8552c5f96eeb6c89e42c7c6c09d545315195f055a47165e78e1b4e20dced6d4f5b8cd6b98c6d8d2f9e8707e6ad9fae2a9141932f869655cc92c872044e2a24f21550d4da77bae1fb895f3875cafdcd81e2c5ba573f94a7ee33dd8fc5249154b47ae193e644415b6d3541f87ca0c096b4436ea193411568561665682b6dd09322013939a4240bb56784c094ea218d39b4161f93948096c83f5446a977b0c07e157730276b957dd4c071fea8165573ec0f642860697bf58d7af53f56fdbe59ce68accb4fe217e20bd3b5338093fa60aea29e9a4d5e82fd7efaf2073256e7aaedc4c5646d77dda2d953c2c30c336c5a1fa9ab70a9f3a8bdd541e8890cb48152363d43f010574b84d9a0f92cfca667f5d58a63461b56d8bde19769a26986c7e57e055f788ec24815a9742137c85762803795b451de0358a15ba4a5239424c4fc153720a6aef12e981cd94daa54785ad94ec3039a0a572517e99192ec5c43a4ab26a669b653c544018dbf30016de16f71159bb9156bd4a262e21ac51ad09e41170b45ef5a8a20d91cf7e61e93f36bd44d15d0fd48144e9b07015971b5509e049ae8cdf3cabc382944d64c29af2f3ec9d62b837948b6208d52a019e047ba7f18f5209e13146aced131c4b9c46e69f4fb4b8acfc717b3859366707b34b4019b0c723d8befdb4d0598801411b6b331af729f1db1c36aa4d92fc95823c6f7256554064081568a9431385285f9933e9145ce08cd83507ccebd4b330485655fc3f96569ac3c181beefb0d8f44e07350129456c2fbb147f5c9a59fb91f85d38f03c7e7f6f4ec3819a167f87c94442f458b18bf3c169f986132a6311de317978ff2f120e6e3b78fedeb9ca590dd82ffabab4913271a5bf0e110068da53cec258ea292c44389560c7dc2e59a5fa1f2d77189a54e7a407a769722aca9f889efe8dcd0b0c489d1a7ae7c585eb9c85e9bcb00537a60c1d308aac02b623f08558cfdd4ac37e11bff31f821fb5371a3cd7f0dfd9b520417d5ff194b2fdb817d414a70612756d02484370bd6e72ba2b6d1373e01f3cb9e4ac2d23b5bb2c9de607d63cc313eed2619f184d677994857a342fe1d0893768383fb72f20778e1b2e9dc34e77bde2b064b269bc44fd7c20419d86b159a36a36b526d339d509ceb96308704ca3c5e217ba321a1b40e35f29294a917855898d25e2d0b23bdc370055f055e13dc81692cd495d075f84f04110a3f1ee06aad8c239dae3d2225bc640a5954792995b6c653691f6e483dbd638bc1998aaaf18cc1092b12861cdd1ff8d8007fe893542c283fa33709b34fcc7c0f65154befe68a838f5c018f438bc219e0e91feb03b9dd4e16c546e492a71bdbbd7ac0a2518a4a962b66d08abee37693b215dcced272a4e34beb85a19248aa87bbb7f87c5cc8dbe8e1f62416b984015d5cb41926fa7f0c4ad2bf3fca93436f348214c759e5a5d6790ed6a0fd591f625e66b35a2e65852ed5db57dce78835b5922c3b69e5886619fbc9b8f1cccb9f75211632c1087ff064c1597a17a33c11f83b7f1316af327977c085bf9db95e005ec91008421ec9d386f1a5ce4398c0a654790eec5f04d8c8c8cb18bcb16c386f919cdc506fe9fc95697b8d68640414bd1923e2355ffa6870b2db84965fcf917ae22b206c97aa07267a9b5848b9eb6245e58011921f3f0aeeaaaea50043886e103c50cc101736874fa1911e3069a9798a6bec2325f27b1d6260a30decb4f88f57bcb070f6b5a6505e81f31d4baecb241aff1b7f7de589e7652afa941ee7b373c3bc8fd56f92c4054bdc9b990a9d31448cf4f52cba54af8366cc632d98e2370919f284e5ad556df587c6eb126bdad889fbcb7c387a981252f7ebb4be174691e4ce8cbd5162722ffd9e88320b6b800d342d56b613049131fd1c53e6315edb4b68877e5b62f838ea6b3f7ae665b486a9f5496fcb6f21bcdf0f5fa23972d7d1f12bbae067f8963ae9ac24beee6c12609e42589c32da2d16fa9c3ba3c8d650d334d9437c62aaafaf1762ec9ae6dd4da2ccac4e8e03e482e25e6cd5f83322605ba18134e908ad3c2f79c303512a8553fa8c181403532a6f094be95d20e3df7d9361d8c1df426d772815f543e7796f06330d153dbffa48561da47b6e205cf1699aee786f4a15edf633198cfb47f3c5ae173376f8dc7ee1df6e00b6a661d8a51148109f5050e5797b8fc8f2db84b5b55db1b3c14dace51def01e11c78f5dca5eebf228f82c06e8009aa2694815bf474358ae0abcdfa1dc0e0d1ad3a79790ccafac2dda3ab0829151427fe761d4f72b944f362d9e6b9008e899277f96022dd8ec741ff31a4014f2ff5c31957609147e1926fea66c50e35929f0520eab0dbfd7addcafe03aa7aba03d51099766358a12d536520a5886eb856e893d3bf8caacb9dbe75899ab81c0f5a0b6e06b5b7e727e665c92e55dff5b9718bf6610ef7bf755f821b855839a4e9b1918c0710d040408e1feff33a83f54404eeed9a8b192763bb064cbe64d1ae5658d0d0b418d27601db0074a140b35921db8f1c617e183adcfa98cc9cdf4c0238531737e372b80443c8f54cb826d04ccf37dc077827b383dcf1ae183d68a36583deb79f54940edad994949dc79f6e6c6fc46276e78fc3170dc09a5696bdc94e14aeb1464dec47c929eaa3b879eb3480d7ec994260cad97b5a723b320ebaf45ea79df405d3a52f14d5b8f6e38b040fb5a066c1cfa087580d18a896e27a53d9c82f3ba2042b5bed6ab6f972956a2cedc91193179070c7984c1629a171e2337e6a12e34d005f0c0ee83485fa6802a06067db256821a56d1c6547c2bd456bb99618eef84a6838ecfa43e1d21a7aeb183db32a7756d1adcd596068aeb54bc95e92712c573642c63245c282d7a3bc7da402c2470feda50d784410506726012d39fce13c33efed475ed7c2e0650062ea39b63db7c48cfddc6940b6ba36b3a60f5ae1de2f63b661fe918a38d3dae23c4586949195f4846a17ff5fc442302db436aa6be71c813abb44800da8dc226f9636704f816b174a581feba6c61e409578c5787faa1e2c3a445a29ed65103c4bbdd65c6516069330442935ee8b39545939df490f46660b703faade5dc53eb85c3419ecae02dfe854e0e5bfdbce80473887440f4ebd4ac32dbecfe1248ec92e3374be3c0e52faaa83cc1ba878a00574647abf280fa083f949633ae6d91a3453c0422b27c72c821060f434c999b7fb7e30f1e38d4386be4b0f386280d5ffc2465f2c49ea93b998366843c0e2f90be18fbe879f3696f9737808af788ae6651f5e3d01ce4420937285f9fe737db2ee65737b060b922173475231dab43e41deec08ad1fefe5326faf25b50fb513a0c6202cdf9d3af47f443af010634e4d014bfdac276edab40f6242b80175ea6c82da5d0fb937f475bfe484e066c3db08786b0ec61a3848a2557660cbddea4fa7e0c688c3ced1461fd9875f69b526a14322949ded7f1fa504afde747931ef1c3be5b0e95489342329015d01b1a31b6b997fc3f875644a0867bda14e5caaaa6fcf6026260834951e51599edfb53a480e0c6a37d58cde70c412c8835f9f165fdce8d5a0bc11138a7b8eb51c9f0e8821de48523e5312774193e1ce2fe867eac506dff85512643feb33d4ab195feaea65839b8d8451081d96d3f506836a6bdb0da721ec787edb539655ab2451f7f09851cdeb39c58aae0d31e50b7bd0acdf3cfd7f6b3d4be17748e081d591381adf7840595e5bc3e6dcc17fb48250e5684872d10d32754b92928b131cb71c535ea16b724c176fca3633d09331e0f5c039c6630bc36d3e99c09b7dc82bf5faf41a8e24a4f22ac760a45cce26ef4c57a86a0360b8d5ceed5b827428f5a0ec2a48626ba0ccbc9e75ef68588c1744ab0fffe5c028802b704199076f33a3c554f292236c20434b368c16dbb6002d845f852a3816eec9477b965c334af09b0ffb3442b4b61f6b667e39412cfdf285e97677748b93251ade2b86459c343a4dd92328dc84cbf3419ed75c1c13ea6736e7d1637ddf859f868b47ae22eb5b3c533094169c405545611a70228858ef61af4d5fd076b9337c1bcfd6a35656fd86e1dcf680898f67f378a99e44c6fed168feafa2b1968c79acaadc0f48c4cd21e08280193c98823aae061ea42904e33b2fb3ed2f0d0067fb2bc1de741b707f84b3736a181a3e4f574067519ff568edc33d45495627390cab645637980ebd6e9c7c2bdf58730de4d55c3513fbeab1f718f299d580536c3367b250aa5543ee48200473487bc023cbe449f1e6179f0a4ad9223abba884aec02baaeeab8e3b09b7ee1e46828d88c245141b6983c85b086c0c8538a32de16e29a61a730a7296ad9fb96ad883af7a03d5c576557b7f5be193de14e3e5691ee0196b9bf5577249194d23ab87b4ffda8b066e1b5ad6e6e308dd346600d15076eb259a669af58efdb2f43b64aabbb59c8bb1a19a7b2b686d65eab89d71dd2e3623f9a2f8aa26589427a46b9cfdfceb2fa9c05e23e3e632970898c5a7c07ac6be53e07cbd17a750cceb161b472e1b95d51ab476626592ce7f685250138748a8f8787d50579344721b27467f145a23aa5ada659e5e92709a5078116a56aa7386a0551250e078ae054dc6815d21d9286cee4e85eb4d113490333e3fbad263abd859e59f75f354bad78d0ac489659b60ecc4839c2cb2a5de1c874202c6bd2be554d9c39ababd41f3529bd09a266119994d37e1efc3831139aa501b58c594d2009bd61517c29a062d20281f8dc92a0e7171192c053fc0d0d8a936d083f1336567662d9a38511cebd421d53498f54de4c57dc825ae892b447db3061dc3bfa6d01221e3283c56b3f4dba4cb81fe6b93a9e4fe91a8aac732aace1045362bc41b93edd3cdc1b5333486e441a5fc9c19f8d23865c6b8e619e3ceb6177b9872e7088a952c89907d2b68b126a15866d93b8415f35f64a437242fc43d6648a8855e54e9e6739acd61158789f4e6277e8570763cf28e11a86e2cc5160899fd91f31b936c65505c9d4390d14a4760777a3e68d910baebd733b86e83f359c7248d19ce8810c957ed247b67d291693818d840b9554ea6385020757b3838ab2ac9991948ac52f8f374e831a4217210afaf925120cdf01a95801ac0c66cac2f156bab0fbae95bd29986263a8762606ef5d8cc5a0a08d1f90f9b1680156e70b4f4cc2604ceb769303c2ba0e5dc3d79f968f7890bdc1779377006ab75fb2d3b17139c6ee5288adbb49f335025e613b636141edb382a64d6779a6537ec144833194901b6cf93a64af7f6f591ebf5e9f4973dc6bbc68fb31294eddfc4fefa355f46b2d4bfcb5666b750d76c12d4dc721b20dcffde82660c026f3f8fda53c1ae77916326f6b26755c1f02622b61deb0e3ec9e9382d8a9ee7363ce201b00149bd8c828d775a9ce39a6befbcafdad40475a1a2647b3b71aae531ae2fcb42fe6c6551362ac16ecd6b50158fb1dcd49e1db6fa268eed2255f2a518c8be9133e4252b50077a75b20585858f8a26f7cec5b844f87423ac1238e4b12983aa7b763a53df85d14aede11005179a76a14df8bc0ad022fced61678d5e409a4a636425fdf3e12a65edaf0df1b0b8381f1821c80b4debdac127bde95239fcac1c9a75a21a0c88d14028eea70b2818bd44faac9013fd798a295b3f640ba28f670e1d4b58bd80e2fec86780c051a66e959f63673f779be58249aec25a8e62156d1386dc15aefa88fb4e0592a5447bff418072632f40fb675918970e99e14c84f236a5860cde57673b8b2e6bd5a29bc52f999a980c8b984d890e6a38c74f62f9206cfc4d2d589486e6a61506a7d92e1aa689caf614c219f8cb50f915056ac74682efb35ab127132ec19cb689c8f3491de23a38370f9c683c66b44869e497ae4f2d59c9e9a9b47c0748626c682a53756457a80f923af4ebd3981a60a686cc55f71698ca52dd4442bedcca64766618c939dab6558fa53863dee26b2b9c8f62741377a882bd3d5c6829b38cbef9aaf95a28b9afcf65eef461cd9432af833e7e4a39a340222a1d409d9562f32cc4d5a55d18d45117e52018aef264843b8bc73cc8e4135f1045eceb52c212fb3573cc91fa6846d96c5cb25fcb41c96c6a498161d6455a8e90af6415daba2b82f9d4118000b1326bb86e657b5cb3924d1252ab51136c88fb73445bcac8910d20cf193207715ce5d06ad56bd1d58b33e863d5330977595295691fedcf492d07bff76ca8f2ae7e006078c036262df5af5cde00549eeb1396e33a43bc06704b28a978ee8079f9077956cd05d928ef44574988aed6d26aada44741bdf9c30034c769b9a97bf62fb6ae13a7708dfcc490905bfd8806a914d8ca93f6abf1e02d4765412ef2cd825fabe64f79c29961a46833ee269654328aded084983caee1401c9cbb6ed180bfce6a3fe98e5c3a1c4a06df9470a3de6c7b080d11f322a3823d3838da9f5fb74cab1ad928ea0e15250d46e9fd63e6a956789e329b30522da6defa666b55f3d80555fbb860e644833202f447076478a054ea9e6e3f87fee4141fa147e28626fe86c890114725ea2e4eff33bfe84d3975c058359dd7de116617608560509f47f0eae7423d724b86feda112181f3087498ab7e5db698cc1fefe08860292e802abd60ecc8774975bdbe818b68971dd770708e7215289881940565cd35503f302c36d9e20c35d58b1ab294a07b314658f82a9a5d3e51bd95dea32292d8f641d279ae6abbd5f6eef09dac4aa7030a039201a6abbb6127f7f0597022629b1c5b7170df84ae6a115e50aa5c0b911e412aa7a90e17afca5f656f249d282a26dc58ab54a174a4aa8b9f670cc9f59a6456c3e1e86f9f530ea65136ee5c04d69878e2d0d22d73eec6bf58e03ff4cea0371c0db7d27b1db01514014a74ba623ecfd3ac20a7683ceec7871fb860f105ca8cb9663527a1d23d7b2da2c94603b65217be3267eb4fe1bfb5af6092dc3db5e437ef9bd2f892f70a1f192f9b3fa37706bdd353ae184e7b10b35055a7ab697b73ee21a69152d1b225c5cde66002e6b05d4a2c7c25694c984dba415d42f618ee0a0719b0c5237c6932c19536a2baeba72b815f4d37f1b0bb516ea88aad3030e71a12f892477ce97434a72c04f7d4e279c8c613440705042492c5f1d7e36f79f75d22250568ffc972792ae31102b43d0f4730d94b6f0f70fd0a90b509f99cfbc8efdc0bc76ce5f148830c2cebe8c953255968132bef47fc1ed737cfd87eb1315194247ca7916cef2de96ba2942e9b5d01a904c5faf26f4c3967d78c4cbd8eca9f48b0e178beea74cca0b1fcb20e09ca6afb03e4ec77ff4dbea54743254f642a484b0426f2af50870ff954e3be2916ffd50db101b449ec33c8feb9ff3c8331441865c0204e9e658de1c9ce6bd49f11687e76b619209bacf90edc05cd4faddc8d5a420f018a981696019f6388c4485c308db363af91aa02ca6bf6d045fe2191f01fd1396050e7fc3a26e2bba2fdfffb1d09214e7521911ecb9620515affc84ab1f70f781cfdad690ad786baa1bc092ecc0e2c261e3560612931df5bf88f596b8789c586d51d9f90c6487dd4f73eed3da7ea25b50e51035d67ab25b1b7c86f06cbed656a894a35839c32de019da011948d5d5aade54c8e6dbb15dbf4109c5a7389a8072e1a577d585f2849b7edfd90344fcd0bd3bc3f50a8413b797ade21f41aea42b068717d62642e187018ac10f7297d7de9321ed17d40dfaeecffaa9617c3f87b136176b04a80b6d3bb1d0c7283cd256c22d857dd0a2ee9b7ac693b56ef7abcc019ff185d291b50cc996c0c8b1fa39eaac582c4a3bbf260e8181aa54fbfd919d250b01dbe3b523b877638f98f05925bc1cd9e590979b863cbd263d756e621a67f31b89df86db12c310dc4536feeb51abdc067ae7fcb5e7718ed742dd183283fa47859eb474d0d56e5d3787a63533c5f2fc46d2b535e40535b76367ec0e92faef04c7dabcb2e85e47418ed5f233184968e4b1b129bcadfb03a08c7e2d70b344914c779744435887349e8fa8f9010e4568cd80f494b40a1508e615bdbd67dd0e4977c6cf9eea81e0f19d37b7e4a7bd68ba5103717479f51c8d47936030657ccb3a8e413f2a8576498e29d501211690a5ea5087b2eee334953f20436dce87aa62cf40900006f879852cc0a418f46b009614607de6c32d15d4488a37a598c142490b1058cddaaa6ff1efbb8d5fc473ad93497e5de5593b8dc0cdf4e8445e2042e80c258d91f4fb9c9ef7c349b23b589c3bcc88ed5548d53c7598483e5a375d8ac0953982aa16bb3d264839720dc0632eb820f88cd4b4f36d7c43a9ce53f79b4da6dfa159a9f8e2cd7dd3edb6902470ff46b6924a5ddd32550e9ca0fe50c82434aec063880f0e8e56b25679ddb1d9c1b36cdc15ad1fefca4b0e3724810138e85be11b3dbfec2b3f9fd8fad334c61cbefe600cfead7deccf2c0694dee7bd53abcc07424f8654533799e25454ff1b0ae795f46a81b5d77de61b2c05d446398cffc51237bfa8405ce459e51a004116a6ea094a624b5e3aadf948eca3360352383cf992994bd76098fe9ca8f8abf21a5dcd94fe7454a33e2c3d042906e2b7347ac3b611531d5e50d97fd35b51a6affd95a248991a0765f06449f5169fce2d188b6c73861bbb714f56daa8d3435936a59649c4708075aa635a1065ecd2f2c50df011c4d75cf2828c6a3e73cda214f1d49d7715df56c1bc5d9eb8914ab646290c8d4de23fbc5edcfecb863e496220890ccb8b852bcac6062701ba16324ce652ad24e6af512fd21872187f9401bb34b6d053b77bfce101dcd9786735c1ce681e2853f99e2529badef7fffd8ed2c2dc2541a9cb2c3fae4d95b6db0a6577ab7ed4fa0c56b4d75af37f68b5ad5759e965634fd4e6347b0dba3ad85f05e7afceb07226e7d03b70b027fb60dcae3e12ea4df912063e6e32ee1bbc298db3319dbc5c299e83aeeb34258291e50d1d07b3186c03a75d4af982bd35d52adddc07505e9dadbd8bd562066c7b5825cb0ceb007b0629b5b5ad5e48c2a4a605e7ec5389ccef475e541a44237e058ca6c1650977f7929121caf1adf6d9e1d7f70f9f0cd280a8a44781f47d0fa578ac771f35f48e44bd73ddf3bc5b15486d90b33d8ad329547146b8ab7966e4c988c205c3fbfeea22c8e551cbafb071852ecc07754afc8c8760f72b1a1bb8396cb07bb2dfc6b7f1fef8dd46212afa53dfdc74c710df60d65bd91e5cca585f96f592bc7a978adfbd7c76c1984cd8b7aea89e660f7f95762b16a22c8b3eb5876f6472d83c8b2e40e2cdcf33d7efb70796020d3d88c66e533a89497b13185f4113ed6cfdf5e9885698fc6b34a525f38c3a1b35e5d66377a501fcae8fde242ba41552397fc4e25736f4603bfae53630569fff5ad8de1d56bf3cf4b015374fa9dcddeb4a050f62f4236998a7f64a99758b8a4fcf772b948fc001b024189ce390adb059128d000b6af867294aa681487c633ffe1708c7a53ee3180b0375ecaa5c25568b7965b6d155a1a1f3b128907b127690e99ff3a57f14db8d126162df64505508195aef212270ee5f0561ac5494e3686dcd71639f01c8430b4ac60e6a1228431848c3617b748cfa2c996c82a0744908f8b519ffa01a95f31d8cb3941db6fda62e1ac91d4b2227015ee3629be3fe83dfd708b85d1f17323cb2e71b31ccc15d07cd49a3772fc2b6bfd3b90dff58e80cd0d715cb781498dadcc06e5c9cef99f7ed5feb3a4cade61d823c9b1d39b40587e3ef10e42d76450ed25372a278757b2e8fa0006f5f6ebdeb65feace53411662c38001ffdffeedc8497e14127e46c3a768b37974e6100ecc163643845beadd05743acca469ac4e6e2890ff17e39190aed9e976edb745abbba1f1bee59a5da9a88452c86a3cc6c9a1811bd7a6d5264cbd734888c5bfe7e397cfb75125ce142c6bd3667ad1f71009113f73e2646770dcc3a44c54251f287059e4812dc6f3d3065bbb30ed2dae417cd369f7aba513021a91bd4d2b65a258f72e2e9ba8c9129905d5bbe13e6921683c5edb3253061455d384e4e61e715ae84a67e33febf8eddf14fc3d1b56d0e4c20f580e0ff7112a22dbfcebcba79d65a89d016a0bf6954bfff352a8e073b507b4d8b16b8bd74029264d0a2346b4c66a1196873edc9e4ec58d85864e0f6049e7f252d85f51b95f08cb028f2495b5a1e97a2d0d7aa64394929ecd46c4424aae977abb39a42565dcb38accb80b99e5bee7345ea85c7813d49f011a5c6b9f23241f718015656c07a9b218c724975e140ad94f50fffd2ce6126bb71db87bba0cd6a2930ccf884172ce5224300382787beb75f67a749f4ccf98b99c61355b6536ef40b6ceb2fed6e4374b1eff05260e69e54f695c63f87660cd7b64fc9e32fd431c5a47ed3f67df1143f06828007a55fe877d0eac59cd40c700047f132dc8329deccbbab8361de2a01f3f81127babeb6fa5c3f62c8bc28b8bd135dcecbc064b95fd97a2bc9a7a7701bde81d889b9ff166ecd9a20adc115407cbf5c5e69d4620ae3acf6ba2afab560011eec688d97bb9473296c90df6d60b6b5c6984c53d55d272ea43e64a53aed8519c4632c721e7b2c27f7125eb39acef7e4d679bc5e4d19dffe6ff53415c080f3956b85b55b41082754b9aebcc3b0d7ba46b40617b2b3ac4bd831b343930e3ea8f2837311d4d9387c39493dab782234463dd3c55734445db65dd651054d826c0576501681dda7bfd8220bdb928abb55a4e8c1425ade213c9bf8295f016e49456610beefd656f0751627f8ff78bb29a1dd7da51759596c2493f73b1580c24f32d0d903d8ab62798d3076c3dc39a34ed6706aaa8b900dd61c1180942c872fe1198503b1d89e6538967942a183da5e79b02bdab4253467a27347f20e22814287b72129a3734f4eb3edc93b0c2ac376accea5bd77d9ebda4a75f535b2ec33d3d5c59adbd1ac8061930b5f770d8b7538d6a80129d5c9f24525dc2f021a9b0742462e4f0a8f7b5e8daba032c91b8bded53316d080b1a161ddafaa05399d105e992f40c21c6e69a2acc59e4a7b1e58575900b74af3c8c94f4b80ac7199a0b1a91120ee86bcb393e68411badc268fd2bc72ab4319ec0f1534b4cd908da5dcddc963270a28051a121f6857e321103af045efb9d4a85ec506dcd85ae747f0e796850323a3dabfba7af871fd07a6b06df4fefa7fd1c8a53c127b3345150d70c3f03175a4e24068be4f6d656b5179e0121e9eda8788ce51b280418fad074a0ce161e0561617039da57c1414eb940edc0aa3e6c481e52e6332eea7211067a5456ec5da75b7fc121c8c51e3222f3f63c79db3275b8c7e452a974bd25d5f31194ae7e9849099cdb7ebad22893bd2e96810858fc0344341f4026b2a725d6021bc1b354c7ccffa27eb2f84e251bad73a395972e6bbf647ca3c8006e3105e526b7be6c280239d163935cee2e269963b768eb7a688e5cfe84967f5e33cb1361c72890b1e90a9054c29f1be317522c9b60fa3b68f5e8ba89a67e10137a311afb9d3cb060ec49716066ff266dc9b8fa418045809c479302edf1b6a36fe5efbc1a7e316e976b6ee7798912481a4a649ca17005f2f9177405807665df15ef04b98a098c7be0fc253443a037db72e7305a1e378d39827abde455f8160b26e52f4be946332a5990b2ce56401317b49059a61a6b97cf56c7328f8e4fae7e3924835e292fd2b88a8384d7c51bc341758dc7a9eaa437906bf9c05aa932a1d609c9a45513fcdf9871cf35755144de1b5fa49e3d42a8abb0bee822545b5c902172d70021cd6b3e647f2b979fc17fee27b72c1bb23f8393fd528f2fc9d79b98c4c50eb694606b316b4b092b9650ed7839f74f1295e48d168369bc06b482cc06b40ccad0ba838909a235439b65dd9f44fe71643b76c3474f0db117b635db87f90e76a163ebca3e575c547a3c09ce6d60e343eb398cb89547c2c70a7600f669449d5a91bec96ccff95089838a7ba39f17939474724c9f381c582241a1bf1316a0951dd08b5f4309bf34f80fd64ec8b2bbac0da337828a46034919743cfd909fad74d5c55d7d901b7cf535e7080d3eadb2768d66742c7325e618dbc267fa62efc85b505db25f63147ab01af9e81b89f5668ca67fd1f155c758b293c282fb9fed503509c836ebe7b2a9629d325f6dc6f4a0548099ccc3b4cbd68047d0962e3decbf3b43c2b4a012ce94b3e105992e24a0281fd895749a069a50214510d765e2b290e5534bab0742aa0a878df147903877f517aeb3a8eccf0a71be9a053b4486ce15ed0fc28657ccecf9f6c659b1493951e469240283ebe3709251a6e7a51c2ef67c84ad516040b5650b0ce1997515993d83c898c2536526c1cf220dbcd3fc9fdaf67f256a9053bbe80f7977967061ba1f7e0d4334d5492b2af5dc2f4999ab2ea9ec92f78e9e13fdea4158b640560b67ae2926e0d1db796a07fb3ec24c9cb59894ad169d0808873487158495ddc3627336ce6af102a610a7887f0b23f5bce700913c00022b084d677cd91cd75b6070114759e9202cb4aaf7a8d7d78b3b1b46e32c7b458d2b47ff2621d12535f4f13af24e53b72cb9988b9981043e900370b79ae2ca0eaaf0b287f91b05876ecf1a59af535cf513f77166329e0bfee8ccfeb171498db51cb45a0170bbb511123a01a96a07a56a87b0109187e585ebc188cf874d73643f6540b125618b75774e8b9c667b5f9e779fc250c4cff26856108f67df6154c21b760af50f657b82b37c0df808c1fa19c02a7fdbbd99dd34314003626d74c5543210ffbbafdaba6e32e52a6e5bbdc2d9f1fbd53319d0bab66084ae12aa806fe939ec7ac1c8dd1e0a06d7b3456d38680a1879515f4d1b9c0cd09879a082c625d93fd08892c8236a3a53dc91be12b8481f7a20eb8dea2260fba02f5e88e55e723844efba855f42a04c1f1185dea3f0a93c683a6fda09fb06ad0f6ee64e935d2974bd311c4701e08165e2b9b1b41f4d2ea2f9373b6c2fe5c05869fb81ec6c3b30d504238ecb8ec6fc753087b7919f83f7397ff8115c65c740a0f4a593ad89b79d81d4ffc6d9e02db23ab64f50a37f608b7a1a2b55d270f6b1b18e939aafffac388686cc0849b97e9c0e039c4ab61f5e13cbcecef625d93cfe94d4ebbc25783a2911730c58b24b740351a5e03f38349c493a35ea27a2edd5129526317ea00109a076464f949d538c44a289b8112c89b7d42a0b05d6e153343a80f245e23fa154de5548eb500f592caaef2501cedcf2b2432ddc0b91e7a267e5020c68eb656d539f27ea90ef96be217c6428badaad5f3dff66de04b3d68be9cf0ed780d1bb1093757db7efe402d8251e504d28fd57c3988bcec2219f28168b54e0528973024bce8d7f891ac6dd559fef603f6ff0b185947406a05a3de432fbe6178eeedddc2102c0dc80f04a110f7209b2274e26646e501379b3f6402430844ec1769affd810f5801bc7fc9aff23519d42d4ebd203cada40de9e80eb375b5a8697d18e32d2292b3a45b0cc0299f707f06e4a44fc516ff569af0182da6e456ed56b6f45fd9649a720ca63c811723962bf372e203ffd920481ef0c37a84f8b2f0aaad9ab6ebb862b74a92eecbeb5b850e84f80de745e33ae5c9fb38ffb1f0d602f0b937e84c281a3367ba1364c8e66a4246a63bb10272ca4ede24b1bb9d59ebdc0f22d7fa34cc00fad74273caf790b2ca4100f2087f4eec7fe7d8f86f1e798b6b817ae311d504ba655313e7e916317eb4fc6860a23e863b47660af400ec47e271354b41eb9ed7de81ea13783863125472692b4c5c9f10b752ed1ff8eea31d28929e1a784840835811274a59002efabc049f2b3308a175c464232490e24a7a3cc6a6d9c24a072511000fd0fd21f52e547706a7a812015258dcacc5fc04e99e719c6fcc06f919b80523661c815062bac5c656d766d6a4240fc054003f4921ac34288f5553002bbfb756100cdcc4c184e13c4eb92b48277eaa1c8d9c483650b3e23c0a25b6120af071a6bd2b5e320c1dc35813337aa3c9de98c1c8aa8890d2458e8da7d1be0916be766a9ccb71681edc64db2f536779eb14056bd7e5e7bc48fdc4a60fdc9a3611bd34d1653f9ac0c14f64a4564a7061cdbb69c817a2a1ce05a02f07266128c51ccae3ab1b2bf742be3ce1ca7212222d42bd45d6ee7effe7b47b04d7c59637cb1d78259165d83252d67ee367d8d78551e4e8c30d69e2736281944e762cf74a8d811c91ae288134e7f6458c92a0ef6bd7696454afc8cbfc99fa04d1e8f971d6ea7a840d8a4e54ec32333db23e08deee904a088c9fd2908a8c64f8ce63a73b9cd50ae06b88b0e7ec0681480bf2ce0f8c2b99e968c7cac11745cad02977a62a25072aa59246336714a08cfc379a36654f336b959e9640c8b346cd60c8170a22ea2b614987ce38b69406af389fcce2b42c8ae73f7168bffa0fb9d815a7bd753dadbf9c2fa332588e1c61a97dfa80e49b7ffde2f070c000638167dab789e8596466aa5b78f6fbd05077aebb6d4f8008ee2fe2df495fd35044a15e5fa53c7530c6cdc3fe4f82cde7379cb7e2885eef7d1bade7231818931ab6246abfb291575ad9f4057ad5de741179d72a61a9a2f8943aaed1fee4a88f3785be3b477fa78b9c1139366c2ec0c3e41caa1d3fd1e60e54a2fe230211086844789edf0c59af51a812f65c1164c9ca92a883801c137a3bb3aee9307d429670f133a0f4a2468fd382f12bfc96cb3710326da732b8d9937e0b78a95beede087e882023c3c53502cb16736fb285ddcc1d33aac6b597db60b5db7bb62e38c1e51d03b88934cd8e3f53269bab4055dce9028db612ce00726c017286080e0b4eef7d7443713e3a00bdf25ca3620eb470fdf78cf547ebab9bf6a67e558a4cd1ade764ed3c8fa969e0c1b6972499aa87f50fc2039a3951ae299c312ba14092d21f26decc13e39f53fc3d75b42f27fe62e105e7c1047fc83fd05df0d332b0a3b1cd083a669e42333c3c211b0a559b48d8c94db16e5ad345bb274f9bbe79c040e58b587416112309b9b957b7e0be728812456dbfac8c682b930108b964c20ce081d628d84529f7ecfc6d0560a6d8b176b1dcfe1a21dc735f4b5dc7a57fa7698c1e0e5021d87940c2d7feaa8350fcad9d8e4e6b1e0a68b3fddc6bbd29f7fb4cc8d655179870879874a8df96ffd789d3c6dbc537f506707c89d46ce627cff33e4d4c56ea110ee441e6c2041d222cab880e9dab6660326a60d6ec8f3bcaa73aee99cc882a0291e7000f1e3b63f36ca7d689322639d4df966a973de66323fef5443beee31a4c8d4ddcae767bd00a4f1d682bc1fe7778f00b17d4d3e7f695b80a3a74d1edc845036ae3a5ea52bc835cd330c77a8cfa77d3d7a15b0bba2354bb4194e8b2568d460348d2a81b15a07ad9a3b43930524c44020b6e6a2a6bc5d88dfb5bba18d671890481ec1b32cb2e4cf1418cc402fe5f4c4f22afa811a542acb12a27cd0ba8d6ec65429495d9c69765f3028290cce56e08c9e7efed06741ca4558949b8fdf9795320b97f218742101ea2ba3e42a270877753b778ef2f2da511f75507a0c7e0c99c9fe8df7d38de5f68390c3b3ba25e82e74061a097e3b890a154260e116f2aeaa3fd8434ff7d1e69c9443443c5abec529fe2a00236887692fda26eb895fc1991e04b6f6d19c3d386c63ed97dc2ab335ee3c823979433584c6b47c34863c9befd9337319dc6b1bafa4f76639ace16e1fc5f82759672677dfc8626d6a80008b35106e830268ea62406c6b2d027625b97309f857154699dd24052a126f3f21cf9091c4da6f4f785537a79f4696700b5666d90f88932ec7829f167c2c61b50ecae91f2fd33e7206df837f2bfca62356e23e8b349a15e98e1ae94d4930227cb63c335e739d255c76137163509dce406731d967e6a2fd05f251c4ab1d181fefc59e11b8141f134fd854838a914d8399d9707132d95eec32c1895b9d5ed219d45eb4fd374217b5c65ed5b2974937272fb0befae38711fc44ed29159a32f6617d7f65c6ebb56be2f91208aa515e78de9ebb09f1028c38be18b10b10e03cb39cb36de2c999628ca6ed2c8ad8458c6b03da6f8fc48c1e79c7b1d5b366abf73f05bb12c06e8e4e82c1afe8087e5ec9094b3f605eca3788426a4250b556231aeda99fca2c3b5c5bf8ff935de5e4b6fb26efd5859a0c01d4ca565f40dd4f8acc5eaaf43d744e790dd2cfe82ba13ade111dcb9c5038e47cee3e726fb65541dbbbf058a4118d4e4c69e23f3c566d00ae138e5e19705b3dcb61bb26a590664f663e283e676b6a6b144a438e7dbf14cff7f94a2a77b475aac5cc3ed0cdc6a46740e935b9274b6ecd65eec315613b8d0f507635e58a580b818962ab736428dfd3847c15146250c5f8ef790be1c435690101ae6e7f5b27e3d2f435c2de6adb3366f0398c6972aa7dbce682c73a1ab6222820f2b7cbc1dcb1dcd240f1fc93579e053529592001e4ac533d92e8c7186e9a6dad5a93a2dda3173eefea4fab70a780ecd2cf448b886877c59f76ce88d1d4cdb338d570423d36895e9d6d7eaa220328cc7e2c1136e58a63bbd086b00a0b5d0e1629a0eda0abdd6bbcf341b9611b5f912ea0e4a008dce9ab1f2d9d00ebeacd57418274365fd12e2b66e3555fcc6f1d21b6f152dd667614a5904541d2abc4dcdda746b1d421609d938124c19622f374b86372e06173ed7d89993a4e1ac23ef2a9572265821fd7f3ea68c0451e93349a2d5d9140ec4098e8d8f00847853a7de2b57fb9885a60bdd4d7f1ca628e8a1483eeaccd63624bee4822b6a25e62d2dad03cbcfd4e1ffc7094f4f727d10473fe68e29b6468611d07e92ec0b94411502950dadc2518893fd61704796376425bfeb78c9306d591ab19510fd6b464ed5ecd92c83155c282f0e4c8959324c5fbfdaa74233b9b5ecd2c539890523a61b38187079598aee65373c15d9d099a83bb2f3ed9f6eac28e1884409423fdc35f6b207fa58d129c07fb122e407aac7b7f5ee4ba21502d00eb2bd320a5a7d4f84d29d180226aecce1404e11eae76d3876ed92f576fcec9b190e774ba821aa3e60cb3af19dfc58626f6788c5dc0cae52f7dc176a108c4615095388c13a2368590e01444eeda93301698a0d3cf4bd208ce401cfe9475e9464285732a497897f1f4cf1ee6ffc424702f17c2ca098afd4a396dc0a55109dc0b7dedb9b9a1574cc97581710deaa082aef83518e5ee01376802699224b9e1746bbec44427d2118b8686b9a7e30962dbeaf00e00b288b3ba74e48cd4c7ebb0c126b8090624c17ecef82258bcd4a111ab68c6e2f1b73a820a7e239a48e25457509032605ab4f6dc086ffa352472b2a306b54ba3376c1bbd32f2fc717d6a66aaf273ba93bdbc9c538d725756c577dc3591f324b6a52160f768f21476dbe21e1a4c34d0fb72f48863b3440fd4c3d8349165bd05ad09e4c086f55ed9d87f127a2c5a03754ef8070c27ee103c5ef28380c3a8b4864767a5b8c927bd354da8067aeac3f2c62693f09302f9a605d57f78c7bea9f0ff03e2d5ab2e26ef438dee4cf9d6d64246176080a6826d72ecd7fbbe91291121985018eaef2fde9a2e0fe7e67709d9633836f9825cff69c42f56f6b2f427441e5a4fe4ca41a45b34a8e17ae580bf5a741e3fdb8c5a35ae3d6bb5493918ef66250c6deeeb4167a3bd85affd5cd368e59fec668bef3046a1be481a99eb8707e15a18979ffb04df1e75e9466d96d65f06bc8c84fd0aa51ffe6f75d3e2a86b46c439a0d0ea022e5ad56c28820bddf6b365a9bc43c7b20c18918683d69aefa93657fb4d933afb3dc03f4770ce7f01f5412c5a4f6a06b6781dd49ce5ed32c830af563b68adc2882e2b26605b99461c3275b1f341675c0b92c1f898d5b6e9984960f408574eadc3929e4672989bbdf65860cef973d7b8430f25966dc1125f67645d08374a28abcce0078f65963edd36e64c2b0ae282aa157b4567aa6a88d44bf89501418b238f692646014dcd4dae1e665770ba8b0a6cee32cb4a4cbc138aa94941242cc63bc0477c973e7a4a4373fe1d6197d59a676240a0deadae1c30faa365b16e6dc31ccfef7655e6dc2a87c6705e2a34814f0a21021ad8a7e5dd09642183f0c79015bbba27036ddd5ac06d3d59398d766f1e4dd4c188a06b9e4a3122a59a6ed2c86e1d2c5c70cfdf372c65d3779bb13f358bbbbad380d8ded16d7df96de1f37c8b4880595fe6a8f905088e45c70abaa96b72096ec3860e1281f62ce382389a4bb3a24f41a56bd94f8f9b71f41c1e697a75ffaf9951619e5cd77945de725ade801d18907b1d186ed56964baa7f11bfb16b8af04b941fd5b5c2ae614b36d3bd163ac22b023bc73dbc5a121a7b70e56d69a1bd6eb1aa040c8d9ea19268354512c8fa62657906fed745182822523274118bcbe4691534a2ee12d6b87335badc203e21b9a0d8fcf94902c4deb9900f9d088fbcde6e382d5e1f0130cbadd507ace58b3bbeff4baa25cbd797cd7afe1705fa7d0e3b44560af2da886999e5c87eab38416f66340e8fe95c78c7a17c12f9e00050bb9b5b0d499f2a15193c6a559eb7e63d54b1f394c806fe6a2d9b1995a8b1ddde761a7321f73e49fd2bf11dd7278c1226724ba6e5567420398310329ffe58e2b247537d1f55327491cc9aa5e5df7d99610772aaa1e7f3d21afa9d5906d1faf3cc3e752ad1c2cd8461ffdb32278e44002080a2245ab970ba5950cd1034f3f969491226e1e079fe53aba7c8a865fac98cc3b7a2ebb9b8029003e9b1682b39456e455d33ba50d9d7a0afd36f674660d6e8a1315e21ccd5f0eaf2457ad9e672f46d78d05c70210a33ace44b3b1cdf14cd057ed3092bb5392e4e3090c92a47a08044fb513158a8113e6ea60b65ab574e2041cbd781ddea3eb9cabdf981b472f1fcb373f283a7c0412a3126056f345728e9bf1aaef9f9c371ef7d14b68217a70816d52853148108a1e47d650f2dfe70e2a45185c3710996ff32b0367cf304a9baed6573fdfa337a48a241a0aab4ddfa6a02ef7da5f170fd8af99e04b1fbff2546703e76e72786abcd6e994f57dd81dfa38e03cb8bb2815a0c36c6de271ad83ec7b10c0e7f57a09c7eb8a80296e3059331e1a30c8dbe2d5984e5faa6d6abfe784c1db3906dc10b105add8c652c48ff2942f7b0475532513984f9f3ccb0ba0c3d39168d23d183a2ad626c865da24e94a1a9fd3be48869ec0556e046f143991455d6806ba1c878f6c7b6174ec1759cd4473e395bbaef32fd6b676432d71cf269e732b9c0c29a7e7b0df950a10a4330fa1ceb92d678a474677d8a1e2bbeba42b30c9470cf4433afa5792f563bcb2a12e115410e3036247fabf75cb435c4d8018fe5efb527f097a8774d649821822e99d288d8de42cef86c2d3247b37804f868c5ca867ff6e5bacaa988bf5736eab6b7b4395d069afdf4ba57f5951cb61860c51fa813060b533cb304b50c7f61d7858a14cbf8938c9fa129686ba6e36fb6c10ca08512a681a87f5bdc88c85b98bcf44e029c12f1a0db68ffee22b3fa5a54020e04852ba05603cede127130e78db246b93aae5171b356ed0cca8487e87cbbf2dbea832678d1adec2fad294fce35fce442fce8883255b16d02b33029574cda2d859f9d82f5b2213ac617898</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","more":"这是一篇加密文章，该文章尚未完全对外开放，请耐心等待。如果你想提前查看，可以点击阅读全文，扫描下方二维码，关注公众号，回复“密码”。","origin":"<p>鲁迅先生曾说过：世界上本没有路，走的人多了也就成了路。</p>\n<p>为了解决大型网站面临的高并发访问、海量数据处理、高可靠运行等一系列问题与挑战，许多大型互联网公司的先辈们在实践中提出了许多解决方案，以实现网站<strong>高性能、高可用、易伸缩、可扩展、安全</strong>等各种技术架构目标。</p>\n<p>这些解决方案又被更多网站重复使用，从而逐渐形成大型网站架构模式。那么大型网站发展的道路上有哪些模式供我们使用呢？</p>\n<h4 id=\"1-分层\"><a href=\"#1-分层\" class=\"headerlink\" title=\"1.分层\"></a>1.分层</h4><p>分层是一种将系统横向切分的方法。将系统在横向维度上切分成几个部分，每个部分负责一部分相对比较单一的职责，然后通过上层对下层的依赖和调用组成一个完整的系统。</p>\n<p>分层结构在计算机世界中无处不在，网络的7层通信协议是一种分层结构；计算机硬件、操作系统、应用软件也可以看作是一种分层结构。在大型网站架构中也采用分层结构，一般可以将网站软件系统分为应用层、服务层、数据层。</p>\n<p>应用层：负责具体业务和视图展示，如网页首页及搜索输入和结果展示。</p>\n<p>服务层：为应用层提供技术支持，如用户管理服务，购物车服务等。</p>\n<p>数据层：提供数据存储访问服务，如数据库、缓存、文件、搜索引擎等。</p>\n<p>通过分层，可以更好地将一个庞大的软件系统切分成不同的部分，便于分工合作开发和维护；各层之间具有一定的独立性，只要维持调用接口不变，各层可以根据具体问题独立演化发展而不需要其他层必须做出相应调整，</p>\n<p>但是分层架构也有一些挑战，就是必须合理规划层次边界和接口，在开发过程中，严格遵循分层架构的约束，禁止跨层次的调用(应用层直接调用数据层)及逆向调用(数据层调用服务层，或者服务层调用应用层)。</p>\n<p>在实践中，大的分层结构内部还可以继续分层，如应用层可以再细分为视图层(美工负责)和业务逻辑层(工程师负责);服务层也可以细分为数据接口层(适配各种输入和输出的数据格式)和逻辑处理层。</p>\n<p>分层架构是逻辑上的，在物理部署上，三层结构可以部署在同一个物理机器上，但是随着网站业务的发展，必然需要对已经分层的模块分离部署，即三层结构分别部署在不同的服务器上，使网站拥有更多的计算资源以应对越来越多的用户访问。</p>\n<p>所以分层的最初目的是规划软件清晰的逻辑结构便于开发维护，但在网站的发展过程中，分层结构对网站支持高并发向分布式方向发展至关重要。因此在网站非常小的时候就应该采用分层架构，这样将来网站做大时才能有更好的应对。</p>\n<h4 id=\"2-分割\"><a href=\"#2-分割\" class=\"headerlink\" title=\"2.分割\"></a>2.分割</h4><p>如果说分层是将软件在横向方面进行切分，那么分割就是在纵向方面对软件进行切分。</p>\n<p>网站越大，功能越复杂服务和数据处理的种类也越多，将这些不同的功能和服务分割开来，包装成高内聚低耦合的模块单元，一方面有利于软件的开发和维护；另一方面便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。</p>\n<p>大型网站分割的粒度可能会很小。比如在应用层，将不同的业务进行分割，例如将购物、论坛、搜索、广告分割成不同的应用，由独立的团队负责，部署在不同的服务器上;在同一个应用内部，如果规模庞大业务复杂，会继续进行分割，比如购物业务，可以进一步分割为机票酒店业务、3C业务，小商品业务等更细小的粒度。而即使在这个粒度上，还是可以继续分割成首页、搜索列表、商品详情等模块，这些模块不管是在逻辑上还是物理部署上，都是可以独立的。同样在服务层也可以根据需要将服务分割成合适的模块。</p>\n<h4 id=\"3-分布式\"><a href=\"#3-分布式\" class=\"headerlink\" title=\"3 分布式\"></a>3 分布式</h4><p>对于大型网站，分层和分割的一个主要目的是为了切分后的模块便于分布式部署，即将不同模块部署在不同服务器上，通过远程调用协同工作。分布式意味着可以使用更多的计算机完成同样的功能，计算机越多，CPU、内存、存储资源也就越多，能够处理的并发访问和数据量就越大，进而能够为更多的用户提供服务。</p>\n<p>但分布式在解决网站高并发问题的同时也带来了其它问题。首先，分布式意味着服务调用必须通过网络，这可能会对性能造成严重的影响；其次，服务器越多，服务宕机的概率也就越大，一台服务器宕机造成的服务不可用可能会导致很多应用不可访问，使网站可用性降低；另外，数据在分布式的环境中保持数据一致性也非常困难，分布式服务也难以保证，这对网站业务正确性和业务流程有可能造成很大影响；分布式事务也难以保证，这对网站业务正确性和业务流程有可能造成很大影响；分布式导致网站依赖错综复杂，开发管理维护困难。因此分布式设计要根据具体情况量力而行，切莫为了分布式而分布式。</p>\n<p>在网站应用中，常用的分布式方案有以下几种：</p>\n<p><strong>分布式应用和服务:</strong>将分层和分割后的应用和服务模块分布式部署，除了可以改善网站性能和并发性、加快开发速度和发布速度、减少数据库连接资源消耗外；还可以使不同应用复用共同的服务，便于业务功能扩展。</p>\n<p><strong>分布式静态资源:</strong>网站的静态资源如JS,CSS,Logo图片等资源独立分布式部署，并采用独立的域名，即人们常说的动静分离。静态资源分布式部署可以减轻应用服务器的负载压力；通过使用独立域名加快浏览器并发加载速度；由负责用户体验的团队进行开发维护有利于网站分工合作，使不同技术工种术业有专攻。</p>\n<p><strong>分布式数据和存储：</strong>大型网站需要处理以P为单位的海量数据，单台计算机无法提供如此大的存储空间，这些数据需要分布式存储。除了传统的关系型数据库进行分布式部署外，为网站应用而生的NoSQL产品几乎都是分布式的。</p>\n<p><strong>分布式计算:</strong>严格来说，应用、服务、实时数据处理都是计算，网站除了要处理这些在线业务，还有很大一部分用户没有直观感受的后台业务要处理，包括搜索引擎的索引构建、数据仓库的数据分析统计等。这些业务的计算规模非常庞大，目前网站普遍使用Hadoop及其MapReduce分布式计算框架进行此类批处理计算，其特点是移动计算而不是移动数据，将计算程序分发到数据所在位置以加速计算和分布式计算。</p>\n<p>此外，还有可以支持网站线上服务器配置实时更新的分布式配置；分布式环境下实现并发和协同的分布式锁；支持云存储的分布式文件系统等。</p>\n<h4 id=\"4-集群\"><a href=\"#4-集群\" class=\"headerlink\" title=\"4 集群\"></a>4 集群</h4><p>使用分布式虽然已经将分层和分割后的模块独立部署，但是对于用户访问集中的模块(如首页)，还需要将独立部署的服务器集群化，即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。</p>\n<p>因为服务器集群有更多服务器提供相同服务，因此可以提供更好的并发特性，当有更多用户访问的时候，只需要向集群中加入新的机器即可。因为同一个应用由多台服务器提供，当某台服务器发生故障时，负载均衡设备或者系统的失效转移机制会将请求转发到集群中其他服务器上，使服务器故障不影响用户使用。所以在网站应用中，即使是访问量很小的分布式应用和服务也至少要部署两台服务器构成一个小的集群，目的就是要提高系统的可用性。</p>\n<h4 id=\"5-缓存\"><a href=\"#5-缓存\" class=\"headerlink\" title=\"5 缓存\"></a>5 缓存</h4><p>缓存就是将数据存放在距离计算最近的位置以加快处理速度。缓存是改善软件性能的第一手段，现代CPU越来越快的一个重要因素就是使用了更多的缓存，在复杂的软件设计中，缓存几乎是无处不在。大型网站架构设计在很多方面都使用了缓存设计。</p>\n<p>CDN：内容分发网络，部署在距离终端用户最近的网络服务商，用户的网络请求总是先到达他的网络服务商那里，在这里缓存网站的一些静态资源(较少变化的数据)，可以就近以最快的速度返回给用户，如视频网站和门户网站会将用户访问量大的热点数据缓存在CDN。</p>\n<p>反向代理：反向代理属于网站前端架构的一部分，部署在网站的前端，当用户请求到达网站的数据中心时，最先访问的就是反向代理服务器，这里缓存网站的静态资源，无需将请求继续转发给应用服务器就能返回给用户。</p>\n<p>本地缓存：在应用服务器本地缓存着热点数据，应用程序可以再本机内存中直接访问数据，而无需访问数据库。</p>\n<p>分布式缓存：大型网站的数据量非常庞大，即使只缓存一小部分，需要的内存空间也不是单机所能承受的，所以除了本地缓存，还需要分布式缓存，将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据。</p>\n<p>使用缓存的两个前提条件：一是数据访问热点不均衡，某些数据会被更频繁的访问，这些数据应该放在缓存中；二是数据在某个时间段内有效，不会很快过期，否则缓存的数据就会因已经失效而产生脏读，影响结果的正确性。网站应用中，缓存除了可以加快数据访问速度，还可以减轻后端应用和数据存储的负载压力，这一点对网站数据库架构至关重要，网站数据库几乎都是按照有缓存的前提进行负载能力设计的。</p>\n<h4 id=\"6-异步\"><a href=\"#6-异步\" class=\"headerlink\" title=\"6 异步\"></a>6 异步</h4><p>计算机软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越小，就越少被彼此影响，越可以独立发展。大型网站架构中，系统解耦和的手段除了分层、分割、分布等，还有一个重要的手段就是异步，业务之间传递消息不再是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步执行协作。</p>\n<p>在单一服务器内部可通过多线程共享内存队列的方式实现异步，处在业务操作前面的线程将输出写入到队列，后面的线程从队列中读取数据进行处理；在分布式系统中，多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看作内存队列的分布式部署。</p>\n<p>异步架构是典型的生产者消费者模式，两者不存在直接调用，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站扩展新功能非常便利。除此之外，使用异步消息队列还有如下特性：</p>\n<p><strong>提高系统可用性。</strong>消费者服务器发生故障，数据会在消息队列服务器中存储堆积，生产者服务器可以继续处理业务请求，系统整体表现无故障。消费者服务器恢复正常后，继续处理消息队列中的数据。</p>\n<p><strong>加快网站响应速度：</strong>处在业务处理前端的生产者服务器在处理完业务请求后，将数据直接写入消息队列，不需要等待消费者服务器处理就可以返回，响应延迟减少。</p>\n<p><strong>消除并发访问高峰：</strong>用户访问网站是随机的，存在访问高峰和低谷，即使网站按照一般访问高峰进行规划和部署，也依然会出现突发事件，比如购物网站的促销活动，微博上的热点事件，都会造成网站并发访问突然增大，这可能会造成整个网站的负载过重，响应延迟，严重时甚至会出现服务宕机的情况。使用消息队列将突然增加的访问请求数据放入消息队列中，等待消费者服务器依次处理，就不会对整个网站负载造成太大压力。</p>\n<p>需要注意的是：使用异步方式处理业务可能会对用户体验、业务流程造成影响，需要网站产品设计方面的支持。</p>\n<h4 id=\"7-冗余\"><a href=\"#7-冗余\" class=\"headerlink\" title=\"7 冗余\"></a>7 冗余</h4><p>网站需要7x24小时连续运行，但是服务器随时可能出现故障，特别是服务器规模比较大时，出现某台服务器宕机是必然事件。要想保证在服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份，这样，当某台服务器宕机时，可以将其上的服务和数据访问转移到其他机器上。</p>\n<p>访问和负载很小的服务也必须部署至少两台服务器构成一个集群，其目的就是通过冗余实现服务高可用。数据库除了定期备份，存档保存，实现冷备份外，为了保证在线业务高可用，还需要对数据库进行主从分离，实现同步实现热备份。</p>\n<p>为了抵御地震、海啸等不可抗力导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署灾备数据中心。网站程序和数据实时同步到多个灾备数据中心。</p>\n<h4 id=\"8-自动化\"><a href=\"#8-自动化\" class=\"headerlink\" title=\"8 自动化\"></a>8 自动化</h4><p>在无人值守的情况下网站可以正常运行，一切都可以自动化是网站的理想状态。目前大型网站的自动化架构设计主要集中在发布运维方面。</p>\n<p>发布对网站都是头等大事，许多网站故障处在发布环节，网站工程师经常加班也是因为发布不顺利。通过减少人为干预，使用<strong>发布过程自动化</strong>可以有效减少故障。发布过程包括诸多环节。自<strong>动化代码管理</strong>，代码版本控制、代码分支创建合并等过程自动化，开发工程师只要提交自己参与开发的产品代号，系统就自动为其创建开发分支，后期会自动进行代码合并；<strong>自动化测试</strong>，代码开发完成，提交测试后，系统自动将代码部署到测试环境，启动自动化测试用例进行测试，向相关人员发送测试报告，向系统反馈测试结果；<strong>自动化安全监测</strong>，安全监测工具通过对代码进行静态安全扫描以及部署到安全测试环境进行安全攻击测试，评估其安全性；最后进行<strong>自动化部署</strong>，将工程代码自动部署到线上生产环境。</p>\n<p>此外，网站在运行过程中可能会遇到各种问题：服务器宕机、程序Bug、存储空间不足、突然爆发的访问高峰。网站需要对线上生产环境进行<strong>自动化监控</strong>，对服务器进行心跳检测，并监控其各项性能指标和应用程序的关键数据指标。如果发现异常、超出预设的阈值，就进行<strong>自动报警</strong>，向相关人员发送报警信息，警告故障可能会发生。在检测到故障发生后，系统会进行<strong>自动化失效转移</strong>，将失效的服务器从集群中隔离出去，不再处理系统中的应用请求。待故障消除后，系统进行<strong>自动化失效恢复</strong>，重新启动服务，同步数据保证数据一致性。在网站遇到访问高峰，超出网站最大处理能力时，为了保证整个网站的安全可用，还会进行<strong>自动化降级</strong>，通过拒绝部分请求及关闭部分不重要的服务将系统负载降至一个安全的水平，必要时，还需要<strong>自动化分配资源</strong>，将空闲资源分配给重要的服务，扩大其部署规模。</p>\n<h4 id=\"9-安全\"><a href=\"#9-安全\" class=\"headerlink\" title=\"9 安全\"></a>9 安全</h4><p>互联网的开放特性使得其从诞生起就面对巨大的安全挑战，网站在安全架构方面也积累了许多模式：通过<strong>密码</strong>与<strong>手机校验码</strong>进行身份验证；登录、交易等操作需要对网络通信进行<strong>加密</strong>，网站服务器上存储的敏感数据和用户信息等也进行加密处理；为了防止机器人程序滥用网络资源攻击网站，网站使用<strong>验证码</strong>进行识别；对于常见的用户攻击网站的XSS攻击、SQL注入，进行编码转换等相应处理；对于垃圾信息、敏感信息进行<strong>过滤</strong>；对交易转账等重要操作根据交易模式和交易信息进行<strong>风险控制</strong>。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><strong>在程序设计与架构设计领域，模式正变得越来越受人关注，许多人寄望通过模式一劳永逸地解决自己的问题。正确使用模式可以更好地利用业界和前人的思想与实践，用更少的时间开发出更好的系统，使设计者的水平也达到更高的境界。但是模式受其适用场景限制，对系统的要求和约束也很多，不恰当地使用模式只会画虎不成反类犬，不但没有解决原来的老问题，反而带来了更棘手的问题。</strong></p>\n<p><strong>好的设计绝对不是模仿，不是生搬硬套某个模式，而是对问题深刻理解之上创造与创新，即使是“微创新”，也是让人耳目一新的似曾相识。山寨与创新的最大区别不在于是否抄袭，是否模仿，而在于对问题和需求是否真正理解与把握。</strong></p>\n","encrypt":true},{"title":"RabbitMQ的使用进阶篇","date":"2018-11-12T01:07:41.000Z","aside":"rabbitmq","_content":"\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章简单总结了分布式系统中的消息中间件以及RabbitMQ的基本使用，这篇文章主要总结一下RabbitMQ在日常项目开发中比较常用的几个特性。\n<!--more-->\n### 一 mandatory 参数\n\n&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章中我们知道，生产者将消息发送到RabbitMQ的交换器中通过RoutingKey与BindingKey的匹配将之路由到具体的队列中以供消费者消费。那么当我们通过匹配规则找不到队列的时候，消息将何去何从呢?Rabbit给我们提供了两种方式。mandatory与备份交换器。\n\n&nbsp;&nbsp;&nbsp;&nbsp;mandatory参数是channel.BasicPublish方法中的参数。其主要功能是消息传递过程中不可达目的地时将消息返回给生产者。当mandatory 参数设为true 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ 会调用BasicReturn 命令将消息返回给生产者。当mandatory 参数设置为false 时。则消息直接被丢弃。其运转流程与实现代码如下(以C# RabbitMQ.Client 3.6.9为例):\n\n![mandatory 参数](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/24859650.jpg)\n\n```c#\n//连接与创建信道--后续的示例代码我们会省略掉这部分代码和释放连接\nConnectionFactory factory = new ConnectionFactory();\n            factory.UserName = \"admin\";\n            factory.Password = \"admin\";\n            factory.HostName = \"192.168.121.205\";\n            IConnection conn = factory.CreateConnection();//连接Rabbit\n IModel channel = conn.CreateModel();//创建信道\n\n\n channel.ExchangeDeclare(\"exchangeName\", \"direct\", true);//定义交换器\n String queueName = channel.QueueDeclare(\"TestQueue\", true, false, false, null).QueueName;//定义  队列 队列名TestQueue,持久化的,非排它的,非自动删除的。\n channel.QueueBind(queueName, \"exchangeName\", \"routingKey\");//队列绑定交换器\n\n var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n channel.BasicPublish(\"exchangeName\", \"routingKey\", true, null, message);//发布一个可以路由到队列的消息，mandatory参数设置为true\n var message1 = Encoding.UTF8.GetBytes(\"TestMsg1\");\n channel.BasicPublish(\"exchangeName\", \"routingKey1\", true, null, message);//发布一个不可以路由到队列的消息，mandatory参数设置为true\n\n //生产者回调函数\n channel.BasicReturn += (model, ea) =>\n {\n      //do something... 消息若不能路由到队列则会调用此回调函数。\n };\n\n //关闭信道与连接\n channel.close();\n conn.close() ;\n```\n\n### 二 备份交换器\n\n&nbsp;&nbsp;&nbsp;&nbsp;当消息不能路由到队列时，通过mandatory设置参数,我们可以将消息返回给生产者处理。但这样会有一个问题，就是生产者需要开一个回调的函数来处理不能路由到的消息，这无疑会增加生产者的处理逻辑。备份交换器(Altemate Exchange)则提供了另一种方式来处理不能路由的消息。备份交换器可以将未被路由的消息存储在RabbitMQ中，在需要的时候去处理这些消息。其主要实现代码如下:\n\n```c#\n  IDictionary<string, object> args = new Dictionary<string, object>();\n  args.Add(\"alternate-exchange\", \"altExchange\");\n  channel.ExchangeDeclare(\"normalExchange\", \"direct\", true, false, args);//定义普通交换器并添加备份交换器参数\n  channel.ExchangeDeclare(\"altExchange\", \"fanout\", true, false, null);   //定义备份交换器，并声明为扇形交换器        \n            \n  channel.QueueDeclare(\"normalQueue\", true, false, false, null);//定义普通队列\n  channel.QueueBind(\"normalQueue\", \"normalExchange\", \"NormalRoutingKey1\");//普通队列队列绑定普通交换器\n\n  channel.QueueDeclare(\"altQueue\", true, false, false, null);//定义备份队列\n  channel.QueueBind(\"altQueue\", \"altExchange\", \"\");//绑定备份队列与交换器\n\n  var msg1 = Encoding.UTF8.GetBytes(\"TestMsg\");\n  channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey1\", false, null, msg1);//发布一个可以路由到队列的消息，消息最终会路由到normalQueue\n\n  var msg2 = Encoding.UTF8.GetBytes(\"TestMsg1\");\n  channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey2\", false, null, msg2);//发布一个不可以被路由的消息，消息最终会进入altQueue\n```\n\n![备份交换器](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/91801281.jpg)\n\n备份交换器其实和普通的交换器没有太大的区别，为了方便使用，建议设置为fanout类型，若设置为direct 或者topic的类型。需要注意的是，消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。考虑这样一种情况，如果备份交换器的类型是direct,并且有一个与其绑定的队列，假设绑定的路由键是key1，当某条携带路由键为key2 的消息被转发到这个备份交换器的时候，备份交换器没有匹配到合适的队列，则消息丢失。如果消息携带的路由键为keyl，则可以存储到队列中。\n对于备份交换器，有以下几种特殊情况:\n\n* 如果设置的备份交换器不存在，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。\n* 如果备份交换器没有绑定任何队列，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。\n* 如果备份交换器没有任何匹配的队列，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。\n* 如果备份交换器和mandatory参数一起使用，那么mandatory参数无效。\n\n### 三 过期时间(TTL)\n\n#### 3.1 设置消息的TTL\n\n&nbsp;&nbsp;&nbsp;&nbsp;目前有两种方法可以设置消息的TTL。第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。第二种方法是对消息本身进行单独设置，每条消息的TTL可以不同。如果两种方法一起使用，则消息的TTL 以两者之间较小的那个数值为准。消息在队列中的生存时间一旦超过设置的TTL值时，就会变成\"死信\" (Dead Message) ，消费者将无法再收到该消息。(有关死信队列请往下看)\n\n&nbsp;&nbsp;&nbsp;&nbsp;通过队列属性设置消息TTL的方法是在channel.QueueDeclare方法中加入x-message-ttl参数实现的，这个参数的单位是毫秒。示例代码下:\n\n```c#\nIDictionary<string, object> args = new Dictionary<string, object>();\nargs.Add(\"x-message-ttl\", 6000);\nchannel.QueueDeclare(\"ttlQueue\", true, false, false, args);\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;如果不设置TTL.则表示此消息不会过期;如果将TTL设置为0 ，则表示除非此时可以直接将消息投递到消费者，否则该消息会被立即丢弃(或由死信队列来处理)。\n\n&nbsp;&nbsp;&nbsp;&nbsp;针对每条消息设置TTL的方法是在channel.BasicPublish方法中加入Expiration的属性参数，单位为毫秒。关键代码如下：\n\n```c#\n BasicProperties properties = new BasicProperties()\n            {\n                Expiration = \"20000\",//设置TTL为20000毫秒\n            };\n var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey\", true, properties, message);\n```\n\n**注意:对于第一种设置队列TTL属性的方法，一旦消息过期，就会从队列中抹去，而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息是否过期是在即将投递到消费者之前判定的。Why?在第一种方法里，队列中己过期的消息肯定在队列头部， RabbitMQ 只要定期从队头开始扫描是否有过期的消息即可。而第二种方法里，每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期，如果过期再进行删除即可。**\n\n#### 3.2 设置队列的TTL\n\n&nbsp;&nbsp;&nbsp;&nbsp;注意，这里和上述通过队列设置消息的TTL不同。上面删除的是消息，而这里删除的是队列。通过channel.QueueDeclare 方法中的x-expires参数可以控制队列被自动删除前处于未使用状态的时间。这个未使用的意思是队列上没有任何的消费者，队列也没有被重新声明，并且在过期时间段内也未调用过channel.BasicGet命令。\n\n&nbsp;&nbsp;&nbsp;&nbsp;设置队列里的TTL可以应用于类似RPC方式的回复队列，在RPC中，许多队列会被创建出来，但是却是未被使用的(有关RabbitMQ实现RPC请往下看)。RabbitMQ会确保在过期时间到达后将队列删除，但是不保障删除的动作有多及时。在RabbitMQ 重启后， 持久化的队列的过期时间会被重新计算。用于表示过期时间的x-expires参数以毫秒为单位， 井且服从和x-message-ttl一样的约束条件，不同的是它不能设置为0(会报错)。\n示例代码如下：\n\n```c#\n IDictionary<string, object> args = new Dictionary<string, object>();\n args.Add(\"x-expires\", 6000);\n channel.QueueDeclare(\"ttlQueue\", false, false, false, args);\n```\n\n### 四 死信队列\n\n&nbsp;&nbsp;&nbsp;&nbsp;DLX(Dead-Letter-Exchange)死信交换器，当消息在一个队列中变成死信之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX ，绑定DLX的队列就称之为死信队列。\n消息变成死信主要有以下几种情况:\n\n* 消息被拒绝(BasicReject/BasicNack) ，井且设置requeue 参数为false;(消费者确认机制将会在下一篇文章中涉及)\n* 消息过期;\n* 队列达到最大长度。\n\n&nbsp;&nbsp;&nbsp;&nbsp;DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时，RabbitMQ 就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。可以监听这个队列中的消息、以进行相应的处理。\n\n&nbsp;&nbsp;&nbsp;&nbsp;通过在channel.QueueDeclare 方法中设置x-dead-letter-exchange参数来为这个队列添加DLX。其示例代码如下:\n\n```c#\n channel.ExchangeDeclare(\"exchange.dlx\", \"direct\", true);//定义死信交换器\n channel.ExchangeDeclare(\"exchange.normal\", \"direct\", true);//定义普通交换器\n IDictionary<String, Object> args = new Dictionary<String, Object>();\n args.Add(\"x-message-ttl\",10000);//定义消息过期时间为10000毫秒\n args.Add(\"x-dead-letter-exchange\", \"exchange.dlx\");//定义exchange.dlx为死信交换器\n args.Add(\"x-dead-letter-routing-key\", \"routingkey\");//定义死信交换器的绑定key,这里也可以不指定，则默认使用原队列的路由key\n\n channel.QueueDeclare(\"queue.normal\", true, false, false, args);//定义普通队列\n channel.QueueBind(\"queue.normal\", \"exchange.normal\", \"normalKey\");//普通队列交换器绑定\n\n channel.QueueDeclare(\"queue.dlx\", true, false, false, null);//定义死信队列\n channel.QueueBind(\"queue.dlx\", \"exchange.dlx\", \"routingkey\");//死信队列交换器绑定,若上方为制定死信队列路由key则这里需要使用原队列的路由key\n //发布消息\n var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n channel.BasicPublish(\"exchange.normal\", \"normalKey\", null, message) ;\n\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;以下为死信队列的运转流程:\n\n![死信队列](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/67534593.jpg)\n\n### 五 延迟队列\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ本身并未提供延迟队列的功能。延迟队列是一个逻辑上的概念，可以通过过期时间+死信队列来模拟它的实现。延迟队列的逻辑架构大致如下:\n\n![延迟队列](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/79679939.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;生产者将消息发送到过期时间为n的队列中，这个队列并未有消费者来消费消息，当过期时间到达时，消息会通过死信交换器被转发到死信队列中。而消费者从死信队列中消费消息。这个时候就达到了生产者发布了消息在讲过了n时间后消费者消费了消息，起到了延迟消费的作用。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟队列在我们的项目中可以应用于很多场景，如：下单后两个消息取消订单，七天自动收货，七天自动好评，密码冻结后24小时解冻，以及在分布式系统中消息补偿机制(1s后补偿,10s后补偿，5m后补偿......)。\n\n![RabbitMQ 延迟队列应用场景](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/88724997.jpg)\n\n### 六 优先级队列\n\n&nbsp;&nbsp;&nbsp;&nbsp;就像我们生活中的“特殊”人士一样，我们的业务上也存在一些“特殊”消息，可能需要优先进行处理，在生活上我们可能会对这部分特殊人士开辟一套VIP通道，而Rabbit同样也有这样的VIP通道(前提是在3.5的版本以后)，即优先级队列，队列中的消息会有优先级优先级高的消息具备优先被消费的特权。针对这些VIP消息，我们只需做两件事:\n\n我们只需做两件事情：\n\n1. 将队列声明为优先级队列，即在创建队列的时候添加参数 **x-max-priority** 以指定最大的优先级，值为0-255（整数）。\n2. 为优先级消息添加优先级。\n\n其示例代码如下:\n\n```c#\nchannel.ExchangeDeclare(\"exchange.priority\", \"direct\", true);//定义交换器\nIDictionary<String, Object> args = new Dictionary<String, Object>();\nargs.Add(\"x-max-priority\", 10);//定义优先级队列的最大优先级为10\nchannel.QueueDeclare(\"queue.priority\", true, false, false, args);//定义优先级队列\nchannel.QueueBind(\"queue.priority\", \"exchange.priority\", \"priorityKey\");//队列交换器绑定\nBasicProperties properties = new BasicProperties()\n{\n    Priority =8,//设置消息优先级为8\n};\nvar message = Encoding.UTF8.GetBytes(\"TestMsg8\");\n//发布消息\nchannel.BasicPublish(\"exchange.priority\", \"priorityKey\", properties, message);\n```\n\n**注意：没有指定优先级的消息会将优先级以0对待。 对于超过优先级队列所定最大优先级的消息，优先级以最大优先级对待。对于相同优先级的消息，后进的排在前面。如果在消费者的消费速度大于生产者的速度且Broker 中没有消息堆积的情况下， 对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。**\n\n&nbsp;&nbsp;&nbsp;&nbsp;关于优先级队列，好像违背了队列这种数据结构先进先出的原则，其具体是怎么实现的在这里就不过多讨论。有兴趣的可以自己研究研究。后续可能也会有相关的文章来分析其原理。\n\n### 七 RPC 实现\n\n&nbsp;&nbsp;&nbsp;&nbsp;RPC,是Remote Procedure Call 的简称，即远程过程调用。它是一种通过网络从远程计算机上请求服务，而不需要了解底层网络的技术。RPC 的主要功用是让构建分布式计算更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。\n\n&nbsp;&nbsp;&nbsp;&nbsp;有关RPC不多介绍，这里我们主要介绍RabbitMQ如何实现RPC。RabbitMQ 可以实现很简单的RPC。客户端发送请求消息，服务端回复响应的消息，为了接收响应的消息，我们需要在请求消息中发送一个回调队列(可以使用默认的队列)。其服务器端实现代码如下:\n\n```c#\n      static void Main(string[] args)\n        {\n            ConnectionFactory factory = new ConnectionFactory();\n            factory.UserName = \"admin\";\n            factory.Password = \"admin\";\n            factory.HostName = \"192.168.121.205\";\n            IConnection conn = factory.CreateConnection();\n            IModel channel = conn.CreateModel();\n            channel.QueueDeclare(\"RpcQueue\", true, false, false, null);\n            SimpleRpcServer rpc = new MySimpRpcServer(new Subscription(channel, \"RpcQueue\"));\n            rpc.MainLoop();\n        }\n```\n\n```c#\n  public class MySimpRpcServer: SimpleRpcServer\n    {\n        public MySimpRpcServer(Subscription subscription) : base(subscription)\n        {\n        }\n\n        /// <summary>\n        /// 执行完成后进行回调\n        /// </summary>   \n        public override byte[] HandleSimpleCall(bool isRedelivered, IBasicProperties requestProperties, byte[] body, out IBasicProperties replyProperties)\n        {\n            replyProperties = null;\n            return Encoding.UTF8.GetBytes(\"我收到了!\");\n        }\n        \n        /// <summary>\n        /// 进行处理\n        /// </summary>\n        /// <param name=\"evt\"></param>\n        public override void ProcessRequest(BasicDeliverEventArgs evt)\n        {\n            // todo.....\n            base.ProcessRequest(evt);\n        }\n    }\n```\n\n客户端实现代码如下:\n\n```c#\n  ConnectionFactory factory = new ConnectionFactory();\n  factory.UserName = \"admin\";\n  factory.Password = \"admin\";\n  factory.HostName = \"192.168.121.205\";\n  IConnection conn = factory.CreateConnection();\n  IModel channel = conn.CreateModel();\n   \n  SimpleRpcClient client = new SimpleRpcClient(channel, \"RpcQueue\");\n  var message = Encoding.UTF8.GetBytes(\"TestMsg8\");\n  var result = client.Call(message);\n  //do somethings...\n```\n\n以上是Rabbit客户端自己帮我们封装好的Rpc客户端与服务端的逻辑。当然我们也可以自己实现，主要是借助于BasicProperties的两个参数。\n\n* ReplyTo: 通常用来设置一个回调队列。\n* CorrelationId : 用来关联请求(request) 和其调用RPC 之后的回复(response) 。\n\n其处理流程如下:\n\n![RabbitMQ Rpc](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-21/77785239.jpg)\n\n1. 当客户端启动时，创建一个匿名的回调队列。\n2. 客户端为RPC 请求设置2个属性: ReplyTo用来告知RPC 服务端回复请求时的目的队列，即回调队列; Correlationld 用来标记一个请求。\n3. 请求被发送到RpcQueue队列中。\n4. RPC 服务端监听RpcQueue队列中的请求，当请求到来时，服务端会处理并且把带有结果的消息发送给客户端。接收的队列就是ReplyTo设定的回调队列。\n5. 客户端监昕回调队列，当有消息时，检查Correlationld 属性，如果与请求匹配，那就是结果了。\n\n### 结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;本篇文章简单介绍了RabbitMQ在我们项目开发中常用的几种特性。这些特性可以帮助我们更好的将Rabbit用于我们不同的业务场景中。这些特性与示例，可以自己在程序中运行一下，然后通过查看Rabbit提供的web管理界面来验证其正确性(关于web管理界面不多介绍，相信大家稍微研究研究就能明白)。当然，关于Rabbit的使用，仍有许多地方在本文中没有提及，如：RabbitMQ的特色——确认机制、持久化......将在下一篇文章中再详细介绍。\n\n","source":"_posts/技术实践/rabbitmq/RabbitMQ的使用进阶篇.md","raw":"---\ntitle: RabbitMQ的使用进阶篇\ndate: 2018-11-12 09:07:41\ntags: \n- 消息队列\n- RabbitMQ\ncategories: 消息队列\naside: rabbitmq\n---\n\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章简单总结了分布式系统中的消息中间件以及RabbitMQ的基本使用，这篇文章主要总结一下RabbitMQ在日常项目开发中比较常用的几个特性。\n<!--more-->\n### 一 mandatory 参数\n\n&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章中我们知道，生产者将消息发送到RabbitMQ的交换器中通过RoutingKey与BindingKey的匹配将之路由到具体的队列中以供消费者消费。那么当我们通过匹配规则找不到队列的时候，消息将何去何从呢?Rabbit给我们提供了两种方式。mandatory与备份交换器。\n\n&nbsp;&nbsp;&nbsp;&nbsp;mandatory参数是channel.BasicPublish方法中的参数。其主要功能是消息传递过程中不可达目的地时将消息返回给生产者。当mandatory 参数设为true 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ 会调用BasicReturn 命令将消息返回给生产者。当mandatory 参数设置为false 时。则消息直接被丢弃。其运转流程与实现代码如下(以C# RabbitMQ.Client 3.6.9为例):\n\n![mandatory 参数](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/24859650.jpg)\n\n```c#\n//连接与创建信道--后续的示例代码我们会省略掉这部分代码和释放连接\nConnectionFactory factory = new ConnectionFactory();\n            factory.UserName = \"admin\";\n            factory.Password = \"admin\";\n            factory.HostName = \"192.168.121.205\";\n            IConnection conn = factory.CreateConnection();//连接Rabbit\n IModel channel = conn.CreateModel();//创建信道\n\n\n channel.ExchangeDeclare(\"exchangeName\", \"direct\", true);//定义交换器\n String queueName = channel.QueueDeclare(\"TestQueue\", true, false, false, null).QueueName;//定义  队列 队列名TestQueue,持久化的,非排它的,非自动删除的。\n channel.QueueBind(queueName, \"exchangeName\", \"routingKey\");//队列绑定交换器\n\n var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n channel.BasicPublish(\"exchangeName\", \"routingKey\", true, null, message);//发布一个可以路由到队列的消息，mandatory参数设置为true\n var message1 = Encoding.UTF8.GetBytes(\"TestMsg1\");\n channel.BasicPublish(\"exchangeName\", \"routingKey1\", true, null, message);//发布一个不可以路由到队列的消息，mandatory参数设置为true\n\n //生产者回调函数\n channel.BasicReturn += (model, ea) =>\n {\n      //do something... 消息若不能路由到队列则会调用此回调函数。\n };\n\n //关闭信道与连接\n channel.close();\n conn.close() ;\n```\n\n### 二 备份交换器\n\n&nbsp;&nbsp;&nbsp;&nbsp;当消息不能路由到队列时，通过mandatory设置参数,我们可以将消息返回给生产者处理。但这样会有一个问题，就是生产者需要开一个回调的函数来处理不能路由到的消息，这无疑会增加生产者的处理逻辑。备份交换器(Altemate Exchange)则提供了另一种方式来处理不能路由的消息。备份交换器可以将未被路由的消息存储在RabbitMQ中，在需要的时候去处理这些消息。其主要实现代码如下:\n\n```c#\n  IDictionary<string, object> args = new Dictionary<string, object>();\n  args.Add(\"alternate-exchange\", \"altExchange\");\n  channel.ExchangeDeclare(\"normalExchange\", \"direct\", true, false, args);//定义普通交换器并添加备份交换器参数\n  channel.ExchangeDeclare(\"altExchange\", \"fanout\", true, false, null);   //定义备份交换器，并声明为扇形交换器        \n            \n  channel.QueueDeclare(\"normalQueue\", true, false, false, null);//定义普通队列\n  channel.QueueBind(\"normalQueue\", \"normalExchange\", \"NormalRoutingKey1\");//普通队列队列绑定普通交换器\n\n  channel.QueueDeclare(\"altQueue\", true, false, false, null);//定义备份队列\n  channel.QueueBind(\"altQueue\", \"altExchange\", \"\");//绑定备份队列与交换器\n\n  var msg1 = Encoding.UTF8.GetBytes(\"TestMsg\");\n  channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey1\", false, null, msg1);//发布一个可以路由到队列的消息，消息最终会路由到normalQueue\n\n  var msg2 = Encoding.UTF8.GetBytes(\"TestMsg1\");\n  channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey2\", false, null, msg2);//发布一个不可以被路由的消息，消息最终会进入altQueue\n```\n\n![备份交换器](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/91801281.jpg)\n\n备份交换器其实和普通的交换器没有太大的区别，为了方便使用，建议设置为fanout类型，若设置为direct 或者topic的类型。需要注意的是，消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。考虑这样一种情况，如果备份交换器的类型是direct,并且有一个与其绑定的队列，假设绑定的路由键是key1，当某条携带路由键为key2 的消息被转发到这个备份交换器的时候，备份交换器没有匹配到合适的队列，则消息丢失。如果消息携带的路由键为keyl，则可以存储到队列中。\n对于备份交换器，有以下几种特殊情况:\n\n* 如果设置的备份交换器不存在，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。\n* 如果备份交换器没有绑定任何队列，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。\n* 如果备份交换器没有任何匹配的队列，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。\n* 如果备份交换器和mandatory参数一起使用，那么mandatory参数无效。\n\n### 三 过期时间(TTL)\n\n#### 3.1 设置消息的TTL\n\n&nbsp;&nbsp;&nbsp;&nbsp;目前有两种方法可以设置消息的TTL。第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。第二种方法是对消息本身进行单独设置，每条消息的TTL可以不同。如果两种方法一起使用，则消息的TTL 以两者之间较小的那个数值为准。消息在队列中的生存时间一旦超过设置的TTL值时，就会变成\"死信\" (Dead Message) ，消费者将无法再收到该消息。(有关死信队列请往下看)\n\n&nbsp;&nbsp;&nbsp;&nbsp;通过队列属性设置消息TTL的方法是在channel.QueueDeclare方法中加入x-message-ttl参数实现的，这个参数的单位是毫秒。示例代码下:\n\n```c#\nIDictionary<string, object> args = new Dictionary<string, object>();\nargs.Add(\"x-message-ttl\", 6000);\nchannel.QueueDeclare(\"ttlQueue\", true, false, false, args);\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;如果不设置TTL.则表示此消息不会过期;如果将TTL设置为0 ，则表示除非此时可以直接将消息投递到消费者，否则该消息会被立即丢弃(或由死信队列来处理)。\n\n&nbsp;&nbsp;&nbsp;&nbsp;针对每条消息设置TTL的方法是在channel.BasicPublish方法中加入Expiration的属性参数，单位为毫秒。关键代码如下：\n\n```c#\n BasicProperties properties = new BasicProperties()\n            {\n                Expiration = \"20000\",//设置TTL为20000毫秒\n            };\n var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey\", true, properties, message);\n```\n\n**注意:对于第一种设置队列TTL属性的方法，一旦消息过期，就会从队列中抹去，而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息是否过期是在即将投递到消费者之前判定的。Why?在第一种方法里，队列中己过期的消息肯定在队列头部， RabbitMQ 只要定期从队头开始扫描是否有过期的消息即可。而第二种方法里，每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期，如果过期再进行删除即可。**\n\n#### 3.2 设置队列的TTL\n\n&nbsp;&nbsp;&nbsp;&nbsp;注意，这里和上述通过队列设置消息的TTL不同。上面删除的是消息，而这里删除的是队列。通过channel.QueueDeclare 方法中的x-expires参数可以控制队列被自动删除前处于未使用状态的时间。这个未使用的意思是队列上没有任何的消费者，队列也没有被重新声明，并且在过期时间段内也未调用过channel.BasicGet命令。\n\n&nbsp;&nbsp;&nbsp;&nbsp;设置队列里的TTL可以应用于类似RPC方式的回复队列，在RPC中，许多队列会被创建出来，但是却是未被使用的(有关RabbitMQ实现RPC请往下看)。RabbitMQ会确保在过期时间到达后将队列删除，但是不保障删除的动作有多及时。在RabbitMQ 重启后， 持久化的队列的过期时间会被重新计算。用于表示过期时间的x-expires参数以毫秒为单位， 井且服从和x-message-ttl一样的约束条件，不同的是它不能设置为0(会报错)。\n示例代码如下：\n\n```c#\n IDictionary<string, object> args = new Dictionary<string, object>();\n args.Add(\"x-expires\", 6000);\n channel.QueueDeclare(\"ttlQueue\", false, false, false, args);\n```\n\n### 四 死信队列\n\n&nbsp;&nbsp;&nbsp;&nbsp;DLX(Dead-Letter-Exchange)死信交换器，当消息在一个队列中变成死信之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX ，绑定DLX的队列就称之为死信队列。\n消息变成死信主要有以下几种情况:\n\n* 消息被拒绝(BasicReject/BasicNack) ，井且设置requeue 参数为false;(消费者确认机制将会在下一篇文章中涉及)\n* 消息过期;\n* 队列达到最大长度。\n\n&nbsp;&nbsp;&nbsp;&nbsp;DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时，RabbitMQ 就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。可以监听这个队列中的消息、以进行相应的处理。\n\n&nbsp;&nbsp;&nbsp;&nbsp;通过在channel.QueueDeclare 方法中设置x-dead-letter-exchange参数来为这个队列添加DLX。其示例代码如下:\n\n```c#\n channel.ExchangeDeclare(\"exchange.dlx\", \"direct\", true);//定义死信交换器\n channel.ExchangeDeclare(\"exchange.normal\", \"direct\", true);//定义普通交换器\n IDictionary<String, Object> args = new Dictionary<String, Object>();\n args.Add(\"x-message-ttl\",10000);//定义消息过期时间为10000毫秒\n args.Add(\"x-dead-letter-exchange\", \"exchange.dlx\");//定义exchange.dlx为死信交换器\n args.Add(\"x-dead-letter-routing-key\", \"routingkey\");//定义死信交换器的绑定key,这里也可以不指定，则默认使用原队列的路由key\n\n channel.QueueDeclare(\"queue.normal\", true, false, false, args);//定义普通队列\n channel.QueueBind(\"queue.normal\", \"exchange.normal\", \"normalKey\");//普通队列交换器绑定\n\n channel.QueueDeclare(\"queue.dlx\", true, false, false, null);//定义死信队列\n channel.QueueBind(\"queue.dlx\", \"exchange.dlx\", \"routingkey\");//死信队列交换器绑定,若上方为制定死信队列路由key则这里需要使用原队列的路由key\n //发布消息\n var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n channel.BasicPublish(\"exchange.normal\", \"normalKey\", null, message) ;\n\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;以下为死信队列的运转流程:\n\n![死信队列](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/67534593.jpg)\n\n### 五 延迟队列\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ本身并未提供延迟队列的功能。延迟队列是一个逻辑上的概念，可以通过过期时间+死信队列来模拟它的实现。延迟队列的逻辑架构大致如下:\n\n![延迟队列](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/79679939.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;生产者将消息发送到过期时间为n的队列中，这个队列并未有消费者来消费消息，当过期时间到达时，消息会通过死信交换器被转发到死信队列中。而消费者从死信队列中消费消息。这个时候就达到了生产者发布了消息在讲过了n时间后消费者消费了消息，起到了延迟消费的作用。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟队列在我们的项目中可以应用于很多场景，如：下单后两个消息取消订单，七天自动收货，七天自动好评，密码冻结后24小时解冻，以及在分布式系统中消息补偿机制(1s后补偿,10s后补偿，5m后补偿......)。\n\n![RabbitMQ 延迟队列应用场景](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/88724997.jpg)\n\n### 六 优先级队列\n\n&nbsp;&nbsp;&nbsp;&nbsp;就像我们生活中的“特殊”人士一样，我们的业务上也存在一些“特殊”消息，可能需要优先进行处理，在生活上我们可能会对这部分特殊人士开辟一套VIP通道，而Rabbit同样也有这样的VIP通道(前提是在3.5的版本以后)，即优先级队列，队列中的消息会有优先级优先级高的消息具备优先被消费的特权。针对这些VIP消息，我们只需做两件事:\n\n我们只需做两件事情：\n\n1. 将队列声明为优先级队列，即在创建队列的时候添加参数 **x-max-priority** 以指定最大的优先级，值为0-255（整数）。\n2. 为优先级消息添加优先级。\n\n其示例代码如下:\n\n```c#\nchannel.ExchangeDeclare(\"exchange.priority\", \"direct\", true);//定义交换器\nIDictionary<String, Object> args = new Dictionary<String, Object>();\nargs.Add(\"x-max-priority\", 10);//定义优先级队列的最大优先级为10\nchannel.QueueDeclare(\"queue.priority\", true, false, false, args);//定义优先级队列\nchannel.QueueBind(\"queue.priority\", \"exchange.priority\", \"priorityKey\");//队列交换器绑定\nBasicProperties properties = new BasicProperties()\n{\n    Priority =8,//设置消息优先级为8\n};\nvar message = Encoding.UTF8.GetBytes(\"TestMsg8\");\n//发布消息\nchannel.BasicPublish(\"exchange.priority\", \"priorityKey\", properties, message);\n```\n\n**注意：没有指定优先级的消息会将优先级以0对待。 对于超过优先级队列所定最大优先级的消息，优先级以最大优先级对待。对于相同优先级的消息，后进的排在前面。如果在消费者的消费速度大于生产者的速度且Broker 中没有消息堆积的情况下， 对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。**\n\n&nbsp;&nbsp;&nbsp;&nbsp;关于优先级队列，好像违背了队列这种数据结构先进先出的原则，其具体是怎么实现的在这里就不过多讨论。有兴趣的可以自己研究研究。后续可能也会有相关的文章来分析其原理。\n\n### 七 RPC 实现\n\n&nbsp;&nbsp;&nbsp;&nbsp;RPC,是Remote Procedure Call 的简称，即远程过程调用。它是一种通过网络从远程计算机上请求服务，而不需要了解底层网络的技术。RPC 的主要功用是让构建分布式计算更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。\n\n&nbsp;&nbsp;&nbsp;&nbsp;有关RPC不多介绍，这里我们主要介绍RabbitMQ如何实现RPC。RabbitMQ 可以实现很简单的RPC。客户端发送请求消息，服务端回复响应的消息，为了接收响应的消息，我们需要在请求消息中发送一个回调队列(可以使用默认的队列)。其服务器端实现代码如下:\n\n```c#\n      static void Main(string[] args)\n        {\n            ConnectionFactory factory = new ConnectionFactory();\n            factory.UserName = \"admin\";\n            factory.Password = \"admin\";\n            factory.HostName = \"192.168.121.205\";\n            IConnection conn = factory.CreateConnection();\n            IModel channel = conn.CreateModel();\n            channel.QueueDeclare(\"RpcQueue\", true, false, false, null);\n            SimpleRpcServer rpc = new MySimpRpcServer(new Subscription(channel, \"RpcQueue\"));\n            rpc.MainLoop();\n        }\n```\n\n```c#\n  public class MySimpRpcServer: SimpleRpcServer\n    {\n        public MySimpRpcServer(Subscription subscription) : base(subscription)\n        {\n        }\n\n        /// <summary>\n        /// 执行完成后进行回调\n        /// </summary>   \n        public override byte[] HandleSimpleCall(bool isRedelivered, IBasicProperties requestProperties, byte[] body, out IBasicProperties replyProperties)\n        {\n            replyProperties = null;\n            return Encoding.UTF8.GetBytes(\"我收到了!\");\n        }\n        \n        /// <summary>\n        /// 进行处理\n        /// </summary>\n        /// <param name=\"evt\"></param>\n        public override void ProcessRequest(BasicDeliverEventArgs evt)\n        {\n            // todo.....\n            base.ProcessRequest(evt);\n        }\n    }\n```\n\n客户端实现代码如下:\n\n```c#\n  ConnectionFactory factory = new ConnectionFactory();\n  factory.UserName = \"admin\";\n  factory.Password = \"admin\";\n  factory.HostName = \"192.168.121.205\";\n  IConnection conn = factory.CreateConnection();\n  IModel channel = conn.CreateModel();\n   \n  SimpleRpcClient client = new SimpleRpcClient(channel, \"RpcQueue\");\n  var message = Encoding.UTF8.GetBytes(\"TestMsg8\");\n  var result = client.Call(message);\n  //do somethings...\n```\n\n以上是Rabbit客户端自己帮我们封装好的Rpc客户端与服务端的逻辑。当然我们也可以自己实现，主要是借助于BasicProperties的两个参数。\n\n* ReplyTo: 通常用来设置一个回调队列。\n* CorrelationId : 用来关联请求(request) 和其调用RPC 之后的回复(response) 。\n\n其处理流程如下:\n\n![RabbitMQ Rpc](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-21/77785239.jpg)\n\n1. 当客户端启动时，创建一个匿名的回调队列。\n2. 客户端为RPC 请求设置2个属性: ReplyTo用来告知RPC 服务端回复请求时的目的队列，即回调队列; Correlationld 用来标记一个请求。\n3. 请求被发送到RpcQueue队列中。\n4. RPC 服务端监听RpcQueue队列中的请求，当请求到来时，服务端会处理并且把带有结果的消息发送给客户端。接收的队列就是ReplyTo设定的回调队列。\n5. 客户端监昕回调队列，当有消息时，检查Correlationld 属性，如果与请求匹配，那就是结果了。\n\n### 结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;本篇文章简单介绍了RabbitMQ在我们项目开发中常用的几种特性。这些特性可以帮助我们更好的将Rabbit用于我们不同的业务场景中。这些特性与示例，可以自己在程序中运行一下，然后通过查看Rabbit提供的web管理界面来验证其正确性(关于web管理界面不多介绍，相信大家稍微研究研究就能明白)。当然，关于Rabbit的使用，仍有许多地方在本文中没有提及，如：RabbitMQ的特色——确认机制、持久化......将在下一篇文章中再详细介绍。\n\n","slug":"技术实践/rabbitmq/RabbitMQ的使用进阶篇","published":1,"updated":"2021-03-14T03:04:50.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfq0a00g5hyjf3akbp14x","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章简单总结了分布式系统中的消息中间件以及RabbitMQ的基本使用，这篇文章主要总结一下RabbitMQ在日常项目开发中比较常用的几个特性。<br><a id=\"more\"></a></p>\n<h3 id=\"一-mandatory-参数\"><a href=\"#一-mandatory-参数\" class=\"headerlink\" title=\"一 mandatory 参数\"></a>一 mandatory 参数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章中我们知道，生产者将消息发送到RabbitMQ的交换器中通过RoutingKey与BindingKey的匹配将之路由到具体的队列中以供消费者消费。那么当我们通过匹配规则找不到队列的时候，消息将何去何从呢?Rabbit给我们提供了两种方式。mandatory与备份交换器。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;mandatory参数是channel.BasicPublish方法中的参数。其主要功能是消息传递过程中不可达目的地时将消息返回给生产者。当mandatory 参数设为true 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ 会调用BasicReturn 命令将消息返回给生产者。当mandatory 参数设置为false 时。则消息直接被丢弃。其运转流程与实现代码如下(以C# RabbitMQ.Client 3.6.9为例):</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/24859650.jpg\" alt=\"mandatory 参数\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//连接与创建信道--后续的示例代码我们会省略掉这部分代码和释放连接</span><br><span class=\"line\">ConnectionFactory factory = new ConnectionFactory();</span><br><span class=\"line\">            factory.UserName = &quot;admin&quot;;</span><br><span class=\"line\">            factory.Password = &quot;admin&quot;;</span><br><span class=\"line\">            factory.HostName = &quot;192.168.121.205&quot;;</span><br><span class=\"line\">            IConnection conn = factory.CreateConnection();//连接Rabbit</span><br><span class=\"line\"> IModel channel = conn.CreateModel();//创建信道</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> channel.ExchangeDeclare(&quot;exchangeName&quot;, &quot;direct&quot;, true);//定义交换器</span><br><span class=\"line\"> String queueName = channel.QueueDeclare(&quot;TestQueue&quot;, true, false, false, null).QueueName;//定义  队列 队列名TestQueue,持久化的,非排它的,非自动删除的。</span><br><span class=\"line\"> channel.QueueBind(queueName, &quot;exchangeName&quot;, &quot;routingKey&quot;);//队列绑定交换器</span><br><span class=\"line\"></span><br><span class=\"line\"> var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\"> channel.BasicPublish(&quot;exchangeName&quot;, &quot;routingKey&quot;, true, null, message);//发布一个可以路由到队列的消息，mandatory参数设置为true</span><br><span class=\"line\"> var message1 = Encoding.UTF8.GetBytes(&quot;TestMsg1&quot;);</span><br><span class=\"line\"> channel.BasicPublish(&quot;exchangeName&quot;, &quot;routingKey1&quot;, true, null, message);//发布一个不可以路由到队列的消息，mandatory参数设置为true</span><br><span class=\"line\"></span><br><span class=\"line\"> //生产者回调函数</span><br><span class=\"line\"> channel.BasicReturn += (model, ea) =&gt;</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      //do something... 消息若不能路由到队列则会调用此回调函数。</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> //关闭信道与连接</span><br><span class=\"line\"> channel.close();</span><br><span class=\"line\"> conn.close() ;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-备份交换器\"><a href=\"#二-备份交换器\" class=\"headerlink\" title=\"二 备份交换器\"></a>二 备份交换器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当消息不能路由到队列时，通过mandatory设置参数,我们可以将消息返回给生产者处理。但这样会有一个问题，就是生产者需要开一个回调的函数来处理不能路由到的消息，这无疑会增加生产者的处理逻辑。备份交换器(Altemate Exchange)则提供了另一种方式来处理不能路由的消息。备份交换器可以将未被路由的消息存储在RabbitMQ中，在需要的时候去处理这些消息。其主要实现代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IDictionary&lt;string, object&gt; args = new Dictionary&lt;string, object&gt;();</span><br><span class=\"line\">args.Add(&quot;alternate-exchange&quot;, &quot;altExchange&quot;);</span><br><span class=\"line\">channel.ExchangeDeclare(&quot;normalExchange&quot;, &quot;direct&quot;, true, false, args);//定义普通交换器并添加备份交换器参数</span><br><span class=\"line\">channel.ExchangeDeclare(&quot;altExchange&quot;, &quot;fanout&quot;, true, false, null);   //定义备份交换器，并声明为扇形交换器        </span><br><span class=\"line\">          </span><br><span class=\"line\">channel.QueueDeclare(&quot;normalQueue&quot;, true, false, false, null);//定义普通队列</span><br><span class=\"line\">channel.QueueBind(&quot;normalQueue&quot;, &quot;normalExchange&quot;, &quot;NormalRoutingKey1&quot;);//普通队列队列绑定普通交换器</span><br><span class=\"line\"></span><br><span class=\"line\">channel.QueueDeclare(&quot;altQueue&quot;, true, false, false, null);//定义备份队列</span><br><span class=\"line\">channel.QueueBind(&quot;altQueue&quot;, &quot;altExchange&quot;, &quot;&quot;);//绑定备份队列与交换器</span><br><span class=\"line\"></span><br><span class=\"line\">var msg1 = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey1&quot;, false, null, msg1);//发布一个可以路由到队列的消息，消息最终会路由到normalQueue</span><br><span class=\"line\"></span><br><span class=\"line\">var msg2 = Encoding.UTF8.GetBytes(&quot;TestMsg1&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey2&quot;, false, null, msg2);//发布一个不可以被路由的消息，消息最终会进入altQueue</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/91801281.jpg\" alt=\"备份交换器\"></p>\n<p>备份交换器其实和普通的交换器没有太大的区别，为了方便使用，建议设置为fanout类型，若设置为direct 或者topic的类型。需要注意的是，消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。考虑这样一种情况，如果备份交换器的类型是direct,并且有一个与其绑定的队列，假设绑定的路由键是key1，当某条携带路由键为key2 的消息被转发到这个备份交换器的时候，备份交换器没有匹配到合适的队列，则消息丢失。如果消息携带的路由键为keyl，则可以存储到队列中。<br>对于备份交换器，有以下几种特殊情况:</p>\n<ul>\n<li>如果设置的备份交换器不存在，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>\n<li>如果备份交换器没有绑定任何队列，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>\n<li>如果备份交换器没有任何匹配的队列，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>\n<li>如果备份交换器和mandatory参数一起使用，那么mandatory参数无效。</li>\n</ul>\n<h3 id=\"三-过期时间-TTL\"><a href=\"#三-过期时间-TTL\" class=\"headerlink\" title=\"三 过期时间(TTL)\"></a>三 过期时间(TTL)</h3><h4 id=\"3-1-设置消息的TTL\"><a href=\"#3-1-设置消息的TTL\" class=\"headerlink\" title=\"3.1 设置消息的TTL\"></a>3.1 设置消息的TTL</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;目前有两种方法可以设置消息的TTL。第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。第二种方法是对消息本身进行单独设置，每条消息的TTL可以不同。如果两种方法一起使用，则消息的TTL 以两者之间较小的那个数值为准。消息在队列中的生存时间一旦超过设置的TTL值时，就会变成”死信” (Dead Message) ，消费者将无法再收到该消息。(有关死信队列请往下看)</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;通过队列属性设置消息TTL的方法是在channel.QueueDeclare方法中加入x-message-ttl参数实现的，这个参数的单位是毫秒。示例代码下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IDictionary&lt;string, object&gt; args = new Dictionary&lt;string, object&gt;();</span><br><span class=\"line\">args.Add(&quot;x-message-ttl&quot;, 6000);</span><br><span class=\"line\">channel.QueueDeclare(&quot;ttlQueue&quot;, true, false, false, args);</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如果不设置TTL.则表示此消息不会过期;如果将TTL设置为0 ，则表示除非此时可以直接将消息投递到消费者，否则该消息会被立即丢弃(或由死信队列来处理)。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;针对每条消息设置TTL的方法是在channel.BasicPublish方法中加入Expiration的属性参数，单位为毫秒。关键代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BasicProperties properties = new BasicProperties()</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               Expiration = &quot;20000&quot;,//设置TTL为20000毫秒</span><br><span class=\"line\">           &#125;;</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;, true, properties, message);</span><br></pre></td></tr></table></figure>\n<p><strong>注意:对于第一种设置队列TTL属性的方法，一旦消息过期，就会从队列中抹去，而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息是否过期是在即将投递到消费者之前判定的。Why?在第一种方法里，队列中己过期的消息肯定在队列头部， RabbitMQ 只要定期从队头开始扫描是否有过期的消息即可。而第二种方法里，每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期，如果过期再进行删除即可。</strong></p>\n<h4 id=\"3-2-设置队列的TTL\"><a href=\"#3-2-设置队列的TTL\" class=\"headerlink\" title=\"3.2 设置队列的TTL\"></a>3.2 设置队列的TTL</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;注意，这里和上述通过队列设置消息的TTL不同。上面删除的是消息，而这里删除的是队列。通过channel.QueueDeclare 方法中的x-expires参数可以控制队列被自动删除前处于未使用状态的时间。这个未使用的意思是队列上没有任何的消费者，队列也没有被重新声明，并且在过期时间段内也未调用过channel.BasicGet命令。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;设置队列里的TTL可以应用于类似RPC方式的回复队列，在RPC中，许多队列会被创建出来，但是却是未被使用的(有关RabbitMQ实现RPC请往下看)。RabbitMQ会确保在过期时间到达后将队列删除，但是不保障删除的动作有多及时。在RabbitMQ 重启后， 持久化的队列的过期时间会被重新计算。用于表示过期时间的x-expires参数以毫秒为单位， 井且服从和x-message-ttl一样的约束条件，不同的是它不能设置为0(会报错)。<br>示例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IDictionary&lt;string, object&gt; args = new Dictionary&lt;string, object&gt;();</span><br><span class=\"line\">args.Add(&quot;x-expires&quot;, 6000);</span><br><span class=\"line\">channel.QueueDeclare(&quot;ttlQueue&quot;, false, false, false, args);</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-死信队列\"><a href=\"#四-死信队列\" class=\"headerlink\" title=\"四 死信队列\"></a>四 死信队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;DLX(Dead-Letter-Exchange)死信交换器，当消息在一个队列中变成死信之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX ，绑定DLX的队列就称之为死信队列。<br>消息变成死信主要有以下几种情况:</p>\n<ul>\n<li>消息被拒绝(BasicReject/BasicNack) ，井且设置requeue 参数为false;(消费者确认机制将会在下一篇文章中涉及)</li>\n<li>消息过期;</li>\n<li>队列达到最大长度。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时，RabbitMQ 就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。可以监听这个队列中的消息、以进行相应的处理。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;通过在channel.QueueDeclare 方法中设置x-dead-letter-exchange参数来为这个队列添加DLX。其示例代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.ExchangeDeclare(&quot;exchange.dlx&quot;, &quot;direct&quot;, true);//定义死信交换器</span><br><span class=\"line\">channel.ExchangeDeclare(&quot;exchange.normal&quot;, &quot;direct&quot;, true);//定义普通交换器</span><br><span class=\"line\">IDictionary&lt;String, Object&gt; args = new Dictionary&lt;String, Object&gt;();</span><br><span class=\"line\">args.Add(&quot;x-message-ttl&quot;,10000);//定义消息过期时间为10000毫秒</span><br><span class=\"line\">args.Add(&quot;x-dead-letter-exchange&quot;, &quot;exchange.dlx&quot;);//定义exchange.dlx为死信交换器</span><br><span class=\"line\">args.Add(&quot;x-dead-letter-routing-key&quot;, &quot;routingkey&quot;);//定义死信交换器的绑定key,这里也可以不指定，则默认使用原队列的路由key</span><br><span class=\"line\"></span><br><span class=\"line\">channel.QueueDeclare(&quot;queue.normal&quot;, true, false, false, args);//定义普通队列</span><br><span class=\"line\">channel.QueueBind(&quot;queue.normal&quot;, &quot;exchange.normal&quot;, &quot;normalKey&quot;);//普通队列交换器绑定</span><br><span class=\"line\"></span><br><span class=\"line\">channel.QueueDeclare(&quot;queue.dlx&quot;, true, false, false, null);//定义死信队列</span><br><span class=\"line\">channel.QueueBind(&quot;queue.dlx&quot;, &quot;exchange.dlx&quot;, &quot;routingkey&quot;);//死信队列交换器绑定,若上方为制定死信队列路由key则这里需要使用原队列的路由key</span><br><span class=\"line\">//发布消息</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;exchange.normal&quot;, &quot;normalKey&quot;, null, message) ;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;以下为死信队列的运转流程:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/67534593.jpg\" alt=\"死信队列\"></p>\n<h3 id=\"五-延迟队列\"><a href=\"#五-延迟队列\" class=\"headerlink\" title=\"五 延迟队列\"></a>五 延迟队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ本身并未提供延迟队列的功能。延迟队列是一个逻辑上的概念，可以通过过期时间+死信队列来模拟它的实现。延迟队列的逻辑架构大致如下:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/79679939.jpg\" alt=\"延迟队列\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;生产者将消息发送到过期时间为n的队列中，这个队列并未有消费者来消费消息，当过期时间到达时，消息会通过死信交换器被转发到死信队列中。而消费者从死信队列中消费消息。这个时候就达到了生产者发布了消息在讲过了n时间后消费者消费了消息，起到了延迟消费的作用。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟队列在我们的项目中可以应用于很多场景，如：下单后两个消息取消订单，七天自动收货，七天自动好评，密码冻结后24小时解冻，以及在分布式系统中消息补偿机制(1s后补偿,10s后补偿，5m后补偿……)。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/88724997.jpg\" alt=\"RabbitMQ 延迟队列应用场景\"></p>\n<h3 id=\"六-优先级队列\"><a href=\"#六-优先级队列\" class=\"headerlink\" title=\"六 优先级队列\"></a>六 优先级队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;就像我们生活中的“特殊”人士一样，我们的业务上也存在一些“特殊”消息，可能需要优先进行处理，在生活上我们可能会对这部分特殊人士开辟一套VIP通道，而Rabbit同样也有这样的VIP通道(前提是在3.5的版本以后)，即优先级队列，队列中的消息会有优先级优先级高的消息具备优先被消费的特权。针对这些VIP消息，我们只需做两件事:</p>\n<p>我们只需做两件事情：</p>\n<ol>\n<li>将队列声明为优先级队列，即在创建队列的时候添加参数 <strong>x-max-priority</strong> 以指定最大的优先级，值为0-255（整数）。</li>\n<li>为优先级消息添加优先级。</li>\n</ol>\n<p>其示例代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.ExchangeDeclare(&quot;exchange.priority&quot;, &quot;direct&quot;, true);//定义交换器</span><br><span class=\"line\">IDictionary&lt;String, Object&gt; args = new Dictionary&lt;String, Object&gt;();</span><br><span class=\"line\">args.Add(&quot;x-max-priority&quot;, 10);//定义优先级队列的最大优先级为10</span><br><span class=\"line\">channel.QueueDeclare(&quot;queue.priority&quot;, true, false, false, args);//定义优先级队列</span><br><span class=\"line\">channel.QueueBind(&quot;queue.priority&quot;, &quot;exchange.priority&quot;, &quot;priorityKey&quot;);//队列交换器绑定</span><br><span class=\"line\">BasicProperties properties = new BasicProperties()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Priority =8,//设置消息优先级为8</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg8&quot;);</span><br><span class=\"line\">//发布消息</span><br><span class=\"line\">channel.BasicPublish(&quot;exchange.priority&quot;, &quot;priorityKey&quot;, properties, message);</span><br></pre></td></tr></table></figure>\n<p><strong>注意：没有指定优先级的消息会将优先级以0对待。 对于超过优先级队列所定最大优先级的消息，优先级以最大优先级对待。对于相同优先级的消息，后进的排在前面。如果在消费者的消费速度大于生产者的速度且Broker 中没有消息堆积的情况下， 对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;关于优先级队列，好像违背了队列这种数据结构先进先出的原则，其具体是怎么实现的在这里就不过多讨论。有兴趣的可以自己研究研究。后续可能也会有相关的文章来分析其原理。</p>\n<h3 id=\"七-RPC-实现\"><a href=\"#七-RPC-实现\" class=\"headerlink\" title=\"七 RPC 实现\"></a>七 RPC 实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;RPC,是Remote Procedure Call 的简称，即远程过程调用。它是一种通过网络从远程计算机上请求服务，而不需要了解底层网络的技术。RPC 的主要功用是让构建分布式计算更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;有关RPC不多介绍，这里我们主要介绍RabbitMQ如何实现RPC。RabbitMQ 可以实现很简单的RPC。客户端发送请求消息，服务端回复响应的消息，为了接收响应的消息，我们需要在请求消息中发送一个回调队列(可以使用默认的队列)。其服务器端实现代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void Main(string[] args)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      ConnectionFactory factory = new ConnectionFactory();</span><br><span class=\"line\">      factory.UserName = &quot;admin&quot;;</span><br><span class=\"line\">      factory.Password = &quot;admin&quot;;</span><br><span class=\"line\">      factory.HostName = &quot;192.168.121.205&quot;;</span><br><span class=\"line\">      IConnection conn = factory.CreateConnection();</span><br><span class=\"line\">      IModel channel = conn.CreateModel();</span><br><span class=\"line\">      channel.QueueDeclare(&quot;RpcQueue&quot;, true, false, false, null);</span><br><span class=\"line\">      SimpleRpcServer rpc = new MySimpRpcServer(new Subscription(channel, &quot;RpcQueue&quot;));</span><br><span class=\"line\">      rpc.MainLoop();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MySimpRpcServer: SimpleRpcServer</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      public MySimpRpcServer(Subscription subscription) : base(subscription)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      /// &lt;summary&gt;</span><br><span class=\"line\">      /// 执行完成后进行回调</span><br><span class=\"line\">      /// &lt;/summary&gt;   </span><br><span class=\"line\">      public override byte[] HandleSimpleCall(bool isRedelivered, IBasicProperties requestProperties, byte[] body, out IBasicProperties replyProperties)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          replyProperties = null;</span><br><span class=\"line\">          return Encoding.UTF8.GetBytes(&quot;我收到了!&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      /// &lt;summary&gt;</span><br><span class=\"line\">      /// 进行处理</span><br><span class=\"line\">      /// &lt;/summary&gt;</span><br><span class=\"line\">      /// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;</span><br><span class=\"line\">      public override void ProcessRequest(BasicDeliverEventArgs evt)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          // todo.....</span><br><span class=\"line\">          base.ProcessRequest(evt);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>客户端实现代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConnectionFactory factory = new ConnectionFactory();</span><br><span class=\"line\">factory.UserName = &quot;admin&quot;;</span><br><span class=\"line\">factory.Password = &quot;admin&quot;;</span><br><span class=\"line\">factory.HostName = &quot;192.168.121.205&quot;;</span><br><span class=\"line\">IConnection conn = factory.CreateConnection();</span><br><span class=\"line\">IModel channel = conn.CreateModel();</span><br><span class=\"line\"> </span><br><span class=\"line\">SimpleRpcClient client = new SimpleRpcClient(channel, &quot;RpcQueue&quot;);</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg8&quot;);</span><br><span class=\"line\">var result = client.Call(message);</span><br><span class=\"line\">//do somethings...</span><br></pre></td></tr></table></figure>\n<p>以上是Rabbit客户端自己帮我们封装好的Rpc客户端与服务端的逻辑。当然我们也可以自己实现，主要是借助于BasicProperties的两个参数。</p>\n<ul>\n<li>ReplyTo: 通常用来设置一个回调队列。</li>\n<li>CorrelationId : 用来关联请求(request) 和其调用RPC 之后的回复(response) 。</li>\n</ul>\n<p>其处理流程如下:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-21/77785239.jpg\" alt=\"RabbitMQ Rpc\"></p>\n<ol>\n<li>当客户端启动时，创建一个匿名的回调队列。</li>\n<li>客户端为RPC 请求设置2个属性: ReplyTo用来告知RPC 服务端回复请求时的目的队列，即回调队列; Correlationld 用来标记一个请求。</li>\n<li>请求被发送到RpcQueue队列中。</li>\n<li>RPC 服务端监听RpcQueue队列中的请求，当请求到来时，服务端会处理并且把带有结果的消息发送给客户端。接收的队列就是ReplyTo设定的回调队列。</li>\n<li>客户端监昕回调队列，当有消息时，检查Correlationld 属性，如果与请求匹配，那就是结果了。</li>\n</ol>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本篇文章简单介绍了RabbitMQ在我们项目开发中常用的几种特性。这些特性可以帮助我们更好的将Rabbit用于我们不同的业务场景中。这些特性与示例，可以自己在程序中运行一下，然后通过查看Rabbit提供的web管理界面来验证其正确性(关于web管理界面不多介绍，相信大家稍微研究研究就能明白)。当然，关于Rabbit的使用，仍有许多地方在本文中没有提及，如：RabbitMQ的特色——确认机制、持久化……将在下一篇文章中再详细介绍。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章简单总结了分布式系统中的消息中间件以及RabbitMQ的基本使用，这篇文章主要总结一下RabbitMQ在日常项目开发中比较常用的几个特性。<br>","more":"</p>\n<h3 id=\"一-mandatory-参数\"><a href=\"#一-mandatory-参数\" class=\"headerlink\" title=\"一 mandatory 参数\"></a>一 mandatory 参数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上一篇文章中我们知道，生产者将消息发送到RabbitMQ的交换器中通过RoutingKey与BindingKey的匹配将之路由到具体的队列中以供消费者消费。那么当我们通过匹配规则找不到队列的时候，消息将何去何从呢?Rabbit给我们提供了两种方式。mandatory与备份交换器。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;mandatory参数是channel.BasicPublish方法中的参数。其主要功能是消息传递过程中不可达目的地时将消息返回给生产者。当mandatory 参数设为true 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ 会调用BasicReturn 命令将消息返回给生产者。当mandatory 参数设置为false 时。则消息直接被丢弃。其运转流程与实现代码如下(以C# RabbitMQ.Client 3.6.9为例):</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/24859650.jpg\" alt=\"mandatory 参数\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//连接与创建信道--后续的示例代码我们会省略掉这部分代码和释放连接</span><br><span class=\"line\">ConnectionFactory factory = new ConnectionFactory();</span><br><span class=\"line\">            factory.UserName = &quot;admin&quot;;</span><br><span class=\"line\">            factory.Password = &quot;admin&quot;;</span><br><span class=\"line\">            factory.HostName = &quot;192.168.121.205&quot;;</span><br><span class=\"line\">            IConnection conn = factory.CreateConnection();//连接Rabbit</span><br><span class=\"line\"> IModel channel = conn.CreateModel();//创建信道</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> channel.ExchangeDeclare(&quot;exchangeName&quot;, &quot;direct&quot;, true);//定义交换器</span><br><span class=\"line\"> String queueName = channel.QueueDeclare(&quot;TestQueue&quot;, true, false, false, null).QueueName;//定义  队列 队列名TestQueue,持久化的,非排它的,非自动删除的。</span><br><span class=\"line\"> channel.QueueBind(queueName, &quot;exchangeName&quot;, &quot;routingKey&quot;);//队列绑定交换器</span><br><span class=\"line\"></span><br><span class=\"line\"> var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\"> channel.BasicPublish(&quot;exchangeName&quot;, &quot;routingKey&quot;, true, null, message);//发布一个可以路由到队列的消息，mandatory参数设置为true</span><br><span class=\"line\"> var message1 = Encoding.UTF8.GetBytes(&quot;TestMsg1&quot;);</span><br><span class=\"line\"> channel.BasicPublish(&quot;exchangeName&quot;, &quot;routingKey1&quot;, true, null, message);//发布一个不可以路由到队列的消息，mandatory参数设置为true</span><br><span class=\"line\"></span><br><span class=\"line\"> //生产者回调函数</span><br><span class=\"line\"> channel.BasicReturn += (model, ea) =&gt;</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">      //do something... 消息若不能路由到队列则会调用此回调函数。</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> //关闭信道与连接</span><br><span class=\"line\"> channel.close();</span><br><span class=\"line\"> conn.close() ;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-备份交换器\"><a href=\"#二-备份交换器\" class=\"headerlink\" title=\"二 备份交换器\"></a>二 备份交换器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当消息不能路由到队列时，通过mandatory设置参数,我们可以将消息返回给生产者处理。但这样会有一个问题，就是生产者需要开一个回调的函数来处理不能路由到的消息，这无疑会增加生产者的处理逻辑。备份交换器(Altemate Exchange)则提供了另一种方式来处理不能路由的消息。备份交换器可以将未被路由的消息存储在RabbitMQ中，在需要的时候去处理这些消息。其主要实现代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IDictionary&lt;string, object&gt; args = new Dictionary&lt;string, object&gt;();</span><br><span class=\"line\">args.Add(&quot;alternate-exchange&quot;, &quot;altExchange&quot;);</span><br><span class=\"line\">channel.ExchangeDeclare(&quot;normalExchange&quot;, &quot;direct&quot;, true, false, args);//定义普通交换器并添加备份交换器参数</span><br><span class=\"line\">channel.ExchangeDeclare(&quot;altExchange&quot;, &quot;fanout&quot;, true, false, null);   //定义备份交换器，并声明为扇形交换器        </span><br><span class=\"line\">          </span><br><span class=\"line\">channel.QueueDeclare(&quot;normalQueue&quot;, true, false, false, null);//定义普通队列</span><br><span class=\"line\">channel.QueueBind(&quot;normalQueue&quot;, &quot;normalExchange&quot;, &quot;NormalRoutingKey1&quot;);//普通队列队列绑定普通交换器</span><br><span class=\"line\"></span><br><span class=\"line\">channel.QueueDeclare(&quot;altQueue&quot;, true, false, false, null);//定义备份队列</span><br><span class=\"line\">channel.QueueBind(&quot;altQueue&quot;, &quot;altExchange&quot;, &quot;&quot;);//绑定备份队列与交换器</span><br><span class=\"line\"></span><br><span class=\"line\">var msg1 = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey1&quot;, false, null, msg1);//发布一个可以路由到队列的消息，消息最终会路由到normalQueue</span><br><span class=\"line\"></span><br><span class=\"line\">var msg2 = Encoding.UTF8.GetBytes(&quot;TestMsg1&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey2&quot;, false, null, msg2);//发布一个不可以被路由的消息，消息最终会进入altQueue</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/91801281.jpg\" alt=\"备份交换器\"></p>\n<p>备份交换器其实和普通的交换器没有太大的区别，为了方便使用，建议设置为fanout类型，若设置为direct 或者topic的类型。需要注意的是，消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。考虑这样一种情况，如果备份交换器的类型是direct,并且有一个与其绑定的队列，假设绑定的路由键是key1，当某条携带路由键为key2 的消息被转发到这个备份交换器的时候，备份交换器没有匹配到合适的队列，则消息丢失。如果消息携带的路由键为keyl，则可以存储到队列中。<br>对于备份交换器，有以下几种特殊情况:</p>\n<ul>\n<li>如果设置的备份交换器不存在，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>\n<li>如果备份交换器没有绑定任何队列，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>\n<li>如果备份交换器没有任何匹配的队列，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>\n<li>如果备份交换器和mandatory参数一起使用，那么mandatory参数无效。</li>\n</ul>\n<h3 id=\"三-过期时间-TTL\"><a href=\"#三-过期时间-TTL\" class=\"headerlink\" title=\"三 过期时间(TTL)\"></a>三 过期时间(TTL)</h3><h4 id=\"3-1-设置消息的TTL\"><a href=\"#3-1-设置消息的TTL\" class=\"headerlink\" title=\"3.1 设置消息的TTL\"></a>3.1 设置消息的TTL</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;目前有两种方法可以设置消息的TTL。第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。第二种方法是对消息本身进行单独设置，每条消息的TTL可以不同。如果两种方法一起使用，则消息的TTL 以两者之间较小的那个数值为准。消息在队列中的生存时间一旦超过设置的TTL值时，就会变成”死信” (Dead Message) ，消费者将无法再收到该消息。(有关死信队列请往下看)</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;通过队列属性设置消息TTL的方法是在channel.QueueDeclare方法中加入x-message-ttl参数实现的，这个参数的单位是毫秒。示例代码下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IDictionary&lt;string, object&gt; args = new Dictionary&lt;string, object&gt;();</span><br><span class=\"line\">args.Add(&quot;x-message-ttl&quot;, 6000);</span><br><span class=\"line\">channel.QueueDeclare(&quot;ttlQueue&quot;, true, false, false, args);</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如果不设置TTL.则表示此消息不会过期;如果将TTL设置为0 ，则表示除非此时可以直接将消息投递到消费者，否则该消息会被立即丢弃(或由死信队列来处理)。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;针对每条消息设置TTL的方法是在channel.BasicPublish方法中加入Expiration的属性参数，单位为毫秒。关键代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BasicProperties properties = new BasicProperties()</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               Expiration = &quot;20000&quot;,//设置TTL为20000毫秒</span><br><span class=\"line\">           &#125;;</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;, true, properties, message);</span><br></pre></td></tr></table></figure>\n<p><strong>注意:对于第一种设置队列TTL属性的方法，一旦消息过期，就会从队列中抹去，而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息是否过期是在即将投递到消费者之前判定的。Why?在第一种方法里，队列中己过期的消息肯定在队列头部， RabbitMQ 只要定期从队头开始扫描是否有过期的消息即可。而第二种方法里，每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期，如果过期再进行删除即可。</strong></p>\n<h4 id=\"3-2-设置队列的TTL\"><a href=\"#3-2-设置队列的TTL\" class=\"headerlink\" title=\"3.2 设置队列的TTL\"></a>3.2 设置队列的TTL</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;注意，这里和上述通过队列设置消息的TTL不同。上面删除的是消息，而这里删除的是队列。通过channel.QueueDeclare 方法中的x-expires参数可以控制队列被自动删除前处于未使用状态的时间。这个未使用的意思是队列上没有任何的消费者，队列也没有被重新声明，并且在过期时间段内也未调用过channel.BasicGet命令。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;设置队列里的TTL可以应用于类似RPC方式的回复队列，在RPC中，许多队列会被创建出来，但是却是未被使用的(有关RabbitMQ实现RPC请往下看)。RabbitMQ会确保在过期时间到达后将队列删除，但是不保障删除的动作有多及时。在RabbitMQ 重启后， 持久化的队列的过期时间会被重新计算。用于表示过期时间的x-expires参数以毫秒为单位， 井且服从和x-message-ttl一样的约束条件，不同的是它不能设置为0(会报错)。<br>示例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IDictionary&lt;string, object&gt; args = new Dictionary&lt;string, object&gt;();</span><br><span class=\"line\">args.Add(&quot;x-expires&quot;, 6000);</span><br><span class=\"line\">channel.QueueDeclare(&quot;ttlQueue&quot;, false, false, false, args);</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-死信队列\"><a href=\"#四-死信队列\" class=\"headerlink\" title=\"四 死信队列\"></a>四 死信队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;DLX(Dead-Letter-Exchange)死信交换器，当消息在一个队列中变成死信之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX ，绑定DLX的队列就称之为死信队列。<br>消息变成死信主要有以下几种情况:</p>\n<ul>\n<li>消息被拒绝(BasicReject/BasicNack) ，井且设置requeue 参数为false;(消费者确认机制将会在下一篇文章中涉及)</li>\n<li>消息过期;</li>\n<li>队列达到最大长度。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时，RabbitMQ 就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。可以监听这个队列中的消息、以进行相应的处理。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;通过在channel.QueueDeclare 方法中设置x-dead-letter-exchange参数来为这个队列添加DLX。其示例代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.ExchangeDeclare(&quot;exchange.dlx&quot;, &quot;direct&quot;, true);//定义死信交换器</span><br><span class=\"line\">channel.ExchangeDeclare(&quot;exchange.normal&quot;, &quot;direct&quot;, true);//定义普通交换器</span><br><span class=\"line\">IDictionary&lt;String, Object&gt; args = new Dictionary&lt;String, Object&gt;();</span><br><span class=\"line\">args.Add(&quot;x-message-ttl&quot;,10000);//定义消息过期时间为10000毫秒</span><br><span class=\"line\">args.Add(&quot;x-dead-letter-exchange&quot;, &quot;exchange.dlx&quot;);//定义exchange.dlx为死信交换器</span><br><span class=\"line\">args.Add(&quot;x-dead-letter-routing-key&quot;, &quot;routingkey&quot;);//定义死信交换器的绑定key,这里也可以不指定，则默认使用原队列的路由key</span><br><span class=\"line\"></span><br><span class=\"line\">channel.QueueDeclare(&quot;queue.normal&quot;, true, false, false, args);//定义普通队列</span><br><span class=\"line\">channel.QueueBind(&quot;queue.normal&quot;, &quot;exchange.normal&quot;, &quot;normalKey&quot;);//普通队列交换器绑定</span><br><span class=\"line\"></span><br><span class=\"line\">channel.QueueDeclare(&quot;queue.dlx&quot;, true, false, false, null);//定义死信队列</span><br><span class=\"line\">channel.QueueBind(&quot;queue.dlx&quot;, &quot;exchange.dlx&quot;, &quot;routingkey&quot;);//死信队列交换器绑定,若上方为制定死信队列路由key则这里需要使用原队列的路由key</span><br><span class=\"line\">//发布消息</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;exchange.normal&quot;, &quot;normalKey&quot;, null, message) ;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;以下为死信队列的运转流程:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/67534593.jpg\" alt=\"死信队列\"></p>\n<h3 id=\"五-延迟队列\"><a href=\"#五-延迟队列\" class=\"headerlink\" title=\"五 延迟队列\"></a>五 延迟队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ本身并未提供延迟队列的功能。延迟队列是一个逻辑上的概念，可以通过过期时间+死信队列来模拟它的实现。延迟队列的逻辑架构大致如下:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/79679939.jpg\" alt=\"延迟队列\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;生产者将消息发送到过期时间为n的队列中，这个队列并未有消费者来消费消息，当过期时间到达时，消息会通过死信交换器被转发到死信队列中。而消费者从死信队列中消费消息。这个时候就达到了生产者发布了消息在讲过了n时间后消费者消费了消息，起到了延迟消费的作用。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟队列在我们的项目中可以应用于很多场景，如：下单后两个消息取消订单，七天自动收货，七天自动好评，密码冻结后24小时解冻，以及在分布式系统中消息补偿机制(1s后补偿,10s后补偿，5m后补偿……)。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-20/88724997.jpg\" alt=\"RabbitMQ 延迟队列应用场景\"></p>\n<h3 id=\"六-优先级队列\"><a href=\"#六-优先级队列\" class=\"headerlink\" title=\"六 优先级队列\"></a>六 优先级队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;就像我们生活中的“特殊”人士一样，我们的业务上也存在一些“特殊”消息，可能需要优先进行处理，在生活上我们可能会对这部分特殊人士开辟一套VIP通道，而Rabbit同样也有这样的VIP通道(前提是在3.5的版本以后)，即优先级队列，队列中的消息会有优先级优先级高的消息具备优先被消费的特权。针对这些VIP消息，我们只需做两件事:</p>\n<p>我们只需做两件事情：</p>\n<ol>\n<li>将队列声明为优先级队列，即在创建队列的时候添加参数 <strong>x-max-priority</strong> 以指定最大的优先级，值为0-255（整数）。</li>\n<li>为优先级消息添加优先级。</li>\n</ol>\n<p>其示例代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.ExchangeDeclare(&quot;exchange.priority&quot;, &quot;direct&quot;, true);//定义交换器</span><br><span class=\"line\">IDictionary&lt;String, Object&gt; args = new Dictionary&lt;String, Object&gt;();</span><br><span class=\"line\">args.Add(&quot;x-max-priority&quot;, 10);//定义优先级队列的最大优先级为10</span><br><span class=\"line\">channel.QueueDeclare(&quot;queue.priority&quot;, true, false, false, args);//定义优先级队列</span><br><span class=\"line\">channel.QueueBind(&quot;queue.priority&quot;, &quot;exchange.priority&quot;, &quot;priorityKey&quot;);//队列交换器绑定</span><br><span class=\"line\">BasicProperties properties = new BasicProperties()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Priority =8,//设置消息优先级为8</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg8&quot;);</span><br><span class=\"line\">//发布消息</span><br><span class=\"line\">channel.BasicPublish(&quot;exchange.priority&quot;, &quot;priorityKey&quot;, properties, message);</span><br></pre></td></tr></table></figure>\n<p><strong>注意：没有指定优先级的消息会将优先级以0对待。 对于超过优先级队列所定最大优先级的消息，优先级以最大优先级对待。对于相同优先级的消息，后进的排在前面。如果在消费者的消费速度大于生产者的速度且Broker 中没有消息堆积的情况下， 对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;关于优先级队列，好像违背了队列这种数据结构先进先出的原则，其具体是怎么实现的在这里就不过多讨论。有兴趣的可以自己研究研究。后续可能也会有相关的文章来分析其原理。</p>\n<h3 id=\"七-RPC-实现\"><a href=\"#七-RPC-实现\" class=\"headerlink\" title=\"七 RPC 实现\"></a>七 RPC 实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;RPC,是Remote Procedure Call 的简称，即远程过程调用。它是一种通过网络从远程计算机上请求服务，而不需要了解底层网络的技术。RPC 的主要功用是让构建分布式计算更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;有关RPC不多介绍，这里我们主要介绍RabbitMQ如何实现RPC。RabbitMQ 可以实现很简单的RPC。客户端发送请求消息，服务端回复响应的消息，为了接收响应的消息，我们需要在请求消息中发送一个回调队列(可以使用默认的队列)。其服务器端实现代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void Main(string[] args)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      ConnectionFactory factory = new ConnectionFactory();</span><br><span class=\"line\">      factory.UserName = &quot;admin&quot;;</span><br><span class=\"line\">      factory.Password = &quot;admin&quot;;</span><br><span class=\"line\">      factory.HostName = &quot;192.168.121.205&quot;;</span><br><span class=\"line\">      IConnection conn = factory.CreateConnection();</span><br><span class=\"line\">      IModel channel = conn.CreateModel();</span><br><span class=\"line\">      channel.QueueDeclare(&quot;RpcQueue&quot;, true, false, false, null);</span><br><span class=\"line\">      SimpleRpcServer rpc = new MySimpRpcServer(new Subscription(channel, &quot;RpcQueue&quot;));</span><br><span class=\"line\">      rpc.MainLoop();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MySimpRpcServer: SimpleRpcServer</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      public MySimpRpcServer(Subscription subscription) : base(subscription)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      /// &lt;summary&gt;</span><br><span class=\"line\">      /// 执行完成后进行回调</span><br><span class=\"line\">      /// &lt;/summary&gt;   </span><br><span class=\"line\">      public override byte[] HandleSimpleCall(bool isRedelivered, IBasicProperties requestProperties, byte[] body, out IBasicProperties replyProperties)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          replyProperties = null;</span><br><span class=\"line\">          return Encoding.UTF8.GetBytes(&quot;我收到了!&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      /// &lt;summary&gt;</span><br><span class=\"line\">      /// 进行处理</span><br><span class=\"line\">      /// &lt;/summary&gt;</span><br><span class=\"line\">      /// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;</span><br><span class=\"line\">      public override void ProcessRequest(BasicDeliverEventArgs evt)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          // todo.....</span><br><span class=\"line\">          base.ProcessRequest(evt);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>客户端实现代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConnectionFactory factory = new ConnectionFactory();</span><br><span class=\"line\">factory.UserName = &quot;admin&quot;;</span><br><span class=\"line\">factory.Password = &quot;admin&quot;;</span><br><span class=\"line\">factory.HostName = &quot;192.168.121.205&quot;;</span><br><span class=\"line\">IConnection conn = factory.CreateConnection();</span><br><span class=\"line\">IModel channel = conn.CreateModel();</span><br><span class=\"line\"> </span><br><span class=\"line\">SimpleRpcClient client = new SimpleRpcClient(channel, &quot;RpcQueue&quot;);</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg8&quot;);</span><br><span class=\"line\">var result = client.Call(message);</span><br><span class=\"line\">//do somethings...</span><br></pre></td></tr></table></figure>\n<p>以上是Rabbit客户端自己帮我们封装好的Rpc客户端与服务端的逻辑。当然我们也可以自己实现，主要是借助于BasicProperties的两个参数。</p>\n<ul>\n<li>ReplyTo: 通常用来设置一个回调队列。</li>\n<li>CorrelationId : 用来关联请求(request) 和其调用RPC 之后的回复(response) 。</li>\n</ul>\n<p>其处理流程如下:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-21/77785239.jpg\" alt=\"RabbitMQ Rpc\"></p>\n<ol>\n<li>当客户端启动时，创建一个匿名的回调队列。</li>\n<li>客户端为RPC 请求设置2个属性: ReplyTo用来告知RPC 服务端回复请求时的目的队列，即回调队列; Correlationld 用来标记一个请求。</li>\n<li>请求被发送到RpcQueue队列中。</li>\n<li>RPC 服务端监听RpcQueue队列中的请求，当请求到来时，服务端会处理并且把带有结果的消息发送给客户端。接收的队列就是ReplyTo设定的回调队列。</li>\n<li>客户端监昕回调队列，当有消息时，检查Correlationld 属性，如果与请求匹配，那就是结果了。</li>\n</ol>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本篇文章简单介绍了RabbitMQ在我们项目开发中常用的几种特性。这些特性可以帮助我们更好的将Rabbit用于我们不同的业务场景中。这些特性与示例，可以自己在程序中运行一下，然后通过查看Rabbit提供的web管理界面来验证其正确性(关于web管理界面不多介绍，相信大家稍微研究研究就能明白)。当然，关于Rabbit的使用，仍有许多地方在本文中没有提及，如：RabbitMQ的特色——确认机制、持久化……将在下一篇文章中再详细介绍。</p>"},{"title":"Redis数据结构——字典","copyright":true,"date":"2018-11-20T08:15:39.000Z","keywords":"Redis,数据结构,链表","aside":"redis","_content":"\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;字典在Redis中的应用非常广泛，数据库与哈希对象的底层实现就是字典。\n\n<!--more-->\n\n### 一、复习散列表\n\n#### 1.1 散列表\n\n&nbsp;&nbsp;&nbsp;&nbsp;散列表(哈希表)，其思想主要是基于数组支持按照下标随机访问数据时间复杂度为O(1)的特性。可是说是数组的一种扩展。假设，我们为了方便记录某高校数学专业的所有学生的信息。要求可以按照学号(学号格式为:入学时间+年级+专业+专业内自增序号，如2011 1101 0001)能够快速找到某个学生的信息。这个时候我们可以取学号的自增序号部分，即后四位作为数组的索引下标，把学生相应的信息存储到对应的空间内即可。\n\n\n\n![散列思想](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/16747511.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上图所示,我们把学号作为key,通过截取学号后四位的函数后计算后得到索引下标，将数据存储到数组中。当我们按照键值(学号)查找时，只需要再次计算出索引下标，然后取出相应数据即可。以上便是散列思想。\n\n#### 1.2 散列函数\n\n&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中，截取学号后四位的函数即是一个简单的散列函数。\n\n```c#\n//散列函数 伪代码 \nint Hash(string key) {\n  // 获取后四位字符\n  string hashValue =int.parse(key.Substring(key.Length-4, 4));\n  // 将后两位字符转换为整数\n  return hashValue;\n}\n```\n\n在这里散列函数的作用就是讲key值映射成数组的索引下标。关于散列函数的设计方法有很多，如:直接寻址法、数字分析法、随机数法等等。但即使是再优秀的设计方法也不能避免散列冲突。在散列表中散列函数不应设计太复杂。\n\n#### 1.3 散列冲突\n\n![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/96951971.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;散列函数具有确定性和不确定性。\n\n* 确定性:哈希的散列值不同，那么哈希的原始输入也就不同。即:key1=key2,那么hash(key1)=hash(key2)。\n* 不确定性:同一个散列值很有可能对应多个不同的原始输入。即:key1≠key2，hash(key1)=hash(key2)。\n\n散列冲突,即key1≠key2，hash(key1)=hash(key2)的情况。散列冲突是不可避免的，如果我们key的长度为100，而数组的索引数量只有50，那么再优秀的算法也无法避免散列冲突。关于散列冲突也有很多解决办法，这里简单复习两种：开放寻址法和链表法。\n\n##### 1.3.1 开放寻址法\n\n&nbsp;&nbsp;&nbsp;&nbsp;开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一一个空闲位置，将其插入。比如，我们可以使用线性探测法。当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，如果遍历到尾部都没有找到空闲的位置，那么我们就再从表头开始找，直到找到为止。\n\n![开放寻址法](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/20232835.jpg)\n\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;散列表中查找元素的时候，我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置还没有找到，就说明要查找的元素并没有在散列表中。\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于删除操作稍微有些特别，不能单纯地把要删除的元素设置为空。因为在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。这里我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。\n\n&nbsp;&nbsp;&nbsp;&nbsp;线性探测法存在很大问题。当散列表中插入的数据越来越多时，其散列冲突的可能性就越大，极端情况下甚至要探测整个散列表,因此最坏时间复杂度为O(N)。在开放寻址法中，除了线性探测法，我们还可以二次探测和双重散列等方式。\n\n##### 1.3.2 链表法\n\n&nbsp;&nbsp;&nbsp;&nbsp;链表法是一种比较常用的散列冲突解决办法,Redis使用的就是链表法来解决散列冲突。链表法的原理是:如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可。\n\n![链表法](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/89123753.jpg)\n\n##### 1.3.3 负载因子与rehash\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用装载因子来衡量散列表的“健康状况”。\n\n```\n散列表的负载因子 = 填入表中的元素个数/散列表的长度\n```\n\n散列表负载因子越大，代表空闲位置越少，冲突也就越多，散列表的性能会下降。\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于散列表来说，负载因子过大或过小都不好，负载因子过大，散列表的性能会下降。而负载因子过小，则会造成内存不能合理利用，从而形成内存浪费。因此我们为了保证负载因子维持在一个合理的范围内，要对散列表的大小进行收缩或扩展，即rehash。散列表的rehash过程类似于数组的收缩与扩容。\n\n##### 1.3.4 开放寻址法与链表法比较\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于开放寻址法解决冲突的散列表，由于数据都存储在数组中，因此可以有效地利用 CPU 缓存加快查询速度(数组占用一块连续的空间)。但是删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，负载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于链表法解决冲突的散列表,对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于1的情况。接近1时，就可能会有大量的散列冲突，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。但是，链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，而且链表中的结点是零散分布在内存中的，不是连续的，所以对CPU缓存是不友好的，这对于执行效率有一定的影响。\n\n### 二、Redis字典\n\n#### 2.1 Redis字典的实现\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis字典使用散列表最为底层实现，一个散列表里面有多个散列表节点，每个散列表节点就保存了字典中的一个键值对。\n\n![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/43712743.jpg)\n\n##### 2.1.1 字典\n\n```c\ntypedef struct dict{\n         //类型特定函数\n         void *type;\n         //私有数据\n         void *privdata;\n         //哈希表-见2.1.2\n         dictht ht[2];\n         //rehash 索引 当rehash不在进行时 值为-1\n         int trehashidx; \n}dict;\n```\n\ntype属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的。\n\n* type属性是一个指向dictType结构的指针，每个dictType用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。\n* privdata属性则保存了需要传给给那些类型特定函数的可选参数。\n\n```c#\ntypedef struct dictType\n{\n         //计算哈希值的函数 \n         unsigned int  (*hashFunction) (const void *key);\n         //复制键的函数\n         void *(*keyDup) (void *privdata,const void *key);\n         //复制值的函数\n         void *(*keyDup) (void *privdata,const void *obj);\n          //复制值的函数\n         void *(*keyCompare) (void *privdata,const void *key1, const void *key2);\n         //销毁键的函数\n         void (*keyDestructor) (void *privdata, void *key);\n         //销毁值的函数\n         void (*keyDestructor) (void *privdata, void *obj);\n}dictType;\n```\n\n* ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表， 一般情况下，字典只使用ht[0] 哈希表, ht[1]哈希表只会对ht[0]哈希表进行rehash时使用。\n* rehashidx记录了rehash目前的进度，如果目前没有进行rehash，值为-1。\n\n##### 2.1.2 散列表\n\n```c\ntypedef struct dictht\n{\n         //哈希表数组，C语言中，*号是为了表明该变量为指针，有几个* 号就相当于是几级指针，这里是二级指针，理解为指向指针的指针\n         dictEntry **table;\n         //哈希表大小\n         unsigned long size;\n         //哈希表大小掩码，用于计算索引值\n         unsigned long sizemask;\n         //该哈希已有节点的数量\n         unsigned long used;\n}dictht;\n```\n\n* table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对\n* size属性记录了哈希表的大小，也是table数组的大小\n* used属性则记录哈希表目前已有节点(键值对)的数量\n* sizemask属性的值总是等于 size-1(从0开始)，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面（索引下标值）。\n\n##### 2.1.3 散列表节点\n\n```c\n//哈希表节点定义dictEntry结构表示，每个dictEntry结构都保存着一个键值对。\ntypedef struct dictEntry\n{\n         //键\n         void *key;\n         //值\n         union{\n           void *val;\n            uint64_tu64;\n            int64_ts64;\n            }v;\n         // 指向下个哈希表节点，形成链表\n         struct dictEntry *next;\n}dictEntry;\n```\n\nkey属性保存着键值中的键，而v属性则保存着键值对中的值，其中键值(v属性)可以是一个指针，或uint64_t整数，或int64_t整数。 next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，解决键冲突问题。\n\n#### 2.2 Redis如何解决散列冲突\n\n##### 2.2.1 链表法\n\n&nbsp;&nbsp;&nbsp;&nbsp;当有两个或以上的键被分配到散列表数组同一个索引上时，就发生了键冲突。Redis使用链表法解决散列冲突。每个散列表节点都有一个next指针，多个散列表节点next可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以使用这个单向链表连接起来。\n\n![Redis 链表法](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/50308918.jpg)\n\n如图所示,当键k0和k1的经过散列函数得到索引值都为1时，就会使用next指针将两个节点连接起来。而由于节点没有指向链尾的指针，因此新的节点总是插入到链表的头部，排在已有节点的前面。\n\n##### 2.2.2 Redis rehash\n\n&nbsp;&nbsp;&nbsp;&nbsp;随着操作的进行，散列表中保存的键值对会也会不断地增加或减少，为了保证负载因子维持在一个合理的范围，当散列表内的键值对过多或过少时，内需要定期进行rehash，以提升性能或节省内存。Redis的rehash的步骤如下:\n\n![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/7685902.jpg)\n\n1. 为字典的ht[1]散列表分配空间，这个空间的大小取决于要执行的操作以及ht[0]当前包含的键值对数量(即:ht[0].used的属性值)\n\n   * 扩展操作：ht[1]的大小为 第一个大于等于ht[0].used*2的2的n次方幂。如:ht[0].used=3则ht[1]的大小为8，ht[0].used=4则ht[1]的大小为8。\n   * 收缩操作: ht[1]的大小为 第一个大于等于ht[0].used的2的n次方幂。\n\n   ![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/6383938.jpg)\n\n2. 将保存在ht[0]中的键值对重新计算键的散列值和索引值，然后放到ht[1]指定的位置上。\n\n   ![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/13728022.jpg)\n\n3. 将ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0],将ht[1]设置为ht[0],并创建一个新的ht[1]哈希表为下一次rehash做准备。\n\n   ![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/38258178.jpg)\n\n**rehash操作需要满足以下条件:**\n\n1. 服务器目前没有执行BGSAVE(rdb持久化)命令或者BGREWRITEAOF(AOF文件重写)命令，并且散列表的负载因子大于等于1。\n2. 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且负载因子大于等于5。\n3. 当负载因子小于0.1时，程序自动开始执行收缩操作。\n\nRedis这么做的目的是基于操作系统创建子进程后写时复制技术，避免不必要的写入操作。(有关BGSAVE、BGREWRITEAOF以及写时复制会在后续持久化一文详细介绍)。\n\n##### 2.2.3 渐进式 rehash\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于rehash我们思考一个问题如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表。这种情况听着就很耗时，而生产环境中甚至会更大。为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。当负载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次一次性数据搬移，插入操作就都变得很快了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis为了解决这个问题采用渐进式rehash方式。以下是Redis渐进式rehash的详细步骤:\n\n1. 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。\n2. 在字典中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 `0` ，表示 rehash 工作正式开始。\n3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。\n4. 随着字典操作的不断执行， 最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 `-1` ， 表示 rehash 操作已完成。\n\n**说明: **\n\n**1.因为在进行渐进式 rehash 的过程中，字典会同时使用 `ht[0]` 和 `ht[1]` 两个哈希表，所以在渐进式 rehash 进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。**\n\n**2. 在渐进式 rehash 执行期间，新添加到字典的键值对一律会被保存到 `ht[1]` 里面，而 `ht[0]` 则不再进行任何添加操作：这一措施保证了 `ht[0]` 包含的键值对数量会只减不增，并随着 rehash 操作的执行而最终变成空表。**\n\n#### 2.3 时间复杂度\n\n&nbsp;&nbsp;&nbsp;&nbsp;下面给出几个Redis字典常见操作的时间复杂度，可以结合上面的内容分析为什么。\n\n| 操作                                           | 时间复杂度                      |\n| ---------------------------------------------- | ------------------------------- |\n| 创建一个新字典                                 | O(1)                            |\n| 将给定的键值对添加到字典内                     | O(1)                            |\n| 将给定的键值对添加到字典内，如果键存在则替换之 | O(1)                            |\n| 返回给定键的值                                 | O(1)                            |\n| 从字典中随机返回一个键值对                     | O(1)                            |\n| 从字典中删除给定键所对应的键值对               | O(1)                            |\n| 释放给定字典以及字典中包含的键值对             | O(N)，N为字典包含的键值对的数量 |\n\n### 本文重点\n\n1. 字典在redis中广泛应用，包括数据库和hash数据结构。\n2. 每个字典有两个哈希表，一个是正常使用，一个用于rehash期间使用。\n3. 当redis计算哈希时，采用的是MurmurHash2哈希算法。\n4. 哈希表采用链表法解决散列冲突，被分配到同一个地址的键会构成一个单向链表。\n5. 在rehash对哈希表进行扩展或者收缩过程中，会将所有键值对进行迁移，并且这个迁移是渐进式的迁移。\n\n### 小结\n\n&nbsp;&nbsp;&nbsp;&nbsp;本篇文章主要回顾了散列表的概念，散列函数以及如何解决散列冲突。并分析了Redis中字典的实现。下篇文章将介绍跳跃表以及跳跃表在Redis中的实现。\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n","source":"_posts/技术实践/redis/Redis数据结构——字典.md","raw":"---\ntitle: Redis数据结构——字典\ncopyright: true\ndate: 2018-11-20 16:15:39\ntags: \n- Redis\n- 数据结构\n- 散列表\ncategories: Redis\nkeywords: Redis,数据结构,链表\naside: redis\n---\n\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;字典在Redis中的应用非常广泛，数据库与哈希对象的底层实现就是字典。\n\n<!--more-->\n\n### 一、复习散列表\n\n#### 1.1 散列表\n\n&nbsp;&nbsp;&nbsp;&nbsp;散列表(哈希表)，其思想主要是基于数组支持按照下标随机访问数据时间复杂度为O(1)的特性。可是说是数组的一种扩展。假设，我们为了方便记录某高校数学专业的所有学生的信息。要求可以按照学号(学号格式为:入学时间+年级+专业+专业内自增序号，如2011 1101 0001)能够快速找到某个学生的信息。这个时候我们可以取学号的自增序号部分，即后四位作为数组的索引下标，把学生相应的信息存储到对应的空间内即可。\n\n\n\n![散列思想](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/16747511.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上图所示,我们把学号作为key,通过截取学号后四位的函数后计算后得到索引下标，将数据存储到数组中。当我们按照键值(学号)查找时，只需要再次计算出索引下标，然后取出相应数据即可。以上便是散列思想。\n\n#### 1.2 散列函数\n\n&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中，截取学号后四位的函数即是一个简单的散列函数。\n\n```c#\n//散列函数 伪代码 \nint Hash(string key) {\n  // 获取后四位字符\n  string hashValue =int.parse(key.Substring(key.Length-4, 4));\n  // 将后两位字符转换为整数\n  return hashValue;\n}\n```\n\n在这里散列函数的作用就是讲key值映射成数组的索引下标。关于散列函数的设计方法有很多，如:直接寻址法、数字分析法、随机数法等等。但即使是再优秀的设计方法也不能避免散列冲突。在散列表中散列函数不应设计太复杂。\n\n#### 1.3 散列冲突\n\n![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/96951971.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;散列函数具有确定性和不确定性。\n\n* 确定性:哈希的散列值不同，那么哈希的原始输入也就不同。即:key1=key2,那么hash(key1)=hash(key2)。\n* 不确定性:同一个散列值很有可能对应多个不同的原始输入。即:key1≠key2，hash(key1)=hash(key2)。\n\n散列冲突,即key1≠key2，hash(key1)=hash(key2)的情况。散列冲突是不可避免的，如果我们key的长度为100，而数组的索引数量只有50，那么再优秀的算法也无法避免散列冲突。关于散列冲突也有很多解决办法，这里简单复习两种：开放寻址法和链表法。\n\n##### 1.3.1 开放寻址法\n\n&nbsp;&nbsp;&nbsp;&nbsp;开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一一个空闲位置，将其插入。比如，我们可以使用线性探测法。当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，如果遍历到尾部都没有找到空闲的位置，那么我们就再从表头开始找，直到找到为止。\n\n![开放寻址法](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/20232835.jpg)\n\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;散列表中查找元素的时候，我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置还没有找到，就说明要查找的元素并没有在散列表中。\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于删除操作稍微有些特别，不能单纯地把要删除的元素设置为空。因为在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。这里我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。\n\n&nbsp;&nbsp;&nbsp;&nbsp;线性探测法存在很大问题。当散列表中插入的数据越来越多时，其散列冲突的可能性就越大，极端情况下甚至要探测整个散列表,因此最坏时间复杂度为O(N)。在开放寻址法中，除了线性探测法，我们还可以二次探测和双重散列等方式。\n\n##### 1.3.2 链表法\n\n&nbsp;&nbsp;&nbsp;&nbsp;链表法是一种比较常用的散列冲突解决办法,Redis使用的就是链表法来解决散列冲突。链表法的原理是:如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可。\n\n![链表法](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/89123753.jpg)\n\n##### 1.3.3 负载因子与rehash\n\n&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用装载因子来衡量散列表的“健康状况”。\n\n```\n散列表的负载因子 = 填入表中的元素个数/散列表的长度\n```\n\n散列表负载因子越大，代表空闲位置越少，冲突也就越多，散列表的性能会下降。\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于散列表来说，负载因子过大或过小都不好，负载因子过大，散列表的性能会下降。而负载因子过小，则会造成内存不能合理利用，从而形成内存浪费。因此我们为了保证负载因子维持在一个合理的范围内，要对散列表的大小进行收缩或扩展，即rehash。散列表的rehash过程类似于数组的收缩与扩容。\n\n##### 1.3.4 开放寻址法与链表法比较\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于开放寻址法解决冲突的散列表，由于数据都存储在数组中，因此可以有效地利用 CPU 缓存加快查询速度(数组占用一块连续的空间)。但是删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，负载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于链表法解决冲突的散列表,对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于1的情况。接近1时，就可能会有大量的散列冲突，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。但是，链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，而且链表中的结点是零散分布在内存中的，不是连续的，所以对CPU缓存是不友好的，这对于执行效率有一定的影响。\n\n### 二、Redis字典\n\n#### 2.1 Redis字典的实现\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis字典使用散列表最为底层实现，一个散列表里面有多个散列表节点，每个散列表节点就保存了字典中的一个键值对。\n\n![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/43712743.jpg)\n\n##### 2.1.1 字典\n\n```c\ntypedef struct dict{\n         //类型特定函数\n         void *type;\n         //私有数据\n         void *privdata;\n         //哈希表-见2.1.2\n         dictht ht[2];\n         //rehash 索引 当rehash不在进行时 值为-1\n         int trehashidx; \n}dict;\n```\n\ntype属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的。\n\n* type属性是一个指向dictType结构的指针，每个dictType用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。\n* privdata属性则保存了需要传给给那些类型特定函数的可选参数。\n\n```c#\ntypedef struct dictType\n{\n         //计算哈希值的函数 \n         unsigned int  (*hashFunction) (const void *key);\n         //复制键的函数\n         void *(*keyDup) (void *privdata,const void *key);\n         //复制值的函数\n         void *(*keyDup) (void *privdata,const void *obj);\n          //复制值的函数\n         void *(*keyCompare) (void *privdata,const void *key1, const void *key2);\n         //销毁键的函数\n         void (*keyDestructor) (void *privdata, void *key);\n         //销毁值的函数\n         void (*keyDestructor) (void *privdata, void *obj);\n}dictType;\n```\n\n* ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表， 一般情况下，字典只使用ht[0] 哈希表, ht[1]哈希表只会对ht[0]哈希表进行rehash时使用。\n* rehashidx记录了rehash目前的进度，如果目前没有进行rehash，值为-1。\n\n##### 2.1.2 散列表\n\n```c\ntypedef struct dictht\n{\n         //哈希表数组，C语言中，*号是为了表明该变量为指针，有几个* 号就相当于是几级指针，这里是二级指针，理解为指向指针的指针\n         dictEntry **table;\n         //哈希表大小\n         unsigned long size;\n         //哈希表大小掩码，用于计算索引值\n         unsigned long sizemask;\n         //该哈希已有节点的数量\n         unsigned long used;\n}dictht;\n```\n\n* table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对\n* size属性记录了哈希表的大小，也是table数组的大小\n* used属性则记录哈希表目前已有节点(键值对)的数量\n* sizemask属性的值总是等于 size-1(从0开始)，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面（索引下标值）。\n\n##### 2.1.3 散列表节点\n\n```c\n//哈希表节点定义dictEntry结构表示，每个dictEntry结构都保存着一个键值对。\ntypedef struct dictEntry\n{\n         //键\n         void *key;\n         //值\n         union{\n           void *val;\n            uint64_tu64;\n            int64_ts64;\n            }v;\n         // 指向下个哈希表节点，形成链表\n         struct dictEntry *next;\n}dictEntry;\n```\n\nkey属性保存着键值中的键，而v属性则保存着键值对中的值，其中键值(v属性)可以是一个指针，或uint64_t整数，或int64_t整数。 next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，解决键冲突问题。\n\n#### 2.2 Redis如何解决散列冲突\n\n##### 2.2.1 链表法\n\n&nbsp;&nbsp;&nbsp;&nbsp;当有两个或以上的键被分配到散列表数组同一个索引上时，就发生了键冲突。Redis使用链表法解决散列冲突。每个散列表节点都有一个next指针，多个散列表节点next可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以使用这个单向链表连接起来。\n\n![Redis 链表法](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/50308918.jpg)\n\n如图所示,当键k0和k1的经过散列函数得到索引值都为1时，就会使用next指针将两个节点连接起来。而由于节点没有指向链尾的指针，因此新的节点总是插入到链表的头部，排在已有节点的前面。\n\n##### 2.2.2 Redis rehash\n\n&nbsp;&nbsp;&nbsp;&nbsp;随着操作的进行，散列表中保存的键值对会也会不断地增加或减少，为了保证负载因子维持在一个合理的范围，当散列表内的键值对过多或过少时，内需要定期进行rehash，以提升性能或节省内存。Redis的rehash的步骤如下:\n\n![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/7685902.jpg)\n\n1. 为字典的ht[1]散列表分配空间，这个空间的大小取决于要执行的操作以及ht[0]当前包含的键值对数量(即:ht[0].used的属性值)\n\n   * 扩展操作：ht[1]的大小为 第一个大于等于ht[0].used*2的2的n次方幂。如:ht[0].used=3则ht[1]的大小为8，ht[0].used=4则ht[1]的大小为8。\n   * 收缩操作: ht[1]的大小为 第一个大于等于ht[0].used的2的n次方幂。\n\n   ![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/6383938.jpg)\n\n2. 将保存在ht[0]中的键值对重新计算键的散列值和索引值，然后放到ht[1]指定的位置上。\n\n   ![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/13728022.jpg)\n\n3. 将ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0],将ht[1]设置为ht[0],并创建一个新的ht[1]哈希表为下一次rehash做准备。\n\n   ![](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/38258178.jpg)\n\n**rehash操作需要满足以下条件:**\n\n1. 服务器目前没有执行BGSAVE(rdb持久化)命令或者BGREWRITEAOF(AOF文件重写)命令，并且散列表的负载因子大于等于1。\n2. 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且负载因子大于等于5。\n3. 当负载因子小于0.1时，程序自动开始执行收缩操作。\n\nRedis这么做的目的是基于操作系统创建子进程后写时复制技术，避免不必要的写入操作。(有关BGSAVE、BGREWRITEAOF以及写时复制会在后续持久化一文详细介绍)。\n\n##### 2.2.3 渐进式 rehash\n\n&nbsp;&nbsp;&nbsp;&nbsp;对于rehash我们思考一个问题如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表。这种情况听着就很耗时，而生产环境中甚至会更大。为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。当负载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次一次性数据搬移，插入操作就都变得很快了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;Redis为了解决这个问题采用渐进式rehash方式。以下是Redis渐进式rehash的详细步骤:\n\n1. 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。\n2. 在字典中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 `0` ，表示 rehash 工作正式开始。\n3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。\n4. 随着字典操作的不断执行， 最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 `-1` ， 表示 rehash 操作已完成。\n\n**说明: **\n\n**1.因为在进行渐进式 rehash 的过程中，字典会同时使用 `ht[0]` 和 `ht[1]` 两个哈希表，所以在渐进式 rehash 进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。**\n\n**2. 在渐进式 rehash 执行期间，新添加到字典的键值对一律会被保存到 `ht[1]` 里面，而 `ht[0]` 则不再进行任何添加操作：这一措施保证了 `ht[0]` 包含的键值对数量会只减不增，并随着 rehash 操作的执行而最终变成空表。**\n\n#### 2.3 时间复杂度\n\n&nbsp;&nbsp;&nbsp;&nbsp;下面给出几个Redis字典常见操作的时间复杂度，可以结合上面的内容分析为什么。\n\n| 操作                                           | 时间复杂度                      |\n| ---------------------------------------------- | ------------------------------- |\n| 创建一个新字典                                 | O(1)                            |\n| 将给定的键值对添加到字典内                     | O(1)                            |\n| 将给定的键值对添加到字典内，如果键存在则替换之 | O(1)                            |\n| 返回给定键的值                                 | O(1)                            |\n| 从字典中随机返回一个键值对                     | O(1)                            |\n| 从字典中删除给定键所对应的键值对               | O(1)                            |\n| 释放给定字典以及字典中包含的键值对             | O(N)，N为字典包含的键值对的数量 |\n\n### 本文重点\n\n1. 字典在redis中广泛应用，包括数据库和hash数据结构。\n2. 每个字典有两个哈希表，一个是正常使用，一个用于rehash期间使用。\n3. 当redis计算哈希时，采用的是MurmurHash2哈希算法。\n4. 哈希表采用链表法解决散列冲突，被分配到同一个地址的键会构成一个单向链表。\n5. 在rehash对哈希表进行扩展或者收缩过程中，会将所有键值对进行迁移，并且这个迁移是渐进式的迁移。\n\n### 小结\n\n&nbsp;&nbsp;&nbsp;&nbsp;本篇文章主要回顾了散列表的概念，散列函数以及如何解决散列冲突。并分析了Redis中字典的实现。下篇文章将介绍跳跃表以及跳跃表在Redis中的实现。\n\n### 参考\n\n《Redis设计与实现》\n\n《Redis开发与运维》\n\n《Redis官方文档》\n","slug":"技术实践/redis/Redis数据结构——字典","published":1,"updated":"2021-03-14T03:04:50.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfq0b00g7hyjf4txk17sp","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;字典在Redis中的应用非常广泛，数据库与哈希对象的底层实现就是字典。</p>\n<a id=\"more\"></a>\n<h3 id=\"一、复习散列表\"><a href=\"#一、复习散列表\" class=\"headerlink\" title=\"一、复习散列表\"></a>一、复习散列表</h3><h4 id=\"1-1-散列表\"><a href=\"#1-1-散列表\" class=\"headerlink\" title=\"1.1 散列表\"></a>1.1 散列表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;散列表(哈希表)，其思想主要是基于数组支持按照下标随机访问数据时间复杂度为O(1)的特性。可是说是数组的一种扩展。假设，我们为了方便记录某高校数学专业的所有学生的信息。要求可以按照学号(学号格式为:入学时间+年级+专业+专业内自增序号，如2011 1101 0001)能够快速找到某个学生的信息。这个时候我们可以取学号的自增序号部分，即后四位作为数组的索引下标，把学生相应的信息存储到对应的空间内即可。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/16747511.jpg\" alt=\"散列思想\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上图所示,我们把学号作为key,通过截取学号后四位的函数后计算后得到索引下标，将数据存储到数组中。当我们按照键值(学号)查找时，只需要再次计算出索引下标，然后取出相应数据即可。以上便是散列思想。</p>\n<h4 id=\"1-2-散列函数\"><a href=\"#1-2-散列函数\" class=\"headerlink\" title=\"1.2 散列函数\"></a>1.2 散列函数</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中，截取学号后四位的函数即是一个简单的散列函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//散列函数 伪代码 </span><br><span class=\"line\">int Hash(string key) &#123;</span><br><span class=\"line\">  // 获取后四位字符</span><br><span class=\"line\">  string hashValue =int.parse(key.Substring(key.Length-4, 4));</span><br><span class=\"line\">  // 将后两位字符转换为整数</span><br><span class=\"line\">  return hashValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里散列函数的作用就是讲key值映射成数组的索引下标。关于散列函数的设计方法有很多，如:直接寻址法、数字分析法、随机数法等等。但即使是再优秀的设计方法也不能避免散列冲突。在散列表中散列函数不应设计太复杂。</p>\n<h4 id=\"1-3-散列冲突\"><a href=\"#1-3-散列冲突\" class=\"headerlink\" title=\"1.3 散列冲突\"></a>1.3 散列冲突</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/96951971.jpg\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;散列函数具有确定性和不确定性。</p>\n<ul>\n<li>确定性:哈希的散列值不同，那么哈希的原始输入也就不同。即:key1=key2,那么hash(key1)=hash(key2)。</li>\n<li>不确定性:同一个散列值很有可能对应多个不同的原始输入。即:key1≠key2，hash(key1)=hash(key2)。</li>\n</ul>\n<p>散列冲突,即key1≠key2，hash(key1)=hash(key2)的情况。散列冲突是不可避免的，如果我们key的长度为100，而数组的索引数量只有50，那么再优秀的算法也无法避免散列冲突。关于散列冲突也有很多解决办法，这里简单复习两种：开放寻址法和链表法。</p>\n<h5 id=\"1-3-1-开放寻址法\"><a href=\"#1-3-1-开放寻址法\" class=\"headerlink\" title=\"1.3.1 开放寻址法\"></a>1.3.1 开放寻址法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一一个空闲位置，将其插入。比如，我们可以使用线性探测法。当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，如果遍历到尾部都没有找到空闲的位置，那么我们就再从表头开始找，直到找到为止。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/20232835.jpg\" alt=\"开放寻址法\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;散列表中查找元素的时候，我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置还没有找到，就说明要查找的元素并没有在散列表中。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;对于删除操作稍微有些特别，不能单纯地把要删除的元素设置为空。因为在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。这里我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;线性探测法存在很大问题。当散列表中插入的数据越来越多时，其散列冲突的可能性就越大，极端情况下甚至要探测整个散列表,因此最坏时间复杂度为O(N)。在开放寻址法中，除了线性探测法，我们还可以二次探测和双重散列等方式。</p>\n<h5 id=\"1-3-2-链表法\"><a href=\"#1-3-2-链表法\" class=\"headerlink\" title=\"1.3.2 链表法\"></a>1.3.2 链表法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;链表法是一种比较常用的散列冲突解决办法,Redis使用的就是链表法来解决散列冲突。链表法的原理是:如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/89123753.jpg\" alt=\"链表法\"></p>\n<h5 id=\"1-3-3-负载因子与rehash\"><a href=\"#1-3-3-负载因子与rehash\" class=\"headerlink\" title=\"1.3.3 负载因子与rehash\"></a>1.3.3 负载因子与rehash</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用装载因子来衡量散列表的“健康状况”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">散列表的负载因子 = 填入表中的元素个数/散列表的长度</span><br></pre></td></tr></table></figure>\n<p>散列表负载因子越大，代表空闲位置越少，冲突也就越多，散列表的性能会下降。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;对于散列表来说，负载因子过大或过小都不好，负载因子过大，散列表的性能会下降。而负载因子过小，则会造成内存不能合理利用，从而形成内存浪费。因此我们为了保证负载因子维持在一个合理的范围内，要对散列表的大小进行收缩或扩展，即rehash。散列表的rehash过程类似于数组的收缩与扩容。</p>\n<h5 id=\"1-3-4-开放寻址法与链表法比较\"><a href=\"#1-3-4-开放寻址法与链表法比较\" class=\"headerlink\" title=\"1.3.4 开放寻址法与链表法比较\"></a>1.3.4 开放寻址法与链表法比较</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;对于开放寻址法解决冲突的散列表，由于数据都存储在数组中，因此可以有效地利用 CPU 缓存加快查询速度(数组占用一块连续的空间)。但是删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，负载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;对于链表法解决冲突的散列表,对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于1的情况。接近1时，就可能会有大量的散列冲突，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。但是，链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，而且链表中的结点是零散分布在内存中的，不是连续的，所以对CPU缓存是不友好的，这对于执行效率有一定的影响。</p>\n<h3 id=\"二、Redis字典\"><a href=\"#二、Redis字典\" class=\"headerlink\" title=\"二、Redis字典\"></a>二、Redis字典</h3><h4 id=\"2-1-Redis字典的实现\"><a href=\"#2-1-Redis字典的实现\" class=\"headerlink\" title=\"2.1 Redis字典的实现\"></a>2.1 Redis字典的实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis字典使用散列表最为底层实现，一个散列表里面有多个散列表节点，每个散列表节点就保存了字典中的一个键值对。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/43712743.jpg\" alt></p>\n<h5 id=\"2-1-1-字典\"><a href=\"#2-1-1-字典\" class=\"headerlink\" title=\"2.1.1 字典\"></a>2.1.1 字典</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span>&#123;</span></span><br><span class=\"line\">         <span class=\"comment\">//类型特定函数</span></span><br><span class=\"line\">         <span class=\"keyword\">void</span> *type;</span><br><span class=\"line\">         <span class=\"comment\">//私有数据</span></span><br><span class=\"line\">         <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">         <span class=\"comment\">//哈希表-见2.1.2</span></span><br><span class=\"line\">         dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">         <span class=\"comment\">//rehash 索引 当rehash不在进行时 值为-1</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span> trehashidx; </span><br><span class=\"line\">&#125;dict;</span><br></pre></td></tr></table></figure>\n<p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的。</p>\n<ul>\n<li>type属性是一个指向dictType结构的指针，每个dictType用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</li>\n<li>privdata属性则保存了需要传给给那些类型特定函数的可选参数。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct dictType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">         //计算哈希值的函数 </span><br><span class=\"line\">         unsigned int  (*hashFunction) (const void *key);</span><br><span class=\"line\">         //复制键的函数</span><br><span class=\"line\">         void *(*keyDup) (void *privdata,const void *key);</span><br><span class=\"line\">         //复制值的函数</span><br><span class=\"line\">         void *(*keyDup) (void *privdata,const void *obj);</span><br><span class=\"line\">          //复制值的函数</span><br><span class=\"line\">         void *(*keyCompare) (void *privdata,const void *key1, const void *key2);</span><br><span class=\"line\">         //销毁键的函数</span><br><span class=\"line\">         void (*keyDestructor) (void *privdata, void *key);</span><br><span class=\"line\">         //销毁值的函数</span><br><span class=\"line\">         void (*keyDestructor) (void *privdata, void *obj);</span><br><span class=\"line\">&#125;dictType;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表， 一般情况下，字典只使用ht[0] 哈希表, ht[1]哈希表只会对ht[0]哈希表进行rehash时使用。</li>\n<li>rehashidx记录了rehash目前的进度，如果目前没有进行rehash，值为-1。</li>\n</ul>\n<h5 id=\"2-1-2-散列表\"><a href=\"#2-1-2-散列表\" class=\"headerlink\" title=\"2.1.2 散列表\"></a>2.1.2 散列表</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">         <span class=\"comment\">//哈希表数组，C语言中，*号是为了表明该变量为指针，有几个* 号就相当于是几级指针，这里是二级指针，理解为指向指针的指针</span></span><br><span class=\"line\">         dictEntry **table;</span><br><span class=\"line\">         <span class=\"comment\">//哈希表大小</span></span><br><span class=\"line\">         <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">         <span class=\"comment\">//哈希表大小掩码，用于计算索引值</span></span><br><span class=\"line\">         <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">         <span class=\"comment\">//该哈希已有节点的数量</span></span><br><span class=\"line\">         <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125;dictht;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对</li>\n<li>size属性记录了哈希表的大小，也是table数组的大小</li>\n<li>used属性则记录哈希表目前已有节点(键值对)的数量</li>\n<li>sizemask属性的值总是等于 size-1(从0开始)，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面（索引下标值）。</li>\n</ul>\n<h5 id=\"2-1-3-散列表节点\"><a href=\"#2-1-3-散列表节点\" class=\"headerlink\" title=\"2.1.3 散列表节点\"></a>2.1.3 散列表节点</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//哈希表节点定义dictEntry结构表示，每个dictEntry结构都保存着一个键值对。</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">         <span class=\"comment\">//键</span></span><br><span class=\"line\">         <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">         <span class=\"comment\">//值</span></span><br><span class=\"line\">         <span class=\"keyword\">union</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">            uint64_tu64;</span><br><span class=\"line\">            int64_ts64;</span><br><span class=\"line\">            &#125;v;</span><br><span class=\"line\">         <span class=\"comment\">// 指向下个哈希表节点，形成链表</span></span><br><span class=\"line\">         <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;dictEntry;</span><br></pre></td></tr></table></figure>\n<p>key属性保存着键值中的键，而v属性则保存着键值对中的值，其中键值(v属性)可以是一个指针，或uint64_t整数，或int64_t整数。 next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，解决键冲突问题。</p>\n<h4 id=\"2-2-Redis如何解决散列冲突\"><a href=\"#2-2-Redis如何解决散列冲突\" class=\"headerlink\" title=\"2.2 Redis如何解决散列冲突\"></a>2.2 Redis如何解决散列冲突</h4><h5 id=\"2-2-1-链表法\"><a href=\"#2-2-1-链表法\" class=\"headerlink\" title=\"2.2.1 链表法\"></a>2.2.1 链表法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;当有两个或以上的键被分配到散列表数组同一个索引上时，就发生了键冲突。Redis使用链表法解决散列冲突。每个散列表节点都有一个next指针，多个散列表节点next可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以使用这个单向链表连接起来。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/50308918.jpg\" alt=\"Redis 链表法\"></p>\n<p>如图所示,当键k0和k1的经过散列函数得到索引值都为1时，就会使用next指针将两个节点连接起来。而由于节点没有指向链尾的指针，因此新的节点总是插入到链表的头部，排在已有节点的前面。</p>\n<h5 id=\"2-2-2-Redis-rehash\"><a href=\"#2-2-2-Redis-rehash\" class=\"headerlink\" title=\"2.2.2 Redis rehash\"></a>2.2.2 Redis rehash</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;随着操作的进行，散列表中保存的键值对会也会不断地增加或减少，为了保证负载因子维持在一个合理的范围，当散列表内的键值对过多或过少时，内需要定期进行rehash，以提升性能或节省内存。Redis的rehash的步骤如下:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/7685902.jpg\" alt></p>\n<ol>\n<li><p>为字典的ht[1]散列表分配空间，这个空间的大小取决于要执行的操作以及ht[0]当前包含的键值对数量(即:ht[0].used的属性值)</p>\n<ul>\n<li>扩展操作：ht[1]的大小为 第一个大于等于ht[0].used*2的2的n次方幂。如:ht[0].used=3则ht[1]的大小为8，ht[0].used=4则ht[1]的大小为8。</li>\n<li>收缩操作: ht[1]的大小为 第一个大于等于ht[0].used的2的n次方幂。</li>\n</ul>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/6383938.jpg\" alt></p>\n</li>\n<li><p>将保存在ht[0]中的键值对重新计算键的散列值和索引值，然后放到ht[1]指定的位置上。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/13728022.jpg\" alt></p>\n</li>\n<li><p>将ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0],将ht[1]设置为ht[0],并创建一个新的ht[1]哈希表为下一次rehash做准备。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/38258178.jpg\" alt></p>\n</li>\n</ol>\n<p><strong>rehash操作需要满足以下条件:</strong></p>\n<ol>\n<li>服务器目前没有执行BGSAVE(rdb持久化)命令或者BGREWRITEAOF(AOF文件重写)命令，并且散列表的负载因子大于等于1。</li>\n<li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且负载因子大于等于5。</li>\n<li>当负载因子小于0.1时，程序自动开始执行收缩操作。</li>\n</ol>\n<p>Redis这么做的目的是基于操作系统创建子进程后写时复制技术，避免不必要的写入操作。(有关BGSAVE、BGREWRITEAOF以及写时复制会在后续持久化一文详细介绍)。</p>\n<h5 id=\"2-2-3-渐进式-rehash\"><a href=\"#2-2-3-渐进式-rehash\" class=\"headerlink\" title=\"2.2.3 渐进式 rehash\"></a>2.2.3 渐进式 rehash</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;对于rehash我们思考一个问题如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表。这种情况听着就很耗时，而生产环境中甚至会更大。为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。当负载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次一次性数据搬移，插入操作就都变得很快了。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis为了解决这个问题采用渐进式rehash方式。以下是Redis渐进式rehash的详细步骤:</p>\n<ol>\n<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>\n<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ，表示 rehash 工作正式开始。</li>\n<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>\n<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>\n</ol>\n<p><strong>说明: </strong></p>\n<p><strong>1.因为在进行渐进式 rehash 的过程中，字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表，所以在渐进式 rehash 进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。</strong></p>\n<p><strong>2. 在渐进式 rehash 执行期间，新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面，而 <code>ht[0]</code> 则不再进行任何添加操作：这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增，并随着 rehash 操作的执行而最终变成空表。</strong></p>\n<h4 id=\"2-3-时间复杂度\"><a href=\"#2-3-时间复杂度\" class=\"headerlink\" title=\"2.3 时间复杂度\"></a>2.3 时间复杂度</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;下面给出几个Redis字典常见操作的时间复杂度，可以结合上面的内容分析为什么。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建一个新字典</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>将给定的键值对添加到字典内</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>将给定的键值对添加到字典内，如果键存在则替换之</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>返回给定键的值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>从字典中随机返回一个键值对</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>从字典中删除给定键所对应的键值对</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>释放给定字典以及字典中包含的键值对</td>\n<td>O(N)，N为字典包含的键值对的数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"本文重点\"><a href=\"#本文重点\" class=\"headerlink\" title=\"本文重点\"></a>本文重点</h3><ol>\n<li>字典在redis中广泛应用，包括数据库和hash数据结构。</li>\n<li>每个字典有两个哈希表，一个是正常使用，一个用于rehash期间使用。</li>\n<li>当redis计算哈希时，采用的是MurmurHash2哈希算法。</li>\n<li>哈希表采用链表法解决散列冲突，被分配到同一个地址的键会构成一个单向链表。</li>\n<li>在rehash对哈希表进行扩展或者收缩过程中，会将所有键值对进行迁移，并且这个迁移是渐进式的迁移。</li>\n</ol>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本篇文章主要回顾了散列表的概念，散列函数以及如何解决散列冲突。并分析了Redis中字典的实现。下篇文章将介绍跳跃表以及跳跃表在Redis中的实现。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;字典在Redis中的应用非常广泛，数据库与哈希对象的底层实现就是字典。</p>","more":"<h3 id=\"一、复习散列表\"><a href=\"#一、复习散列表\" class=\"headerlink\" title=\"一、复习散列表\"></a>一、复习散列表</h3><h4 id=\"1-1-散列表\"><a href=\"#1-1-散列表\" class=\"headerlink\" title=\"1.1 散列表\"></a>1.1 散列表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;散列表(哈希表)，其思想主要是基于数组支持按照下标随机访问数据时间复杂度为O(1)的特性。可是说是数组的一种扩展。假设，我们为了方便记录某高校数学专业的所有学生的信息。要求可以按照学号(学号格式为:入学时间+年级+专业+专业内自增序号，如2011 1101 0001)能够快速找到某个学生的信息。这个时候我们可以取学号的自增序号部分，即后四位作为数组的索引下标，把学生相应的信息存储到对应的空间内即可。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/16747511.jpg\" alt=\"散列思想\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上图所示,我们把学号作为key,通过截取学号后四位的函数后计算后得到索引下标，将数据存储到数组中。当我们按照键值(学号)查找时，只需要再次计算出索引下标，然后取出相应数据即可。以上便是散列思想。</p>\n<h4 id=\"1-2-散列函数\"><a href=\"#1-2-散列函数\" class=\"headerlink\" title=\"1.2 散列函数\"></a>1.2 散列函数</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中，截取学号后四位的函数即是一个简单的散列函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//散列函数 伪代码 </span><br><span class=\"line\">int Hash(string key) &#123;</span><br><span class=\"line\">  // 获取后四位字符</span><br><span class=\"line\">  string hashValue =int.parse(key.Substring(key.Length-4, 4));</span><br><span class=\"line\">  // 将后两位字符转换为整数</span><br><span class=\"line\">  return hashValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里散列函数的作用就是讲key值映射成数组的索引下标。关于散列函数的设计方法有很多，如:直接寻址法、数字分析法、随机数法等等。但即使是再优秀的设计方法也不能避免散列冲突。在散列表中散列函数不应设计太复杂。</p>\n<h4 id=\"1-3-散列冲突\"><a href=\"#1-3-散列冲突\" class=\"headerlink\" title=\"1.3 散列冲突\"></a>1.3 散列冲突</h4><p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/96951971.jpg\" alt></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;散列函数具有确定性和不确定性。</p>\n<ul>\n<li>确定性:哈希的散列值不同，那么哈希的原始输入也就不同。即:key1=key2,那么hash(key1)=hash(key2)。</li>\n<li>不确定性:同一个散列值很有可能对应多个不同的原始输入。即:key1≠key2，hash(key1)=hash(key2)。</li>\n</ul>\n<p>散列冲突,即key1≠key2，hash(key1)=hash(key2)的情况。散列冲突是不可避免的，如果我们key的长度为100，而数组的索引数量只有50，那么再优秀的算法也无法避免散列冲突。关于散列冲突也有很多解决办法，这里简单复习两种：开放寻址法和链表法。</p>\n<h5 id=\"1-3-1-开放寻址法\"><a href=\"#1-3-1-开放寻址法\" class=\"headerlink\" title=\"1.3.1 开放寻址法\"></a>1.3.1 开放寻址法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一一个空闲位置，将其插入。比如，我们可以使用线性探测法。当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，如果遍历到尾部都没有找到空闲的位置，那么我们就再从表头开始找，直到找到为止。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/20232835.jpg\" alt=\"开放寻址法\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;散列表中查找元素的时候，我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置还没有找到，就说明要查找的元素并没有在散列表中。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;对于删除操作稍微有些特别，不能单纯地把要删除的元素设置为空。因为在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。这里我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;线性探测法存在很大问题。当散列表中插入的数据越来越多时，其散列冲突的可能性就越大，极端情况下甚至要探测整个散列表,因此最坏时间复杂度为O(N)。在开放寻址法中，除了线性探测法，我们还可以二次探测和双重散列等方式。</p>\n<h5 id=\"1-3-2-链表法\"><a href=\"#1-3-2-链表法\" class=\"headerlink\" title=\"1.3.2 链表法\"></a>1.3.2 链表法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;链表法是一种比较常用的散列冲突解决办法,Redis使用的就是链表法来解决散列冲突。链表法的原理是:如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-19/89123753.jpg\" alt=\"链表法\"></p>\n<h5 id=\"1-3-3-负载因子与rehash\"><a href=\"#1-3-3-负载因子与rehash\" class=\"headerlink\" title=\"1.3.3 负载因子与rehash\"></a>1.3.3 负载因子与rehash</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用装载因子来衡量散列表的“健康状况”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">散列表的负载因子 = 填入表中的元素个数/散列表的长度</span><br></pre></td></tr></table></figure>\n<p>散列表负载因子越大，代表空闲位置越少，冲突也就越多，散列表的性能会下降。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;对于散列表来说，负载因子过大或过小都不好，负载因子过大，散列表的性能会下降。而负载因子过小，则会造成内存不能合理利用，从而形成内存浪费。因此我们为了保证负载因子维持在一个合理的范围内，要对散列表的大小进行收缩或扩展，即rehash。散列表的rehash过程类似于数组的收缩与扩容。</p>\n<h5 id=\"1-3-4-开放寻址法与链表法比较\"><a href=\"#1-3-4-开放寻址法与链表法比较\" class=\"headerlink\" title=\"1.3.4 开放寻址法与链表法比较\"></a>1.3.4 开放寻址法与链表法比较</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;对于开放寻址法解决冲突的散列表，由于数据都存储在数组中，因此可以有效地利用 CPU 缓存加快查询速度(数组占用一块连续的空间)。但是删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，负载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;对于链表法解决冲突的散列表,对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于1的情况。接近1时，就可能会有大量的散列冲突，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。但是，链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，而且链表中的结点是零散分布在内存中的，不是连续的，所以对CPU缓存是不友好的，这对于执行效率有一定的影响。</p>\n<h3 id=\"二、Redis字典\"><a href=\"#二、Redis字典\" class=\"headerlink\" title=\"二、Redis字典\"></a>二、Redis字典</h3><h4 id=\"2-1-Redis字典的实现\"><a href=\"#2-1-Redis字典的实现\" class=\"headerlink\" title=\"2.1 Redis字典的实现\"></a>2.1 Redis字典的实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Redis字典使用散列表最为底层实现，一个散列表里面有多个散列表节点，每个散列表节点就保存了字典中的一个键值对。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/43712743.jpg\" alt></p>\n<h5 id=\"2-1-1-字典\"><a href=\"#2-1-1-字典\" class=\"headerlink\" title=\"2.1.1 字典\"></a>2.1.1 字典</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span>&#123;</span></span><br><span class=\"line\">         <span class=\"comment\">//类型特定函数</span></span><br><span class=\"line\">         <span class=\"keyword\">void</span> *type;</span><br><span class=\"line\">         <span class=\"comment\">//私有数据</span></span><br><span class=\"line\">         <span class=\"keyword\">void</span> *privdata;</span><br><span class=\"line\">         <span class=\"comment\">//哈希表-见2.1.2</span></span><br><span class=\"line\">         dictht ht[<span class=\"number\">2</span>];</span><br><span class=\"line\">         <span class=\"comment\">//rehash 索引 当rehash不在进行时 值为-1</span></span><br><span class=\"line\">         <span class=\"keyword\">int</span> trehashidx; </span><br><span class=\"line\">&#125;dict;</span><br></pre></td></tr></table></figure>\n<p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的。</p>\n<ul>\n<li>type属性是一个指向dictType结构的指针，每个dictType用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</li>\n<li>privdata属性则保存了需要传给给那些类型特定函数的可选参数。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct dictType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">         //计算哈希值的函数 </span><br><span class=\"line\">         unsigned int  (*hashFunction) (const void *key);</span><br><span class=\"line\">         //复制键的函数</span><br><span class=\"line\">         void *(*keyDup) (void *privdata,const void *key);</span><br><span class=\"line\">         //复制值的函数</span><br><span class=\"line\">         void *(*keyDup) (void *privdata,const void *obj);</span><br><span class=\"line\">          //复制值的函数</span><br><span class=\"line\">         void *(*keyCompare) (void *privdata,const void *key1, const void *key2);</span><br><span class=\"line\">         //销毁键的函数</span><br><span class=\"line\">         void (*keyDestructor) (void *privdata, void *key);</span><br><span class=\"line\">         //销毁值的函数</span><br><span class=\"line\">         void (*keyDestructor) (void *privdata, void *obj);</span><br><span class=\"line\">&#125;dictType;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表， 一般情况下，字典只使用ht[0] 哈希表, ht[1]哈希表只会对ht[0]哈希表进行rehash时使用。</li>\n<li>rehashidx记录了rehash目前的进度，如果目前没有进行rehash，值为-1。</li>\n</ul>\n<h5 id=\"2-1-2-散列表\"><a href=\"#2-1-2-散列表\" class=\"headerlink\" title=\"2.1.2 散列表\"></a>2.1.2 散列表</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictht</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">         <span class=\"comment\">//哈希表数组，C语言中，*号是为了表明该变量为指针，有几个* 号就相当于是几级指针，这里是二级指针，理解为指向指针的指针</span></span><br><span class=\"line\">         dictEntry **table;</span><br><span class=\"line\">         <span class=\"comment\">//哈希表大小</span></span><br><span class=\"line\">         <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size;</span><br><span class=\"line\">         <span class=\"comment\">//哈希表大小掩码，用于计算索引值</span></span><br><span class=\"line\">         <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> sizemask;</span><br><span class=\"line\">         <span class=\"comment\">//该哈希已有节点的数量</span></span><br><span class=\"line\">         <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> used;</span><br><span class=\"line\">&#125;dictht;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对</li>\n<li>size属性记录了哈希表的大小，也是table数组的大小</li>\n<li>used属性则记录哈希表目前已有节点(键值对)的数量</li>\n<li>sizemask属性的值总是等于 size-1(从0开始)，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面（索引下标值）。</li>\n</ul>\n<h5 id=\"2-1-3-散列表节点\"><a href=\"#2-1-3-散列表节点\" class=\"headerlink\" title=\"2.1.3 散列表节点\"></a>2.1.3 散列表节点</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//哈希表节点定义dictEntry结构表示，每个dictEntry结构都保存着一个键值对。</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">         <span class=\"comment\">//键</span></span><br><span class=\"line\">         <span class=\"keyword\">void</span> *key;</span><br><span class=\"line\">         <span class=\"comment\">//值</span></span><br><span class=\"line\">         <span class=\"keyword\">union</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">void</span> *val;</span><br><span class=\"line\">            uint64_tu64;</span><br><span class=\"line\">            int64_ts64;</span><br><span class=\"line\">            &#125;v;</span><br><span class=\"line\">         <span class=\"comment\">// 指向下个哈希表节点，形成链表</span></span><br><span class=\"line\">         <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dictEntry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;dictEntry;</span><br></pre></td></tr></table></figure>\n<p>key属性保存着键值中的键，而v属性则保存着键值对中的值，其中键值(v属性)可以是一个指针，或uint64_t整数，或int64_t整数。 next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，解决键冲突问题。</p>\n<h4 id=\"2-2-Redis如何解决散列冲突\"><a href=\"#2-2-Redis如何解决散列冲突\" class=\"headerlink\" title=\"2.2 Redis如何解决散列冲突\"></a>2.2 Redis如何解决散列冲突</h4><h5 id=\"2-2-1-链表法\"><a href=\"#2-2-1-链表法\" class=\"headerlink\" title=\"2.2.1 链表法\"></a>2.2.1 链表法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;当有两个或以上的键被分配到散列表数组同一个索引上时，就发生了键冲突。Redis使用链表法解决散列冲突。每个散列表节点都有一个next指针，多个散列表节点next可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以使用这个单向链表连接起来。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/50308918.jpg\" alt=\"Redis 链表法\"></p>\n<p>如图所示,当键k0和k1的经过散列函数得到索引值都为1时，就会使用next指针将两个节点连接起来。而由于节点没有指向链尾的指针，因此新的节点总是插入到链表的头部，排在已有节点的前面。</p>\n<h5 id=\"2-2-2-Redis-rehash\"><a href=\"#2-2-2-Redis-rehash\" class=\"headerlink\" title=\"2.2.2 Redis rehash\"></a>2.2.2 Redis rehash</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;随着操作的进行，散列表中保存的键值对会也会不断地增加或减少，为了保证负载因子维持在一个合理的范围，当散列表内的键值对过多或过少时，内需要定期进行rehash，以提升性能或节省内存。Redis的rehash的步骤如下:</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/7685902.jpg\" alt></p>\n<ol>\n<li><p>为字典的ht[1]散列表分配空间，这个空间的大小取决于要执行的操作以及ht[0]当前包含的键值对数量(即:ht[0].used的属性值)</p>\n<ul>\n<li>扩展操作：ht[1]的大小为 第一个大于等于ht[0].used*2的2的n次方幂。如:ht[0].used=3则ht[1]的大小为8，ht[0].used=4则ht[1]的大小为8。</li>\n<li>收缩操作: ht[1]的大小为 第一个大于等于ht[0].used的2的n次方幂。</li>\n</ul>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/6383938.jpg\" alt></p>\n</li>\n<li><p>将保存在ht[0]中的键值对重新计算键的散列值和索引值，然后放到ht[1]指定的位置上。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/13728022.jpg\" alt></p>\n</li>\n<li><p>将ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0],将ht[1]设置为ht[0],并创建一个新的ht[1]哈希表为下一次rehash做准备。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-20/38258178.jpg\" alt></p>\n</li>\n</ol>\n<p><strong>rehash操作需要满足以下条件:</strong></p>\n<ol>\n<li>服务器目前没有执行BGSAVE(rdb持久化)命令或者BGREWRITEAOF(AOF文件重写)命令，并且散列表的负载因子大于等于1。</li>\n<li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且负载因子大于等于5。</li>\n<li>当负载因子小于0.1时，程序自动开始执行收缩操作。</li>\n</ol>\n<p>Redis这么做的目的是基于操作系统创建子进程后写时复制技术，避免不必要的写入操作。(有关BGSAVE、BGREWRITEAOF以及写时复制会在后续持久化一文详细介绍)。</p>\n<h5 id=\"2-2-3-渐进式-rehash\"><a href=\"#2-2-3-渐进式-rehash\" class=\"headerlink\" title=\"2.2.3 渐进式 rehash\"></a>2.2.3 渐进式 rehash</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;对于rehash我们思考一个问题如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表。这种情况听着就很耗时，而生产环境中甚至会更大。为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。当负载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次一次性数据搬移，插入操作就都变得很快了。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Redis为了解决这个问题采用渐进式rehash方式。以下是Redis渐进式rehash的详细步骤:</p>\n<ol>\n<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>\n<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ，表示 rehash 工作正式开始。</li>\n<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>\n<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>\n</ol>\n<p><strong>说明: </strong></p>\n<p><strong>1.因为在进行渐进式 rehash 的过程中，字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表，所以在渐进式 rehash 进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。</strong></p>\n<p><strong>2. 在渐进式 rehash 执行期间，新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面，而 <code>ht[0]</code> 则不再进行任何添加操作：这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增，并随着 rehash 操作的执行而最终变成空表。</strong></p>\n<h4 id=\"2-3-时间复杂度\"><a href=\"#2-3-时间复杂度\" class=\"headerlink\" title=\"2.3 时间复杂度\"></a>2.3 时间复杂度</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;下面给出几个Redis字典常见操作的时间复杂度，可以结合上面的内容分析为什么。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>创建一个新字典</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>将给定的键值对添加到字典内</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>将给定的键值对添加到字典内，如果键存在则替换之</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>返回给定键的值</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>从字典中随机返回一个键值对</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>从字典中删除给定键所对应的键值对</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>释放给定字典以及字典中包含的键值对</td>\n<td>O(N)，N为字典包含的键值对的数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"本文重点\"><a href=\"#本文重点\" class=\"headerlink\" title=\"本文重点\"></a>本文重点</h3><ol>\n<li>字典在redis中广泛应用，包括数据库和hash数据结构。</li>\n<li>每个字典有两个哈希表，一个是正常使用，一个用于rehash期间使用。</li>\n<li>当redis计算哈希时，采用的是MurmurHash2哈希算法。</li>\n<li>哈希表采用链表法解决散列冲突，被分配到同一个地址的键会构成一个单向链表。</li>\n<li>在rehash对哈希表进行扩展或者收缩过程中，会将所有键值对进行迁移，并且这个迁移是渐进式的迁移。</li>\n</ol>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本篇文章主要回顾了散列表的概念，散列函数以及如何解决散列冲突。并分析了Redis中字典的实现。下篇文章将介绍跳跃表以及跳跃表在Redis中的实现。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《Redis设计与实现》</p>\n<p>《Redis开发与运维》</p>\n<p>《Redis官方文档》</p>"},{"title":"RabbitMQ的使用思考篇","date":"2018-11-13T01:07:41.000Z","aside":"rabbitmq","_content":"\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;前面的两篇文章，我们简单介绍了消息中间件与RabbitMQ的一些基本概念、基础用法以及常用的几个特性。但如果我们想更好的去结合我们的业务场景使用好RabbitMQ，我们还需要思考一些问题。比如:何时去创建队列,RabbitMQ的持久化，如何保证消息到达RabbitMQ，以及消费者如何确认消息......\n\n<!--more-->\n\n### 系列文章\n\n[分布式系统消息中间件——RabbitMQ的使用基础篇](http://blog.loading.ink/2018/11/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/)\n\n[分布式系统消息中间件——RabbitMQ的使用进阶篇](http://blog.loading.ink/2018/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/)\n\n[分布式系统消息中间件——RabbitMQ的使用思考篇](http://blog.loading.ink/2018/11/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%9D%E8%80%83%E7%AF%87/)\n\n### 一、何时创建队列\n\n&nbsp;&nbsp;&nbsp;&nbsp;从前面的文章我们知道，RabbitMQ可以选择在生产者创建队列，也可以在消费者端创建队列，也可以提前创建好队列，而生产者消费者直接使用即可。\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ的消息存储在队列中，交换器的使用并不真正耗费服务器的性能，而队列会。如在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值，以便在固定硬件资源的情况下能够进行合理有效的分配。\n\n&nbsp;&nbsp;&nbsp;&nbsp;按照RabbitMQ官方建议，生产者和消费者都应该尝试创建(这里指声明操作)队列。这虽然是一个很好的建议，但是在我看来这个时间上没有最好的方案，只有最适合的方案。我们往往需要结合业务、资源等方面在各种方案里面选择一个最适合我们的方案。\n\n&nbsp;&nbsp;&nbsp;&nbsp;如果业务本身在架构设计之初己经充分地预估了队列的使用情况，完全可以在业务程序上线之前在服务器上创建好(比如通过页面管理、RabbitMQ命令或者更好的是从配置中心下发)，这样业务程序也可以免去声明的过程，直接使用即可。预先创建好资源还有一个好处是，可以确保交换器和队列之间正确地绑定匹配。很多时候，由于人为因素、代码缺陷等，发送消息的交换器并没有绑定任何队列，那么消息将会丢失:或者交换器绑定了某个队列，但是发送消息时的路由键无法与现存的队列匹配，那么消息也会丢失。当然可以配合mandatory参数或者备份交换器(关于mandatory参数的使用详细可参考我的上一篇文章) 来提高程序的健壮性。与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预定的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列迁移到其他集群。迁移的过程也可以对业务程序完全透明。此种方法也更有利于开发和运维分工，便于相应资源的管理。如果集群资源充足，而即将使用的队列所占用的资源又在可控的范围之内，为了增加业务程序的灵活性，也完全可以在业务程序中声明队列。至于是使用预先分配创建资源的静态方式还是动态的创建方式，需要从业务逻辑本身、公司运维体系和公司硬件资源等方面考虑。\n\n### 二、持久化及策略\n\n&nbsp;&nbsp;&nbsp;&nbsp;作为一个内存中间件，在保证了速度的情况下，不可避免存在如内存数据库同样的问题，即丢失问题。持久化可以提高RabbitMQ 的可靠性，以防在异常情况(重启、关闭、宕机等)下的数据丢失。RabbitMQ的持久化分为三个部分:交换器的持久化、队列的持久化和消息的持久化。\n\n1. 交换器的持久化\n\n&nbsp;&nbsp;&nbsp;&nbsp;交换器的持久化是通过在声明队列是将durable 参数置为true 实现的(该参数默认为false)。如果交换器不设置持久化，那么在RabbitMQ 服务重启之后，相关的交换器元数据会丢失，不过消息不会丢失，只是不能将消息发送到这个交换器中了。对一个长期使用的交换器来说，建议将其置为持久化的。\n\n2. 队列的持久化\n\n&nbsp;&nbsp;&nbsp;&nbsp;队列的持久化是通过在声明队列时将durable 参数置为true 实现的(该参数默认为false)，如果队列不设置持久化，那么在RabbitMQ 服务重启之后，相关队列的元数据会丢失，此时数据也会丢失。正所谓\"皮之不存，毛将焉附\"，队列都没有了，消息又能存在哪里呢?\n\n3. 消息的持久化\n\n&nbsp;&nbsp;&nbsp;&nbsp;队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。通过将消息的投递模式(BasicProperties中的DeliveryMode属性)设置为2即可实现消息的持久化。\n\n&nbsp;&nbsp;&nbsp;&nbsp;因此，消息如果要想在Rabbit重启、关闭、宕机时能够恢复，需要做到以下三点:\n\n* 把消息的投递模式设置为2\n* 发送到持久化的交换器\n* 到达持久化的队列\n\n&nbsp;&nbsp;&nbsp;&nbsp;**注意:RabbitMQ 确保持久化消息能从服务器重启中恢复的方式是将它们写入磁盘上的一个持久化日志文件中。当发布一条持久化消息到持久化交换器时，Rabbit会在日志提交到日志文件后才发送响应(开启生产者确认机制)。之后，如果消息到了非持久化队列，它会自动从日志文件中删除，并且无法在服务器重启后恢复。因此单单只设置队列持久化，重启之后消息会丢失;单单只设置消息的持久化，重启之后队列消失，继而消息也丢失。单单设置消息持久化而不设置队列的持久化是毫无意义的。当从持久化队列中消费了消息后(并且确认后)，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。而在消费持久化消息之前，若RabbitMQ服务器重启，会自动重建交换器、队列以及绑定，重播持久化日志文件中的消息到合适的队列或者交换器上(取决于宕机时，消息处在路由的哪个环节)。**\n\n&nbsp;&nbsp;&nbsp;&nbsp;为了保障消息不会丢失，也许我们可以简单粗暴的将所有的消息标记为持久化，但这样我们会付出性能的代价。写入磁盘的速度比写入内存的速度慢得不只一点点。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一个权衡。\n\n&nbsp;&nbsp;&nbsp;&nbsp;将交换器、队列、消息都设置了持久化之后就能百分之百保证数据不丢失了吗?\n\n* 从消费者来说，如果在订阅消费队列时将noAck参数设置为true ，那么当消费者接收到相关消息之后，还没来得及处理就宕机了，这样也算数据丢失。\n* 在持久化的消息正确存入RabbitMQ 之后，还需要有一段时间(虽然很短，但是不可忽视〉才能存入磁盘之中。RabbitMQ 并不会为每条消息都进行同步存盘的处理，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。如果在这段时间内RabbitMQ 服务节点发生了岩机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。\n\n&nbsp;&nbsp;&nbsp;&nbsp;关于第一个问题，可以通过消费者确认机制来解决。而第二个问题可以通过生产者确认机制来解决，也可以使用镜像队列机制(镜像队列机制，将在运维篇总结)。生产者确认消费者确认请往下看。\n\n### 三、生产者确认\n\n&nbsp;&nbsp;&nbsp;&nbsp;上文我们知道，在使用RabbitMQ的时候，可以通过消息持久化操作来解决因为服务器的异常崩溃而导致的消息丢失，除此之外，我们还会遇到一个问题，当消息的生产者将消息发送出去之后，消息到底有没有正确地到达服务器呢?如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，也就是默认情况下生产者是不知道消息有没有正确地到达服务器。如果在消息到达服务器之前己经丢失，持久化操作也解决不了这个问题，因为消息根本没有到达服务器，何谈持久化?\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ针对这个问题，提供了两种解决方式:\n\n* 通过事务机制实现:\n* 通过发送方确认(publisher confirm)机制实现。\n\n#### 3.1 RabbitMQ 事务机制\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 客户端中与事务机制相关的方法有三个:channel.TxSelect(用于将当前信道设置为事务模式);channel.TxCommit(用于提交事务)，channel.TxRollback(用于回滚事务)。在通过channel.TxSelect方法开启事务之后，我们便可以发布消息给RabbitMQ了，如果事务提交成功，则消息一定到达了RabbitMQ 中，如果在事务提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行channel.TxRollback方法来实现事务回滚。示例代码如下所示:\n\n```c#\n  channel.TxSelect();//将信道设置为事务模式\n  try\n  {\n      //do something\n      var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n      channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey\", true, null, message);\n      //do something\n      channel.TxCommit();//提交事务\n  }\n  catch (Exception ex)\n  {\n      //log(ex);\n      channel.TxRollback();\n  }\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;事务确实能够解决消息发送方和RabbitMQ之间消息确认的问题，只有消息成功被RabbitMQ接收，事务才能提交成功，否则便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。但是使用事务同样会带来一些问题。\n\n* 会阻塞，发布者必须等待broker处理每个消息。\n* 事务是重量级的，每次提交都需要fsync()，需要耗费大量的时间\n* 事务非常耗性能，会降低RabbitMQ的消息吞吐量。\n\n#### 3.2 发送方确认机制\n\n&nbsp;&nbsp;&nbsp;&nbsp;前面介绍了RabbitMQ可能会遇到的一个问题，即消息发送方(生产者〉并不知道消息是否真正地到达了RabbitMQ。随后了解到在AMQP协议层面提供了事务机制来解决这个问题，但是采用事务机制实现会严重降低RabbitMQ的消息吞吐量，这里就引入了一种轻量级的方式一发送方确认(publisher confirm)机制。生产者将信道设置成confirm确认)模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID( 从1开始)，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认(BasicAck) 给生产者(包含消息的唯一ID)，这就使得生产者知晓消息已经正确到达了目的地了。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。\n\n![RabbitMQ发送方确认机制](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-13/17508911.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;发送方确认模式，示例代码如下:\n\n```c#\n //示例1--同步等待\n channel.ConfirmSelect();//开启确认模式\n var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n channel.ExchangeDeclare(\"normalExchange\", \"direct\", true, false, null);\n channel.QueueDeclare(\"normalQueue\", true, false, false, null);\n channel.QueueBind(\"normalQueue\", \"normalExchange\", \"NormalRoutingKey\");\n channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey\", true, null, message);\n //var result=channel.WaitForConfirmsOrDie(Timeout); \n //WaitForConfirmsOrDie 使用WaitForConfirmsOrDie 在Rabbit发送Nack命令或超时时会抛出一个异常\n var result = channel.WaitForConfirms();//等待该信道所有未确认的消息结果\n if(!result){\n     //send message failed;\n }\n```\n\n```c#\n //示例2--异步通知\n channel.ConfirmSelect();//开启确认模式\n var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n channel.ExchangeDeclare(\"normalExchange\", \"direct\", true, false, null);\n channel.QueueDeclare(\"normalQueue\", true, false, false, null);\n channel.QueueBind(\"normalQueue\", \"normalExchange\", \"NormalRoutingKey\");\n channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey\", true, null, message);\n channel.BasicAcks += (model, ea) =>\n {\n     //消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认(Basic.Ack)给生产者(包含消息的唯一ID)\n     //ea.Multiple为True代表 ea.DeliveryTag编号之前的消息均已被确认。\n\t//do something;\n };\n channel.BasicNacks += (model, ea) =>\n {\n     //如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条nack(BasicNack) 命令\n\t//do something;\n };\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;关于生产者确认机制同样会有一些问题，broker不能保证消息会被confirm，只知道将会进行confirm。这样如果broker与生产者之间的连接断开，导致生产者不能收到确认消息，可能会重复进行发布。总之，生产者确认模式给客户端提供了一种较为轻量级的方式，能够跟踪哪些消息被broker处理，哪些可能因为broker宕掉或者网络失败的情况而重新发布。\n\n**&nbsp;&nbsp;&nbsp;&nbsp;注意:事务机制和publisher confirm机制两者是互斥的，不能共存。如果企图将已开启事务模式的信道再设置为publisher confmn模式， RabbitMQ会报错,或者如果企图将已开启publisher confirm模式的信道设置为事务模式， RabbitMQ也会报错。在性能上来看，而到底应该选择事务机制还是Confirm机制，则需要结合我们的业务场景。**\n\n### 四、消费者确认\n\n&nbsp;&nbsp;&nbsp;&nbsp;为了保证消息从队列可靠地达到消费者，RabbitMQ提供了消息确认机制(message acknowledgement)。消费者在订阅队列时，可以指定noAck参数，当noAck等于false时，RabbitMQ会等待消费者显式地回复确认信号后才从内存(或者磁盘)中移去消息(实质上是先打上删除标记，之后再删除)。当noAck等于true时，RabbitMQ会自动把发送出去的消息置为确认，然后从内存(或者磁盘)中删除，而不管消费者是否真正地消费到了这些消息。\n\n&nbsp;&nbsp;&nbsp;&nbsp;采用消息确认机制后，只要设置noAck参数为false，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直等待持有消息直到消费者显式调用BasicAck命令为止。\n\n&nbsp;&nbsp;&nbsp;&nbsp;当noAck参数置为false，对于RabbitMQ服务端而言，队列中的消息分成了两个部分:一部分是等待投递给消费者的消息:一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。如果RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开，这么设计的原因是RabbitMQ 允许消费者消费一条消息的时间可以很久很久。\n\n&nbsp;&nbsp;&nbsp;&nbsp;关于RabbitMQ消费者确认机制示例代码如下:\n\n```c#\n  //推模式\n  EventingBasicConsumer consumer = new EventingBasicConsumer(channel);\n  //定义消费者回调事件\n  consumer.Received += (model, ea) =>\n  {\n      //do someting;\n      //channel.BasicReject(ea.DeliveryTag, requeue: true);//拒绝\n      //requeue参数为true会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者\n      channel.BasicAck(ea.DeliveryTag, multiple: false);//确认\n      //若:multiple参数为true，则确认DeliverTag这个编号之前的消息\n  };\n  channel.BasicConsume(queue: \"queueName\",\n                      noAck: false,\n                     consumer: consumer);\n\n  //拉模式\n  BasicGetResult result = channel.BasicGet(\"queueName\", noAck: false);\n  //确认\n  channel.BasicAck(result.DeliveryTag, multiple: false);\n```\n\n![RabbitMQ 消费者确认](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-25/36944382.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上，消费者在消费消息的同时，Rabbit会同步给予消费者一个DeliveryTag，这个DeliveryTag就像我们数据库中的主键，消费者在消费完毕后拿着这个DeliveryTag去Rabbit确认或拒绝这个消息。\n\n```c#\nvoid BasicAck(ulong deliveryTag, bool multiple);\n\nvoid BasicReject(ulong deliveryTag, bool requeue);\n\nvoid BasicNack(ulong deliveryTag, bool multiple, bool requeue);\n```\n\n* deliveryTag:可以看作消息的编号，它是一个64位的长整型值，最大值是9223372036854775807。\n* requeue:如果requeue 参数设置为true，则RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者;如果requeue 参数设置为false，则RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。\n* BasicReject命令一次只能拒绝一条消息，如果想要批量拒绝消息，则可以使用Basic.Nack这个命令。\n* multiple:在BasicAck中，multiple 参数设置为true 则表示确认deliveryTag编号之前所有已被当前消费者确认的消息。在BasicNack中，multiple 参数设置为true 则表示拒绝deliveryTag 编号之前所有未被当前消费者确认的消息。\n\n**&nbsp;&nbsp;&nbsp;&nbsp;说明:将channel.BasicReject 或者channel.BasicNack中的requeue设置为false ，可以启用\"死信队列\"的功能。**(关于死信队列请看我的上一篇文章 https://www.cnblogs.com/hunternet/p/9697754.html）。\n\n&nbsp;&nbsp;&nbsp;&nbsp;上述requeue，都会将消息重新存入队列发送给下一个消费者(也有可能是其它消费者)。关于requeue还有下面一种用法。可以选择是否补发给当前的consumer。\n\n```c#\n//补发消息 true退回到queue中 /false只补发给当前的consumer\nchannel.BasicRecover(true);\n```\n\n**&nbsp;&nbsp;&nbsp;&nbsp;注意：RabbitMQ仅仅通过Consumer的连接中断来确认该Message并没有被正确处理。也就是说，RabbitMQ给了Consumer足够长的时间来做数据处理。如果忘记了ack，那么后果很严重。当Consumer退出时，Message会重新分发。然后RabbitMQ会占用越来越多的内存，由于RabbitMQ会长时间运行，这个“内存泄漏”是致命的。**\n\n### 五、消息分发与顺序\n\n#### 5.1 消息分发\n\n&nbsp;&nbsp;&nbsp;&nbsp;当RabbitMQ 队列拥有多个消费者时，队列收到的消息将以轮询(round-robin)的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者。这种方式非常适合扩展，而且它是专门为并发程序设计的。如果现在负载加重，那么只需要创建更多的消费者来消费处理消息即可。\n&nbsp;&nbsp;&nbsp;&nbsp;很多时候轮询的分发机制也不是那么优雅。默认情况下，如果有n个消费者，那么RabbitMQ会将第m条消息分发给第m%n (取余的方式)个消费者， RabbitMQ 不管消费者是否消费并己经确认了消息。试想一下，如果某些消费者任务繁重，来不及消费那么多的消息，而某些其他消费者由于某些原因(比如业务逻辑简单、机器性能卓越等)很快地处理完了所分配到的消息，进而进程空闲，这样就会造成整体应用吞吐量的下降。那么该如何处理这种情况呢?这里就要用到channel.BasicQos(int prefetchCount)这个方法，channel.BasicQos方法允许限制信道上的消费者所能保持的最大未确认消息的数量。\n&nbsp;&nbsp;&nbsp;&nbsp;举例说明，在订阅消费队列之前，消费端程序调用了channel.BasicQos(5)，之后订阅了某个队列进行消费。RabbitMQ 会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么RabbitMQ 就不会向这个消费者再发送任何消息。直到消费者确认了某条消息之后， RabbitMQ 将相应的计数减1，之后消费者可以继续接收消息，直到再次到达计数上限。\n\n**注意:Basic.Qos 的使用对于拉模式的消费方式无效.**\n\n```c#\nvoid BasicQos(uint prefetchSize, ushort prefetchCount, bool global);\n```\n\n* prefetchCount：允许限制信道上的消费者所能保持的最大未确认消息的数量，设置为0表示没有上限。\n* prefetchSize：消费者所能接收未确认消息的总体大小的上限，单位为B，设置为0表示没有上限。\n* global：对于一个信道来说，它可以同时消费多个队列，当设置了prefetchCount 大于0 时，这个信道需要和各个队列协调以确保发送的消息都没有超过所限定的prefetchCount 的值，这样会使RabbitMQ 的性能降低，尤其是这些队列分散在集群中的多个Broker节点之中。RabbitMQ 为了提升相关的性能，在AMQPO-9-1 协议之上重新定义了global这个参数。如下表所示:\n\n| global参数 | AMQP 0-9-1                                                   | RabbitMQ                                         |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------ |\n| false      | 信道上所有的消费者都需要遵从prefetchCount 的限信道上新的消费者需要遵从prefetchCount 的限定值 | 信道上新的消费者需要遵从prefetchCount 的限定值   |\n| true       | 当前通信链路( Connection) 上所有的消费者都需信道上所有的消费者都需要遵从prefetchCount的限定值 | 信道上所有的消费者需要遵从prefetchCount 的限定值 |\n\n**注意:**\n\n1. 对于同一个信道上的多个消费者而言，如果设置了prefetchCount 的值，那么都会生效。\n\n```c#\n//伪代码\nConsumer consumer1 = ...;\nConsumer consumer2 = ...;\nchannel.BasicQos(10) ; \nchannel.BasicConsume(\"my-queue1\" , false , consumer1);\nchannel.BasicConsume(\"my-queue2\" , false , consumer2);\n//两个消费者各自的能接收到的未确认消息的上限都为10 。\n```\n\n2. 如果在订阅消息之前，既设置了global 为true 的限制，又设置了global为false的限制,RabbitMQ 会确保两者都会生效。但会增加RabbitMQ的负载因为RabbitMQ 需要更多的资源来协调完成这些限制。\n\n```c#\n//伪代码\nChannel channel = ...;\nConsumer consumerl = ...;\nConsumer consumer2 = ...;\nchannel.BasicQos(3 , false); \nchannel.BasicQos(5 , true); \nchannel.BasicConsume(\"queuel\" , false , consumerl) ;\nchannel.BasicConsume(\"queue2\" , false , consumer2) ;\n//这里每个消费者最多只能收到3个未确认的消息，两个消费者能收到的未确认的消息个数之和的上限为5\n```\n\n#### 5.2 消息顺序\n\n&nbsp;&nbsp;&nbsp;&nbsp;消息的顺序性是指消费者消费到的消息和发送者发布的消息的顺序是一致的。举个例子，不考虑消息重复的情况，如果生产者发布的消息分别为msgl、msg2、msg3，那么消费者必然也是按照msgl、msg2、msg3的顺序进行消费的。\n&nbsp;&nbsp;&nbsp;&nbsp;目前很多资料显示RabbitMQ的消息能够保障顺序性，这是不正确的，或者说这个观点有很大的局限性。在不使用任何RabbitMQ的高级特性，也没有消息丢失、网络故障之类异常的情况发生，并且只有一个消费者的情况下，最好也只有一个生产者的情况下可以保证消息的顺序性。如果有多个生产者同时发送消息，无法确定消息到达Broker 的前后顺序，也就无法验证消息的顺序性。\n&nbsp;&nbsp;&nbsp;&nbsp;那么哪些情况下RabbitMQ 的消息顺序性会被打破呢?下面介绍几种常见的情形。\n\n* 如果生产者使用了事务机制，在发送消息之后遇到异常进行了事务回滚，那么需要重新补偿发送这条消息，如果补偿发送是在另一个线程实现的，那么消息在生产者这个源头就出现了错序。同样，如果启用publisher confirm时，在发生超时、中断，又或者是收到RabbitMQ的BasicNack命令时，那么同样需要补偿发送，结果与事务机制一样会错序。或者这种说法有些牵强，我们可以固执地认为消息的顺序性保障是从存入队列之后开始的，而不是在发迭的时候开始的。\n\n* 考虑另一种情形，如果生产者发送的消息设置了不同的超时时间，井且也设置了死信队列，整体上来说相当于一个延迟队列，那么消费者在消费这个延迟队列的时候，消息的顺序必然不会和生产者发送消息的顺序一致。\n\n* 如果消息设置了优先级，那么消费者消费到的消息也必然不是顺序性的。\n\n* 如果一个队列按照前后顺序分有msg1， msg2、msg3、msg4这4 个消息，同时有ConsumerA和ConsumerB 这两个消费者同时订阅了这个队列。队列中的消息轮询分发到各个消费者之中，ConsumerA 中的消息为msg1和msg3，ConsumerB中的消息为msg2、msg4。ConsumerA收到消息msg1之后并不想处理而调用了BasicNack/BasicReject将消息拒绝，与此同时将requeue设置为true，这样这条消息就可以重新存入队列中。消息msg1之后被发送到了ConsumerB中，此时ConsumerB己经消费了msg2、msg4，之后再消费msg1.这样消息顺序性也就错乱了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;包括但不仅限于以上几种情形会使RabbitMQ 消息错序。如果要保证消息的顺序性，需要业务方使用的时候做进一步的处理。如在消息体内添加全局有序标识等。\n\n### 六、消息传输保障\n\n&nbsp;&nbsp;&nbsp;&nbsp;消息可靠传输一般是业务系统接入消息中间件时首要考虑的问题，一般消息中间件的消息\n传输保障分为三个层级。\n\n* At most once: 最多一次。消息可能会丢失，但绝不会重复传输。\n* At least once: 最少一次。消息绝不会丢失，但可能会重复传输。\n* Exactly once: 恰好一次。每条消息肯定会被传输一次且仅传输一次。\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 支持其中的\"最多一次\"和\"最少一次\"。其中\"最少一次\"投递实现需要考虑以下这个几个方面的内容:\n\n1. 消息生产者需要开启事务机制或者publisher confirm 机制，以确保消息可以可靠地传\n   输到RabbitMQ 中。\n2. 消息生产者需要配合使用mandatory参数或者备份交换器来确保消息能够从交换器\n   路由到队列中，进而能够保存下来而不会被丢弃。\n3. 消息和队列都需要进行持久化处理，以确保RabbitMQ服务器在遇到异常情况时不会造成消息丢失。\n4. 消费者在消费消息的同时需要将noAck设置为false，然后通过手动确认的方式去确认己经正确消费的消息，以避免在消费端引起不必要的消息丢失。\n\n&nbsp;&nbsp;&nbsp;&nbsp;\"最多一次\"的方式就无须考虑以上那些方面，生产者随意发送，消费者随意消费，不过这样很难确保消息不会重复消费。\n\n&nbsp;&nbsp;&nbsp;&nbsp;\"恰好一次\"是RabbitMQ目前无法保障的(目前我也不知道哪个中间件能够保证)。消费者在消费完一条消息之后向RabbitMQ 发送确认BasicAck命令，此时由于网络断开或者其他原因造成RabbitMQ并没有收到这个确认命令，那么RabbitMQ不会将此条消息标记删除。在重新建立连接之后，消费者还是会消费到这一条消息，这就造成了重复消费。再考虑一种情况，生产者在使用publisher confirm机制的时候，发送完一条消息等待RabbitMQ 返回确认通知，此时网络断开，生产者捕获到异常情况，为了确保消息可靠性选择重新发送，这样RabbitMQ中就有两条同样的消息，在消费的时候，消费者就会重复消费。而解决重复消费可以通过消费者幂等等方式来解决。\n\n### 结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;本篇文章，我们思考了使用RabbitMQ过程中需要注意的几个问题，而前两篇文章对RabbitMQ的概念以及如何使用做了简单的介绍，相信经过这些介绍已经对RabbitMQ有了基本的了解。但这些远远不够，想要更好的利用好RabbitMQ还需要结合我们的业务场景来更多的去使用它(切记不要为了使用技术而使用技术!)。关于RabbitMQ的运维篇，会在以后的文章中继续给大家分享。\n\n","source":"_posts/技术实践/rabbitmq/RabbitMQ的使用思考篇.md","raw":"---\ntitle: RabbitMQ的使用思考篇\ndate: 2018-11-13 09:07:41\ntags: \n- 消息队列\n- RabbitMQ\ncategories: 消息队列\naside: rabbitmq\n---\n\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;前面的两篇文章，我们简单介绍了消息中间件与RabbitMQ的一些基本概念、基础用法以及常用的几个特性。但如果我们想更好的去结合我们的业务场景使用好RabbitMQ，我们还需要思考一些问题。比如:何时去创建队列,RabbitMQ的持久化，如何保证消息到达RabbitMQ，以及消费者如何确认消息......\n\n<!--more-->\n\n### 系列文章\n\n[分布式系统消息中间件——RabbitMQ的使用基础篇](http://blog.loading.ink/2018/11/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/)\n\n[分布式系统消息中间件——RabbitMQ的使用进阶篇](http://blog.loading.ink/2018/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/)\n\n[分布式系统消息中间件——RabbitMQ的使用思考篇](http://blog.loading.ink/2018/11/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%9D%E8%80%83%E7%AF%87/)\n\n### 一、何时创建队列\n\n&nbsp;&nbsp;&nbsp;&nbsp;从前面的文章我们知道，RabbitMQ可以选择在生产者创建队列，也可以在消费者端创建队列，也可以提前创建好队列，而生产者消费者直接使用即可。\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ的消息存储在队列中，交换器的使用并不真正耗费服务器的性能，而队列会。如在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值，以便在固定硬件资源的情况下能够进行合理有效的分配。\n\n&nbsp;&nbsp;&nbsp;&nbsp;按照RabbitMQ官方建议，生产者和消费者都应该尝试创建(这里指声明操作)队列。这虽然是一个很好的建议，但是在我看来这个时间上没有最好的方案，只有最适合的方案。我们往往需要结合业务、资源等方面在各种方案里面选择一个最适合我们的方案。\n\n&nbsp;&nbsp;&nbsp;&nbsp;如果业务本身在架构设计之初己经充分地预估了队列的使用情况，完全可以在业务程序上线之前在服务器上创建好(比如通过页面管理、RabbitMQ命令或者更好的是从配置中心下发)，这样业务程序也可以免去声明的过程，直接使用即可。预先创建好资源还有一个好处是，可以确保交换器和队列之间正确地绑定匹配。很多时候，由于人为因素、代码缺陷等，发送消息的交换器并没有绑定任何队列，那么消息将会丢失:或者交换器绑定了某个队列，但是发送消息时的路由键无法与现存的队列匹配，那么消息也会丢失。当然可以配合mandatory参数或者备份交换器(关于mandatory参数的使用详细可参考我的上一篇文章) 来提高程序的健壮性。与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预定的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列迁移到其他集群。迁移的过程也可以对业务程序完全透明。此种方法也更有利于开发和运维分工，便于相应资源的管理。如果集群资源充足，而即将使用的队列所占用的资源又在可控的范围之内，为了增加业务程序的灵活性，也完全可以在业务程序中声明队列。至于是使用预先分配创建资源的静态方式还是动态的创建方式，需要从业务逻辑本身、公司运维体系和公司硬件资源等方面考虑。\n\n### 二、持久化及策略\n\n&nbsp;&nbsp;&nbsp;&nbsp;作为一个内存中间件，在保证了速度的情况下，不可避免存在如内存数据库同样的问题，即丢失问题。持久化可以提高RabbitMQ 的可靠性，以防在异常情况(重启、关闭、宕机等)下的数据丢失。RabbitMQ的持久化分为三个部分:交换器的持久化、队列的持久化和消息的持久化。\n\n1. 交换器的持久化\n\n&nbsp;&nbsp;&nbsp;&nbsp;交换器的持久化是通过在声明队列是将durable 参数置为true 实现的(该参数默认为false)。如果交换器不设置持久化，那么在RabbitMQ 服务重启之后，相关的交换器元数据会丢失，不过消息不会丢失，只是不能将消息发送到这个交换器中了。对一个长期使用的交换器来说，建议将其置为持久化的。\n\n2. 队列的持久化\n\n&nbsp;&nbsp;&nbsp;&nbsp;队列的持久化是通过在声明队列时将durable 参数置为true 实现的(该参数默认为false)，如果队列不设置持久化，那么在RabbitMQ 服务重启之后，相关队列的元数据会丢失，此时数据也会丢失。正所谓\"皮之不存，毛将焉附\"，队列都没有了，消息又能存在哪里呢?\n\n3. 消息的持久化\n\n&nbsp;&nbsp;&nbsp;&nbsp;队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。通过将消息的投递模式(BasicProperties中的DeliveryMode属性)设置为2即可实现消息的持久化。\n\n&nbsp;&nbsp;&nbsp;&nbsp;因此，消息如果要想在Rabbit重启、关闭、宕机时能够恢复，需要做到以下三点:\n\n* 把消息的投递模式设置为2\n* 发送到持久化的交换器\n* 到达持久化的队列\n\n&nbsp;&nbsp;&nbsp;&nbsp;**注意:RabbitMQ 确保持久化消息能从服务器重启中恢复的方式是将它们写入磁盘上的一个持久化日志文件中。当发布一条持久化消息到持久化交换器时，Rabbit会在日志提交到日志文件后才发送响应(开启生产者确认机制)。之后，如果消息到了非持久化队列，它会自动从日志文件中删除，并且无法在服务器重启后恢复。因此单单只设置队列持久化，重启之后消息会丢失;单单只设置消息的持久化，重启之后队列消失，继而消息也丢失。单单设置消息持久化而不设置队列的持久化是毫无意义的。当从持久化队列中消费了消息后(并且确认后)，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。而在消费持久化消息之前，若RabbitMQ服务器重启，会自动重建交换器、队列以及绑定，重播持久化日志文件中的消息到合适的队列或者交换器上(取决于宕机时，消息处在路由的哪个环节)。**\n\n&nbsp;&nbsp;&nbsp;&nbsp;为了保障消息不会丢失，也许我们可以简单粗暴的将所有的消息标记为持久化，但这样我们会付出性能的代价。写入磁盘的速度比写入内存的速度慢得不只一点点。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一个权衡。\n\n&nbsp;&nbsp;&nbsp;&nbsp;将交换器、队列、消息都设置了持久化之后就能百分之百保证数据不丢失了吗?\n\n* 从消费者来说，如果在订阅消费队列时将noAck参数设置为true ，那么当消费者接收到相关消息之后，还没来得及处理就宕机了，这样也算数据丢失。\n* 在持久化的消息正确存入RabbitMQ 之后，还需要有一段时间(虽然很短，但是不可忽视〉才能存入磁盘之中。RabbitMQ 并不会为每条消息都进行同步存盘的处理，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。如果在这段时间内RabbitMQ 服务节点发生了岩机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。\n\n&nbsp;&nbsp;&nbsp;&nbsp;关于第一个问题，可以通过消费者确认机制来解决。而第二个问题可以通过生产者确认机制来解决，也可以使用镜像队列机制(镜像队列机制，将在运维篇总结)。生产者确认消费者确认请往下看。\n\n### 三、生产者确认\n\n&nbsp;&nbsp;&nbsp;&nbsp;上文我们知道，在使用RabbitMQ的时候，可以通过消息持久化操作来解决因为服务器的异常崩溃而导致的消息丢失，除此之外，我们还会遇到一个问题，当消息的生产者将消息发送出去之后，消息到底有没有正确地到达服务器呢?如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，也就是默认情况下生产者是不知道消息有没有正确地到达服务器。如果在消息到达服务器之前己经丢失，持久化操作也解决不了这个问题，因为消息根本没有到达服务器，何谈持久化?\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ针对这个问题，提供了两种解决方式:\n\n* 通过事务机制实现:\n* 通过发送方确认(publisher confirm)机制实现。\n\n#### 3.1 RabbitMQ 事务机制\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 客户端中与事务机制相关的方法有三个:channel.TxSelect(用于将当前信道设置为事务模式);channel.TxCommit(用于提交事务)，channel.TxRollback(用于回滚事务)。在通过channel.TxSelect方法开启事务之后，我们便可以发布消息给RabbitMQ了，如果事务提交成功，则消息一定到达了RabbitMQ 中，如果在事务提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行channel.TxRollback方法来实现事务回滚。示例代码如下所示:\n\n```c#\n  channel.TxSelect();//将信道设置为事务模式\n  try\n  {\n      //do something\n      var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n      channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey\", true, null, message);\n      //do something\n      channel.TxCommit();//提交事务\n  }\n  catch (Exception ex)\n  {\n      //log(ex);\n      channel.TxRollback();\n  }\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;事务确实能够解决消息发送方和RabbitMQ之间消息确认的问题，只有消息成功被RabbitMQ接收，事务才能提交成功，否则便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。但是使用事务同样会带来一些问题。\n\n* 会阻塞，发布者必须等待broker处理每个消息。\n* 事务是重量级的，每次提交都需要fsync()，需要耗费大量的时间\n* 事务非常耗性能，会降低RabbitMQ的消息吞吐量。\n\n#### 3.2 发送方确认机制\n\n&nbsp;&nbsp;&nbsp;&nbsp;前面介绍了RabbitMQ可能会遇到的一个问题，即消息发送方(生产者〉并不知道消息是否真正地到达了RabbitMQ。随后了解到在AMQP协议层面提供了事务机制来解决这个问题，但是采用事务机制实现会严重降低RabbitMQ的消息吞吐量，这里就引入了一种轻量级的方式一发送方确认(publisher confirm)机制。生产者将信道设置成confirm确认)模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID( 从1开始)，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认(BasicAck) 给生产者(包含消息的唯一ID)，这就使得生产者知晓消息已经正确到达了目的地了。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。\n\n![RabbitMQ发送方确认机制](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-13/17508911.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;发送方确认模式，示例代码如下:\n\n```c#\n //示例1--同步等待\n channel.ConfirmSelect();//开启确认模式\n var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n channel.ExchangeDeclare(\"normalExchange\", \"direct\", true, false, null);\n channel.QueueDeclare(\"normalQueue\", true, false, false, null);\n channel.QueueBind(\"normalQueue\", \"normalExchange\", \"NormalRoutingKey\");\n channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey\", true, null, message);\n //var result=channel.WaitForConfirmsOrDie(Timeout); \n //WaitForConfirmsOrDie 使用WaitForConfirmsOrDie 在Rabbit发送Nack命令或超时时会抛出一个异常\n var result = channel.WaitForConfirms();//等待该信道所有未确认的消息结果\n if(!result){\n     //send message failed;\n }\n```\n\n```c#\n //示例2--异步通知\n channel.ConfirmSelect();//开启确认模式\n var message = Encoding.UTF8.GetBytes(\"TestMsg\");\n channel.ExchangeDeclare(\"normalExchange\", \"direct\", true, false, null);\n channel.QueueDeclare(\"normalQueue\", true, false, false, null);\n channel.QueueBind(\"normalQueue\", \"normalExchange\", \"NormalRoutingKey\");\n channel.BasicPublish(\"normalExchange\", \"NormalRoutingKey\", true, null, message);\n channel.BasicAcks += (model, ea) =>\n {\n     //消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认(Basic.Ack)给生产者(包含消息的唯一ID)\n     //ea.Multiple为True代表 ea.DeliveryTag编号之前的消息均已被确认。\n\t//do something;\n };\n channel.BasicNacks += (model, ea) =>\n {\n     //如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条nack(BasicNack) 命令\n\t//do something;\n };\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;关于生产者确认机制同样会有一些问题，broker不能保证消息会被confirm，只知道将会进行confirm。这样如果broker与生产者之间的连接断开，导致生产者不能收到确认消息，可能会重复进行发布。总之，生产者确认模式给客户端提供了一种较为轻量级的方式，能够跟踪哪些消息被broker处理，哪些可能因为broker宕掉或者网络失败的情况而重新发布。\n\n**&nbsp;&nbsp;&nbsp;&nbsp;注意:事务机制和publisher confirm机制两者是互斥的，不能共存。如果企图将已开启事务模式的信道再设置为publisher confmn模式， RabbitMQ会报错,或者如果企图将已开启publisher confirm模式的信道设置为事务模式， RabbitMQ也会报错。在性能上来看，而到底应该选择事务机制还是Confirm机制，则需要结合我们的业务场景。**\n\n### 四、消费者确认\n\n&nbsp;&nbsp;&nbsp;&nbsp;为了保证消息从队列可靠地达到消费者，RabbitMQ提供了消息确认机制(message acknowledgement)。消费者在订阅队列时，可以指定noAck参数，当noAck等于false时，RabbitMQ会等待消费者显式地回复确认信号后才从内存(或者磁盘)中移去消息(实质上是先打上删除标记，之后再删除)。当noAck等于true时，RabbitMQ会自动把发送出去的消息置为确认，然后从内存(或者磁盘)中删除，而不管消费者是否真正地消费到了这些消息。\n\n&nbsp;&nbsp;&nbsp;&nbsp;采用消息确认机制后，只要设置noAck参数为false，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直等待持有消息直到消费者显式调用BasicAck命令为止。\n\n&nbsp;&nbsp;&nbsp;&nbsp;当noAck参数置为false，对于RabbitMQ服务端而言，队列中的消息分成了两个部分:一部分是等待投递给消费者的消息:一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。如果RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开，这么设计的原因是RabbitMQ 允许消费者消费一条消息的时间可以很久很久。\n\n&nbsp;&nbsp;&nbsp;&nbsp;关于RabbitMQ消费者确认机制示例代码如下:\n\n```c#\n  //推模式\n  EventingBasicConsumer consumer = new EventingBasicConsumer(channel);\n  //定义消费者回调事件\n  consumer.Received += (model, ea) =>\n  {\n      //do someting;\n      //channel.BasicReject(ea.DeliveryTag, requeue: true);//拒绝\n      //requeue参数为true会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者\n      channel.BasicAck(ea.DeliveryTag, multiple: false);//确认\n      //若:multiple参数为true，则确认DeliverTag这个编号之前的消息\n  };\n  channel.BasicConsume(queue: \"queueName\",\n                      noAck: false,\n                     consumer: consumer);\n\n  //拉模式\n  BasicGetResult result = channel.BasicGet(\"queueName\", noAck: false);\n  //确认\n  channel.BasicAck(result.DeliveryTag, multiple: false);\n```\n\n![RabbitMQ 消费者确认](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-25/36944382.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上，消费者在消费消息的同时，Rabbit会同步给予消费者一个DeliveryTag，这个DeliveryTag就像我们数据库中的主键，消费者在消费完毕后拿着这个DeliveryTag去Rabbit确认或拒绝这个消息。\n\n```c#\nvoid BasicAck(ulong deliveryTag, bool multiple);\n\nvoid BasicReject(ulong deliveryTag, bool requeue);\n\nvoid BasicNack(ulong deliveryTag, bool multiple, bool requeue);\n```\n\n* deliveryTag:可以看作消息的编号，它是一个64位的长整型值，最大值是9223372036854775807。\n* requeue:如果requeue 参数设置为true，则RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者;如果requeue 参数设置为false，则RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。\n* BasicReject命令一次只能拒绝一条消息，如果想要批量拒绝消息，则可以使用Basic.Nack这个命令。\n* multiple:在BasicAck中，multiple 参数设置为true 则表示确认deliveryTag编号之前所有已被当前消费者确认的消息。在BasicNack中，multiple 参数设置为true 则表示拒绝deliveryTag 编号之前所有未被当前消费者确认的消息。\n\n**&nbsp;&nbsp;&nbsp;&nbsp;说明:将channel.BasicReject 或者channel.BasicNack中的requeue设置为false ，可以启用\"死信队列\"的功能。**(关于死信队列请看我的上一篇文章 https://www.cnblogs.com/hunternet/p/9697754.html）。\n\n&nbsp;&nbsp;&nbsp;&nbsp;上述requeue，都会将消息重新存入队列发送给下一个消费者(也有可能是其它消费者)。关于requeue还有下面一种用法。可以选择是否补发给当前的consumer。\n\n```c#\n//补发消息 true退回到queue中 /false只补发给当前的consumer\nchannel.BasicRecover(true);\n```\n\n**&nbsp;&nbsp;&nbsp;&nbsp;注意：RabbitMQ仅仅通过Consumer的连接中断来确认该Message并没有被正确处理。也就是说，RabbitMQ给了Consumer足够长的时间来做数据处理。如果忘记了ack，那么后果很严重。当Consumer退出时，Message会重新分发。然后RabbitMQ会占用越来越多的内存，由于RabbitMQ会长时间运行，这个“内存泄漏”是致命的。**\n\n### 五、消息分发与顺序\n\n#### 5.1 消息分发\n\n&nbsp;&nbsp;&nbsp;&nbsp;当RabbitMQ 队列拥有多个消费者时，队列收到的消息将以轮询(round-robin)的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者。这种方式非常适合扩展，而且它是专门为并发程序设计的。如果现在负载加重，那么只需要创建更多的消费者来消费处理消息即可。\n&nbsp;&nbsp;&nbsp;&nbsp;很多时候轮询的分发机制也不是那么优雅。默认情况下，如果有n个消费者，那么RabbitMQ会将第m条消息分发给第m%n (取余的方式)个消费者， RabbitMQ 不管消费者是否消费并己经确认了消息。试想一下，如果某些消费者任务繁重，来不及消费那么多的消息，而某些其他消费者由于某些原因(比如业务逻辑简单、机器性能卓越等)很快地处理完了所分配到的消息，进而进程空闲，这样就会造成整体应用吞吐量的下降。那么该如何处理这种情况呢?这里就要用到channel.BasicQos(int prefetchCount)这个方法，channel.BasicQos方法允许限制信道上的消费者所能保持的最大未确认消息的数量。\n&nbsp;&nbsp;&nbsp;&nbsp;举例说明，在订阅消费队列之前，消费端程序调用了channel.BasicQos(5)，之后订阅了某个队列进行消费。RabbitMQ 会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么RabbitMQ 就不会向这个消费者再发送任何消息。直到消费者确认了某条消息之后， RabbitMQ 将相应的计数减1，之后消费者可以继续接收消息，直到再次到达计数上限。\n\n**注意:Basic.Qos 的使用对于拉模式的消费方式无效.**\n\n```c#\nvoid BasicQos(uint prefetchSize, ushort prefetchCount, bool global);\n```\n\n* prefetchCount：允许限制信道上的消费者所能保持的最大未确认消息的数量，设置为0表示没有上限。\n* prefetchSize：消费者所能接收未确认消息的总体大小的上限，单位为B，设置为0表示没有上限。\n* global：对于一个信道来说，它可以同时消费多个队列，当设置了prefetchCount 大于0 时，这个信道需要和各个队列协调以确保发送的消息都没有超过所限定的prefetchCount 的值，这样会使RabbitMQ 的性能降低，尤其是这些队列分散在集群中的多个Broker节点之中。RabbitMQ 为了提升相关的性能，在AMQPO-9-1 协议之上重新定义了global这个参数。如下表所示:\n\n| global参数 | AMQP 0-9-1                                                   | RabbitMQ                                         |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------ |\n| false      | 信道上所有的消费者都需要遵从prefetchCount 的限信道上新的消费者需要遵从prefetchCount 的限定值 | 信道上新的消费者需要遵从prefetchCount 的限定值   |\n| true       | 当前通信链路( Connection) 上所有的消费者都需信道上所有的消费者都需要遵从prefetchCount的限定值 | 信道上所有的消费者需要遵从prefetchCount 的限定值 |\n\n**注意:**\n\n1. 对于同一个信道上的多个消费者而言，如果设置了prefetchCount 的值，那么都会生效。\n\n```c#\n//伪代码\nConsumer consumer1 = ...;\nConsumer consumer2 = ...;\nchannel.BasicQos(10) ; \nchannel.BasicConsume(\"my-queue1\" , false , consumer1);\nchannel.BasicConsume(\"my-queue2\" , false , consumer2);\n//两个消费者各自的能接收到的未确认消息的上限都为10 。\n```\n\n2. 如果在订阅消息之前，既设置了global 为true 的限制，又设置了global为false的限制,RabbitMQ 会确保两者都会生效。但会增加RabbitMQ的负载因为RabbitMQ 需要更多的资源来协调完成这些限制。\n\n```c#\n//伪代码\nChannel channel = ...;\nConsumer consumerl = ...;\nConsumer consumer2 = ...;\nchannel.BasicQos(3 , false); \nchannel.BasicQos(5 , true); \nchannel.BasicConsume(\"queuel\" , false , consumerl) ;\nchannel.BasicConsume(\"queue2\" , false , consumer2) ;\n//这里每个消费者最多只能收到3个未确认的消息，两个消费者能收到的未确认的消息个数之和的上限为5\n```\n\n#### 5.2 消息顺序\n\n&nbsp;&nbsp;&nbsp;&nbsp;消息的顺序性是指消费者消费到的消息和发送者发布的消息的顺序是一致的。举个例子，不考虑消息重复的情况，如果生产者发布的消息分别为msgl、msg2、msg3，那么消费者必然也是按照msgl、msg2、msg3的顺序进行消费的。\n&nbsp;&nbsp;&nbsp;&nbsp;目前很多资料显示RabbitMQ的消息能够保障顺序性，这是不正确的，或者说这个观点有很大的局限性。在不使用任何RabbitMQ的高级特性，也没有消息丢失、网络故障之类异常的情况发生，并且只有一个消费者的情况下，最好也只有一个生产者的情况下可以保证消息的顺序性。如果有多个生产者同时发送消息，无法确定消息到达Broker 的前后顺序，也就无法验证消息的顺序性。\n&nbsp;&nbsp;&nbsp;&nbsp;那么哪些情况下RabbitMQ 的消息顺序性会被打破呢?下面介绍几种常见的情形。\n\n* 如果生产者使用了事务机制，在发送消息之后遇到异常进行了事务回滚，那么需要重新补偿发送这条消息，如果补偿发送是在另一个线程实现的，那么消息在生产者这个源头就出现了错序。同样，如果启用publisher confirm时，在发生超时、中断，又或者是收到RabbitMQ的BasicNack命令时，那么同样需要补偿发送，结果与事务机制一样会错序。或者这种说法有些牵强，我们可以固执地认为消息的顺序性保障是从存入队列之后开始的，而不是在发迭的时候开始的。\n\n* 考虑另一种情形，如果生产者发送的消息设置了不同的超时时间，井且也设置了死信队列，整体上来说相当于一个延迟队列，那么消费者在消费这个延迟队列的时候，消息的顺序必然不会和生产者发送消息的顺序一致。\n\n* 如果消息设置了优先级，那么消费者消费到的消息也必然不是顺序性的。\n\n* 如果一个队列按照前后顺序分有msg1， msg2、msg3、msg4这4 个消息，同时有ConsumerA和ConsumerB 这两个消费者同时订阅了这个队列。队列中的消息轮询分发到各个消费者之中，ConsumerA 中的消息为msg1和msg3，ConsumerB中的消息为msg2、msg4。ConsumerA收到消息msg1之后并不想处理而调用了BasicNack/BasicReject将消息拒绝，与此同时将requeue设置为true，这样这条消息就可以重新存入队列中。消息msg1之后被发送到了ConsumerB中，此时ConsumerB己经消费了msg2、msg4，之后再消费msg1.这样消息顺序性也就错乱了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;包括但不仅限于以上几种情形会使RabbitMQ 消息错序。如果要保证消息的顺序性，需要业务方使用的时候做进一步的处理。如在消息体内添加全局有序标识等。\n\n### 六、消息传输保障\n\n&nbsp;&nbsp;&nbsp;&nbsp;消息可靠传输一般是业务系统接入消息中间件时首要考虑的问题，一般消息中间件的消息\n传输保障分为三个层级。\n\n* At most once: 最多一次。消息可能会丢失，但绝不会重复传输。\n* At least once: 最少一次。消息绝不会丢失，但可能会重复传输。\n* Exactly once: 恰好一次。每条消息肯定会被传输一次且仅传输一次。\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 支持其中的\"最多一次\"和\"最少一次\"。其中\"最少一次\"投递实现需要考虑以下这个几个方面的内容:\n\n1. 消息生产者需要开启事务机制或者publisher confirm 机制，以确保消息可以可靠地传\n   输到RabbitMQ 中。\n2. 消息生产者需要配合使用mandatory参数或者备份交换器来确保消息能够从交换器\n   路由到队列中，进而能够保存下来而不会被丢弃。\n3. 消息和队列都需要进行持久化处理，以确保RabbitMQ服务器在遇到异常情况时不会造成消息丢失。\n4. 消费者在消费消息的同时需要将noAck设置为false，然后通过手动确认的方式去确认己经正确消费的消息，以避免在消费端引起不必要的消息丢失。\n\n&nbsp;&nbsp;&nbsp;&nbsp;\"最多一次\"的方式就无须考虑以上那些方面，生产者随意发送，消费者随意消费，不过这样很难确保消息不会重复消费。\n\n&nbsp;&nbsp;&nbsp;&nbsp;\"恰好一次\"是RabbitMQ目前无法保障的(目前我也不知道哪个中间件能够保证)。消费者在消费完一条消息之后向RabbitMQ 发送确认BasicAck命令，此时由于网络断开或者其他原因造成RabbitMQ并没有收到这个确认命令，那么RabbitMQ不会将此条消息标记删除。在重新建立连接之后，消费者还是会消费到这一条消息，这就造成了重复消费。再考虑一种情况，生产者在使用publisher confirm机制的时候，发送完一条消息等待RabbitMQ 返回确认通知，此时网络断开，生产者捕获到异常情况，为了确保消息可靠性选择重新发送，这样RabbitMQ中就有两条同样的消息，在消费的时候，消费者就会重复消费。而解决重复消费可以通过消费者幂等等方式来解决。\n\n### 结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;本篇文章，我们思考了使用RabbitMQ过程中需要注意的几个问题，而前两篇文章对RabbitMQ的概念以及如何使用做了简单的介绍，相信经过这些介绍已经对RabbitMQ有了基本的了解。但这些远远不够，想要更好的利用好RabbitMQ还需要结合我们的业务场景来更多的去使用它(切记不要为了使用技术而使用技术!)。关于RabbitMQ的运维篇，会在以后的文章中继续给大家分享。\n\n","slug":"技术实践/rabbitmq/RabbitMQ的使用思考篇","published":1,"updated":"2021-03-14T03:04:50.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfq0h00gmhyjffl0pxrc4","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;前面的两篇文章，我们简单介绍了消息中间件与RabbitMQ的一些基本概念、基础用法以及常用的几个特性。但如果我们想更好的去结合我们的业务场景使用好RabbitMQ，我们还需要思考一些问题。比如:何时去创建队列,RabbitMQ的持久化，如何保证消息到达RabbitMQ，以及消费者如何确认消息……</p>\n<a id=\"more\"></a>\n<h3 id=\"系列文章\"><a href=\"#系列文章\" class=\"headerlink\" title=\"系列文章\"></a>系列文章</h3><p><a href=\"http://blog.loading.ink/2018/11/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用基础篇</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用进阶篇</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%9D%E8%80%83%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用思考篇</a></p>\n<h3 id=\"一、何时创建队列\"><a href=\"#一、何时创建队列\" class=\"headerlink\" title=\"一、何时创建队列\"></a>一、何时创建队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;从前面的文章我们知道，RabbitMQ可以选择在生产者创建队列，也可以在消费者端创建队列，也可以提前创建好队列，而生产者消费者直接使用即可。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ的消息存储在队列中，交换器的使用并不真正耗费服务器的性能，而队列会。如在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值，以便在固定硬件资源的情况下能够进行合理有效的分配。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;按照RabbitMQ官方建议，生产者和消费者都应该尝试创建(这里指声明操作)队列。这虽然是一个很好的建议，但是在我看来这个时间上没有最好的方案，只有最适合的方案。我们往往需要结合业务、资源等方面在各种方案里面选择一个最适合我们的方案。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如果业务本身在架构设计之初己经充分地预估了队列的使用情况，完全可以在业务程序上线之前在服务器上创建好(比如通过页面管理、RabbitMQ命令或者更好的是从配置中心下发)，这样业务程序也可以免去声明的过程，直接使用即可。预先创建好资源还有一个好处是，可以确保交换器和队列之间正确地绑定匹配。很多时候，由于人为因素、代码缺陷等，发送消息的交换器并没有绑定任何队列，那么消息将会丢失:或者交换器绑定了某个队列，但是发送消息时的路由键无法与现存的队列匹配，那么消息也会丢失。当然可以配合mandatory参数或者备份交换器(关于mandatory参数的使用详细可参考我的上一篇文章) 来提高程序的健壮性。与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预定的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列迁移到其他集群。迁移的过程也可以对业务程序完全透明。此种方法也更有利于开发和运维分工，便于相应资源的管理。如果集群资源充足，而即将使用的队列所占用的资源又在可控的范围之内，为了增加业务程序的灵活性，也完全可以在业务程序中声明队列。至于是使用预先分配创建资源的静态方式还是动态的创建方式，需要从业务逻辑本身、公司运维体系和公司硬件资源等方面考虑。</p>\n<h3 id=\"二、持久化及策略\"><a href=\"#二、持久化及策略\" class=\"headerlink\" title=\"二、持久化及策略\"></a>二、持久化及策略</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;作为一个内存中间件，在保证了速度的情况下，不可避免存在如内存数据库同样的问题，即丢失问题。持久化可以提高RabbitMQ 的可靠性，以防在异常情况(重启、关闭、宕机等)下的数据丢失。RabbitMQ的持久化分为三个部分:交换器的持久化、队列的持久化和消息的持久化。</p>\n<ol>\n<li>交换器的持久化</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;交换器的持久化是通过在声明队列是将durable 参数置为true 实现的(该参数默认为false)。如果交换器不设置持久化，那么在RabbitMQ 服务重启之后，相关的交换器元数据会丢失，不过消息不会丢失，只是不能将消息发送到这个交换器中了。对一个长期使用的交换器来说，建议将其置为持久化的。</p>\n<ol>\n<li>队列的持久化</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;队列的持久化是通过在声明队列时将durable 参数置为true 实现的(该参数默认为false)，如果队列不设置持久化，那么在RabbitMQ 服务重启之后，相关队列的元数据会丢失，此时数据也会丢失。正所谓”皮之不存，毛将焉附”，队列都没有了，消息又能存在哪里呢?</p>\n<ol>\n<li>消息的持久化</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。通过将消息的投递模式(BasicProperties中的DeliveryMode属性)设置为2即可实现消息的持久化。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;因此，消息如果要想在Rabbit重启、关闭、宕机时能够恢复，需要做到以下三点:</p>\n<ul>\n<li>把消息的投递模式设置为2</li>\n<li>发送到持久化的交换器</li>\n<li>到达持久化的队列</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意:RabbitMQ 确保持久化消息能从服务器重启中恢复的方式是将它们写入磁盘上的一个持久化日志文件中。当发布一条持久化消息到持久化交换器时，Rabbit会在日志提交到日志文件后才发送响应(开启生产者确认机制)。之后，如果消息到了非持久化队列，它会自动从日志文件中删除，并且无法在服务器重启后恢复。因此单单只设置队列持久化，重启之后消息会丢失;单单只设置消息的持久化，重启之后队列消失，继而消息也丢失。单单设置消息持久化而不设置队列的持久化是毫无意义的。当从持久化队列中消费了消息后(并且确认后)，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。而在消费持久化消息之前，若RabbitMQ服务器重启，会自动重建交换器、队列以及绑定，重播持久化日志文件中的消息到合适的队列或者交换器上(取决于宕机时，消息处在路由的哪个环节)。</strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;为了保障消息不会丢失，也许我们可以简单粗暴的将所有的消息标记为持久化，但这样我们会付出性能的代价。写入磁盘的速度比写入内存的速度慢得不只一点点。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一个权衡。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;将交换器、队列、消息都设置了持久化之后就能百分之百保证数据不丢失了吗?</p>\n<ul>\n<li>从消费者来说，如果在订阅消费队列时将noAck参数设置为true ，那么当消费者接收到相关消息之后，还没来得及处理就宕机了，这样也算数据丢失。</li>\n<li>在持久化的消息正确存入RabbitMQ 之后，还需要有一段时间(虽然很短，但是不可忽视〉才能存入磁盘之中。RabbitMQ 并不会为每条消息都进行同步存盘的处理，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。如果在这段时间内RabbitMQ 服务节点发生了岩机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;关于第一个问题，可以通过消费者确认机制来解决。而第二个问题可以通过生产者确认机制来解决，也可以使用镜像队列机制(镜像队列机制，将在运维篇总结)。生产者确认消费者确认请往下看。</p>\n<h3 id=\"三、生产者确认\"><a href=\"#三、生产者确认\" class=\"headerlink\" title=\"三、生产者确认\"></a>三、生产者确认</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上文我们知道，在使用RabbitMQ的时候，可以通过消息持久化操作来解决因为服务器的异常崩溃而导致的消息丢失，除此之外，我们还会遇到一个问题，当消息的生产者将消息发送出去之后，消息到底有没有正确地到达服务器呢?如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，也就是默认情况下生产者是不知道消息有没有正确地到达服务器。如果在消息到达服务器之前己经丢失，持久化操作也解决不了这个问题，因为消息根本没有到达服务器，何谈持久化?</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ针对这个问题，提供了两种解决方式:</p>\n<ul>\n<li>通过事务机制实现:</li>\n<li>通过发送方确认(publisher confirm)机制实现。</li>\n</ul>\n<h4 id=\"3-1-RabbitMQ-事务机制\"><a href=\"#3-1-RabbitMQ-事务机制\" class=\"headerlink\" title=\"3.1 RabbitMQ 事务机制\"></a>3.1 RabbitMQ 事务机制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 客户端中与事务机制相关的方法有三个:channel.TxSelect(用于将当前信道设置为事务模式);channel.TxCommit(用于提交事务)，channel.TxRollback(用于回滚事务)。在通过channel.TxSelect方法开启事务之后，我们便可以发布消息给RabbitMQ了，如果事务提交成功，则消息一定到达了RabbitMQ 中，如果在事务提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行channel.TxRollback方法来实现事务回滚。示例代码如下所示:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.TxSelect();//将信道设置为事务模式</span><br><span class=\"line\">try</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //do something</span><br><span class=\"line\">    var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">    channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;, true, null, message);</span><br><span class=\"line\">    //do something</span><br><span class=\"line\">    channel.TxCommit();//提交事务</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">catch (Exception ex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //log(ex);</span><br><span class=\"line\">    channel.TxRollback();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;事务确实能够解决消息发送方和RabbitMQ之间消息确认的问题，只有消息成功被RabbitMQ接收，事务才能提交成功，否则便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。但是使用事务同样会带来一些问题。</p>\n<ul>\n<li>会阻塞，发布者必须等待broker处理每个消息。</li>\n<li>事务是重量级的，每次提交都需要fsync()，需要耗费大量的时间</li>\n<li>事务非常耗性能，会降低RabbitMQ的消息吞吐量。</li>\n</ul>\n<h4 id=\"3-2-发送方确认机制\"><a href=\"#3-2-发送方确认机制\" class=\"headerlink\" title=\"3.2 发送方确认机制\"></a>3.2 发送方确认机制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;前面介绍了RabbitMQ可能会遇到的一个问题，即消息发送方(生产者〉并不知道消息是否真正地到达了RabbitMQ。随后了解到在AMQP协议层面提供了事务机制来解决这个问题，但是采用事务机制实现会严重降低RabbitMQ的消息吞吐量，这里就引入了一种轻量级的方式一发送方确认(publisher confirm)机制。生产者将信道设置成confirm确认)模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID( 从1开始)，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认(BasicAck) 给生产者(包含消息的唯一ID)，这就使得生产者知晓消息已经正确到达了目的地了。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-13/17508911.jpg\" alt=\"RabbitMQ发送方确认机制\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;发送方确认模式，示例代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//示例1--同步等待</span><br><span class=\"line\">channel.ConfirmSelect();//开启确认模式</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">channel.ExchangeDeclare(&quot;normalExchange&quot;, &quot;direct&quot;, true, false, null);</span><br><span class=\"line\">channel.QueueDeclare(&quot;normalQueue&quot;, true, false, false, null);</span><br><span class=\"line\">channel.QueueBind(&quot;normalQueue&quot;, &quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;, true, null, message);</span><br><span class=\"line\">//var result=channel.WaitForConfirmsOrDie(Timeout); </span><br><span class=\"line\">//WaitForConfirmsOrDie 使用WaitForConfirmsOrDie 在Rabbit发送Nack命令或超时时会抛出一个异常</span><br><span class=\"line\">var result = channel.WaitForConfirms();//等待该信道所有未确认的消息结果</span><br><span class=\"line\">if(!result)&#123;</span><br><span class=\"line\">    //send message failed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//示例2--异步通知</span><br><span class=\"line\">channel.ConfirmSelect();//开启确认模式</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">channel.ExchangeDeclare(&quot;normalExchange&quot;, &quot;direct&quot;, true, false, null);</span><br><span class=\"line\">channel.QueueDeclare(&quot;normalQueue&quot;, true, false, false, null);</span><br><span class=\"line\">channel.QueueBind(&quot;normalQueue&quot;, &quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;, true, null, message);</span><br><span class=\"line\">channel.BasicAcks += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认(Basic.Ack)给生产者(包含消息的唯一ID)</span><br><span class=\"line\">    //ea.Multiple为True代表 ea.DeliveryTag编号之前的消息均已被确认。</span><br><span class=\"line\">//do something;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel.BasicNacks += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条nack(BasicNack) 命令</span><br><span class=\"line\">//do something;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;关于生产者确认机制同样会有一些问题，broker不能保证消息会被confirm，只知道将会进行confirm。这样如果broker与生产者之间的连接断开，导致生产者不能收到确认消息，可能会重复进行发布。总之，生产者确认模式给客户端提供了一种较为轻量级的方式，能够跟踪哪些消息被broker处理，哪些可能因为broker宕掉或者网络失败的情况而重新发布。</p>\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;注意:事务机制和publisher confirm机制两者是互斥的，不能共存。如果企图将已开启事务模式的信道再设置为publisher confmn模式， RabbitMQ会报错,或者如果企图将已开启publisher confirm模式的信道设置为事务模式， RabbitMQ也会报错。在性能上来看，而到底应该选择事务机制还是Confirm机制，则需要结合我们的业务场景。</strong></p>\n<h3 id=\"四、消费者确认\"><a href=\"#四、消费者确认\" class=\"headerlink\" title=\"四、消费者确认\"></a>四、消费者确认</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;为了保证消息从队列可靠地达到消费者，RabbitMQ提供了消息确认机制(message acknowledgement)。消费者在订阅队列时，可以指定noAck参数，当noAck等于false时，RabbitMQ会等待消费者显式地回复确认信号后才从内存(或者磁盘)中移去消息(实质上是先打上删除标记，之后再删除)。当noAck等于true时，RabbitMQ会自动把发送出去的消息置为确认，然后从内存(或者磁盘)中删除，而不管消费者是否真正地消费到了这些消息。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;采用消息确认机制后，只要设置noAck参数为false，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直等待持有消息直到消费者显式调用BasicAck命令为止。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;当noAck参数置为false，对于RabbitMQ服务端而言，队列中的消息分成了两个部分:一部分是等待投递给消费者的消息:一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。如果RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开，这么设计的原因是RabbitMQ 允许消费者消费一条消息的时间可以很久很久。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;关于RabbitMQ消费者确认机制示例代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//推模式</span><br><span class=\"line\">EventingBasicConsumer consumer = new EventingBasicConsumer(channel);</span><br><span class=\"line\">//定义消费者回调事件</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //do someting;</span><br><span class=\"line\">    //channel.BasicReject(ea.DeliveryTag, requeue: true);//拒绝</span><br><span class=\"line\">    //requeue参数为true会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者</span><br><span class=\"line\">    channel.BasicAck(ea.DeliveryTag, multiple: false);//确认</span><br><span class=\"line\">    //若:multiple参数为true，则确认DeliverTag这个编号之前的消息</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel.BasicConsume(queue: &quot;queueName&quot;,</span><br><span class=\"line\">                    noAck: false,</span><br><span class=\"line\">                   consumer: consumer);</span><br><span class=\"line\"></span><br><span class=\"line\">//拉模式</span><br><span class=\"line\">BasicGetResult result = channel.BasicGet(&quot;queueName&quot;, noAck: false);</span><br><span class=\"line\">//确认</span><br><span class=\"line\">channel.BasicAck(result.DeliveryTag, multiple: false);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-25/36944382.jpg\" alt=\"RabbitMQ 消费者确认\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上，消费者在消费消息的同时，Rabbit会同步给予消费者一个DeliveryTag，这个DeliveryTag就像我们数据库中的主键，消费者在消费完毕后拿着这个DeliveryTag去Rabbit确认或拒绝这个消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void BasicAck(ulong deliveryTag, bool multiple);</span><br><span class=\"line\"></span><br><span class=\"line\">void BasicReject(ulong deliveryTag, bool requeue);</span><br><span class=\"line\"></span><br><span class=\"line\">void BasicNack(ulong deliveryTag, bool multiple, bool requeue);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>deliveryTag:可以看作消息的编号，它是一个64位的长整型值，最大值是9223372036854775807。</li>\n<li>requeue:如果requeue 参数设置为true，则RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者;如果requeue 参数设置为false，则RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。</li>\n<li>BasicReject命令一次只能拒绝一条消息，如果想要批量拒绝消息，则可以使用Basic.Nack这个命令。</li>\n<li>multiple:在BasicAck中，multiple 参数设置为true 则表示确认deliveryTag编号之前所有已被当前消费者确认的消息。在BasicNack中，multiple 参数设置为true 则表示拒绝deliveryTag 编号之前所有未被当前消费者确认的消息。</li>\n</ul>\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;说明:将channel.BasicReject 或者channel.BasicNack中的requeue设置为false ，可以启用”死信队列”的功能。</strong>(关于死信队列请看我的上一篇文章 <a href=\"https://www.cnblogs.com/hunternet/p/9697754.html）。\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/hunternet/p/9697754.html）。</a></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;上述requeue，都会将消息重新存入队列发送给下一个消费者(也有可能是其它消费者)。关于requeue还有下面一种用法。可以选择是否补发给当前的consumer。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//补发消息 true退回到queue中 /false只补发给当前的consumer</span><br><span class=\"line\">channel.BasicRecover(true);</span><br></pre></td></tr></table></figure>\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;注意：RabbitMQ仅仅通过Consumer的连接中断来确认该Message并没有被正确处理。也就是说，RabbitMQ给了Consumer足够长的时间来做数据处理。如果忘记了ack，那么后果很严重。当Consumer退出时，Message会重新分发。然后RabbitMQ会占用越来越多的内存，由于RabbitMQ会长时间运行，这个“内存泄漏”是致命的。</strong></p>\n<h3 id=\"五、消息分发与顺序\"><a href=\"#五、消息分发与顺序\" class=\"headerlink\" title=\"五、消息分发与顺序\"></a>五、消息分发与顺序</h3><h4 id=\"5-1-消息分发\"><a href=\"#5-1-消息分发\" class=\"headerlink\" title=\"5.1 消息分发\"></a>5.1 消息分发</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当RabbitMQ 队列拥有多个消费者时，队列收到的消息将以轮询(round-robin)的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者。这种方式非常适合扩展，而且它是专门为并发程序设计的。如果现在负载加重，那么只需要创建更多的消费者来消费处理消息即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;很多时候轮询的分发机制也不是那么优雅。默认情况下，如果有n个消费者，那么RabbitMQ会将第m条消息分发给第m%n (取余的方式)个消费者， RabbitMQ 不管消费者是否消费并己经确认了消息。试想一下，如果某些消费者任务繁重，来不及消费那么多的消息，而某些其他消费者由于某些原因(比如业务逻辑简单、机器性能卓越等)很快地处理完了所分配到的消息，进而进程空闲，这样就会造成整体应用吞吐量的下降。那么该如何处理这种情况呢?这里就要用到channel.BasicQos(int prefetchCount)这个方法，channel.BasicQos方法允许限制信道上的消费者所能保持的最大未确认消息的数量。<br>&nbsp;&nbsp;&nbsp;&nbsp;举例说明，在订阅消费队列之前，消费端程序调用了channel.BasicQos(5)，之后订阅了某个队列进行消费。RabbitMQ 会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么RabbitMQ 就不会向这个消费者再发送任何消息。直到消费者确认了某条消息之后， RabbitMQ 将相应的计数减1，之后消费者可以继续接收消息，直到再次到达计数上限。</p>\n<p><strong>注意:Basic.Qos 的使用对于拉模式的消费方式无效.</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void BasicQos(uint prefetchSize, ushort prefetchCount, bool global);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>prefetchCount：允许限制信道上的消费者所能保持的最大未确认消息的数量，设置为0表示没有上限。</li>\n<li>prefetchSize：消费者所能接收未确认消息的总体大小的上限，单位为B，设置为0表示没有上限。</li>\n<li>global：对于一个信道来说，它可以同时消费多个队列，当设置了prefetchCount 大于0 时，这个信道需要和各个队列协调以确保发送的消息都没有超过所限定的prefetchCount 的值，这样会使RabbitMQ 的性能降低，尤其是这些队列分散在集群中的多个Broker节点之中。RabbitMQ 为了提升相关的性能，在AMQPO-9-1 协议之上重新定义了global这个参数。如下表所示:</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>global参数</th>\n<th>AMQP 0-9-1</th>\n<th>RabbitMQ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>false</td>\n<td>信道上所有的消费者都需要遵从prefetchCount 的限信道上新的消费者需要遵从prefetchCount 的限定值</td>\n<td>信道上新的消费者需要遵从prefetchCount 的限定值</td>\n</tr>\n<tr>\n<td>true</td>\n<td>当前通信链路( Connection) 上所有的消费者都需信道上所有的消费者都需要遵从prefetchCount的限定值</td>\n<td>信道上所有的消费者需要遵从prefetchCount 的限定值</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>注意:</strong></p>\n<ol>\n<li>对于同一个信道上的多个消费者而言，如果设置了prefetchCount 的值，那么都会生效。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//伪代码</span><br><span class=\"line\">Consumer consumer1 = ...;</span><br><span class=\"line\">Consumer consumer2 = ...;</span><br><span class=\"line\">channel.BasicQos(10) ; </span><br><span class=\"line\">channel.BasicConsume(&quot;my-queue1&quot; , false , consumer1);</span><br><span class=\"line\">channel.BasicConsume(&quot;my-queue2&quot; , false , consumer2);</span><br><span class=\"line\">//两个消费者各自的能接收到的未确认消息的上限都为10 。</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果在订阅消息之前，既设置了global 为true 的限制，又设置了global为false的限制,RabbitMQ 会确保两者都会生效。但会增加RabbitMQ的负载因为RabbitMQ 需要更多的资源来协调完成这些限制。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//伪代码</span><br><span class=\"line\">Channel channel = ...;</span><br><span class=\"line\">Consumer consumerl = ...;</span><br><span class=\"line\">Consumer consumer2 = ...;</span><br><span class=\"line\">channel.BasicQos(3 , false); </span><br><span class=\"line\">channel.BasicQos(5 , true); </span><br><span class=\"line\">channel.BasicConsume(&quot;queuel&quot; , false , consumerl) ;</span><br><span class=\"line\">channel.BasicConsume(&quot;queue2&quot; , false , consumer2) ;</span><br><span class=\"line\">//这里每个消费者最多只能收到3个未确认的消息，两个消费者能收到的未确认的消息个数之和的上限为5</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-2-消息顺序\"><a href=\"#5-2-消息顺序\" class=\"headerlink\" title=\"5.2 消息顺序\"></a>5.2 消息顺序</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;消息的顺序性是指消费者消费到的消息和发送者发布的消息的顺序是一致的。举个例子，不考虑消息重复的情况，如果生产者发布的消息分别为msgl、msg2、msg3，那么消费者必然也是按照msgl、msg2、msg3的顺序进行消费的。<br>&nbsp;&nbsp;&nbsp;&nbsp;目前很多资料显示RabbitMQ的消息能够保障顺序性，这是不正确的，或者说这个观点有很大的局限性。在不使用任何RabbitMQ的高级特性，也没有消息丢失、网络故障之类异常的情况发生，并且只有一个消费者的情况下，最好也只有一个生产者的情况下可以保证消息的顺序性。如果有多个生产者同时发送消息，无法确定消息到达Broker 的前后顺序，也就无法验证消息的顺序性。<br>&nbsp;&nbsp;&nbsp;&nbsp;那么哪些情况下RabbitMQ 的消息顺序性会被打破呢?下面介绍几种常见的情形。</p>\n<ul>\n<li><p>如果生产者使用了事务机制，在发送消息之后遇到异常进行了事务回滚，那么需要重新补偿发送这条消息，如果补偿发送是在另一个线程实现的，那么消息在生产者这个源头就出现了错序。同样，如果启用publisher confirm时，在发生超时、中断，又或者是收到RabbitMQ的BasicNack命令时，那么同样需要补偿发送，结果与事务机制一样会错序。或者这种说法有些牵强，我们可以固执地认为消息的顺序性保障是从存入队列之后开始的，而不是在发迭的时候开始的。</p>\n</li>\n<li><p>考虑另一种情形，如果生产者发送的消息设置了不同的超时时间，井且也设置了死信队列，整体上来说相当于一个延迟队列，那么消费者在消费这个延迟队列的时候，消息的顺序必然不会和生产者发送消息的顺序一致。</p>\n</li>\n<li><p>如果消息设置了优先级，那么消费者消费到的消息也必然不是顺序性的。</p>\n</li>\n<li><p>如果一个队列按照前后顺序分有msg1， msg2、msg3、msg4这4 个消息，同时有ConsumerA和ConsumerB 这两个消费者同时订阅了这个队列。队列中的消息轮询分发到各个消费者之中，ConsumerA 中的消息为msg1和msg3，ConsumerB中的消息为msg2、msg4。ConsumerA收到消息msg1之后并不想处理而调用了BasicNack/BasicReject将消息拒绝，与此同时将requeue设置为true，这样这条消息就可以重新存入队列中。消息msg1之后被发送到了ConsumerB中，此时ConsumerB己经消费了msg2、msg4，之后再消费msg1.这样消息顺序性也就错乱了。</p>\n</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;包括但不仅限于以上几种情形会使RabbitMQ 消息错序。如果要保证消息的顺序性，需要业务方使用的时候做进一步的处理。如在消息体内添加全局有序标识等。</p>\n<h3 id=\"六、消息传输保障\"><a href=\"#六、消息传输保障\" class=\"headerlink\" title=\"六、消息传输保障\"></a>六、消息传输保障</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;消息可靠传输一般是业务系统接入消息中间件时首要考虑的问题，一般消息中间件的消息<br>传输保障分为三个层级。</p>\n<ul>\n<li>At most once: 最多一次。消息可能会丢失，但绝不会重复传输。</li>\n<li>At least once: 最少一次。消息绝不会丢失，但可能会重复传输。</li>\n<li>Exactly once: 恰好一次。每条消息肯定会被传输一次且仅传输一次。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 支持其中的”最多一次”和”最少一次”。其中”最少一次”投递实现需要考虑以下这个几个方面的内容:</p>\n<ol>\n<li>消息生产者需要开启事务机制或者publisher confirm 机制，以确保消息可以可靠地传<br>输到RabbitMQ 中。</li>\n<li>消息生产者需要配合使用mandatory参数或者备份交换器来确保消息能够从交换器<br>路由到队列中，进而能够保存下来而不会被丢弃。</li>\n<li>消息和队列都需要进行持久化处理，以确保RabbitMQ服务器在遇到异常情况时不会造成消息丢失。</li>\n<li>消费者在消费消息的同时需要将noAck设置为false，然后通过手动确认的方式去确认己经正确消费的消息，以避免在消费端引起不必要的消息丢失。</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;”最多一次”的方式就无须考虑以上那些方面，生产者随意发送，消费者随意消费，不过这样很难确保消息不会重复消费。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;”恰好一次”是RabbitMQ目前无法保障的(目前我也不知道哪个中间件能够保证)。消费者在消费完一条消息之后向RabbitMQ 发送确认BasicAck命令，此时由于网络断开或者其他原因造成RabbitMQ并没有收到这个确认命令，那么RabbitMQ不会将此条消息标记删除。在重新建立连接之后，消费者还是会消费到这一条消息，这就造成了重复消费。再考虑一种情况，生产者在使用publisher confirm机制的时候，发送完一条消息等待RabbitMQ 返回确认通知，此时网络断开，生产者捕获到异常情况，为了确保消息可靠性选择重新发送，这样RabbitMQ中就有两条同样的消息，在消费的时候，消费者就会重复消费。而解决重复消费可以通过消费者幂等等方式来解决。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本篇文章，我们思考了使用RabbitMQ过程中需要注意的几个问题，而前两篇文章对RabbitMQ的概念以及如何使用做了简单的介绍，相信经过这些介绍已经对RabbitMQ有了基本的了解。但这些远远不够，想要更好的利用好RabbitMQ还需要结合我们的业务场景来更多的去使用它(切记不要为了使用技术而使用技术!)。关于RabbitMQ的运维篇，会在以后的文章中继续给大家分享。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;前面的两篇文章，我们简单介绍了消息中间件与RabbitMQ的一些基本概念、基础用法以及常用的几个特性。但如果我们想更好的去结合我们的业务场景使用好RabbitMQ，我们还需要思考一些问题。比如:何时去创建队列,RabbitMQ的持久化，如何保证消息到达RabbitMQ，以及消费者如何确认消息……</p>","more":"<h3 id=\"系列文章\"><a href=\"#系列文章\" class=\"headerlink\" title=\"系列文章\"></a>系列文章</h3><p><a href=\"http://blog.loading.ink/2018/11/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用基础篇</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用进阶篇</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%9D%E8%80%83%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用思考篇</a></p>\n<h3 id=\"一、何时创建队列\"><a href=\"#一、何时创建队列\" class=\"headerlink\" title=\"一、何时创建队列\"></a>一、何时创建队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;从前面的文章我们知道，RabbitMQ可以选择在生产者创建队列，也可以在消费者端创建队列，也可以提前创建好队列，而生产者消费者直接使用即可。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ的消息存储在队列中，交换器的使用并不真正耗费服务器的性能，而队列会。如在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值，以便在固定硬件资源的情况下能够进行合理有效的分配。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;按照RabbitMQ官方建议，生产者和消费者都应该尝试创建(这里指声明操作)队列。这虽然是一个很好的建议，但是在我看来这个时间上没有最好的方案，只有最适合的方案。我们往往需要结合业务、资源等方面在各种方案里面选择一个最适合我们的方案。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如果业务本身在架构设计之初己经充分地预估了队列的使用情况，完全可以在业务程序上线之前在服务器上创建好(比如通过页面管理、RabbitMQ命令或者更好的是从配置中心下发)，这样业务程序也可以免去声明的过程，直接使用即可。预先创建好资源还有一个好处是，可以确保交换器和队列之间正确地绑定匹配。很多时候，由于人为因素、代码缺陷等，发送消息的交换器并没有绑定任何队列，那么消息将会丢失:或者交换器绑定了某个队列，但是发送消息时的路由键无法与现存的队列匹配，那么消息也会丢失。当然可以配合mandatory参数或者备份交换器(关于mandatory参数的使用详细可参考我的上一篇文章) 来提高程序的健壮性。与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预定的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列迁移到其他集群。迁移的过程也可以对业务程序完全透明。此种方法也更有利于开发和运维分工，便于相应资源的管理。如果集群资源充足，而即将使用的队列所占用的资源又在可控的范围之内，为了增加业务程序的灵活性，也完全可以在业务程序中声明队列。至于是使用预先分配创建资源的静态方式还是动态的创建方式，需要从业务逻辑本身、公司运维体系和公司硬件资源等方面考虑。</p>\n<h3 id=\"二、持久化及策略\"><a href=\"#二、持久化及策略\" class=\"headerlink\" title=\"二、持久化及策略\"></a>二、持久化及策略</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;作为一个内存中间件，在保证了速度的情况下，不可避免存在如内存数据库同样的问题，即丢失问题。持久化可以提高RabbitMQ 的可靠性，以防在异常情况(重启、关闭、宕机等)下的数据丢失。RabbitMQ的持久化分为三个部分:交换器的持久化、队列的持久化和消息的持久化。</p>\n<ol>\n<li>交换器的持久化</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;交换器的持久化是通过在声明队列是将durable 参数置为true 实现的(该参数默认为false)。如果交换器不设置持久化，那么在RabbitMQ 服务重启之后，相关的交换器元数据会丢失，不过消息不会丢失，只是不能将消息发送到这个交换器中了。对一个长期使用的交换器来说，建议将其置为持久化的。</p>\n<ol>\n<li>队列的持久化</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;队列的持久化是通过在声明队列时将durable 参数置为true 实现的(该参数默认为false)，如果队列不设置持久化，那么在RabbitMQ 服务重启之后，相关队列的元数据会丢失，此时数据也会丢失。正所谓”皮之不存，毛将焉附”，队列都没有了，消息又能存在哪里呢?</p>\n<ol>\n<li>消息的持久化</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。通过将消息的投递模式(BasicProperties中的DeliveryMode属性)设置为2即可实现消息的持久化。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;因此，消息如果要想在Rabbit重启、关闭、宕机时能够恢复，需要做到以下三点:</p>\n<ul>\n<li>把消息的投递模式设置为2</li>\n<li>发送到持久化的交换器</li>\n<li>到达持久化的队列</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意:RabbitMQ 确保持久化消息能从服务器重启中恢复的方式是将它们写入磁盘上的一个持久化日志文件中。当发布一条持久化消息到持久化交换器时，Rabbit会在日志提交到日志文件后才发送响应(开启生产者确认机制)。之后，如果消息到了非持久化队列，它会自动从日志文件中删除，并且无法在服务器重启后恢复。因此单单只设置队列持久化，重启之后消息会丢失;单单只设置消息的持久化，重启之后队列消失，继而消息也丢失。单单设置消息持久化而不设置队列的持久化是毫无意义的。当从持久化队列中消费了消息后(并且确认后)，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。而在消费持久化消息之前，若RabbitMQ服务器重启，会自动重建交换器、队列以及绑定，重播持久化日志文件中的消息到合适的队列或者交换器上(取决于宕机时，消息处在路由的哪个环节)。</strong></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;为了保障消息不会丢失，也许我们可以简单粗暴的将所有的消息标记为持久化，但这样我们会付出性能的代价。写入磁盘的速度比写入内存的速度慢得不只一点点。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一个权衡。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;将交换器、队列、消息都设置了持久化之后就能百分之百保证数据不丢失了吗?</p>\n<ul>\n<li>从消费者来说，如果在订阅消费队列时将noAck参数设置为true ，那么当消费者接收到相关消息之后，还没来得及处理就宕机了，这样也算数据丢失。</li>\n<li>在持久化的消息正确存入RabbitMQ 之后，还需要有一段时间(虽然很短，但是不可忽视〉才能存入磁盘之中。RabbitMQ 并不会为每条消息都进行同步存盘的处理，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。如果在这段时间内RabbitMQ 服务节点发生了岩机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;关于第一个问题，可以通过消费者确认机制来解决。而第二个问题可以通过生产者确认机制来解决，也可以使用镜像队列机制(镜像队列机制，将在运维篇总结)。生产者确认消费者确认请往下看。</p>\n<h3 id=\"三、生产者确认\"><a href=\"#三、生产者确认\" class=\"headerlink\" title=\"三、生产者确认\"></a>三、生产者确认</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上文我们知道，在使用RabbitMQ的时候，可以通过消息持久化操作来解决因为服务器的异常崩溃而导致的消息丢失，除此之外，我们还会遇到一个问题，当消息的生产者将消息发送出去之后，消息到底有没有正确地到达服务器呢?如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，也就是默认情况下生产者是不知道消息有没有正确地到达服务器。如果在消息到达服务器之前己经丢失，持久化操作也解决不了这个问题，因为消息根本没有到达服务器，何谈持久化?</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ针对这个问题，提供了两种解决方式:</p>\n<ul>\n<li>通过事务机制实现:</li>\n<li>通过发送方确认(publisher confirm)机制实现。</li>\n</ul>\n<h4 id=\"3-1-RabbitMQ-事务机制\"><a href=\"#3-1-RabbitMQ-事务机制\" class=\"headerlink\" title=\"3.1 RabbitMQ 事务机制\"></a>3.1 RabbitMQ 事务机制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 客户端中与事务机制相关的方法有三个:channel.TxSelect(用于将当前信道设置为事务模式);channel.TxCommit(用于提交事务)，channel.TxRollback(用于回滚事务)。在通过channel.TxSelect方法开启事务之后，我们便可以发布消息给RabbitMQ了，如果事务提交成功，则消息一定到达了RabbitMQ 中，如果在事务提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行channel.TxRollback方法来实现事务回滚。示例代码如下所示:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.TxSelect();//将信道设置为事务模式</span><br><span class=\"line\">try</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //do something</span><br><span class=\"line\">    var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">    channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;, true, null, message);</span><br><span class=\"line\">    //do something</span><br><span class=\"line\">    channel.TxCommit();//提交事务</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">catch (Exception ex)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //log(ex);</span><br><span class=\"line\">    channel.TxRollback();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;事务确实能够解决消息发送方和RabbitMQ之间消息确认的问题，只有消息成功被RabbitMQ接收，事务才能提交成功，否则便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。但是使用事务同样会带来一些问题。</p>\n<ul>\n<li>会阻塞，发布者必须等待broker处理每个消息。</li>\n<li>事务是重量级的，每次提交都需要fsync()，需要耗费大量的时间</li>\n<li>事务非常耗性能，会降低RabbitMQ的消息吞吐量。</li>\n</ul>\n<h4 id=\"3-2-发送方确认机制\"><a href=\"#3-2-发送方确认机制\" class=\"headerlink\" title=\"3.2 发送方确认机制\"></a>3.2 发送方确认机制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;前面介绍了RabbitMQ可能会遇到的一个问题，即消息发送方(生产者〉并不知道消息是否真正地到达了RabbitMQ。随后了解到在AMQP协议层面提供了事务机制来解决这个问题，但是采用事务机制实现会严重降低RabbitMQ的消息吞吐量，这里就引入了一种轻量级的方式一发送方确认(publisher confirm)机制。生产者将信道设置成confirm确认)模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID( 从1开始)，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认(BasicAck) 给生产者(包含消息的唯一ID)，这就使得生产者知晓消息已经正确到达了目的地了。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-11-13/17508911.jpg\" alt=\"RabbitMQ发送方确认机制\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;发送方确认模式，示例代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//示例1--同步等待</span><br><span class=\"line\">channel.ConfirmSelect();//开启确认模式</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">channel.ExchangeDeclare(&quot;normalExchange&quot;, &quot;direct&quot;, true, false, null);</span><br><span class=\"line\">channel.QueueDeclare(&quot;normalQueue&quot;, true, false, false, null);</span><br><span class=\"line\">channel.QueueBind(&quot;normalQueue&quot;, &quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;, true, null, message);</span><br><span class=\"line\">//var result=channel.WaitForConfirmsOrDie(Timeout); </span><br><span class=\"line\">//WaitForConfirmsOrDie 使用WaitForConfirmsOrDie 在Rabbit发送Nack命令或超时时会抛出一个异常</span><br><span class=\"line\">var result = channel.WaitForConfirms();//等待该信道所有未确认的消息结果</span><br><span class=\"line\">if(!result)&#123;</span><br><span class=\"line\">    //send message failed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//示例2--异步通知</span><br><span class=\"line\">channel.ConfirmSelect();//开启确认模式</span><br><span class=\"line\">var message = Encoding.UTF8.GetBytes(&quot;TestMsg&quot;);</span><br><span class=\"line\">channel.ExchangeDeclare(&quot;normalExchange&quot;, &quot;direct&quot;, true, false, null);</span><br><span class=\"line\">channel.QueueDeclare(&quot;normalQueue&quot;, true, false, false, null);</span><br><span class=\"line\">channel.QueueBind(&quot;normalQueue&quot;, &quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;);</span><br><span class=\"line\">channel.BasicPublish(&quot;normalExchange&quot;, &quot;NormalRoutingKey&quot;, true, null, message);</span><br><span class=\"line\">channel.BasicAcks += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认(Basic.Ack)给生产者(包含消息的唯一ID)</span><br><span class=\"line\">    //ea.Multiple为True代表 ea.DeliveryTag编号之前的消息均已被确认。</span><br><span class=\"line\">//do something;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel.BasicNacks += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条nack(BasicNack) 命令</span><br><span class=\"line\">//do something;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;关于生产者确认机制同样会有一些问题，broker不能保证消息会被confirm，只知道将会进行confirm。这样如果broker与生产者之间的连接断开，导致生产者不能收到确认消息，可能会重复进行发布。总之，生产者确认模式给客户端提供了一种较为轻量级的方式，能够跟踪哪些消息被broker处理，哪些可能因为broker宕掉或者网络失败的情况而重新发布。</p>\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;注意:事务机制和publisher confirm机制两者是互斥的，不能共存。如果企图将已开启事务模式的信道再设置为publisher confmn模式， RabbitMQ会报错,或者如果企图将已开启publisher confirm模式的信道设置为事务模式， RabbitMQ也会报错。在性能上来看，而到底应该选择事务机制还是Confirm机制，则需要结合我们的业务场景。</strong></p>\n<h3 id=\"四、消费者确认\"><a href=\"#四、消费者确认\" class=\"headerlink\" title=\"四、消费者确认\"></a>四、消费者确认</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;为了保证消息从队列可靠地达到消费者，RabbitMQ提供了消息确认机制(message acknowledgement)。消费者在订阅队列时，可以指定noAck参数，当noAck等于false时，RabbitMQ会等待消费者显式地回复确认信号后才从内存(或者磁盘)中移去消息(实质上是先打上删除标记，之后再删除)。当noAck等于true时，RabbitMQ会自动把发送出去的消息置为确认，然后从内存(或者磁盘)中删除，而不管消费者是否真正地消费到了这些消息。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;采用消息确认机制后，只要设置noAck参数为false，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直等待持有消息直到消费者显式调用BasicAck命令为止。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;当noAck参数置为false，对于RabbitMQ服务端而言，队列中的消息分成了两个部分:一部分是等待投递给消费者的消息:一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。如果RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开，这么设计的原因是RabbitMQ 允许消费者消费一条消息的时间可以很久很久。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;关于RabbitMQ消费者确认机制示例代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//推模式</span><br><span class=\"line\">EventingBasicConsumer consumer = new EventingBasicConsumer(channel);</span><br><span class=\"line\">//定义消费者回调事件</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //do someting;</span><br><span class=\"line\">    //channel.BasicReject(ea.DeliveryTag, requeue: true);//拒绝</span><br><span class=\"line\">    //requeue参数为true会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者</span><br><span class=\"line\">    channel.BasicAck(ea.DeliveryTag, multiple: false);//确认</span><br><span class=\"line\">    //若:multiple参数为true，则确认DeliverTag这个编号之前的消息</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel.BasicConsume(queue: &quot;queueName&quot;,</span><br><span class=\"line\">                    noAck: false,</span><br><span class=\"line\">                   consumer: consumer);</span><br><span class=\"line\"></span><br><span class=\"line\">//拉模式</span><br><span class=\"line\">BasicGetResult result = channel.BasicGet(&quot;queueName&quot;, noAck: false);</span><br><span class=\"line\">//确认</span><br><span class=\"line\">channel.BasicAck(result.DeliveryTag, multiple: false);</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-25/36944382.jpg\" alt=\"RabbitMQ 消费者确认\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上，消费者在消费消息的同时，Rabbit会同步给予消费者一个DeliveryTag，这个DeliveryTag就像我们数据库中的主键，消费者在消费完毕后拿着这个DeliveryTag去Rabbit确认或拒绝这个消息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void BasicAck(ulong deliveryTag, bool multiple);</span><br><span class=\"line\"></span><br><span class=\"line\">void BasicReject(ulong deliveryTag, bool requeue);</span><br><span class=\"line\"></span><br><span class=\"line\">void BasicNack(ulong deliveryTag, bool multiple, bool requeue);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>deliveryTag:可以看作消息的编号，它是一个64位的长整型值，最大值是9223372036854775807。</li>\n<li>requeue:如果requeue 参数设置为true，则RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者;如果requeue 参数设置为false，则RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。</li>\n<li>BasicReject命令一次只能拒绝一条消息，如果想要批量拒绝消息，则可以使用Basic.Nack这个命令。</li>\n<li>multiple:在BasicAck中，multiple 参数设置为true 则表示确认deliveryTag编号之前所有已被当前消费者确认的消息。在BasicNack中，multiple 参数设置为true 则表示拒绝deliveryTag 编号之前所有未被当前消费者确认的消息。</li>\n</ul>\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;说明:将channel.BasicReject 或者channel.BasicNack中的requeue设置为false ，可以启用”死信队列”的功能。</strong>(关于死信队列请看我的上一篇文章 <a href=\"https://www.cnblogs.com/hunternet/p/9697754.html）。\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/hunternet/p/9697754.html）。</a></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;上述requeue，都会将消息重新存入队列发送给下一个消费者(也有可能是其它消费者)。关于requeue还有下面一种用法。可以选择是否补发给当前的consumer。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//补发消息 true退回到queue中 /false只补发给当前的consumer</span><br><span class=\"line\">channel.BasicRecover(true);</span><br></pre></td></tr></table></figure>\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;注意：RabbitMQ仅仅通过Consumer的连接中断来确认该Message并没有被正确处理。也就是说，RabbitMQ给了Consumer足够长的时间来做数据处理。如果忘记了ack，那么后果很严重。当Consumer退出时，Message会重新分发。然后RabbitMQ会占用越来越多的内存，由于RabbitMQ会长时间运行，这个“内存泄漏”是致命的。</strong></p>\n<h3 id=\"五、消息分发与顺序\"><a href=\"#五、消息分发与顺序\" class=\"headerlink\" title=\"五、消息分发与顺序\"></a>五、消息分发与顺序</h3><h4 id=\"5-1-消息分发\"><a href=\"#5-1-消息分发\" class=\"headerlink\" title=\"5.1 消息分发\"></a>5.1 消息分发</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当RabbitMQ 队列拥有多个消费者时，队列收到的消息将以轮询(round-robin)的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者。这种方式非常适合扩展，而且它是专门为并发程序设计的。如果现在负载加重，那么只需要创建更多的消费者来消费处理消息即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;很多时候轮询的分发机制也不是那么优雅。默认情况下，如果有n个消费者，那么RabbitMQ会将第m条消息分发给第m%n (取余的方式)个消费者， RabbitMQ 不管消费者是否消费并己经确认了消息。试想一下，如果某些消费者任务繁重，来不及消费那么多的消息，而某些其他消费者由于某些原因(比如业务逻辑简单、机器性能卓越等)很快地处理完了所分配到的消息，进而进程空闲，这样就会造成整体应用吞吐量的下降。那么该如何处理这种情况呢?这里就要用到channel.BasicQos(int prefetchCount)这个方法，channel.BasicQos方法允许限制信道上的消费者所能保持的最大未确认消息的数量。<br>&nbsp;&nbsp;&nbsp;&nbsp;举例说明，在订阅消费队列之前，消费端程序调用了channel.BasicQos(5)，之后订阅了某个队列进行消费。RabbitMQ 会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么RabbitMQ 就不会向这个消费者再发送任何消息。直到消费者确认了某条消息之后， RabbitMQ 将相应的计数减1，之后消费者可以继续接收消息，直到再次到达计数上限。</p>\n<p><strong>注意:Basic.Qos 的使用对于拉模式的消费方式无效.</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void BasicQos(uint prefetchSize, ushort prefetchCount, bool global);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>prefetchCount：允许限制信道上的消费者所能保持的最大未确认消息的数量，设置为0表示没有上限。</li>\n<li>prefetchSize：消费者所能接收未确认消息的总体大小的上限，单位为B，设置为0表示没有上限。</li>\n<li>global：对于一个信道来说，它可以同时消费多个队列，当设置了prefetchCount 大于0 时，这个信道需要和各个队列协调以确保发送的消息都没有超过所限定的prefetchCount 的值，这样会使RabbitMQ 的性能降低，尤其是这些队列分散在集群中的多个Broker节点之中。RabbitMQ 为了提升相关的性能，在AMQPO-9-1 协议之上重新定义了global这个参数。如下表所示:</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>global参数</th>\n<th>AMQP 0-9-1</th>\n<th>RabbitMQ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>false</td>\n<td>信道上所有的消费者都需要遵从prefetchCount 的限信道上新的消费者需要遵从prefetchCount 的限定值</td>\n<td>信道上新的消费者需要遵从prefetchCount 的限定值</td>\n</tr>\n<tr>\n<td>true</td>\n<td>当前通信链路( Connection) 上所有的消费者都需信道上所有的消费者都需要遵从prefetchCount的限定值</td>\n<td>信道上所有的消费者需要遵从prefetchCount 的限定值</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>注意:</strong></p>\n<ol>\n<li>对于同一个信道上的多个消费者而言，如果设置了prefetchCount 的值，那么都会生效。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//伪代码</span><br><span class=\"line\">Consumer consumer1 = ...;</span><br><span class=\"line\">Consumer consumer2 = ...;</span><br><span class=\"line\">channel.BasicQos(10) ; </span><br><span class=\"line\">channel.BasicConsume(&quot;my-queue1&quot; , false , consumer1);</span><br><span class=\"line\">channel.BasicConsume(&quot;my-queue2&quot; , false , consumer2);</span><br><span class=\"line\">//两个消费者各自的能接收到的未确认消息的上限都为10 。</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果在订阅消息之前，既设置了global 为true 的限制，又设置了global为false的限制,RabbitMQ 会确保两者都会生效。但会增加RabbitMQ的负载因为RabbitMQ 需要更多的资源来协调完成这些限制。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//伪代码</span><br><span class=\"line\">Channel channel = ...;</span><br><span class=\"line\">Consumer consumerl = ...;</span><br><span class=\"line\">Consumer consumer2 = ...;</span><br><span class=\"line\">channel.BasicQos(3 , false); </span><br><span class=\"line\">channel.BasicQos(5 , true); </span><br><span class=\"line\">channel.BasicConsume(&quot;queuel&quot; , false , consumerl) ;</span><br><span class=\"line\">channel.BasicConsume(&quot;queue2&quot; , false , consumer2) ;</span><br><span class=\"line\">//这里每个消费者最多只能收到3个未确认的消息，两个消费者能收到的未确认的消息个数之和的上限为5</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-2-消息顺序\"><a href=\"#5-2-消息顺序\" class=\"headerlink\" title=\"5.2 消息顺序\"></a>5.2 消息顺序</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;消息的顺序性是指消费者消费到的消息和发送者发布的消息的顺序是一致的。举个例子，不考虑消息重复的情况，如果生产者发布的消息分别为msgl、msg2、msg3，那么消费者必然也是按照msgl、msg2、msg3的顺序进行消费的。<br>&nbsp;&nbsp;&nbsp;&nbsp;目前很多资料显示RabbitMQ的消息能够保障顺序性，这是不正确的，或者说这个观点有很大的局限性。在不使用任何RabbitMQ的高级特性，也没有消息丢失、网络故障之类异常的情况发生，并且只有一个消费者的情况下，最好也只有一个生产者的情况下可以保证消息的顺序性。如果有多个生产者同时发送消息，无法确定消息到达Broker 的前后顺序，也就无法验证消息的顺序性。<br>&nbsp;&nbsp;&nbsp;&nbsp;那么哪些情况下RabbitMQ 的消息顺序性会被打破呢?下面介绍几种常见的情形。</p>\n<ul>\n<li><p>如果生产者使用了事务机制，在发送消息之后遇到异常进行了事务回滚，那么需要重新补偿发送这条消息，如果补偿发送是在另一个线程实现的，那么消息在生产者这个源头就出现了错序。同样，如果启用publisher confirm时，在发生超时、中断，又或者是收到RabbitMQ的BasicNack命令时，那么同样需要补偿发送，结果与事务机制一样会错序。或者这种说法有些牵强，我们可以固执地认为消息的顺序性保障是从存入队列之后开始的，而不是在发迭的时候开始的。</p>\n</li>\n<li><p>考虑另一种情形，如果生产者发送的消息设置了不同的超时时间，井且也设置了死信队列，整体上来说相当于一个延迟队列，那么消费者在消费这个延迟队列的时候，消息的顺序必然不会和生产者发送消息的顺序一致。</p>\n</li>\n<li><p>如果消息设置了优先级，那么消费者消费到的消息也必然不是顺序性的。</p>\n</li>\n<li><p>如果一个队列按照前后顺序分有msg1， msg2、msg3、msg4这4 个消息，同时有ConsumerA和ConsumerB 这两个消费者同时订阅了这个队列。队列中的消息轮询分发到各个消费者之中，ConsumerA 中的消息为msg1和msg3，ConsumerB中的消息为msg2、msg4。ConsumerA收到消息msg1之后并不想处理而调用了BasicNack/BasicReject将消息拒绝，与此同时将requeue设置为true，这样这条消息就可以重新存入队列中。消息msg1之后被发送到了ConsumerB中，此时ConsumerB己经消费了msg2、msg4，之后再消费msg1.这样消息顺序性也就错乱了。</p>\n</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;包括但不仅限于以上几种情形会使RabbitMQ 消息错序。如果要保证消息的顺序性，需要业务方使用的时候做进一步的处理。如在消息体内添加全局有序标识等。</p>\n<h3 id=\"六、消息传输保障\"><a href=\"#六、消息传输保障\" class=\"headerlink\" title=\"六、消息传输保障\"></a>六、消息传输保障</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;消息可靠传输一般是业务系统接入消息中间件时首要考虑的问题，一般消息中间件的消息<br>传输保障分为三个层级。</p>\n<ul>\n<li>At most once: 最多一次。消息可能会丢失，但绝不会重复传输。</li>\n<li>At least once: 最少一次。消息绝不会丢失，但可能会重复传输。</li>\n<li>Exactly once: 恰好一次。每条消息肯定会被传输一次且仅传输一次。</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 支持其中的”最多一次”和”最少一次”。其中”最少一次”投递实现需要考虑以下这个几个方面的内容:</p>\n<ol>\n<li>消息生产者需要开启事务机制或者publisher confirm 机制，以确保消息可以可靠地传<br>输到RabbitMQ 中。</li>\n<li>消息生产者需要配合使用mandatory参数或者备份交换器来确保消息能够从交换器<br>路由到队列中，进而能够保存下来而不会被丢弃。</li>\n<li>消息和队列都需要进行持久化处理，以确保RabbitMQ服务器在遇到异常情况时不会造成消息丢失。</li>\n<li>消费者在消费消息的同时需要将noAck设置为false，然后通过手动确认的方式去确认己经正确消费的消息，以避免在消费端引起不必要的消息丢失。</li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;”最多一次”的方式就无须考虑以上那些方面，生产者随意发送，消费者随意消费，不过这样很难确保消息不会重复消费。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;”恰好一次”是RabbitMQ目前无法保障的(目前我也不知道哪个中间件能够保证)。消费者在消费完一条消息之后向RabbitMQ 发送确认BasicAck命令，此时由于网络断开或者其他原因造成RabbitMQ并没有收到这个确认命令，那么RabbitMQ不会将此条消息标记删除。在重新建立连接之后，消费者还是会消费到这一条消息，这就造成了重复消费。再考虑一种情况，生产者在使用publisher confirm机制的时候，发送完一条消息等待RabbitMQ 返回确认通知，此时网络断开，生产者捕获到异常情况，为了确保消息可靠性选择重新发送，这样RabbitMQ中就有两条同样的消息，在消费的时候，消费者就会重复消费。而解决重复消费可以通过消费者幂等等方式来解决。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本篇文章，我们思考了使用RabbitMQ过程中需要注意的几个问题，而前两篇文章对RabbitMQ的概念以及如何使用做了简单的介绍，相信经过这些介绍已经对RabbitMQ有了基本的了解。但这些远远不够，想要更好的利用好RabbitMQ还需要结合我们的业务场景来更多的去使用它(切记不要为了使用技术而使用技术!)。关于RabbitMQ的运维篇，会在以后的文章中继续给大家分享。</p>"},{"title":"RabbitMQ的使用基础篇","date":"2018-11-11T01:07:41.000Z","aside":"rabbitmq","_content":"\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;我是在解决分布式事务的一致性问题时了解到RabbitMQ的，当时主要是要基于RabbitMQ来实现我们分布式系统之间对有事务可靠性要求的系统间通信的。关于分布式事务一致性问题及其常见的解决方案，可以看我另一篇博客。提到RabbitMQ，不难想到的几个关键字:消息中间件、消息队列。而消息队列不由让我想到，当时在大学学习操作系统这门课，消息队列不难想到生产者消费者模式。(PS:操作系统这门课程真的很好也很重要，其中的一些思想在我工作的很长一段一时间内给了我很大帮助和启发，给我提供了许多解决问题的思路。强烈建议每一个程序员都去学一学操作系统！)\n<!--more-->\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-8/59528487.jpg)\n\n### 系列文章\n\n[分布式系统消息中间件——RabbitMQ的使用基础篇](http://blog.loading.ink/2018/11/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/)\n\n[分布式系统消息中间件——RabbitMQ的使用进阶篇](http://blog.loading.ink/2018/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/)\n\n[分布式系统消息中间件——RabbitMQ的使用思考篇](http://blog.loading.ink/2018/11/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%9D%E8%80%83%E7%AF%87/)\n\n### 一 消息中间件\n\n#### 1.1 简介\n\n&nbsp;&nbsp;&nbsp;&nbsp;消息中间件也可以称消息队列，是指用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信。当下主流的消息中间件有RabbitMQ、Kafka、ActiveMQ、RocketMQ等。其能在不同平台之间进行通信，常用来屏蔽各种平台协议之间的特性，实现应用程序之间的协同。其优点在于能够在客户端和服务器之间进行同步和异步的连接，并且在任何时刻都可以将消息进行传送和转发。是分布式系统中非常重要的组件，主要用来解决应用耦合、异步通信、流量削峰等问题。\n\n#### 1.2 作用\n\n&nbsp;&nbsp;&nbsp;&nbsp;消息中间件几大主要作用如下:\n\n* 解耦:在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束即可。\n* 冗余(存储):在某些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息己经被处理完成，从而确保你的数据被安全地保存直到你使用完毕。\n* 扩展性:因为消息中间件解捐了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。\n* 削峰:在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩惯。\n* 可恢复性:当系统一部分组件失效时，不会影响到整个系统。消息中间件降低了进程间的稿合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。\n* 顺序保证：在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。\n* 缓冲：在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。\n* 异步通信:在很多时候应用不想也不需要立即处理消息。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。\n\n#### 1.3 消息中间件的两种模式\n\n##### 1.3.1 P2P模式\n\n&nbsp;&nbsp;&nbsp;&nbsp;P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。\n\nP2P的特点:\n\n* 每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)\n* 发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行它不会影响到消息被发送到队列\n* 接收者在成功接收消息之后需向队列应答成功 \n* 如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式\n\n##### 1.3.2 Pub/Sub模式\n\n&nbsp;&nbsp;&nbsp;&nbsp;Pub/Sub模式包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。\n\nPub/Sub的特点\n\n* 每个消息可以有多个消费者\n* 发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。\n* 为了消费消息，订阅者必须保持运行的状态。\n* 如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。\n\n#### 1.4 常用中间件介绍与对比\n\n* Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。\n\n* RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。\n\n* RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。\n\nRabbitMQ比Kafka可靠，kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。\n\n### 二 RabbitMQ了解\n\n#### 2.1 简介\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ是流行的开源消息队列系统。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由(Routing)，负载均衡(Load balance)或者数据持久化都有很好的支持。其主要特点如下:\n\n* 可靠性\n* 灵活的路由\n* 扩展性\n* 高可用性\n* 多种协议\n* 多语言客户端\n* 管理界面\n* 插件机制\n\n#### 2.2 概念\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ从整体上来看是一个典型的生产者消费者模型，主要负责接收、存储和转发消息。其整体模型架构如下图所示:![RabbitMQ 模型架构](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-9/84394083.jpg)\n\n\n\n我们先来看一个RabbitMQ的运转流程，稍后会对这个流程中所涉及到的一些概念进行详细的解释。\n\n生产者:\n\n(1)生产者连接到RabbitMQ Broker，建立一个连接( Connection)开启一个信道(Channel)\n(2)生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等\n(3)生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等\n(4)生产者通过路由键将交换器和队列绑定起来\n(5)生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息。\n(6)相应的交换器根据接收到的路由键查找相匹配的队列。\n(7)如果找到，则将从生产者发送过来的消息存入相应的队列中。\n(8)如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者\n(9)关闭信道。\n(10)关闭连接。'\n\n消费者:\n\n(1)消费者连接到RabbitMQ Broker ，建立一个连接(Connection)，开启一个信道(Channel) 。\n(2)消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，\n(3)等待RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。\n(4)消费者确认(ack) 接收到的消息。\n(5)RabbitMQ 从队列中删除相应己经被确认的消息。\n(6)关闭信道。\n\n(7)关闭连接。\n\n##### 2.2.1 信道\n\n这里我们主要了解两个问题：\n\n为什么要有信道?\n\n&nbsp;&nbsp;&nbsp;&nbsp;主要原因还是在于TCP连接的&quot;昂贵&quot;性。无论是生产者还是消费者，都需要和RabbitMQ Broker 建立连接，这个连接就是一条TCP 连接。而操作系统对于TCP连接的创建于销毁是非常昂贵的开销。假设消费者要消费消息，并根据服务需求合理调度线程，若只进行TCP连接，那么当高并发的时候，每秒可能都有成千上万的TCP连接，不仅仅是对TCP连接的浪费，也很快会超过操作系统每秒所能建立连接的数量。如果能在一条TCP连接上操作，又能保证各个线程之间的私密性就完美了，于是信道的概念出现了。\n\n信道是什么?\n\n&nbsp;&nbsp;&nbsp;&nbsp;信道是建立在Connection 之上的虚拟连接。当应用程序与Rabbit Broker建立TCP连接的时候，客户端紧接着可以创建一个AMQP 信道(Channel) ，每个信道都会被指派一个唯一的D。RabbitMQ 处理的每条AMQP 指令都是通过信道完成的。信道就像电缆里的光纤束。一条电缆内含有许多光纤束，允许所有的连接通过多条光线束进行传输和接收。\n\n##### 2.2.2 生产者消费者\n\n&nbsp;&nbsp;&nbsp;&nbsp;关于生产者消费者我们需要了解几个概念:\n\n* Producer:生产者，即消息投递者一方。\n* 消息:消息一般分两个部分:消息体(payload)和标签。标签用来描述这条消息，如:一个交换器的名称或者一个路由Key，Rabbit通过解析标签来确定消息的去向，payload是消息内容可以使一个json，数组等等。\n* Consumer:消费者，就是接收消息的一方。消费者订阅RabbitMQ的队列，当消费者消费一条消息时，只是消费消息的消息体。在消息路由的过程中，会丢弃标签，存入到队列中的只有消息体。\n* Broker:消息中间件的服务节点。\n\n##### 2.2.3 队列、交换器、路由key、绑定\n\n&nbsp;&nbsp;&nbsp;&nbsp;从RabbitMQ的运转流程我们可以知道生产者的消息是发布到交换器上的。而消费者则是从队列上获取消息的。那么消息到底是如何从交换器到队列的呢?我们先具体了解一下这几个概念。\n\n&nbsp;&nbsp;&nbsp;&nbsp;Queue:队列，是RabbitMQ的内部对象，用于存储消息。RabbitMQ中消息只能存储在队列中。生产者投递消息到队列，消费者从队列中获取消息并消费。多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊(轮询)给多个消费者进行消费，而不是每个消费者都收到所有的消息进行消费。(注意：RabbitMQ不支持队列层面的广播消费，如果需要广播消费，可以采用一个交换器通过路由Key绑定多个队列，由多个消费者来订阅这些队列的方式。)\n\n&nbsp;&nbsp;&nbsp;&nbsp;Exchange：交换器。在RabbitMQ中，生产者并非直接将消息投递到队列中。真实情况是，生产者将消息发送到Exchange(交换器)，由交换器将消息路由到一个或多个队列中。如果路由不到，或返回给生产者，或直接丢弃，或做其它处理。\n\n&nbsp;&nbsp;&nbsp;&nbsp;RoutingKey:路由Key。生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则。这个路由Key需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时通过指定RoutingKey来决定消息流向哪里。\n\n&nbsp;&nbsp;&nbsp;&nbsp;Binding：RabbitMQ通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ就可以指定如何正确的路由到队列了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;从这里我们可以看到在RabbitMQ中交换器和队列实际上可以是一对多，也可以是多对多关系。交换器和队列就像我们关系数据库中的两张表。他们同归BindingKey做关联(多对多关系表)。在我们投递消息时，可以通过Exchange和RoutingKey(对应BindingKey)就可以找到相对应的队列。\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ主要有四种类型的交换器:\n\n* fanout：扇形交换器，它会把发送到该交换器的消息路由到所有与该交换器绑定的队列中。如果使用扇形交换器，则不会匹配路由Key。\n\n  ![RabbitMQ Fanout交换器](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/39683646.jpg)\n\n* direct:direct交换器，会把消息路由到RoutingKey与BindingKey完全匹配的队列中。\n\n  ![RabbitMQ direct交换器](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/40498280.jpg)\n\n* topic:完全匹配BindingKey和RoutingKey的direct交换器 有些时候并不能满足实际业务的需求。topic 类型的交换器在匹配规则上进行了扩展，它与direct 类型的交换器相似，也是将消息路由到BindingKey 和RoutingKey 相匹配的队\n  列中，但这里的匹配规则有些不同，它约定:\n\n  * RoutingKey 为一个点号&quot;.&quot;分隔的字符串(被点号&quot;.&quot;分隔开的每一段独立的字符\n    串称为一个单词)λ，如&quot;hs.rabbitmq.client&quot;，&quot;com.rabbit.client&quot;等。\n  * BindingKey 和RoutingKey 一样也是点号&quot;.&quot;分隔的字符串;\n  * BindingKey 中可以存在两种特殊字符串&quot;\\*&quot;和&quot;#&quot;，用于做模糊匹配，其中&quot;\\*&quot;用于匹配一个单词，&quot;\\#&quot;用于匹配多规格单词(可以是零个)。\n\n![RabbitMQ topic交换器](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/30382119.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如图:\n\n​    · 路由键为\" apple.rabbit.client\" 的消息会同时路由到Queuel 和Queue2;\n​    · 路由键为\" orange.mq.client\" 的消息只会路由到Queue2 中:\n​    · 路由键为\" apple.mq.demo\" 的消息只会路由到Queue2 中:\n​    · 路由键为\" banana.rabbit.demo\" 的消息只会路由到Queuel 中:\n​    · 路由键为\" apple.orange.banana\" 的消息将会被丢弃或者返回给生产者因为它没有匹配任何路由键。\n\n* header:headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中\n  的headers 属性进行匹配。在绑定队列和交换器时制定一组键值对， 当发送消息到交换器时，\n  RabbitMQ 会获取到该消息的headers (也是一个键值对的形式) ，对比其中的键值对是否完全\n  匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由\n  到该队列。(注:该交换器类型性能较差且不实用，因此一般不会用到)。\n\n了解了上面的概念，我们再来思考消息是如何从交换器到队列的。首先Rabbit在接收到消息时，会解析消息的标签从而得到消息的交换器与路由key信息。然后根据交换器的类型、路由key以及该交换器和队列的绑定关系来决定消息最终投递到哪个队列里面。\n\n### 三 RabbitMQ使用\n\n#### 3.1 RabbitMQ安装\n\n这里我们基于docker来安装。\n\n##### 3.1.1 拉取镜像\n\n```\ndocker pull rabbitmq:management\n```\n\n##### 3.1.2 启动容器\n\n```\ndocker run -d  --name rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management\n```\n\n#### 3.2 RabbitMQ 客户端开发使用\n\n这里我们以dotnet平台下RabbitMQ.Client3.6.9(可以从nuget中下载)为示例，简单介绍dotnet平台下对RabbitMQ的简单操作。更详细的内容可以从nuget中下载源码和文档进行查看。\n\n##### 3.2.1 连接Rabbit\n\n```c#\n  ConnectionFactory factory = new ConnectionFactory();\n            factory.UserName = \"admin\";//用户名\n            factory.Password = \"admin\";//密码      \n            factory.HostName = \"192.168.17.205\";//主机名\n            factory.VirtualHost = \"\";//虚拟主机(这个暂时不需要，稍后的文章里会介绍虚拟主机的概念)\n            factory.Port = 15672;//端口\n            IConnection conn = factory.CreateConnection();//创建连接\n```\n\n##### 3.2.2 创建信道\n\n```c#\n    IModel channel = conn.CreateModel();\n```\n\n说明：Connection 可以用来创建多个Channel 实例，但是Channel 实例不能在线程问共享，应用程序应该为每一个线程开辟一个Channel 。某些情况下Channel 的操作可以并发运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时也会影响友送方确认( publisherconfrrm)机制的运行，所以多线程问共享Channel实例是非线程安全的。\n\n##### 3.2.3 交换器、队列和绑定\n\n```C#\n channel.ExchangeDeclare(\"exchangeName\", \"direct\", true);\n String queueName = channel.QueueDeclare().QueueName;\n channel.QueueBind(queueName, \"exchangeName\", \"routingKey\");\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上创建了一个持久化的、非自动删除的、绑定类型为direct 的交换器，同时也创建了一个非持久化的、排他的、自动删除的队列(此队列的名称由RabbitMQ 自动生成)。这里的交换器和队列也都没有设置特殊的参数。\n\n&nbsp;&nbsp;&nbsp;&nbsp;上面的代码也展示了如何使用路由键将队列和交换器绑定起来。上面声明的队列具备如下特性: 只对当前应用中同一个Connection 层面可用，同一个Connection 的不同Channel可共用，并且也会在应用连接断开时自动删除。\n\n&nbsp;&nbsp;&nbsp;&nbsp;上述方法根据参数不同，可以有不同的重载形式，根据自身的需要进行调用。\n\n**ExchangeDeclare方法详解：**\n\nExchangeDeclare有多个重载方法，这些重载方法都是由下面这个方法中缺省的某些参数构成的。\n\n```c#\nvoid ExchangeDeclare(string exchange, string type, bool durable, bool autoDelete, IDictionary<string, object> arguments);\n```\n\n* exchange : 交换器的名称。\n* type : 交换器的类型，常见的如fanout、direct 、topic\n* durable: 设置是否持久化。durab l e 设置为true 表示持久化， 反之是非持久化。持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。\n* autoDelete : 设置是否自动删除。autoDelete 设置为true 则表示自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。注意不能错误地把这个参数理解为:\"当与此交换器连接的客户端都断开时， RabbitMQ 会自动删除本交换器\"。\n* internal : 设置是否是内置的。如果设置为true ，则表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。\n* argument : 其他一些结构化参数，比如alternate - exchange。\n\n**QueueDeclare方法详解：**\n\nQueueDeclare只有两个重载。\n\n```c#\n QueueDeclareOk QueueDeclare();\n \n QueueDeclareOk QueueDeclare(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary<string, object> arguments);\n```\n\n不带任何参数的queueDeclare 方法默认创建一个由RabbitMQ 命名的(类似这种amq.gen-LhQzlgv3GhDOv8PIDabOXA 名称，这种队列也称之为匿名队列〉、排他的、自动删除的、非持久化的队列。\n\n* queue : 队列的名称。\n* durable: 设置是否持久化。为true 则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。\n* exclusive : 设置是否排他。为true 则设置队列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意三点:排他队列是基于连接( Connection) 可见的，同一个连接的不同信道(Channel)是可以同时访问同一连接创建的排他队列; \"首次\"是指如果一个连接己经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同:即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。\n* autoDelete: 设置是否自动删除。为true 则设置队列为自动删除。自动删除的前提是:至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为:当连接到此队列的所有客户端断开时，这个队列自动删除\"，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。\n* argurnents: 设置队列的其他一些参数，如x-rnessage-ttl、x-expires、x-rnax-length、x-rnax-length-bytes、x-dead-letter-exchange、x-deadletter-routing-key, x-rnax-priority等。\n\n**注意:生产者和消费者都能够使用queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道直为\"传输\"模式，之后才能声明队列。**\n\n**QueueBind 方法详解：**\n\n将队列和交换器绑定的方法如下：\n\n```c#\nvoid QueueBind(string queue, string exchange, string routingKey, IDictionary<string, object> arguments);\n```\n\n* queue: 队列名称:\n* exchange: 交换器的名称:\n* routingKey: 用来绑定队列和交换器的路由键;\n* argument: 定义绑定的一些参数。\n\n将队列与交换器解绑的方法如下:\n\n```c#\nQueueUnbind(string queue, string exchange, string routingKey, IDictionary<string, object> arguments);\n```\n\n其参数与绑定意义相同。\n\n注：除队列可以绑定交换器外，交换器同样可以绑定队列。即:ExchangeBind方法，其使用方式与队列绑定相似。\n\n##### 3.2.4 发送消息\n\n&nbsp;&nbsp;&nbsp;&nbsp;发送消息可以使用BasicPublish方法。\n\n```\nvoid BasicPublish(string exchange, string routingKey, bool mandatory,IBasicProperties basicProperties, byte[] body);\n```\n\n* exchange: 交换器的名称，指明消息需要发送到哪个交换器中。如果设置为空字符串，则消息会被发送到RabbitMQ 默认的交换器中。\n* routingKey : 路由键，交换器根据路由键将消息存储到相应的队列之中。\n* basicProperties: 消息的基本属性集。\n* body : 消息体( pay1oad ),真正需要发送的消息。\n* mandatory: 是否将消息返回给生产者(会在后续的文章中介绍这个参数).\n\n##### 3.2.5 消费消息\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 的消费模式分两种: 推(Push)模式和拉(Pull)模式。推模式采用BasicConsume\n进行消费，而拉模式则是调用BasicGet进行消费。\n\n**推模式:**\n\n```c#\n EventingBasicConsumer consumer = new EventingBasicConsumer(channel);//定义消费者对象\n consumer.Received += (model, ea) =>\n {\n        //do someting;\n        channel.BasicAck(ea.DeliveryTag, multiple: false);//确认\n };\n   channel.BasicConsume(queue: \"queueName\",\n                        noAck: false,\n                        consumer: consumer);//订阅消息\n```\n\n```c#\nstring BasicConsume(string queue, bool noAck, string consumerTag, bool noLocal, bool exclusive, IDictionary<string, object> arguments, IBasicConsumer consumer);\n```\n\n* queue : 队列的名称:\n* noAck : 设置是否需要确认，false为需要确认。\n* consumerTag: 消费者标签，用来区分多个消费者:\n* noLocal : 设置为true 则表示不能将同一个Connection中生产者发送的消息传送给这个Connection中的消费者:\n* exclusive : 设置是否排他\n* arguments : 设置消费者的其他参数\n* consumer: 指定处理消息的消费者对象。\n\n**拉模式**\n\n```\nBasicGetResult result = channel.BasicGet(\"queueName\", noAck: false);//获取消息\n\nchannel.BasicAck(result.DeliveryTag, multiple: false);//确认\n```\n\n##### 3.2.6 关闭连接\n\n在应用程序使用完之后，需要关闭连接，释放资源:\n\n```\nchannel.close();\nconn.close() ;\n```\n\n显式地关闭Channel 是个好习惯，但这不是必须的，在Connection 关闭的时候，Channel 也会自动关闭。\n\n### 结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;以上简单介绍了分布式系统中消息中间件的概念与作用，以及RabbitMQ的一些基本概念与简单使用。下一篇文章将继续针对RabbitMQ进行总结。主要内容包括何时创建队列、RabbitMQ的确认机制、过期时间的使用、死信队列、以及利用RabbitMQ实现延迟队列......\n\n### 参考\n\n《RabbitMQ实战指南》\n\n《RabbitMQ实战 高效部署分布式消息队列》\n\n\n\n\n\n","source":"_posts/技术实践/rabbitmq/RabbitMQ的使用基础篇.md","raw":"---\ntitle: RabbitMQ的使用基础篇\ndate: 2018-11-11 09:07:41\ntags: \n- 消息队列\n- RabbitMQ\ncategories: 消息队列\naside: rabbitmq\n---\n\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;我是在解决分布式事务的一致性问题时了解到RabbitMQ的，当时主要是要基于RabbitMQ来实现我们分布式系统之间对有事务可靠性要求的系统间通信的。关于分布式事务一致性问题及其常见的解决方案，可以看我另一篇博客。提到RabbitMQ，不难想到的几个关键字:消息中间件、消息队列。而消息队列不由让我想到，当时在大学学习操作系统这门课，消息队列不难想到生产者消费者模式。(PS:操作系统这门课程真的很好也很重要，其中的一些思想在我工作的很长一段一时间内给了我很大帮助和启发，给我提供了许多解决问题的思路。强烈建议每一个程序员都去学一学操作系统！)\n<!--more-->\n![image](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-8/59528487.jpg)\n\n### 系列文章\n\n[分布式系统消息中间件——RabbitMQ的使用基础篇](http://blog.loading.ink/2018/11/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/)\n\n[分布式系统消息中间件——RabbitMQ的使用进阶篇](http://blog.loading.ink/2018/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/)\n\n[分布式系统消息中间件——RabbitMQ的使用思考篇](http://blog.loading.ink/2018/11/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%9D%E8%80%83%E7%AF%87/)\n\n### 一 消息中间件\n\n#### 1.1 简介\n\n&nbsp;&nbsp;&nbsp;&nbsp;消息中间件也可以称消息队列，是指用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信。当下主流的消息中间件有RabbitMQ、Kafka、ActiveMQ、RocketMQ等。其能在不同平台之间进行通信，常用来屏蔽各种平台协议之间的特性，实现应用程序之间的协同。其优点在于能够在客户端和服务器之间进行同步和异步的连接，并且在任何时刻都可以将消息进行传送和转发。是分布式系统中非常重要的组件，主要用来解决应用耦合、异步通信、流量削峰等问题。\n\n#### 1.2 作用\n\n&nbsp;&nbsp;&nbsp;&nbsp;消息中间件几大主要作用如下:\n\n* 解耦:在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束即可。\n* 冗余(存储):在某些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息己经被处理完成，从而确保你的数据被安全地保存直到你使用完毕。\n* 扩展性:因为消息中间件解捐了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。\n* 削峰:在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩惯。\n* 可恢复性:当系统一部分组件失效时，不会影响到整个系统。消息中间件降低了进程间的稿合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。\n* 顺序保证：在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。\n* 缓冲：在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。\n* 异步通信:在很多时候应用不想也不需要立即处理消息。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。\n\n#### 1.3 消息中间件的两种模式\n\n##### 1.3.1 P2P模式\n\n&nbsp;&nbsp;&nbsp;&nbsp;P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。\n\nP2P的特点:\n\n* 每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)\n* 发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行它不会影响到消息被发送到队列\n* 接收者在成功接收消息之后需向队列应答成功 \n* 如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式\n\n##### 1.3.2 Pub/Sub模式\n\n&nbsp;&nbsp;&nbsp;&nbsp;Pub/Sub模式包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。\n\nPub/Sub的特点\n\n* 每个消息可以有多个消费者\n* 发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。\n* 为了消费消息，订阅者必须保持运行的状态。\n* 如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。\n\n#### 1.4 常用中间件介绍与对比\n\n* Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。\n\n* RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。\n\n* RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。\n\nRabbitMQ比Kafka可靠，kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。\n\n### 二 RabbitMQ了解\n\n#### 2.1 简介\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ是流行的开源消息队列系统。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由(Routing)，负载均衡(Load balance)或者数据持久化都有很好的支持。其主要特点如下:\n\n* 可靠性\n* 灵活的路由\n* 扩展性\n* 高可用性\n* 多种协议\n* 多语言客户端\n* 管理界面\n* 插件机制\n\n#### 2.2 概念\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ从整体上来看是一个典型的生产者消费者模型，主要负责接收、存储和转发消息。其整体模型架构如下图所示:![RabbitMQ 模型架构](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-9/84394083.jpg)\n\n\n\n我们先来看一个RabbitMQ的运转流程，稍后会对这个流程中所涉及到的一些概念进行详细的解释。\n\n生产者:\n\n(1)生产者连接到RabbitMQ Broker，建立一个连接( Connection)开启一个信道(Channel)\n(2)生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等\n(3)生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等\n(4)生产者通过路由键将交换器和队列绑定起来\n(5)生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息。\n(6)相应的交换器根据接收到的路由键查找相匹配的队列。\n(7)如果找到，则将从生产者发送过来的消息存入相应的队列中。\n(8)如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者\n(9)关闭信道。\n(10)关闭连接。'\n\n消费者:\n\n(1)消费者连接到RabbitMQ Broker ，建立一个连接(Connection)，开启一个信道(Channel) 。\n(2)消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，\n(3)等待RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。\n(4)消费者确认(ack) 接收到的消息。\n(5)RabbitMQ 从队列中删除相应己经被确认的消息。\n(6)关闭信道。\n\n(7)关闭连接。\n\n##### 2.2.1 信道\n\n这里我们主要了解两个问题：\n\n为什么要有信道?\n\n&nbsp;&nbsp;&nbsp;&nbsp;主要原因还是在于TCP连接的&quot;昂贵&quot;性。无论是生产者还是消费者，都需要和RabbitMQ Broker 建立连接，这个连接就是一条TCP 连接。而操作系统对于TCP连接的创建于销毁是非常昂贵的开销。假设消费者要消费消息，并根据服务需求合理调度线程，若只进行TCP连接，那么当高并发的时候，每秒可能都有成千上万的TCP连接，不仅仅是对TCP连接的浪费，也很快会超过操作系统每秒所能建立连接的数量。如果能在一条TCP连接上操作，又能保证各个线程之间的私密性就完美了，于是信道的概念出现了。\n\n信道是什么?\n\n&nbsp;&nbsp;&nbsp;&nbsp;信道是建立在Connection 之上的虚拟连接。当应用程序与Rabbit Broker建立TCP连接的时候，客户端紧接着可以创建一个AMQP 信道(Channel) ，每个信道都会被指派一个唯一的D。RabbitMQ 处理的每条AMQP 指令都是通过信道完成的。信道就像电缆里的光纤束。一条电缆内含有许多光纤束，允许所有的连接通过多条光线束进行传输和接收。\n\n##### 2.2.2 生产者消费者\n\n&nbsp;&nbsp;&nbsp;&nbsp;关于生产者消费者我们需要了解几个概念:\n\n* Producer:生产者，即消息投递者一方。\n* 消息:消息一般分两个部分:消息体(payload)和标签。标签用来描述这条消息，如:一个交换器的名称或者一个路由Key，Rabbit通过解析标签来确定消息的去向，payload是消息内容可以使一个json，数组等等。\n* Consumer:消费者，就是接收消息的一方。消费者订阅RabbitMQ的队列，当消费者消费一条消息时，只是消费消息的消息体。在消息路由的过程中，会丢弃标签，存入到队列中的只有消息体。\n* Broker:消息中间件的服务节点。\n\n##### 2.2.3 队列、交换器、路由key、绑定\n\n&nbsp;&nbsp;&nbsp;&nbsp;从RabbitMQ的运转流程我们可以知道生产者的消息是发布到交换器上的。而消费者则是从队列上获取消息的。那么消息到底是如何从交换器到队列的呢?我们先具体了解一下这几个概念。\n\n&nbsp;&nbsp;&nbsp;&nbsp;Queue:队列，是RabbitMQ的内部对象，用于存储消息。RabbitMQ中消息只能存储在队列中。生产者投递消息到队列，消费者从队列中获取消息并消费。多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊(轮询)给多个消费者进行消费，而不是每个消费者都收到所有的消息进行消费。(注意：RabbitMQ不支持队列层面的广播消费，如果需要广播消费，可以采用一个交换器通过路由Key绑定多个队列，由多个消费者来订阅这些队列的方式。)\n\n&nbsp;&nbsp;&nbsp;&nbsp;Exchange：交换器。在RabbitMQ中，生产者并非直接将消息投递到队列中。真实情况是，生产者将消息发送到Exchange(交换器)，由交换器将消息路由到一个或多个队列中。如果路由不到，或返回给生产者，或直接丢弃，或做其它处理。\n\n&nbsp;&nbsp;&nbsp;&nbsp;RoutingKey:路由Key。生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则。这个路由Key需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时通过指定RoutingKey来决定消息流向哪里。\n\n&nbsp;&nbsp;&nbsp;&nbsp;Binding：RabbitMQ通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ就可以指定如何正确的路由到队列了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;从这里我们可以看到在RabbitMQ中交换器和队列实际上可以是一对多，也可以是多对多关系。交换器和队列就像我们关系数据库中的两张表。他们同归BindingKey做关联(多对多关系表)。在我们投递消息时，可以通过Exchange和RoutingKey(对应BindingKey)就可以找到相对应的队列。\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ主要有四种类型的交换器:\n\n* fanout：扇形交换器，它会把发送到该交换器的消息路由到所有与该交换器绑定的队列中。如果使用扇形交换器，则不会匹配路由Key。\n\n  ![RabbitMQ Fanout交换器](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/39683646.jpg)\n\n* direct:direct交换器，会把消息路由到RoutingKey与BindingKey完全匹配的队列中。\n\n  ![RabbitMQ direct交换器](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/40498280.jpg)\n\n* topic:完全匹配BindingKey和RoutingKey的direct交换器 有些时候并不能满足实际业务的需求。topic 类型的交换器在匹配规则上进行了扩展，它与direct 类型的交换器相似，也是将消息路由到BindingKey 和RoutingKey 相匹配的队\n  列中，但这里的匹配规则有些不同，它约定:\n\n  * RoutingKey 为一个点号&quot;.&quot;分隔的字符串(被点号&quot;.&quot;分隔开的每一段独立的字符\n    串称为一个单词)λ，如&quot;hs.rabbitmq.client&quot;，&quot;com.rabbit.client&quot;等。\n  * BindingKey 和RoutingKey 一样也是点号&quot;.&quot;分隔的字符串;\n  * BindingKey 中可以存在两种特殊字符串&quot;\\*&quot;和&quot;#&quot;，用于做模糊匹配，其中&quot;\\*&quot;用于匹配一个单词，&quot;\\#&quot;用于匹配多规格单词(可以是零个)。\n\n![RabbitMQ topic交换器](http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/30382119.jpg)\n\n&nbsp;&nbsp;&nbsp;&nbsp;如图:\n\n​    · 路由键为\" apple.rabbit.client\" 的消息会同时路由到Queuel 和Queue2;\n​    · 路由键为\" orange.mq.client\" 的消息只会路由到Queue2 中:\n​    · 路由键为\" apple.mq.demo\" 的消息只会路由到Queue2 中:\n​    · 路由键为\" banana.rabbit.demo\" 的消息只会路由到Queuel 中:\n​    · 路由键为\" apple.orange.banana\" 的消息将会被丢弃或者返回给生产者因为它没有匹配任何路由键。\n\n* header:headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中\n  的headers 属性进行匹配。在绑定队列和交换器时制定一组键值对， 当发送消息到交换器时，\n  RabbitMQ 会获取到该消息的headers (也是一个键值对的形式) ，对比其中的键值对是否完全\n  匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由\n  到该队列。(注:该交换器类型性能较差且不实用，因此一般不会用到)。\n\n了解了上面的概念，我们再来思考消息是如何从交换器到队列的。首先Rabbit在接收到消息时，会解析消息的标签从而得到消息的交换器与路由key信息。然后根据交换器的类型、路由key以及该交换器和队列的绑定关系来决定消息最终投递到哪个队列里面。\n\n### 三 RabbitMQ使用\n\n#### 3.1 RabbitMQ安装\n\n这里我们基于docker来安装。\n\n##### 3.1.1 拉取镜像\n\n```\ndocker pull rabbitmq:management\n```\n\n##### 3.1.2 启动容器\n\n```\ndocker run -d  --name rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management\n```\n\n#### 3.2 RabbitMQ 客户端开发使用\n\n这里我们以dotnet平台下RabbitMQ.Client3.6.9(可以从nuget中下载)为示例，简单介绍dotnet平台下对RabbitMQ的简单操作。更详细的内容可以从nuget中下载源码和文档进行查看。\n\n##### 3.2.1 连接Rabbit\n\n```c#\n  ConnectionFactory factory = new ConnectionFactory();\n            factory.UserName = \"admin\";//用户名\n            factory.Password = \"admin\";//密码      \n            factory.HostName = \"192.168.17.205\";//主机名\n            factory.VirtualHost = \"\";//虚拟主机(这个暂时不需要，稍后的文章里会介绍虚拟主机的概念)\n            factory.Port = 15672;//端口\n            IConnection conn = factory.CreateConnection();//创建连接\n```\n\n##### 3.2.2 创建信道\n\n```c#\n    IModel channel = conn.CreateModel();\n```\n\n说明：Connection 可以用来创建多个Channel 实例，但是Channel 实例不能在线程问共享，应用程序应该为每一个线程开辟一个Channel 。某些情况下Channel 的操作可以并发运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时也会影响友送方确认( publisherconfrrm)机制的运行，所以多线程问共享Channel实例是非线程安全的。\n\n##### 3.2.3 交换器、队列和绑定\n\n```C#\n channel.ExchangeDeclare(\"exchangeName\", \"direct\", true);\n String queueName = channel.QueueDeclare().QueueName;\n channel.QueueBind(queueName, \"exchangeName\", \"routingKey\");\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;如上创建了一个持久化的、非自动删除的、绑定类型为direct 的交换器，同时也创建了一个非持久化的、排他的、自动删除的队列(此队列的名称由RabbitMQ 自动生成)。这里的交换器和队列也都没有设置特殊的参数。\n\n&nbsp;&nbsp;&nbsp;&nbsp;上面的代码也展示了如何使用路由键将队列和交换器绑定起来。上面声明的队列具备如下特性: 只对当前应用中同一个Connection 层面可用，同一个Connection 的不同Channel可共用，并且也会在应用连接断开时自动删除。\n\n&nbsp;&nbsp;&nbsp;&nbsp;上述方法根据参数不同，可以有不同的重载形式，根据自身的需要进行调用。\n\n**ExchangeDeclare方法详解：**\n\nExchangeDeclare有多个重载方法，这些重载方法都是由下面这个方法中缺省的某些参数构成的。\n\n```c#\nvoid ExchangeDeclare(string exchange, string type, bool durable, bool autoDelete, IDictionary<string, object> arguments);\n```\n\n* exchange : 交换器的名称。\n* type : 交换器的类型，常见的如fanout、direct 、topic\n* durable: 设置是否持久化。durab l e 设置为true 表示持久化， 反之是非持久化。持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。\n* autoDelete : 设置是否自动删除。autoDelete 设置为true 则表示自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。注意不能错误地把这个参数理解为:\"当与此交换器连接的客户端都断开时， RabbitMQ 会自动删除本交换器\"。\n* internal : 设置是否是内置的。如果设置为true ，则表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。\n* argument : 其他一些结构化参数，比如alternate - exchange。\n\n**QueueDeclare方法详解：**\n\nQueueDeclare只有两个重载。\n\n```c#\n QueueDeclareOk QueueDeclare();\n \n QueueDeclareOk QueueDeclare(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary<string, object> arguments);\n```\n\n不带任何参数的queueDeclare 方法默认创建一个由RabbitMQ 命名的(类似这种amq.gen-LhQzlgv3GhDOv8PIDabOXA 名称，这种队列也称之为匿名队列〉、排他的、自动删除的、非持久化的队列。\n\n* queue : 队列的名称。\n* durable: 设置是否持久化。为true 则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。\n* exclusive : 设置是否排他。为true 则设置队列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意三点:排他队列是基于连接( Connection) 可见的，同一个连接的不同信道(Channel)是可以同时访问同一连接创建的排他队列; \"首次\"是指如果一个连接己经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同:即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。\n* autoDelete: 设置是否自动删除。为true 则设置队列为自动删除。自动删除的前提是:至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为:当连接到此队列的所有客户端断开时，这个队列自动删除\"，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。\n* argurnents: 设置队列的其他一些参数，如x-rnessage-ttl、x-expires、x-rnax-length、x-rnax-length-bytes、x-dead-letter-exchange、x-deadletter-routing-key, x-rnax-priority等。\n\n**注意:生产者和消费者都能够使用queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道直为\"传输\"模式，之后才能声明队列。**\n\n**QueueBind 方法详解：**\n\n将队列和交换器绑定的方法如下：\n\n```c#\nvoid QueueBind(string queue, string exchange, string routingKey, IDictionary<string, object> arguments);\n```\n\n* queue: 队列名称:\n* exchange: 交换器的名称:\n* routingKey: 用来绑定队列和交换器的路由键;\n* argument: 定义绑定的一些参数。\n\n将队列与交换器解绑的方法如下:\n\n```c#\nQueueUnbind(string queue, string exchange, string routingKey, IDictionary<string, object> arguments);\n```\n\n其参数与绑定意义相同。\n\n注：除队列可以绑定交换器外，交换器同样可以绑定队列。即:ExchangeBind方法，其使用方式与队列绑定相似。\n\n##### 3.2.4 发送消息\n\n&nbsp;&nbsp;&nbsp;&nbsp;发送消息可以使用BasicPublish方法。\n\n```\nvoid BasicPublish(string exchange, string routingKey, bool mandatory,IBasicProperties basicProperties, byte[] body);\n```\n\n* exchange: 交换器的名称，指明消息需要发送到哪个交换器中。如果设置为空字符串，则消息会被发送到RabbitMQ 默认的交换器中。\n* routingKey : 路由键，交换器根据路由键将消息存储到相应的队列之中。\n* basicProperties: 消息的基本属性集。\n* body : 消息体( pay1oad ),真正需要发送的消息。\n* mandatory: 是否将消息返回给生产者(会在后续的文章中介绍这个参数).\n\n##### 3.2.5 消费消息\n\n&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 的消费模式分两种: 推(Push)模式和拉(Pull)模式。推模式采用BasicConsume\n进行消费，而拉模式则是调用BasicGet进行消费。\n\n**推模式:**\n\n```c#\n EventingBasicConsumer consumer = new EventingBasicConsumer(channel);//定义消费者对象\n consumer.Received += (model, ea) =>\n {\n        //do someting;\n        channel.BasicAck(ea.DeliveryTag, multiple: false);//确认\n };\n   channel.BasicConsume(queue: \"queueName\",\n                        noAck: false,\n                        consumer: consumer);//订阅消息\n```\n\n```c#\nstring BasicConsume(string queue, bool noAck, string consumerTag, bool noLocal, bool exclusive, IDictionary<string, object> arguments, IBasicConsumer consumer);\n```\n\n* queue : 队列的名称:\n* noAck : 设置是否需要确认，false为需要确认。\n* consumerTag: 消费者标签，用来区分多个消费者:\n* noLocal : 设置为true 则表示不能将同一个Connection中生产者发送的消息传送给这个Connection中的消费者:\n* exclusive : 设置是否排他\n* arguments : 设置消费者的其他参数\n* consumer: 指定处理消息的消费者对象。\n\n**拉模式**\n\n```\nBasicGetResult result = channel.BasicGet(\"queueName\", noAck: false);//获取消息\n\nchannel.BasicAck(result.DeliveryTag, multiple: false);//确认\n```\n\n##### 3.2.6 关闭连接\n\n在应用程序使用完之后，需要关闭连接，释放资源:\n\n```\nchannel.close();\nconn.close() ;\n```\n\n显式地关闭Channel 是个好习惯，但这不是必须的，在Connection 关闭的时候，Channel 也会自动关闭。\n\n### 结束语\n\n&nbsp;&nbsp;&nbsp;&nbsp;以上简单介绍了分布式系统中消息中间件的概念与作用，以及RabbitMQ的一些基本概念与简单使用。下一篇文章将继续针对RabbitMQ进行总结。主要内容包括何时创建队列、RabbitMQ的确认机制、过期时间的使用、死信队列、以及利用RabbitMQ实现延迟队列......\n\n### 参考\n\n《RabbitMQ实战指南》\n\n《RabbitMQ实战 高效部署分布式消息队列》\n\n\n\n\n\n","slug":"技术实践/rabbitmq/RabbitMQ的使用基础篇","published":1,"updated":"2021-03-21T08:35:16.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn1qfq0i00gnhyjf8lhtq396","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;我是在解决分布式事务的一致性问题时了解到RabbitMQ的，当时主要是要基于RabbitMQ来实现我们分布式系统之间对有事务可靠性要求的系统间通信的。关于分布式事务一致性问题及其常见的解决方案，可以看我另一篇博客。提到RabbitMQ，不难想到的几个关键字:消息中间件、消息队列。而消息队列不由让我想到，当时在大学学习操作系统这门课，消息队列不难想到生产者消费者模式。(PS:操作系统这门课程真的很好也很重要，其中的一些思想在我工作的很长一段一时间内给了我很大帮助和启发，给我提供了许多解决问题的思路。强烈建议每一个程序员都去学一学操作系统！)<br><a id=\"more\"></a><br><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-8/59528487.jpg\" alt=\"image\"></p>\n<h3 id=\"系列文章\"><a href=\"#系列文章\" class=\"headerlink\" title=\"系列文章\"></a>系列文章</h3><p><a href=\"http://blog.loading.ink/2018/11/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用基础篇</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用进阶篇</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%9D%E8%80%83%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用思考篇</a></p>\n<h3 id=\"一-消息中间件\"><a href=\"#一-消息中间件\" class=\"headerlink\" title=\"一 消息中间件\"></a>一 消息中间件</h3><h4 id=\"1-1-简介\"><a href=\"#1-1-简介\" class=\"headerlink\" title=\"1.1 简介\"></a>1.1 简介</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;消息中间件也可以称消息队列，是指用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信。当下主流的消息中间件有RabbitMQ、Kafka、ActiveMQ、RocketMQ等。其能在不同平台之间进行通信，常用来屏蔽各种平台协议之间的特性，实现应用程序之间的协同。其优点在于能够在客户端和服务器之间进行同步和异步的连接，并且在任何时刻都可以将消息进行传送和转发。是分布式系统中非常重要的组件，主要用来解决应用耦合、异步通信、流量削峰等问题。</p>\n<h4 id=\"1-2-作用\"><a href=\"#1-2-作用\" class=\"headerlink\" title=\"1.2 作用\"></a>1.2 作用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;消息中间件几大主要作用如下:</p>\n<ul>\n<li>解耦:在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束即可。</li>\n<li>冗余(存储):在某些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息己经被处理完成，从而确保你的数据被安全地保存直到你使用完毕。</li>\n<li>扩展性:因为消息中间件解捐了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。</li>\n<li>削峰:在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩惯。</li>\n<li>可恢复性:当系统一部分组件失效时，不会影响到整个系统。消息中间件降低了进程间的稿合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。</li>\n<li>顺序保证：在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。</li>\n<li>缓冲：在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。</li>\n<li>异步通信:在很多时候应用不想也不需要立即处理消息。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。</li>\n</ul>\n<h4 id=\"1-3-消息中间件的两种模式\"><a href=\"#1-3-消息中间件的两种模式\" class=\"headerlink\" title=\"1.3 消息中间件的两种模式\"></a>1.3 消息中间件的两种模式</h4><h5 id=\"1-3-1-P2P模式\"><a href=\"#1-3-1-P2P模式\" class=\"headerlink\" title=\"1.3.1 P2P模式\"></a>1.3.1 P2P模式</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p>\n<p>P2P的特点:</p>\n<ul>\n<li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li>\n<li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行它不会影响到消息被发送到队列</li>\n<li>接收者在成功接收消息之后需向队列应答成功 </li>\n<li>如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式</li>\n</ul>\n<h5 id=\"1-3-2-Pub-Sub模式\"><a href=\"#1-3-2-Pub-Sub模式\" class=\"headerlink\" title=\"1.3.2 Pub/Sub模式\"></a>1.3.2 Pub/Sub模式</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Pub/Sub模式包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p>\n<p>Pub/Sub的特点</p>\n<ul>\n<li>每个消息可以有多个消费者</li>\n<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li>\n<li>为了消费消息，订阅者必须保持运行的状态。</li>\n<li>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。</li>\n</ul>\n<h4 id=\"1-4-常用中间件介绍与对比\"><a href=\"#1-4-常用中间件介绍与对比\" class=\"headerlink\" title=\"1.4 常用中间件介绍与对比\"></a>1.4 常用中间件介绍与对比</h4><ul>\n<li><p>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</p>\n</li>\n<li><p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p>\n</li>\n<li><p>RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</p>\n</li>\n</ul>\n<p>RabbitMQ比Kafka可靠，kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</p>\n<h3 id=\"二-RabbitMQ了解\"><a href=\"#二-RabbitMQ了解\" class=\"headerlink\" title=\"二 RabbitMQ了解\"></a>二 RabbitMQ了解</h3><h4 id=\"2-1-简介\"><a href=\"#2-1-简介\" class=\"headerlink\" title=\"2.1 简介\"></a>2.1 简介</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ是流行的开源消息队列系统。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由(Routing)，负载均衡(Load balance)或者数据持久化都有很好的支持。其主要特点如下:</p>\n<ul>\n<li>可靠性</li>\n<li>灵活的路由</li>\n<li>扩展性</li>\n<li>高可用性</li>\n<li>多种协议</li>\n<li>多语言客户端</li>\n<li>管理界面</li>\n<li>插件机制</li>\n</ul>\n<h4 id=\"2-2-概念\"><a href=\"#2-2-概念\" class=\"headerlink\" title=\"2.2 概念\"></a>2.2 概念</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ从整体上来看是一个典型的生产者消费者模型，主要负责接收、存储和转发消息。其整体模型架构如下图所示:<img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-9/84394083.jpg\" alt=\"RabbitMQ 模型架构\"></p>\n<p>我们先来看一个RabbitMQ的运转流程，稍后会对这个流程中所涉及到的一些概念进行详细的解释。</p>\n<p>生产者:</p>\n<p>(1)生产者连接到RabbitMQ Broker，建立一个连接( Connection)开启一个信道(Channel)<br>(2)生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等<br>(3)生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等<br>(4)生产者通过路由键将交换器和队列绑定起来<br>(5)生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息。<br>(6)相应的交换器根据接收到的路由键查找相匹配的队列。<br>(7)如果找到，则将从生产者发送过来的消息存入相应的队列中。<br>(8)如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者<br>(9)关闭信道。<br>(10)关闭连接。’</p>\n<p>消费者:</p>\n<p>(1)消费者连接到RabbitMQ Broker ，建立一个连接(Connection)，开启一个信道(Channel) 。<br>(2)消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，<br>(3)等待RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。<br>(4)消费者确认(ack) 接收到的消息。<br>(5)RabbitMQ 从队列中删除相应己经被确认的消息。<br>(6)关闭信道。</p>\n<p>(7)关闭连接。</p>\n<h5 id=\"2-2-1-信道\"><a href=\"#2-2-1-信道\" class=\"headerlink\" title=\"2.2.1 信道\"></a>2.2.1 信道</h5><p>这里我们主要了解两个问题：</p>\n<p>为什么要有信道?</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;主要原因还是在于TCP连接的&quot;昂贵&quot;性。无论是生产者还是消费者，都需要和RabbitMQ Broker 建立连接，这个连接就是一条TCP 连接。而操作系统对于TCP连接的创建于销毁是非常昂贵的开销。假设消费者要消费消息，并根据服务需求合理调度线程，若只进行TCP连接，那么当高并发的时候，每秒可能都有成千上万的TCP连接，不仅仅是对TCP连接的浪费，也很快会超过操作系统每秒所能建立连接的数量。如果能在一条TCP连接上操作，又能保证各个线程之间的私密性就完美了，于是信道的概念出现了。</p>\n<p>信道是什么?</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;信道是建立在Connection 之上的虚拟连接。当应用程序与Rabbit Broker建立TCP连接的时候，客户端紧接着可以创建一个AMQP 信道(Channel) ，每个信道都会被指派一个唯一的D。RabbitMQ 处理的每条AMQP 指令都是通过信道完成的。信道就像电缆里的光纤束。一条电缆内含有许多光纤束，允许所有的连接通过多条光线束进行传输和接收。</p>\n<h5 id=\"2-2-2-生产者消费者\"><a href=\"#2-2-2-生产者消费者\" class=\"headerlink\" title=\"2.2.2 生产者消费者\"></a>2.2.2 生产者消费者</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;关于生产者消费者我们需要了解几个概念:</p>\n<ul>\n<li>Producer:生产者，即消息投递者一方。</li>\n<li>消息:消息一般分两个部分:消息体(payload)和标签。标签用来描述这条消息，如:一个交换器的名称或者一个路由Key，Rabbit通过解析标签来确定消息的去向，payload是消息内容可以使一个json，数组等等。</li>\n<li>Consumer:消费者，就是接收消息的一方。消费者订阅RabbitMQ的队列，当消费者消费一条消息时，只是消费消息的消息体。在消息路由的过程中，会丢弃标签，存入到队列中的只有消息体。</li>\n<li>Broker:消息中间件的服务节点。</li>\n</ul>\n<h5 id=\"2-2-3-队列、交换器、路由key、绑定\"><a href=\"#2-2-3-队列、交换器、路由key、绑定\" class=\"headerlink\" title=\"2.2.3 队列、交换器、路由key、绑定\"></a>2.2.3 队列、交换器、路由key、绑定</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;从RabbitMQ的运转流程我们可以知道生产者的消息是发布到交换器上的。而消费者则是从队列上获取消息的。那么消息到底是如何从交换器到队列的呢?我们先具体了解一下这几个概念。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Queue:队列，是RabbitMQ的内部对象，用于存储消息。RabbitMQ中消息只能存储在队列中。生产者投递消息到队列，消费者从队列中获取消息并消费。多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊(轮询)给多个消费者进行消费，而不是每个消费者都收到所有的消息进行消费。(注意：RabbitMQ不支持队列层面的广播消费，如果需要广播消费，可以采用一个交换器通过路由Key绑定多个队列，由多个消费者来订阅这些队列的方式。)</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Exchange：交换器。在RabbitMQ中，生产者并非直接将消息投递到队列中。真实情况是，生产者将消息发送到Exchange(交换器)，由交换器将消息路由到一个或多个队列中。如果路由不到，或返回给生产者，或直接丢弃，或做其它处理。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RoutingKey:路由Key。生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则。这个路由Key需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时通过指定RoutingKey来决定消息流向哪里。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Binding：RabbitMQ通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ就可以指定如何正确的路由到队列了。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;从这里我们可以看到在RabbitMQ中交换器和队列实际上可以是一对多，也可以是多对多关系。交换器和队列就像我们关系数据库中的两张表。他们同归BindingKey做关联(多对多关系表)。在我们投递消息时，可以通过Exchange和RoutingKey(对应BindingKey)就可以找到相对应的队列。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ主要有四种类型的交换器:</p>\n<ul>\n<li><p>fanout：扇形交换器，它会把发送到该交换器的消息路由到所有与该交换器绑定的队列中。如果使用扇形交换器，则不会匹配路由Key。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/39683646.jpg\" alt=\"RabbitMQ Fanout交换器\"></p>\n</li>\n<li><p>direct:direct交换器，会把消息路由到RoutingKey与BindingKey完全匹配的队列中。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/40498280.jpg\" alt=\"RabbitMQ direct交换器\"></p>\n</li>\n<li><p>topic:完全匹配BindingKey和RoutingKey的direct交换器 有些时候并不能满足实际业务的需求。topic 类型的交换器在匹配规则上进行了扩展，它与direct 类型的交换器相似，也是将消息路由到BindingKey 和RoutingKey 相匹配的队<br>列中，但这里的匹配规则有些不同，它约定:</p>\n<ul>\n<li>RoutingKey 为一个点号&quot;.&quot;分隔的字符串(被点号&quot;.&quot;分隔开的每一段独立的字符<br>串称为一个单词)λ，如&quot;hs.rabbitmq.client&quot;，&quot;com.rabbit.client&quot;等。</li>\n<li>BindingKey 和RoutingKey 一样也是点号&quot;.&quot;分隔的字符串;</li>\n<li>BindingKey 中可以存在两种特殊字符串&quot;*&quot;和&quot;#&quot;，用于做模糊匹配，其中&quot;*&quot;用于匹配一个单词，&quot;#&quot;用于匹配多规格单词(可以是零个)。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/30382119.jpg\" alt=\"RabbitMQ topic交换器\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如图:</p>\n<p>​    · 路由键为” apple.rabbit.client” 的消息会同时路由到Queuel 和Queue2;<br>​    · 路由键为” orange.mq.client” 的消息只会路由到Queue2 中:<br>​    · 路由键为” apple.mq.demo” 的消息只会路由到Queue2 中:<br>​    · 路由键为” banana.rabbit.demo” 的消息只会路由到Queuel 中:<br>​    · 路由键为” apple.orange.banana” 的消息将会被丢弃或者返回给生产者因为它没有匹配任何路由键。</p>\n<ul>\n<li>header:headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中<br>的headers 属性进行匹配。在绑定队列和交换器时制定一组键值对， 当发送消息到交换器时，<br>RabbitMQ 会获取到该消息的headers (也是一个键值对的形式) ，对比其中的键值对是否完全<br>匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由<br>到该队列。(注:该交换器类型性能较差且不实用，因此一般不会用到)。</li>\n</ul>\n<p>了解了上面的概念，我们再来思考消息是如何从交换器到队列的。首先Rabbit在接收到消息时，会解析消息的标签从而得到消息的交换器与路由key信息。然后根据交换器的类型、路由key以及该交换器和队列的绑定关系来决定消息最终投递到哪个队列里面。</p>\n<h3 id=\"三-RabbitMQ使用\"><a href=\"#三-RabbitMQ使用\" class=\"headerlink\" title=\"三 RabbitMQ使用\"></a>三 RabbitMQ使用</h3><h4 id=\"3-1-RabbitMQ安装\"><a href=\"#3-1-RabbitMQ安装\" class=\"headerlink\" title=\"3.1 RabbitMQ安装\"></a>3.1 RabbitMQ安装</h4><p>这里我们基于docker来安装。</p>\n<h5 id=\"3-1-1-拉取镜像\"><a href=\"#3-1-1-拉取镜像\" class=\"headerlink\" title=\"3.1.1 拉取镜像\"></a>3.1.1 拉取镜像</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-1-2-启动容器\"><a href=\"#3-1-2-启动容器\" class=\"headerlink\" title=\"3.1.2 启动容器\"></a>3.1.2 启动容器</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d  --name rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-RabbitMQ-客户端开发使用\"><a href=\"#3-2-RabbitMQ-客户端开发使用\" class=\"headerlink\" title=\"3.2 RabbitMQ 客户端开发使用\"></a>3.2 RabbitMQ 客户端开发使用</h4><p>这里我们以dotnet平台下RabbitMQ.Client3.6.9(可以从nuget中下载)为示例，简单介绍dotnet平台下对RabbitMQ的简单操作。更详细的内容可以从nuget中下载源码和文档进行查看。</p>\n<h5 id=\"3-2-1-连接Rabbit\"><a href=\"#3-2-1-连接Rabbit\" class=\"headerlink\" title=\"3.2.1 连接Rabbit\"></a>3.2.1 连接Rabbit</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConnectionFactory factory = new ConnectionFactory();</span><br><span class=\"line\">          factory.UserName = &quot;admin&quot;;//用户名</span><br><span class=\"line\">          factory.Password = &quot;admin&quot;;//密码      </span><br><span class=\"line\">          factory.HostName = &quot;192.168.17.205&quot;;//主机名</span><br><span class=\"line\">          factory.VirtualHost = &quot;&quot;;//虚拟主机(这个暂时不需要，稍后的文章里会介绍虚拟主机的概念)</span><br><span class=\"line\">          factory.Port = 15672;//端口</span><br><span class=\"line\">          IConnection conn = factory.CreateConnection();//创建连接</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-2-2-创建信道\"><a href=\"#3-2-2-创建信道\" class=\"headerlink\" title=\"3.2.2 创建信道\"></a>3.2.2 创建信道</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IModel channel = conn.CreateModel();</span><br></pre></td></tr></table></figure>\n<p>说明：Connection 可以用来创建多个Channel 实例，但是Channel 实例不能在线程问共享，应用程序应该为每一个线程开辟一个Channel 。某些情况下Channel 的操作可以并发运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时也会影响友送方确认( publisherconfrrm)机制的运行，所以多线程问共享Channel实例是非线程安全的。</p>\n<h5 id=\"3-2-3-交换器、队列和绑定\"><a href=\"#3-2-3-交换器、队列和绑定\" class=\"headerlink\" title=\"3.2.3 交换器、队列和绑定\"></a>3.2.3 交换器、队列和绑定</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.ExchangeDeclare(&quot;exchangeName&quot;, &quot;direct&quot;, true);</span><br><span class=\"line\">String queueName = channel.QueueDeclare().QueueName;</span><br><span class=\"line\">channel.QueueBind(queueName, &quot;exchangeName&quot;, &quot;routingKey&quot;);</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上创建了一个持久化的、非自动删除的、绑定类型为direct 的交换器，同时也创建了一个非持久化的、排他的、自动删除的队列(此队列的名称由RabbitMQ 自动生成)。这里的交换器和队列也都没有设置特殊的参数。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;上面的代码也展示了如何使用路由键将队列和交换器绑定起来。上面声明的队列具备如下特性: 只对当前应用中同一个Connection 层面可用，同一个Connection 的不同Channel可共用，并且也会在应用连接断开时自动删除。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;上述方法根据参数不同，可以有不同的重载形式，根据自身的需要进行调用。</p>\n<p><strong>ExchangeDeclare方法详解：</strong></p>\n<p>ExchangeDeclare有多个重载方法，这些重载方法都是由下面这个方法中缺省的某些参数构成的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void ExchangeDeclare(string exchange, string type, bool durable, bool autoDelete, IDictionary&lt;string, object&gt; arguments);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>exchange : 交换器的名称。</li>\n<li>type : 交换器的类型，常见的如fanout、direct 、topic</li>\n<li>durable: 设置是否持久化。durab l e 设置为true 表示持久化， 反之是非持久化。持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</li>\n<li>autoDelete : 设置是否自动删除。autoDelete 设置为true 则表示自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。注意不能错误地把这个参数理解为:”当与此交换器连接的客户端都断开时， RabbitMQ 会自动删除本交换器”。</li>\n<li>internal : 设置是否是内置的。如果设置为true ，则表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。</li>\n<li>argument : 其他一些结构化参数，比如alternate - exchange。</li>\n</ul>\n<p><strong>QueueDeclare方法详解：</strong></p>\n<p>QueueDeclare只有两个重载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueDeclareOk QueueDeclare();</span><br><span class=\"line\"></span><br><span class=\"line\">QueueDeclareOk QueueDeclare(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary&lt;string, object&gt; arguments);</span><br></pre></td></tr></table></figure>\n<p>不带任何参数的queueDeclare 方法默认创建一个由RabbitMQ 命名的(类似这种amq.gen-LhQzlgv3GhDOv8PIDabOXA 名称，这种队列也称之为匿名队列〉、排他的、自动删除的、非持久化的队列。</p>\n<ul>\n<li>queue : 队列的名称。</li>\n<li>durable: 设置是否持久化。为true 则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。</li>\n<li>exclusive : 设置是否排他。为true 则设置队列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意三点:排他队列是基于连接( Connection) 可见的，同一个连接的不同信道(Channel)是可以同时访问同一连接创建的排他队列; “首次”是指如果一个连接己经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同:即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。</li>\n<li>autoDelete: 设置是否自动删除。为true 则设置队列为自动删除。自动删除的前提是:至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为:当连接到此队列的所有客户端断开时，这个队列自动删除”，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。</li>\n<li>argurnents: 设置队列的其他一些参数，如x-rnessage-ttl、x-expires、x-rnax-length、x-rnax-length-bytes、x-dead-letter-exchange、x-deadletter-routing-key, x-rnax-priority等。</li>\n</ul>\n<p><strong>注意:生产者和消费者都能够使用queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道直为”传输”模式，之后才能声明队列。</strong></p>\n<p><strong>QueueBind 方法详解：</strong></p>\n<p>将队列和交换器绑定的方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void QueueBind(string queue, string exchange, string routingKey, IDictionary&lt;string, object&gt; arguments);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>queue: 队列名称:</li>\n<li>exchange: 交换器的名称:</li>\n<li>routingKey: 用来绑定队列和交换器的路由键;</li>\n<li>argument: 定义绑定的一些参数。</li>\n</ul>\n<p>将队列与交换器解绑的方法如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueUnbind(string queue, string exchange, string routingKey, IDictionary&lt;string, object&gt; arguments);</span><br></pre></td></tr></table></figure>\n<p>其参数与绑定意义相同。</p>\n<p>注：除队列可以绑定交换器外，交换器同样可以绑定队列。即:ExchangeBind方法，其使用方式与队列绑定相似。</p>\n<h5 id=\"3-2-4-发送消息\"><a href=\"#3-2-4-发送消息\" class=\"headerlink\" title=\"3.2.4 发送消息\"></a>3.2.4 发送消息</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;发送消息可以使用BasicPublish方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void BasicPublish(string exchange, string routingKey, bool mandatory,IBasicProperties basicProperties, byte[] body);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>exchange: 交换器的名称，指明消息需要发送到哪个交换器中。如果设置为空字符串，则消息会被发送到RabbitMQ 默认的交换器中。</li>\n<li>routingKey : 路由键，交换器根据路由键将消息存储到相应的队列之中。</li>\n<li>basicProperties: 消息的基本属性集。</li>\n<li>body : 消息体( pay1oad ),真正需要发送的消息。</li>\n<li>mandatory: 是否将消息返回给生产者(会在后续的文章中介绍这个参数).</li>\n</ul>\n<h5 id=\"3-2-5-消费消息\"><a href=\"#3-2-5-消费消息\" class=\"headerlink\" title=\"3.2.5 消费消息\"></a>3.2.5 消费消息</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 的消费模式分两种: 推(Push)模式和拉(Pull)模式。推模式采用BasicConsume<br>进行消费，而拉模式则是调用BasicGet进行消费。</p>\n<p><strong>推模式:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventingBasicConsumer consumer = new EventingBasicConsumer(channel);//定义消费者对象</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">       //do someting;</span><br><span class=\"line\">       channel.BasicAck(ea.DeliveryTag, multiple: false);//确认</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  channel.BasicConsume(queue: &quot;queueName&quot;,</span><br><span class=\"line\">                       noAck: false,</span><br><span class=\"line\">                       consumer: consumer);//订阅消息</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string BasicConsume(string queue, bool noAck, string consumerTag, bool noLocal, bool exclusive, IDictionary&lt;string, object&gt; arguments, IBasicConsumer consumer);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>queue : 队列的名称:</li>\n<li>noAck : 设置是否需要确认，false为需要确认。</li>\n<li>consumerTag: 消费者标签，用来区分多个消费者:</li>\n<li>noLocal : 设置为true 则表示不能将同一个Connection中生产者发送的消息传送给这个Connection中的消费者:</li>\n<li>exclusive : 设置是否排他</li>\n<li>arguments : 设置消费者的其他参数</li>\n<li>consumer: 指定处理消息的消费者对象。</li>\n</ul>\n<p><strong>拉模式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BasicGetResult result = channel.BasicGet(&quot;queueName&quot;, noAck: false);//获取消息</span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicAck(result.DeliveryTag, multiple: false);//确认</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-2-6-关闭连接\"><a href=\"#3-2-6-关闭连接\" class=\"headerlink\" title=\"3.2.6 关闭连接\"></a>3.2.6 关闭连接</h5><p>在应用程序使用完之后，需要关闭连接，释放资源:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.close();</span><br><span class=\"line\">conn.close() ;</span><br></pre></td></tr></table></figure>\n<p>显式地关闭Channel 是个好习惯，但这不是必须的，在Connection 关闭的时候，Channel 也会自动关闭。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;以上简单介绍了分布式系统中消息中间件的概念与作用，以及RabbitMQ的一些基本概念与简单使用。下一篇文章将继续针对RabbitMQ进行总结。主要内容包括何时创建队列、RabbitMQ的确认机制、过期时间的使用、死信队列、以及利用RabbitMQ实现延迟队列……</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《RabbitMQ实战指南》</p>\n<p>《RabbitMQ实战 高效部署分布式消息队列》</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;我是在解决分布式事务的一致性问题时了解到RabbitMQ的，当时主要是要基于RabbitMQ来实现我们分布式系统之间对有事务可靠性要求的系统间通信的。关于分布式事务一致性问题及其常见的解决方案，可以看我另一篇博客。提到RabbitMQ，不难想到的几个关键字:消息中间件、消息队列。而消息队列不由让我想到，当时在大学学习操作系统这门课，消息队列不难想到生产者消费者模式。(PS:操作系统这门课程真的很好也很重要，其中的一些思想在我工作的很长一段一时间内给了我很大帮助和启发，给我提供了许多解决问题的思路。强烈建议每一个程序员都去学一学操作系统！)<br>","more":"<br><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-8/59528487.jpg\" alt=\"image\"></p>\n<h3 id=\"系列文章\"><a href=\"#系列文章\" class=\"headerlink\" title=\"系列文章\"></a>系列文章</h3><p><a href=\"http://blog.loading.ink/2018/11/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用基础篇</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用进阶篇</a></p>\n<p><a href=\"http://blog.loading.ink/2018/11/13/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%9D%E8%80%83%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">分布式系统消息中间件——RabbitMQ的使用思考篇</a></p>\n<h3 id=\"一-消息中间件\"><a href=\"#一-消息中间件\" class=\"headerlink\" title=\"一 消息中间件\"></a>一 消息中间件</h3><h4 id=\"1-1-简介\"><a href=\"#1-1-简介\" class=\"headerlink\" title=\"1.1 简介\"></a>1.1 简介</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;消息中间件也可以称消息队列，是指用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信。当下主流的消息中间件有RabbitMQ、Kafka、ActiveMQ、RocketMQ等。其能在不同平台之间进行通信，常用来屏蔽各种平台协议之间的特性，实现应用程序之间的协同。其优点在于能够在客户端和服务器之间进行同步和异步的连接，并且在任何时刻都可以将消息进行传送和转发。是分布式系统中非常重要的组件，主要用来解决应用耦合、异步通信、流量削峰等问题。</p>\n<h4 id=\"1-2-作用\"><a href=\"#1-2-作用\" class=\"headerlink\" title=\"1.2 作用\"></a>1.2 作用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;消息中间件几大主要作用如下:</p>\n<ul>\n<li>解耦:在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束即可。</li>\n<li>冗余(存储):在某些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息己经被处理完成，从而确保你的数据被安全地保存直到你使用完毕。</li>\n<li>扩展性:因为消息中间件解捐了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。</li>\n<li>削峰:在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩惯。</li>\n<li>可恢复性:当系统一部分组件失效时，不会影响到整个系统。消息中间件降低了进程间的稿合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。</li>\n<li>顺序保证：在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。</li>\n<li>缓冲：在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。</li>\n<li>异步通信:在很多时候应用不想也不需要立即处理消息。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。</li>\n</ul>\n<h4 id=\"1-3-消息中间件的两种模式\"><a href=\"#1-3-消息中间件的两种模式\" class=\"headerlink\" title=\"1.3 消息中间件的两种模式\"></a>1.3 消息中间件的两种模式</h4><h5 id=\"1-3-1-P2P模式\"><a href=\"#1-3-1-P2P模式\" class=\"headerlink\" title=\"1.3.1 P2P模式\"></a>1.3.1 P2P模式</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p>\n<p>P2P的特点:</p>\n<ul>\n<li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li>\n<li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行它不会影响到消息被发送到队列</li>\n<li>接收者在成功接收消息之后需向队列应答成功 </li>\n<li>如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式</li>\n</ul>\n<h5 id=\"1-3-2-Pub-Sub模式\"><a href=\"#1-3-2-Pub-Sub模式\" class=\"headerlink\" title=\"1.3.2 Pub/Sub模式\"></a>1.3.2 Pub/Sub模式</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Pub/Sub模式包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p>\n<p>Pub/Sub的特点</p>\n<ul>\n<li>每个消息可以有多个消费者</li>\n<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li>\n<li>为了消费消息，订阅者必须保持运行的状态。</li>\n<li>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。</li>\n</ul>\n<h4 id=\"1-4-常用中间件介绍与对比\"><a href=\"#1-4-常用中间件介绍与对比\" class=\"headerlink\" title=\"1.4 常用中间件介绍与对比\"></a>1.4 常用中间件介绍与对比</h4><ul>\n<li><p>Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</p>\n</li>\n<li><p>RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p>\n</li>\n<li><p>RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</p>\n</li>\n</ul>\n<p>RabbitMQ比Kafka可靠，kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</p>\n<h3 id=\"二-RabbitMQ了解\"><a href=\"#二-RabbitMQ了解\" class=\"headerlink\" title=\"二 RabbitMQ了解\"></a>二 RabbitMQ了解</h3><h4 id=\"2-1-简介\"><a href=\"#2-1-简介\" class=\"headerlink\" title=\"2.1 简介\"></a>2.1 简介</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ是流行的开源消息队列系统。RabbitMQ是AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由(Routing)，负载均衡(Load balance)或者数据持久化都有很好的支持。其主要特点如下:</p>\n<ul>\n<li>可靠性</li>\n<li>灵活的路由</li>\n<li>扩展性</li>\n<li>高可用性</li>\n<li>多种协议</li>\n<li>多语言客户端</li>\n<li>管理界面</li>\n<li>插件机制</li>\n</ul>\n<h4 id=\"2-2-概念\"><a href=\"#2-2-概念\" class=\"headerlink\" title=\"2.2 概念\"></a>2.2 概念</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ从整体上来看是一个典型的生产者消费者模型，主要负责接收、存储和转发消息。其整体模型架构如下图所示:<img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-9/84394083.jpg\" alt=\"RabbitMQ 模型架构\"></p>\n<p>我们先来看一个RabbitMQ的运转流程，稍后会对这个流程中所涉及到的一些概念进行详细的解释。</p>\n<p>生产者:</p>\n<p>(1)生产者连接到RabbitMQ Broker，建立一个连接( Connection)开启一个信道(Channel)<br>(2)生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等<br>(3)生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等<br>(4)生产者通过路由键将交换器和队列绑定起来<br>(5)生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息。<br>(6)相应的交换器根据接收到的路由键查找相匹配的队列。<br>(7)如果找到，则将从生产者发送过来的消息存入相应的队列中。<br>(8)如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者<br>(9)关闭信道。<br>(10)关闭连接。’</p>\n<p>消费者:</p>\n<p>(1)消费者连接到RabbitMQ Broker ，建立一个连接(Connection)，开启一个信道(Channel) 。<br>(2)消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，<br>(3)等待RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。<br>(4)消费者确认(ack) 接收到的消息。<br>(5)RabbitMQ 从队列中删除相应己经被确认的消息。<br>(6)关闭信道。</p>\n<p>(7)关闭连接。</p>\n<h5 id=\"2-2-1-信道\"><a href=\"#2-2-1-信道\" class=\"headerlink\" title=\"2.2.1 信道\"></a>2.2.1 信道</h5><p>这里我们主要了解两个问题：</p>\n<p>为什么要有信道?</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;主要原因还是在于TCP连接的&quot;昂贵&quot;性。无论是生产者还是消费者，都需要和RabbitMQ Broker 建立连接，这个连接就是一条TCP 连接。而操作系统对于TCP连接的创建于销毁是非常昂贵的开销。假设消费者要消费消息，并根据服务需求合理调度线程，若只进行TCP连接，那么当高并发的时候，每秒可能都有成千上万的TCP连接，不仅仅是对TCP连接的浪费，也很快会超过操作系统每秒所能建立连接的数量。如果能在一条TCP连接上操作，又能保证各个线程之间的私密性就完美了，于是信道的概念出现了。</p>\n<p>信道是什么?</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;信道是建立在Connection 之上的虚拟连接。当应用程序与Rabbit Broker建立TCP连接的时候，客户端紧接着可以创建一个AMQP 信道(Channel) ，每个信道都会被指派一个唯一的D。RabbitMQ 处理的每条AMQP 指令都是通过信道完成的。信道就像电缆里的光纤束。一条电缆内含有许多光纤束，允许所有的连接通过多条光线束进行传输和接收。</p>\n<h5 id=\"2-2-2-生产者消费者\"><a href=\"#2-2-2-生产者消费者\" class=\"headerlink\" title=\"2.2.2 生产者消费者\"></a>2.2.2 生产者消费者</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;关于生产者消费者我们需要了解几个概念:</p>\n<ul>\n<li>Producer:生产者，即消息投递者一方。</li>\n<li>消息:消息一般分两个部分:消息体(payload)和标签。标签用来描述这条消息，如:一个交换器的名称或者一个路由Key，Rabbit通过解析标签来确定消息的去向，payload是消息内容可以使一个json，数组等等。</li>\n<li>Consumer:消费者，就是接收消息的一方。消费者订阅RabbitMQ的队列，当消费者消费一条消息时，只是消费消息的消息体。在消息路由的过程中，会丢弃标签，存入到队列中的只有消息体。</li>\n<li>Broker:消息中间件的服务节点。</li>\n</ul>\n<h5 id=\"2-2-3-队列、交换器、路由key、绑定\"><a href=\"#2-2-3-队列、交换器、路由key、绑定\" class=\"headerlink\" title=\"2.2.3 队列、交换器、路由key、绑定\"></a>2.2.3 队列、交换器、路由key、绑定</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;从RabbitMQ的运转流程我们可以知道生产者的消息是发布到交换器上的。而消费者则是从队列上获取消息的。那么消息到底是如何从交换器到队列的呢?我们先具体了解一下这几个概念。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Queue:队列，是RabbitMQ的内部对象，用于存储消息。RabbitMQ中消息只能存储在队列中。生产者投递消息到队列，消费者从队列中获取消息并消费。多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊(轮询)给多个消费者进行消费，而不是每个消费者都收到所有的消息进行消费。(注意：RabbitMQ不支持队列层面的广播消费，如果需要广播消费，可以采用一个交换器通过路由Key绑定多个队列，由多个消费者来订阅这些队列的方式。)</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Exchange：交换器。在RabbitMQ中，生产者并非直接将消息投递到队列中。真实情况是，生产者将消息发送到Exchange(交换器)，由交换器将消息路由到一个或多个队列中。如果路由不到，或返回给生产者，或直接丢弃，或做其它处理。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RoutingKey:路由Key。生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则。这个路由Key需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时通过指定RoutingKey来决定消息流向哪里。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;Binding：RabbitMQ通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ就可以指定如何正确的路由到队列了。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;从这里我们可以看到在RabbitMQ中交换器和队列实际上可以是一对多，也可以是多对多关系。交换器和队列就像我们关系数据库中的两张表。他们同归BindingKey做关联(多对多关系表)。在我们投递消息时，可以通过Exchange和RoutingKey(对应BindingKey)就可以找到相对应的队列。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ主要有四种类型的交换器:</p>\n<ul>\n<li><p>fanout：扇形交换器，它会把发送到该交换器的消息路由到所有与该交换器绑定的队列中。如果使用扇形交换器，则不会匹配路由Key。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/39683646.jpg\" alt=\"RabbitMQ Fanout交换器\"></p>\n</li>\n<li><p>direct:direct交换器，会把消息路由到RoutingKey与BindingKey完全匹配的队列中。</p>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/40498280.jpg\" alt=\"RabbitMQ direct交换器\"></p>\n</li>\n<li><p>topic:完全匹配BindingKey和RoutingKey的direct交换器 有些时候并不能满足实际业务的需求。topic 类型的交换器在匹配规则上进行了扩展，它与direct 类型的交换器相似，也是将消息路由到BindingKey 和RoutingKey 相匹配的队<br>列中，但这里的匹配规则有些不同，它约定:</p>\n<ul>\n<li>RoutingKey 为一个点号&quot;.&quot;分隔的字符串(被点号&quot;.&quot;分隔开的每一段独立的字符<br>串称为一个单词)λ，如&quot;hs.rabbitmq.client&quot;，&quot;com.rabbit.client&quot;等。</li>\n<li>BindingKey 和RoutingKey 一样也是点号&quot;.&quot;分隔的字符串;</li>\n<li>BindingKey 中可以存在两种特殊字符串&quot;*&quot;和&quot;#&quot;，用于做模糊匹配，其中&quot;*&quot;用于匹配一个单词，&quot;#&quot;用于匹配多规格单词(可以是零个)。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://hunter-image.oss-cn-beijing.aliyuncs.com/18-9-18/30382119.jpg\" alt=\"RabbitMQ topic交换器\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如图:</p>\n<p>​    · 路由键为” apple.rabbit.client” 的消息会同时路由到Queuel 和Queue2;<br>​    · 路由键为” orange.mq.client” 的消息只会路由到Queue2 中:<br>​    · 路由键为” apple.mq.demo” 的消息只会路由到Queue2 中:<br>​    · 路由键为” banana.rabbit.demo” 的消息只会路由到Queuel 中:<br>​    · 路由键为” apple.orange.banana” 的消息将会被丢弃或者返回给生产者因为它没有匹配任何路由键。</p>\n<ul>\n<li>header:headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中<br>的headers 属性进行匹配。在绑定队列和交换器时制定一组键值对， 当发送消息到交换器时，<br>RabbitMQ 会获取到该消息的headers (也是一个键值对的形式) ，对比其中的键值对是否完全<br>匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由<br>到该队列。(注:该交换器类型性能较差且不实用，因此一般不会用到)。</li>\n</ul>\n<p>了解了上面的概念，我们再来思考消息是如何从交换器到队列的。首先Rabbit在接收到消息时，会解析消息的标签从而得到消息的交换器与路由key信息。然后根据交换器的类型、路由key以及该交换器和队列的绑定关系来决定消息最终投递到哪个队列里面。</p>\n<h3 id=\"三-RabbitMQ使用\"><a href=\"#三-RabbitMQ使用\" class=\"headerlink\" title=\"三 RabbitMQ使用\"></a>三 RabbitMQ使用</h3><h4 id=\"3-1-RabbitMQ安装\"><a href=\"#3-1-RabbitMQ安装\" class=\"headerlink\" title=\"3.1 RabbitMQ安装\"></a>3.1 RabbitMQ安装</h4><p>这里我们基于docker来安装。</p>\n<h5 id=\"3-1-1-拉取镜像\"><a href=\"#3-1-1-拉取镜像\" class=\"headerlink\" title=\"3.1.1 拉取镜像\"></a>3.1.1 拉取镜像</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-1-2-启动容器\"><a href=\"#3-1-2-启动容器\" class=\"headerlink\" title=\"3.1.2 启动容器\"></a>3.1.2 启动容器</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d  --name rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-RabbitMQ-客户端开发使用\"><a href=\"#3-2-RabbitMQ-客户端开发使用\" class=\"headerlink\" title=\"3.2 RabbitMQ 客户端开发使用\"></a>3.2 RabbitMQ 客户端开发使用</h4><p>这里我们以dotnet平台下RabbitMQ.Client3.6.9(可以从nuget中下载)为示例，简单介绍dotnet平台下对RabbitMQ的简单操作。更详细的内容可以从nuget中下载源码和文档进行查看。</p>\n<h5 id=\"3-2-1-连接Rabbit\"><a href=\"#3-2-1-连接Rabbit\" class=\"headerlink\" title=\"3.2.1 连接Rabbit\"></a>3.2.1 连接Rabbit</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConnectionFactory factory = new ConnectionFactory();</span><br><span class=\"line\">          factory.UserName = &quot;admin&quot;;//用户名</span><br><span class=\"line\">          factory.Password = &quot;admin&quot;;//密码      </span><br><span class=\"line\">          factory.HostName = &quot;192.168.17.205&quot;;//主机名</span><br><span class=\"line\">          factory.VirtualHost = &quot;&quot;;//虚拟主机(这个暂时不需要，稍后的文章里会介绍虚拟主机的概念)</span><br><span class=\"line\">          factory.Port = 15672;//端口</span><br><span class=\"line\">          IConnection conn = factory.CreateConnection();//创建连接</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-2-2-创建信道\"><a href=\"#3-2-2-创建信道\" class=\"headerlink\" title=\"3.2.2 创建信道\"></a>3.2.2 创建信道</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IModel channel = conn.CreateModel();</span><br></pre></td></tr></table></figure>\n<p>说明：Connection 可以用来创建多个Channel 实例，但是Channel 实例不能在线程问共享，应用程序应该为每一个线程开辟一个Channel 。某些情况下Channel 的操作可以并发运行，但是在其他情况下会导致在网络上出现错误的通信帧交错，同时也会影响友送方确认( publisherconfrrm)机制的运行，所以多线程问共享Channel实例是非线程安全的。</p>\n<h5 id=\"3-2-3-交换器、队列和绑定\"><a href=\"#3-2-3-交换器、队列和绑定\" class=\"headerlink\" title=\"3.2.3 交换器、队列和绑定\"></a>3.2.3 交换器、队列和绑定</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.ExchangeDeclare(&quot;exchangeName&quot;, &quot;direct&quot;, true);</span><br><span class=\"line\">String queueName = channel.QueueDeclare().QueueName;</span><br><span class=\"line\">channel.QueueBind(queueName, &quot;exchangeName&quot;, &quot;routingKey&quot;);</span><br></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;如上创建了一个持久化的、非自动删除的、绑定类型为direct 的交换器，同时也创建了一个非持久化的、排他的、自动删除的队列(此队列的名称由RabbitMQ 自动生成)。这里的交换器和队列也都没有设置特殊的参数。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;上面的代码也展示了如何使用路由键将队列和交换器绑定起来。上面声明的队列具备如下特性: 只对当前应用中同一个Connection 层面可用，同一个Connection 的不同Channel可共用，并且也会在应用连接断开时自动删除。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;上述方法根据参数不同，可以有不同的重载形式，根据自身的需要进行调用。</p>\n<p><strong>ExchangeDeclare方法详解：</strong></p>\n<p>ExchangeDeclare有多个重载方法，这些重载方法都是由下面这个方法中缺省的某些参数构成的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void ExchangeDeclare(string exchange, string type, bool durable, bool autoDelete, IDictionary&lt;string, object&gt; arguments);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>exchange : 交换器的名称。</li>\n<li>type : 交换器的类型，常见的如fanout、direct 、topic</li>\n<li>durable: 设置是否持久化。durab l e 设置为true 表示持久化， 反之是非持久化。持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</li>\n<li>autoDelete : 设置是否自动删除。autoDelete 设置为true 则表示自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。注意不能错误地把这个参数理解为:”当与此交换器连接的客户端都断开时， RabbitMQ 会自动删除本交换器”。</li>\n<li>internal : 设置是否是内置的。如果设置为true ，则表示是内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。</li>\n<li>argument : 其他一些结构化参数，比如alternate - exchange。</li>\n</ul>\n<p><strong>QueueDeclare方法详解：</strong></p>\n<p>QueueDeclare只有两个重载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueDeclareOk QueueDeclare();</span><br><span class=\"line\"></span><br><span class=\"line\">QueueDeclareOk QueueDeclare(string queue, bool durable, bool exclusive, bool autoDelete, IDictionary&lt;string, object&gt; arguments);</span><br></pre></td></tr></table></figure>\n<p>不带任何参数的queueDeclare 方法默认创建一个由RabbitMQ 命名的(类似这种amq.gen-LhQzlgv3GhDOv8PIDabOXA 名称，这种队列也称之为匿名队列〉、排他的、自动删除的、非持久化的队列。</p>\n<ul>\n<li>queue : 队列的名称。</li>\n<li>durable: 设置是否持久化。为true 则设置队列为持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。</li>\n<li>exclusive : 设置是否排他。为true 则设置队列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意三点:排他队列是基于连接( Connection) 可见的，同一个连接的不同信道(Channel)是可以同时访问同一连接创建的排他队列; “首次”是指如果一个连接己经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同:即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。</li>\n<li>autoDelete: 设置是否自动删除。为true 则设置队列为自动删除。自动删除的前提是:至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为:当连接到此队列的所有客户端断开时，这个队列自动删除”，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。</li>\n<li>argurnents: 设置队列的其他一些参数，如x-rnessage-ttl、x-expires、x-rnax-length、x-rnax-length-bytes、x-dead-letter-exchange、x-deadletter-routing-key, x-rnax-priority等。</li>\n</ul>\n<p><strong>注意:生产者和消费者都能够使用queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道直为”传输”模式，之后才能声明队列。</strong></p>\n<p><strong>QueueBind 方法详解：</strong></p>\n<p>将队列和交换器绑定的方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void QueueBind(string queue, string exchange, string routingKey, IDictionary&lt;string, object&gt; arguments);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>queue: 队列名称:</li>\n<li>exchange: 交换器的名称:</li>\n<li>routingKey: 用来绑定队列和交换器的路由键;</li>\n<li>argument: 定义绑定的一些参数。</li>\n</ul>\n<p>将队列与交换器解绑的方法如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueUnbind(string queue, string exchange, string routingKey, IDictionary&lt;string, object&gt; arguments);</span><br></pre></td></tr></table></figure>\n<p>其参数与绑定意义相同。</p>\n<p>注：除队列可以绑定交换器外，交换器同样可以绑定队列。即:ExchangeBind方法，其使用方式与队列绑定相似。</p>\n<h5 id=\"3-2-4-发送消息\"><a href=\"#3-2-4-发送消息\" class=\"headerlink\" title=\"3.2.4 发送消息\"></a>3.2.4 发送消息</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;发送消息可以使用BasicPublish方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void BasicPublish(string exchange, string routingKey, bool mandatory,IBasicProperties basicProperties, byte[] body);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>exchange: 交换器的名称，指明消息需要发送到哪个交换器中。如果设置为空字符串，则消息会被发送到RabbitMQ 默认的交换器中。</li>\n<li>routingKey : 路由键，交换器根据路由键将消息存储到相应的队列之中。</li>\n<li>basicProperties: 消息的基本属性集。</li>\n<li>body : 消息体( pay1oad ),真正需要发送的消息。</li>\n<li>mandatory: 是否将消息返回给生产者(会在后续的文章中介绍这个参数).</li>\n</ul>\n<h5 id=\"3-2-5-消费消息\"><a href=\"#3-2-5-消费消息\" class=\"headerlink\" title=\"3.2.5 消费消息\"></a>3.2.5 消费消息</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;RabbitMQ 的消费模式分两种: 推(Push)模式和拉(Pull)模式。推模式采用BasicConsume<br>进行消费，而拉模式则是调用BasicGet进行消费。</p>\n<p><strong>推模式:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventingBasicConsumer consumer = new EventingBasicConsumer(channel);//定义消费者对象</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">       //do someting;</span><br><span class=\"line\">       channel.BasicAck(ea.DeliveryTag, multiple: false);//确认</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  channel.BasicConsume(queue: &quot;queueName&quot;,</span><br><span class=\"line\">                       noAck: false,</span><br><span class=\"line\">                       consumer: consumer);//订阅消息</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string BasicConsume(string queue, bool noAck, string consumerTag, bool noLocal, bool exclusive, IDictionary&lt;string, object&gt; arguments, IBasicConsumer consumer);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>queue : 队列的名称:</li>\n<li>noAck : 设置是否需要确认，false为需要确认。</li>\n<li>consumerTag: 消费者标签，用来区分多个消费者:</li>\n<li>noLocal : 设置为true 则表示不能将同一个Connection中生产者发送的消息传送给这个Connection中的消费者:</li>\n<li>exclusive : 设置是否排他</li>\n<li>arguments : 设置消费者的其他参数</li>\n<li>consumer: 指定处理消息的消费者对象。</li>\n</ul>\n<p><strong>拉模式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BasicGetResult result = channel.BasicGet(&quot;queueName&quot;, noAck: false);//获取消息</span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicAck(result.DeliveryTag, multiple: false);//确认</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-2-6-关闭连接\"><a href=\"#3-2-6-关闭连接\" class=\"headerlink\" title=\"3.2.6 关闭连接\"></a>3.2.6 关闭连接</h5><p>在应用程序使用完之后，需要关闭连接，释放资源:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.close();</span><br><span class=\"line\">conn.close() ;</span><br></pre></td></tr></table></figure>\n<p>显式地关闭Channel 是个好习惯，但这不是必须的，在Connection 关闭的时候，Channel 也会自动关闭。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;以上简单介绍了分布式系统中消息中间件的概念与作用，以及RabbitMQ的一些基本概念与简单使用。下一篇文章将继续针对RabbitMQ进行总结。主要内容包括何时创建队列、RabbitMQ的确认机制、过期时间的使用、死信队列、以及利用RabbitMQ实现延迟队列……</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>《RabbitMQ实战指南》</p>\n<p>《RabbitMQ实战 高效部署分布式消息队列》</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckn1qfpq00005hyjf18zl65g9","category_id":"ckn1qfpq70006hyjfko9kwc5s","_id":"ckn1qfpqb0009hyjfj6o0nvvf"},{"post_id":"ckn1qfpr3000ghyjfw21gam39","category_id":"ckn1qfpq70006hyjfko9kwc5s","_id":"ckn1qfpr8000khyjfq8slmfin"},{"post_id":"ckn1qfpr5000hhyjf0sufl94y","category_id":"ckn1qfpq70006hyjfko9kwc5s","_id":"ckn1qfpr8000mhyjf22zuftzx"},{"post_id":"ckn1qfpso000qhyjfh7iyye5w","category_id":"ckn1qfpsp000shyjfkzh2096a","_id":"ckn1qfpss000whyjfewymbyac"},{"post_id":"ckn1qfpsp000rhyjfi5hbo0mi","category_id":"ckn1qfpsp000shyjfkzh2096a","_id":"ckn1qfpss000yhyjfqcecr40q"},{"post_id":"ckn1qfptv001chyjff3p1tvar","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpu4001rhyjfm4i0d58v"},{"post_id":"ckn1qfptv001chyjff3p1tvar","category_id":"ckn1qfpu1001khyjfc0ki5aa2","_id":"ckn1qfpu5001thyjfss9gm6lh"},{"post_id":"ckn1qfpu2001mhyjfinz50wdp","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpu6001whyjf2mfgiuo8"},{"post_id":"ckn1qfpu2001mhyjfinz50wdp","category_id":"ckn1qfpu1001khyjfc0ki5aa2","_id":"ckn1qfpu7001yhyjfg3ocqt8x"},{"post_id":"ckn1qfptr0018hyjfylcx0emg","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpu80020hyjfsl7dbj6l"},{"post_id":"ckn1qfptr0018hyjfylcx0emg","category_id":"ckn1qfpu1001khyjfc0ki5aa2","_id":"ckn1qfpu90023hyjf6jrkesp9"},{"post_id":"ckn1qfptw001dhyjfm1j1ae68","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpu90025hyjfyry7nj7g"},{"post_id":"ckn1qfptw001dhyjfm1j1ae68","category_id":"ckn1qfpu1001khyjfc0ki5aa2","_id":"ckn1qfpua0028hyjfats9d0ag"},{"post_id":"ckn1qfpu6001xhyjfjq0e894o","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpub002ahyjfeqx8ltb9"},{"post_id":"ckn1qfpu6001xhyjfjq0e894o","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpuc002dhyjfx3nbb364"},{"post_id":"ckn1qfptx001fhyjfcsh83q9u","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpud002fhyjfxsz1kin3"},{"post_id":"ckn1qfptx001fhyjfcsh83q9u","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpui002ihyjfefr20d91"},{"post_id":"ckn1qfpu7001zhyjfduuw21ed","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpuj002khyjfsw3i67k9"},{"post_id":"ckn1qfpu7001zhyjfduuw21ed","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpuk002nhyjf518tyxm5"},{"post_id":"ckn1qfpu80022hyjfltlap4lw","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpuk002phyjfsuhk0sx2"},{"post_id":"ckn1qfpu80022hyjfltlap4lw","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpul002shyjfkhy5renc"},{"post_id":"ckn1qfpts0019hyjfid377nk4","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpum002uhyjfmpu2h6y1"},{"post_id":"ckn1qfpts0019hyjfid377nk4","category_id":"ckn1qfpu1001khyjfc0ki5aa2","_id":"ckn1qfpun002xhyjfrs7h8idk"},{"post_id":"ckn1qfpu90024hyjfgc6aun5p","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpuo002zhyjfmmrp4l6y"},{"post_id":"ckn1qfpu90024hyjfgc6aun5p","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpup0032hyjf1yjkswv2"},{"post_id":"ckn1qfpua0027hyjfc84a1x66","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpuq0034hyjfo5gbffa8"},{"post_id":"ckn1qfpua0027hyjfc84a1x66","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpur0037hyjfytk337e8"},{"post_id":"ckn1qfptz001ghyjffytdecw8","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpus0039hyjffxjuxs0e"},{"post_id":"ckn1qfptz001ghyjffytdecw8","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfput003chyjfnn090v6u"},{"post_id":"ckn1qfpua0029hyjfatm7j3e9","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpuv003ehyjf4uydysla"},{"post_id":"ckn1qfpua0029hyjfatm7j3e9","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpux003hhyjfghe4iqth"},{"post_id":"ckn1qfpu0001ihyjfewky7e83","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpuy003jhyjf5lqbl0x9"},{"post_id":"ckn1qfpu0001ihyjfewky7e83","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpuz003mhyjf4654pd10"},{"post_id":"ckn1qfptu001bhyjfxrmzo810","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpv0003ohyjfqdkbjyg0"},{"post_id":"ckn1qfptu001bhyjfxrmzo810","category_id":"ckn1qfpu1001khyjfc0ki5aa2","_id":"ckn1qfpv1003rhyjfm0uylgib"},{"post_id":"ckn1qfpu0001jhyjfjhx9l67y","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpv1003thyjfca8njkvl"},{"post_id":"ckn1qfpu0001jhyjfjhx9l67y","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpv2003whyjfhf1gany3"},{"post_id":"ckn1qfpu1001lhyjfwib6dwi2","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpv3003yhyjfvi0xk9kc"},{"post_id":"ckn1qfpu1001lhyjfwib6dwi2","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpv40041hyjflk3lr3zg"},{"post_id":"ckn1qfpu3001ohyjfudawn3m2","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpv50043hyjf05sh0nek"},{"post_id":"ckn1qfpu3001ohyjfudawn3m2","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpv60046hyjfxh26zed5"},{"post_id":"ckn1qfpu4001phyjfxp1yd2w7","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpv60048hyjfxhi0zjrw"},{"post_id":"ckn1qfpu4001phyjfxp1yd2w7","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpv7004bhyjfnayeucx7"},{"post_id":"ckn1qfpu4001shyjf7axk2fq7","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpv8004dhyjfsuwq7tc4"},{"post_id":"ckn1qfpu4001shyjf7axk2fq7","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpv8004ghyjffcdfbqc0"},{"post_id":"ckn1qfpu5001uhyjfifzu1xm7","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpv9004ihyjf1h7vit40"},{"post_id":"ckn1qfpu5001uhyjfifzu1xm7","category_id":"ckn1qfpu6001vhyjfqkh0nfly","_id":"ckn1qfpvb004lhyjfg39kpk6i"},{"post_id":"ckn1qfpuw003ghyjflz9r4nat","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpvd004nhyjfrpcm4gjj"},{"post_id":"ckn1qfpuw003ghyjflz9r4nat","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpve004qhyjf1kbxu5hp"},{"post_id":"ckn1qfpub002chyjfe0idjnbj","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpve004shyjfex19oc5t"},{"post_id":"ckn1qfpub002chyjfe0idjnbj","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpvg004vhyjf7hb4wgm2"},{"post_id":"ckn1qfpuc002ehyjfxyb5b57i","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpvh004xhyjfxlbbjm9m"},{"post_id":"ckn1qfpuc002ehyjfxyb5b57i","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpvi0050hyjflhqjh387"},{"post_id":"ckn1qfpue002hhyjf473d7azo","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpvk0052hyjflb2dwv2o"},{"post_id":"ckn1qfpue002hhyjf473d7azo","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpvl0055hyjfynuajmpc"},{"post_id":"ckn1qfpui002jhyjf96h2n92h","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpvm0057hyjf2rx19080"},{"post_id":"ckn1qfpui002jhyjf96h2n92h","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpvn005ahyjfiaurvhgs"},{"post_id":"ckn1qfpuj002mhyjf2ish9l52","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpvn005chyjfix6yv96t"},{"post_id":"ckn1qfpuj002mhyjf2ish9l52","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpvo005fhyjft0pq9373"},{"post_id":"ckn1qfpuk002ohyjfb809bntj","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpvp005hhyjfdy1z1bkr"},{"post_id":"ckn1qfpuk002ohyjfb809bntj","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpvr005khyjf7d53nwy9"},{"post_id":"ckn1qfpul002rhyjfzjf6ywy2","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpvu005mhyjfv39uhxr0"},{"post_id":"ckn1qfpul002rhyjfzjf6ywy2","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpvv005phyjf4m6ooc7g"},{"post_id":"ckn1qfpum002thyjfdwdb29ma","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpvw005rhyjf2kr4z93r"},{"post_id":"ckn1qfpum002thyjfdwdb29ma","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpvx005uhyjfjynedc0t"},{"post_id":"ckn1qfpun002whyjflb6ts5oh","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpvz005whyjfwlv5ogsk"},{"post_id":"ckn1qfpun002whyjflb6ts5oh","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpw0005zhyjfzch6s7go"},{"post_id":"ckn1qfpuo002yhyjf7g8573pb","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpw10061hyjf8pnmqcud"},{"post_id":"ckn1qfpuo002yhyjf7g8573pb","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpw10064hyjfm0mlvi34"},{"post_id":"ckn1qfpuo0031hyjf1rodj2fm","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpw20066hyjfo5br0b0n"},{"post_id":"ckn1qfpuo0031hyjf1rodj2fm","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpw30069hyjfj4ac4yot"},{"post_id":"ckn1qfpup0033hyjf4oq8y9el","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpw3006bhyjfcjwdv475"},{"post_id":"ckn1qfpup0033hyjf4oq8y9el","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpw4006ehyjfpmru6my6"},{"post_id":"ckn1qfpuq0036hyjfj0ajxud8","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpw5006ghyjfhvwcqol2"},{"post_id":"ckn1qfpuq0036hyjfj0ajxud8","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpw6006jhyjf7ql2l0zg"},{"post_id":"ckn1qfpur0038hyjf1ysr67em","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpw6006lhyjf1959orb4"},{"post_id":"ckn1qfpur0038hyjf1ysr67em","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpw7006ohyjfak7i6wsa"},{"post_id":"ckn1qfput003bhyjf12stp5n6","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpw8006qhyjf3upcpu5a"},{"post_id":"ckn1qfput003bhyjf12stp5n6","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpwa006thyjf3x1vyks0"},{"post_id":"ckn1qfpuu003dhyjfng89q1zt","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwb006vhyjfav017ngi"},{"post_id":"ckn1qfpuu003dhyjfng89q1zt","category_id":"ckn1qfpuv003fhyjf10xhvldp","_id":"ckn1qfpwc006yhyjftszmdes1"},{"post_id":"ckn1qfpux003ihyjf6in5zmq3","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwc0070hyjf8uhxt1rb"},{"post_id":"ckn1qfpux003ihyjf6in5zmq3","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwe0073hyjfwynp2zge"},{"post_id":"ckn1qfpuy003lhyjf65gdw98p","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwe0075hyjfwf15l49q"},{"post_id":"ckn1qfpuy003lhyjf65gdw98p","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwf0078hyjfsregw1x0"},{"post_id":"ckn1qfpuz003nhyjfjwdltki0","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwf007ahyjffzm2ttvn"},{"post_id":"ckn1qfpuz003nhyjfjwdltki0","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwg007dhyjfj5osxu3r"},{"post_id":"ckn1qfpv0003qhyjf3481mkho","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwh007fhyjfmq8n243n"},{"post_id":"ckn1qfpv0003qhyjf3481mkho","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwh007ihyjfnsalh7n2"},{"post_id":"ckn1qfpv1003shyjfmn5r72u4","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwi007khyjf7y40roo6"},{"post_id":"ckn1qfpv1003shyjfmn5r72u4","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwj007nhyjf3wu53wkn"},{"post_id":"ckn1qfpv2003vhyjffr83mjuu","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwk007qhyjfzjk2za9w"},{"post_id":"ckn1qfpv2003vhyjffr83mjuu","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwl007thyjfv2ozs7tm"},{"post_id":"ckn1qfpv3003xhyjfwjfcm1du","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwl007whyjf6tylo0gp"},{"post_id":"ckn1qfpv3003xhyjfwjfcm1du","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwm007zhyjfaiv4fezz"},{"post_id":"ckn1qfpv40040hyjfndc3pe9f","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwn0082hyjfq1mojetv"},{"post_id":"ckn1qfpv40040hyjfndc3pe9f","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwo0086hyjf22qbz7ur"},{"post_id":"ckn1qfpv40042hyjfdr9dut5e","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwq008ahyjf80x2fosa"},{"post_id":"ckn1qfpv40042hyjfdr9dut5e","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpws008dhyjfmyufdgll"},{"post_id":"ckn1qfpv50045hyjfhornuqk1","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpws008ghyjfr5e9roub"},{"post_id":"ckn1qfpv50045hyjfhornuqk1","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwt008jhyjf51fca4wh"},{"post_id":"ckn1qfpv60047hyjfptteat65","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwt008lhyjfxslqlofp"},{"post_id":"ckn1qfpv60047hyjfptteat65","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwt008phyjf22zgtkda"},{"post_id":"ckn1qfpv6004ahyjf6cli8w7r","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwt008qhyjfbyhpo1ni"},{"post_id":"ckn1qfpv6004ahyjf6cli8w7r","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwu008uhyjf4jl3hlkf"},{"post_id":"ckn1qfpv7004chyjf5qcgens1","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwu008vhyjffz9oi37i"},{"post_id":"ckn1qfpv7004chyjf5qcgens1","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwv008zhyjfr3cur265"},{"post_id":"ckn1qfpv8004fhyjfgejr4dva","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwv0090hyjff8amapjr"},{"post_id":"ckn1qfpv8004fhyjfgejr4dva","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwv0093hyjfgunqkdd4"},{"post_id":"ckn1qfpv8004hhyjfun9ohvka","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwv0094hyjfpe3wsafp"},{"post_id":"ckn1qfpv8004hhyjfun9ohvka","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpww0097hyjft137va7b"},{"post_id":"ckn1qfpva004khyjfxx6o44zy","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpww0099hyjf2xabpeyr"},{"post_id":"ckn1qfpva004khyjfxx6o44zy","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpww009dhyjftfbzmnot"},{"post_id":"ckn1qfpvc004mhyjf2qh32yex","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpww009ehyjfk2p79czo"},{"post_id":"ckn1qfpvc004mhyjf2qh32yex","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwx009hhyjfe33e2fgv"},{"post_id":"ckn1qfpvd004phyjfn1kz2z9m","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwx009jhyjflwibrzpq"},{"post_id":"ckn1qfpvd004phyjfn1kz2z9m","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpwx009mhyjf7y2qvsqc"},{"post_id":"ckn1qfpve004rhyjf500csmsp","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpwx009ohyjf26nkla1d"},{"post_id":"ckn1qfpve004rhyjf500csmsp","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpx0009qhyjfnkk1qu2y"},{"post_id":"ckn1qfpvf004uhyjfipa9atr1","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx0009rhyjfx4um45zr"},{"post_id":"ckn1qfpvf004uhyjfipa9atr1","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpx1009thyjf1hs88ogn"},{"post_id":"ckn1qfpvh004whyjfilyytc84","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx1009uhyjfwmuu98rl"},{"post_id":"ckn1qfpvh004whyjfilyytc84","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpx1009whyjfcq1hvgrm"},{"post_id":"ckn1qfpvi004zhyjfqhxlqs0h","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx1009xhyjfdnsqcj7v"},{"post_id":"ckn1qfpvi004zhyjfqhxlqs0h","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpx2009zhyjfbx655l88"},{"post_id":"ckn1qfpvj0051hyjfc1lhkowm","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx200a0hyjfljexu6ne"},{"post_id":"ckn1qfpvj0051hyjfc1lhkowm","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpx200a2hyjffwdizsd9"},{"post_id":"ckn1qfpvk0054hyjfz8bayluf","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx200a3hyjfn81wwqnx"},{"post_id":"ckn1qfpvk0054hyjfz8bayluf","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpx200a5hyjfz3x1mcd2"},{"post_id":"ckn1qfpvl0056hyjf2l0xki6s","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx200a6hyjfm1b08fud"},{"post_id":"ckn1qfpvl0056hyjf2l0xki6s","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpx300a8hyjf5zlbp0sa"},{"post_id":"ckn1qfpvm0059hyjfjg6rllo4","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx300a9hyjfkujezzo0"},{"post_id":"ckn1qfpvm0059hyjfjg6rllo4","category_id":"ckn1qfpvu005nhyjfd9gygce9","_id":"ckn1qfpx300abhyjfdayah8s0"},{"post_id":"ckn1qfpvn005bhyjf52yc15yo","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx300achyjffdlb859a"},{"post_id":"ckn1qfpvn005bhyjf52yc15yo","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpx400aehyjfu8fb2uaj"},{"post_id":"ckn1qfpvo005ehyjfhbarev9t","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx400afhyjfff8g7nj4"},{"post_id":"ckn1qfpvo005ehyjfhbarev9t","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpx500ahhyjf6np1qh4l"},{"post_id":"ckn1qfpvo005ghyjfgo9bsv48","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx600aihyjf2k7akit4"},{"post_id":"ckn1qfpvo005ghyjfgo9bsv48","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpx600akhyjfhxpkh0ab"},{"post_id":"ckn1qfpvp005jhyjfquts20ia","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx700alhyjf4jx94mwe"},{"post_id":"ckn1qfpvp005jhyjfquts20ia","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpx700anhyjf8vqlnyip"},{"post_id":"ckn1qfpvs005lhyjfrnqjlk4a","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx800aohyjfgfj8ej6q"},{"post_id":"ckn1qfpvs005lhyjfrnqjlk4a","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpx800aqhyjfszke9pvq"},{"post_id":"ckn1qfpvu005ohyjfxmfle6rp","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx800arhyjfkf19doc2"},{"post_id":"ckn1qfpvu005ohyjfxmfle6rp","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpx800ashyjfg7ukztwc"},{"post_id":"ckn1qfpvv005qhyjftn600mb7","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx800auhyjfd6yymcjp"},{"post_id":"ckn1qfpvv005qhyjftn600mb7","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpx900avhyjf5847mxn4"},{"post_id":"ckn1qfpvw005shyjfpzzazmm2","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx900axhyjfiw4vaq9b"},{"post_id":"ckn1qfpvw005shyjfpzzazmm2","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpx900ayhyjf4yqda7yv"},{"post_id":"ckn1qfpvy005vhyjfgkw5lo31","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpx900b0hyjfbieqtrsf"},{"post_id":"ckn1qfpvy005vhyjfgkw5lo31","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpx900b1hyjftugwza95"},{"post_id":"ckn1qfpvz005xhyjf6scirzck","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxa00b3hyjfk3ongfib"},{"post_id":"ckn1qfpvz005xhyjf6scirzck","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpxa00b4hyjf1fqgp5qr"},{"post_id":"ckn1qfpw00060hyjfagubriyo","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxa00b6hyjfrf5qht12"},{"post_id":"ckn1qfpw00060hyjfagubriyo","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpxa00b7hyjf0fftpbwu"},{"post_id":"ckn1qfpw10062hyjf0qfumkuq","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxa00b9hyjf35d9jy6s"},{"post_id":"ckn1qfpw10062hyjf0qfumkuq","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpxb00bahyjfstaap60i"},{"post_id":"ckn1qfpw10065hyjfiqgtogpr","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxb00bchyjfyw0bo1es"},{"post_id":"ckn1qfpw10065hyjfiqgtogpr","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpxb00bdhyjfzwcttfd0"},{"post_id":"ckn1qfpw20067hyjfp1z1631g","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxc00bfhyjfbr6c2pks"},{"post_id":"ckn1qfpw20067hyjfp1z1631g","category_id":"ckn1qfpww0096hyjfv5w21stz","_id":"ckn1qfpxc00bghyjfqz7am5oc"},{"post_id":"ckn1qfpw3006ahyjfnhd33no1","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxc00bihyjf32slz5hp"},{"post_id":"ckn1qfpw3006ahyjfnhd33no1","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxc00bjhyjfonhns861"},{"post_id":"ckn1qfpw4006chyjfkkml08oc","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxc00blhyjfq8zwnxyg"},{"post_id":"ckn1qfpw4006chyjfkkml08oc","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxd00bmhyjfeylgiwfn"},{"post_id":"ckn1qfpw4006fhyjf18ger2cs","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxd00bohyjfrrdouglj"},{"post_id":"ckn1qfpw4006fhyjf18ger2cs","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxd00bphyjfm94ej077"},{"post_id":"ckn1qfpw5006hhyjf7cimql31","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxd00brhyjfyzbug8jc"},{"post_id":"ckn1qfpw5006hhyjf7cimql31","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxd00bshyjfs0wnt3hc"},{"post_id":"ckn1qfpw6006khyjf114c901i","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxe00buhyjfboau82cv"},{"post_id":"ckn1qfpw6006khyjf114c901i","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxe00bvhyjft4ahsi9n"},{"post_id":"ckn1qfpw6006mhyjfrdlywjt4","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxe00bxhyjf90s4lzp9"},{"post_id":"ckn1qfpw6006mhyjfrdlywjt4","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxe00byhyjfmnx7q88h"},{"post_id":"ckn1qfpw7006phyjf5fdrr3ui","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxe00c0hyjfpobogjiq"},{"post_id":"ckn1qfpw7006phyjf5fdrr3ui","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxf00c1hyjfgb983aie"},{"post_id":"ckn1qfpw8006rhyjfp20n8nvv","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxf00c3hyjfesci5u4v"},{"post_id":"ckn1qfpw8006rhyjfp20n8nvv","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxf00c4hyjf2x97693m"},{"post_id":"ckn1qfpwa006uhyjfgt5ch40a","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxf00c6hyjf3h97zma1"},{"post_id":"ckn1qfpwa006uhyjfgt5ch40a","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxf00c7hyjfwfrzxw97"},{"post_id":"ckn1qfpwb006whyjf1lj2drzq","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxg00c9hyjfvrc1tvm4"},{"post_id":"ckn1qfpwb006whyjf1lj2drzq","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxg00cahyjf1z1zuqqu"},{"post_id":"ckn1qfpwc006zhyjfa6t1h92x","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxg00cchyjfnayp8g3c"},{"post_id":"ckn1qfpwc006zhyjfa6t1h92x","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxg00cdhyjfn477is39"},{"post_id":"ckn1qfpwd0071hyjf9pcr0ty6","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxg00cfhyjf9dab81jc"},{"post_id":"ckn1qfpwd0071hyjf9pcr0ty6","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxg00cghyjf0mhhy4jo"},{"post_id":"ckn1qfpwe0074hyjfrnjzh8k5","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxh00cihyjf03qzqkbo"},{"post_id":"ckn1qfpwe0074hyjfrnjzh8k5","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxh00cjhyjfmgwsr1ij"},{"post_id":"ckn1qfpwe0076hyjfs2z9trf4","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxh00clhyjfgmw6m0ev"},{"post_id":"ckn1qfpwe0076hyjfs2z9trf4","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxh00cmhyjfm1dkzgpz"},{"post_id":"ckn1qfpwf0079hyjfja6htlww","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxh00cohyjfqikzqnf0"},{"post_id":"ckn1qfpwf0079hyjfja6htlww","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxh00cphyjf1aqwk0r8"},{"post_id":"ckn1qfpwg007bhyjfhjs8cgk4","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxi00crhyjfr2rm2m4w"},{"post_id":"ckn1qfpwg007bhyjfhjs8cgk4","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxi00cshyjf6heesrl2"},{"post_id":"ckn1qfpwg007ehyjffciuzjeg","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxi00cuhyjfhgihyyds"},{"post_id":"ckn1qfpwg007ehyjffciuzjeg","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxi00cvhyjf3wub0zlo"},{"post_id":"ckn1qfpwh007ghyjf57j3ouxh","category_id":"ckn1qfptu001ahyjfk65ykb09","_id":"ckn1qfpxi00cxhyjf7g4pj6gn"},{"post_id":"ckn1qfpwh007ghyjf57j3ouxh","category_id":"ckn1qfpx800aphyjfhpn0vuzh","_id":"ckn1qfpxi00cyhyjfypmdalz7"},{"post_id":"ckn1qfpwj007phyjf4klx5fnp","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpxj00d0hyjfjuz3ir74"},{"post_id":"ckn1qfpwk007rhyjfs0k8myz9","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpxj00d1hyjfawejbpeu"},{"post_id":"ckn1qfpwl007uhyjf5k70ypib","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpxj00d2hyjf24ph8h7u"},{"post_id":"ckn1qfpwl007xhyjft2uwyqe6","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpxj00d4hyjfk1hvpykb"},{"post_id":"ckn1qfpwm0080hyjf78fxnp5q","category_id":"ckn1qfpxh00cqhyjf98ajs8zv","_id":"ckn1qfpxj00d5hyjfiojmy1pd"},{"post_id":"ckn1qfpwn0083hyjfflo969po","category_id":"ckn1qfpxh00cqhyjf98ajs8zv","_id":"ckn1qfpxj00d7hyjfqsqjw9p1"},{"post_id":"ckn1qfpwo0087hyjf1fasz2bt","category_id":"ckn1qfpxh00cqhyjf98ajs8zv","_id":"ckn1qfpxj00d8hyjfxrjduvaw"},{"post_id":"ckn1qfpwr008bhyjfhe3zb4gr","category_id":"ckn1qfpxi00czhyjf4iict7ox","_id":"ckn1qfpxk00dahyjf753qsgww"},{"post_id":"ckn1qfpws008ehyjffgo2a3ef","category_id":"ckn1qfpxj00d3hyjfzn7htzsn","_id":"ckn1qfpxk00dbhyjf1l84x3xa"},{"post_id":"ckn1qfpwi007jhyjfu351gneb","category_id":"ckn1qfpxf00c8hyjfibnkf85p","_id":"ckn1qfpxk00dchyjfhpa3iwfn"},{"post_id":"ckn1qfpwi007jhyjfu351gneb","category_id":"ckn1qfpxj00d6hyjf0mjtd33r","_id":"ckn1qfpxk00ddhyjfy1wogh0t"},{"post_id":"ckn1qfpwi007lhyjfi1goh27s","category_id":"ckn1qfpxf00c8hyjfibnkf85p","_id":"ckn1qfpxk00dehyjf75qevidn"},{"post_id":"ckn1qfpwi007lhyjfi1goh27s","category_id":"ckn1qfpxj00d6hyjf0mjtd33r","_id":"ckn1qfpxk00dfhyjfdh5j5tbf"},{"post_id":"ckn1qfpzd00dghyjfp40ho080","category_id":"ckn1qfpxf00c8hyjfibnkf85p","_id":"ckn1qfpzh00dohyjf544378an"},{"post_id":"ckn1qfpzd00dghyjfp40ho080","category_id":"ckn1qfpxj00d6hyjf0mjtd33r","_id":"ckn1qfpzj00dqhyjfll3tzfs2"},{"post_id":"ckn1qfpze00dhhyjfup2rmqsh","category_id":"ckn1qfpzg00dkhyjfekcfczp2","_id":"ckn1qfpzl00dxhyjfz6f6l0xl"},{"post_id":"ckn1qfpzj00drhyjf4wiyhwvw","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpzm00e2hyjfba4c22xw"},{"post_id":"ckn1qfpzk00duhyjf0iub5g37","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpzm00e5hyjfifsbps3c"},{"post_id":"ckn1qfpzl00dwhyjf0r8ulzy5","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpzo00eahyjfke70oj7m"},{"post_id":"ckn1qfpzl00e1hyjfnekrqx9q","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpzo00edhyjfsqc1nnut"},{"post_id":"ckn1qfpzg00dnhyjfd0atifs0","category_id":"ckn1qfpzl00dyhyjfd5dsbme5","_id":"ckn1qfpzq00eihyjfmbdd2aw9"},{"post_id":"ckn1qfpzm00e4hyjf3sfmv0b9","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpzr00elhyjfg7zreqtz"},{"post_id":"ckn1qfpzn00e9hyjfn8iimp1w","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpzs00ephyjfpkpuqugj"},{"post_id":"ckn1qfpzo00echyjfar91vjaf","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpzt00ethyjfy875ny5b"},{"post_id":"ckn1qfpzp00ehhyjfv1jex8wa","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpzu00ewhyjf60rjo9id"},{"post_id":"ckn1qfpzf00djhyjfemer3slv","category_id":"ckn1qfpzj00dshyjf5xjz933v","_id":"ckn1qfpzv00f0hyjf3dn3jdkr"},{"post_id":"ckn1qfpzf00djhyjfemer3slv","category_id":"ckn1qfpzp00eehyjft3vomhrk","_id":"ckn1qfpzx00f3hyjf90set02u"},{"post_id":"ckn1qfpzq00ekhyjf97cd9a3z","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfpzz00f7hyjfynn0df62"},{"post_id":"ckn1qfpzs00eohyjf2ry84s9b","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfq0000fahyjf6g90exj4"},{"post_id":"ckn1qfpzs00eshyjfpjwvfbej","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfq0200fehyjfd0lfil66"},{"post_id":"ckn1qfpzi00dphyjfze88t5ck","category_id":"ckn1qfpzj00dshyjf5xjz933v","_id":"ckn1qfq0200fhhyjfswt76egb"},{"post_id":"ckn1qfpzi00dphyjfze88t5ck","category_id":"ckn1qfpzr00enhyjf0g4dizim","_id":"ckn1qfq0300fjhyjf0ldcitq9"},{"post_id":"ckn1qfpzt00evhyjfttt0t9h8","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfq0300flhyjfcx3fq73q"},{"post_id":"ckn1qfpzu00ezhyjflane9jw0","category_id":"ckn1qfpxh00cqhyjf98ajs8zv","_id":"ckn1qfq0300fnhyjfu9yntl9b"},{"post_id":"ckn1qfpzw00f2hyjfyzaok49b","category_id":"ckn1qfpxi00czhyjf4iict7ox","_id":"ckn1qfq0300fphyjfepb0almo"},{"post_id":"ckn1qfpzz00f6hyjfvukgkk43","category_id":"ckn1qfpxi00czhyjf4iict7ox","_id":"ckn1qfq0300frhyjfc57bif0i"},{"post_id":"ckn1qfq0000f9hyjfueho52d7","category_id":"ckn1qfpxj00d3hyjfzn7htzsn","_id":"ckn1qfq0400fthyjfgf34yen1"},{"post_id":"ckn1qfq0100fdhyjfe4s0es05","category_id":"ckn1qfpxj00d3hyjfzn7htzsn","_id":"ckn1qfq0400fvhyjfd96a9x3c"},{"post_id":"ckn1qfq0200fghyjfa7bme090","category_id":"ckn1qfpxj00d3hyjfzn7htzsn","_id":"ckn1qfq0400fxhyjfxipsmyqs"},{"post_id":"ckn1qfq0900g4hyjf906x3313","category_id":"ckn1qfpxf00c8hyjfibnkf85p","_id":"ckn1qfq0c00gbhyjf50r83sfz"},{"post_id":"ckn1qfq0900g4hyjf906x3313","category_id":"ckn1qfpxj00d6hyjf0mjtd33r","_id":"ckn1qfq0c00gchyjfpletyyx4"},{"post_id":"ckn1qfq0b00g7hyjf4txk17sp","category_id":"ckn1qfpxg00cehyjf8t9sm4q5","_id":"ckn1qfq0d00gehyjflvq6sxyu"},{"post_id":"ckn1qfq0a00g5hyjf3akbp14x","category_id":"ckn1qfq0b00g8hyjfzdzgz1cv","_id":"ckn1qfq0d00gfhyjf0fmcu57e"},{"post_id":"ckn1qfq0h00gmhyjffl0pxrc4","category_id":"ckn1qfq0b00g8hyjfzdzgz1cv","_id":"ckn1qfq0j00gqhyjfoa3fkna1"},{"post_id":"ckn1qfq0i00gnhyjf8lhtq396","category_id":"ckn1qfq0b00g8hyjfzdzgz1cv","_id":"ckn1qfq0j00gshyjfxo3wasl5"}],"PostTag":[{"post_id":"ckn1qfpq00005hyjf18zl65g9","tag_id":"ckn1qfpq90007hyjfz17mc8sp","_id":"ckn1qfpqc000chyjfy4y47t5n"},{"post_id":"ckn1qfpq00005hyjf18zl65g9","tag_id":"ckn1qfpqa0008hyjfglb0mn2u","_id":"ckn1qfpqc000dhyjfxlxp075u"},{"post_id":"ckn1qfpq00005hyjf18zl65g9","tag_id":"ckn1qfpqb000ahyjfyn96cmcp","_id":"ckn1qfpqc000ehyjf7thdab7s"},{"post_id":"ckn1qfpq00005hyjf18zl65g9","tag_id":"ckn1qfpqb000bhyjfzu0ow23c","_id":"ckn1qfpqc000fhyjfpfxf78m3"},{"post_id":"ckn1qfpr3000ghyjfw21gam39","tag_id":"ckn1qfpq90007hyjfz17mc8sp","_id":"ckn1qfpr7000ihyjfl4e854s1"},{"post_id":"ckn1qfpr3000ghyjfw21gam39","tag_id":"ckn1qfpqa0008hyjfglb0mn2u","_id":"ckn1qfpr8000jhyjfzxumyqcg"},{"post_id":"ckn1qfpr3000ghyjfw21gam39","tag_id":"ckn1qfpqb000ahyjfyn96cmcp","_id":"ckn1qfpr8000lhyjflbc8id3n"},{"post_id":"ckn1qfpr5000hhyjf0sufl94y","tag_id":"ckn1qfpq90007hyjfz17mc8sp","_id":"ckn1qfpr8000nhyjf7buhvuho"},{"post_id":"ckn1qfpr5000hhyjf0sufl94y","tag_id":"ckn1qfpqa0008hyjfglb0mn2u","_id":"ckn1qfpr8000ohyjfhxdat05m"},{"post_id":"ckn1qfpr5000hhyjf0sufl94y","tag_id":"ckn1qfpqb000ahyjfyn96cmcp","_id":"ckn1qfpr8000phyjf30dc9wzv"},{"post_id":"ckn1qfpso000qhyjfh7iyye5w","tag_id":"ckn1qfpsq000thyjfx69q8x2w","_id":"ckn1qfpst0011hyjftn0ohcdw"},{"post_id":"ckn1qfpso000qhyjfh7iyye5w","tag_id":"ckn1qfpsq000vhyjfwin58tgk","_id":"ckn1qfpst0012hyjfyo74hebh"},{"post_id":"ckn1qfpso000qhyjfh7iyye5w","tag_id":"ckn1qfpss000xhyjfq2lohacq","_id":"ckn1qfpst0014hyjf6qx70knp"},{"post_id":"ckn1qfpso000qhyjfh7iyye5w","tag_id":"ckn1qfpss000zhyjfwbkrutet","_id":"ckn1qfpsu0015hyjf2ziyiy03"},{"post_id":"ckn1qfpsp000rhyjfi5hbo0mi","tag_id":"ckn1qfpsq000thyjfx69q8x2w","_id":"ckn1qfpsu0016hyjfhq5aynkv"},{"post_id":"ckn1qfpsp000rhyjfi5hbo0mi","tag_id":"ckn1qfpss000zhyjfwbkrutet","_id":"ckn1qfpsu0017hyjfzja274iu"},{"post_id":"ckn1qfpwi007jhyjfu351gneb","tag_id":"ckn1qfpwj007ohyjfzvw4jhsv","_id":"ckn1qfpwo0084hyjf8yx36gfl"},{"post_id":"ckn1qfpwi007jhyjfu351gneb","tag_id":"ckn1qfpwl007vhyjf5xdkcbu4","_id":"ckn1qfpwq0088hyjfg2gq591x"},{"post_id":"ckn1qfpwi007lhyjfi1goh27s","tag_id":"ckn1qfpwj007ohyjfzvw4jhsv","_id":"ckn1qfpws008hhyjf3btddkgx"},{"post_id":"ckn1qfpwi007lhyjfi1goh27s","tag_id":"ckn1qfpwl007vhyjf5xdkcbu4","_id":"ckn1qfpwt008khyjfpo05yeet"},{"post_id":"ckn1qfpwj007phyjf4klx5fnp","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpwt008ohyjf14x2grq3"},{"post_id":"ckn1qfpwk007rhyjfs0k8myz9","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpwu008thyjflbydx1eh"},{"post_id":"ckn1qfpwl007uhyjf5k70ypib","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpwv008yhyjfela7rxen"},{"post_id":"ckn1qfpwl007xhyjft2uwyqe6","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpww0098hyjfs0ogwxc6"},{"post_id":"ckn1qfpwl007xhyjft2uwyqe6","tag_id":"ckn1qfpwv0091hyjfqpknw8r2","_id":"ckn1qfpww009ahyjftfqkg7x6"},{"post_id":"ckn1qfpwr008bhyjfhe3zb4gr","tag_id":"ckn1qfpwv0095hyjfqfapncbz","_id":"ckn1qfpwx009ihyjfbn0ia1tq"},{"post_id":"ckn1qfpwr008bhyjfhe3zb4gr","tag_id":"ckn1qfpww009bhyjfciw6ixx1","_id":"ckn1qfpwx009khyjfzr9lxqcb"},{"post_id":"ckn1qfpws008ehyjffgo2a3ef","tag_id":"ckn1qfpwx009fhyjfvm75v6gy","_id":"ckn1qfpwx009nhyjfiu0g9kgx"},{"post_id":"ckn1qfpzd00dghyjfp40ho080","tag_id":"ckn1qfpwj007ohyjfzvw4jhsv","_id":"ckn1qfpzf00dihyjfkgniccai"},{"post_id":"ckn1qfpzd00dghyjfp40ho080","tag_id":"ckn1qfpwl007vhyjf5xdkcbu4","_id":"ckn1qfpzg00dmhyjf69an04ad"},{"post_id":"ckn1qfpzj00drhyjf4wiyhwvw","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpzk00dvhyjf9idxsn2e"},{"post_id":"ckn1qfpzk00duhyjf0iub5g37","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpzl00e0hyjfrtv8kf54"},{"post_id":"ckn1qfpzl00dwhyjf0r8ulzy5","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpzm00e3hyjfcbqp6iws"},{"post_id":"ckn1qfpzl00e1hyjfnekrqx9q","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpzn00e8hyjfwpt1f4i8"},{"post_id":"ckn1qfpze00dhhyjfup2rmqsh","tag_id":"ckn1qfpzg00dlhyjfoa2s92j7","_id":"ckn1qfpzo00ebhyjf68jqt1v8"},{"post_id":"ckn1qfpze00dhhyjfup2rmqsh","tag_id":"ckn1qfpzj00dthyjf1xemspyb","_id":"ckn1qfpzp00efhyjfxiaxizxw"},{"post_id":"ckn1qfpze00dhhyjfup2rmqsh","tag_id":"ckn1qfpzl00dzhyjfg6xe0lc1","_id":"ckn1qfpzq00ejhyjfa6juzliu"},{"post_id":"ckn1qfpzm00e4hyjf3sfmv0b9","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpzr00emhyjfw25z2261"},{"post_id":"ckn1qfpzn00e9hyjfn8iimp1w","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpzs00erhyjfhqjbuoox"},{"post_id":"ckn1qfpzo00echyjfar91vjaf","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpzt00euhyjfujf8vz1e"},{"post_id":"ckn1qfpzp00ehhyjfv1jex8wa","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpzu00eyhyjfv0xi59yj"},{"post_id":"ckn1qfpzp00ehhyjfv1jex8wa","tag_id":"ckn1qfpwv0091hyjfqpknw8r2","_id":"ckn1qfpzw00f1hyjf136km9ai"},{"post_id":"ckn1qfpzq00ekhyjf97cd9a3z","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfpzy00f5hyjf7rml9p19"},{"post_id":"ckn1qfpzq00ekhyjf97cd9a3z","tag_id":"ckn1qfpwv0091hyjfqpknw8r2","_id":"ckn1qfq0000f8hyjf0nrc00v4"},{"post_id":"ckn1qfpzf00djhyjfemer3slv","tag_id":"ckn1qfpzn00e7hyjf7kcar3kf","_id":"ckn1qfq0100fchyjfwohxd52x"},{"post_id":"ckn1qfpzf00djhyjfemer3slv","tag_id":"ckn1qfpzp00eghyjftk6hg3ut","_id":"ckn1qfq0200ffhyjf69md1uf8"},{"post_id":"ckn1qfpzs00eohyjf2ry84s9b","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfq0300fihyjfzvk1d5jz"},{"post_id":"ckn1qfpzs00eohyjf2ry84s9b","tag_id":"ckn1qfpwv0091hyjfqpknw8r2","_id":"ckn1qfq0300fkhyjf0mpsiq7t"},{"post_id":"ckn1qfpzs00eshyjfpjwvfbej","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfq0300fmhyjfwdmxic42"},{"post_id":"ckn1qfpzs00eshyjfpjwvfbej","tag_id":"ckn1qfpwv0091hyjfqpknw8r2","_id":"ckn1qfq0300fohyjf7nwoytqt"},{"post_id":"ckn1qfpzg00dnhyjfd0atifs0","tag_id":"ckn1qfpzs00eqhyjf45z3p6v0","_id":"ckn1qfq0300fqhyjfeahb53rd"},{"post_id":"ckn1qfpzt00evhyjfttt0t9h8","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfq0300fshyjfgm9n66xt"},{"post_id":"ckn1qfpzw00f2hyjfyzaok49b","tag_id":"ckn1qfpwv0095hyjfqfapncbz","_id":"ckn1qfq0400fuhyjf61a4q5as"},{"post_id":"ckn1qfpzi00dphyjfze88t5ck","tag_id":"ckn1qfpzn00e7hyjf7kcar3kf","_id":"ckn1qfq0400fwhyjfg7kkr9w4"},{"post_id":"ckn1qfpzi00dphyjfze88t5ck","tag_id":"ckn1qfpzp00eghyjftk6hg3ut","_id":"ckn1qfq0400fyhyjfmfmgbm3j"},{"post_id":"ckn1qfq0000f9hyjfueho52d7","tag_id":"ckn1qfpwx009fhyjfvm75v6gy","_id":"ckn1qfq0400fzhyjfo2xp2jnu"},{"post_id":"ckn1qfq0100fdhyjfe4s0es05","tag_id":"ckn1qfpwx009fhyjfvm75v6gy","_id":"ckn1qfq0400g0hyjfnl1k47a2"},{"post_id":"ckn1qfq0200fghyjfa7bme090","tag_id":"ckn1qfpwx009fhyjfvm75v6gy","_id":"ckn1qfq0400g1hyjfsn1a672o"},{"post_id":"ckn1qfpzz00f6hyjfvukgkk43","tag_id":"ckn1qfpwv0095hyjfqfapncbz","_id":"ckn1qfq0500g2hyjf7ffcxcc6"},{"post_id":"ckn1qfpzz00f6hyjfvukgkk43","tag_id":"ckn1qfq0100fbhyjfzedx3kym","_id":"ckn1qfq0500g3hyjfgzadyous"},{"post_id":"ckn1qfq0900g4hyjf906x3313","tag_id":"ckn1qfpwj007ohyjfzvw4jhsv","_id":"ckn1qfq0b00g6hyjf6j96kv3s"},{"post_id":"ckn1qfq0900g4hyjf906x3313","tag_id":"ckn1qfpwl007vhyjf5xdkcbu4","_id":"ckn1qfq0c00gahyjf85o2cl0y"},{"post_id":"ckn1qfq0a00g5hyjf3akbp14x","tag_id":"ckn1qfq0c00g9hyjfyi1b7goo","_id":"ckn1qfq0d00ghhyjf0lq6f92t"},{"post_id":"ckn1qfq0a00g5hyjf3akbp14x","tag_id":"ckn1qfq0c00gdhyjfy3j21h4a","_id":"ckn1qfq0d00gihyjfbto1izdd"},{"post_id":"ckn1qfq0b00g7hyjf4txk17sp","tag_id":"ckn1qfpws008fhyjf08j0t992","_id":"ckn1qfq0d00gjhyjfet2v42um"},{"post_id":"ckn1qfq0b00g7hyjf4txk17sp","tag_id":"ckn1qfpwv0091hyjfqpknw8r2","_id":"ckn1qfq0d00gkhyjf1c782cjx"},{"post_id":"ckn1qfq0b00g7hyjf4txk17sp","tag_id":"ckn1qfq0d00gghyjfpgyugv0m","_id":"ckn1qfq0d00glhyjfg0hn99ml"},{"post_id":"ckn1qfq0h00gmhyjffl0pxrc4","tag_id":"ckn1qfq0c00g9hyjfyi1b7goo","_id":"ckn1qfq0j00gohyjfsggp0mm2"},{"post_id":"ckn1qfq0h00gmhyjffl0pxrc4","tag_id":"ckn1qfq0c00gdhyjfy3j21h4a","_id":"ckn1qfq0j00gphyjfo41kt6ri"},{"post_id":"ckn1qfq0i00gnhyjf8lhtq396","tag_id":"ckn1qfq0c00g9hyjfyi1b7goo","_id":"ckn1qfq0j00grhyjfj7xl7u7l"},{"post_id":"ckn1qfq0i00gnhyjf8lhtq396","tag_id":"ckn1qfq0c00gdhyjfy3j21h4a","_id":"ckn1qfq0j00gthyjfwh57ig8s"}],"Tag":[{"name":"持续集成","_id":"ckn1qfpq90007hyjfz17mc8sp"},{"name":"Jenkins","_id":"ckn1qfpqa0008hyjfglb0mn2u"},{"name":"自动化发布","_id":"ckn1qfpqb000ahyjfyn96cmcp"},{"name":"NuGet","_id":"ckn1qfpqb000bhyjfzu0ow23c"},{"name":"日志","_id":"ckn1qfpsq000thyjfx69q8x2w"},{"name":"kafka","_id":"ckn1qfpsq000vhyjfwin58tgk"},{"name":"elk","_id":"ckn1qfpss000xhyjfq2lohacq"},{"name":"log4net","_id":"ckn1qfpss000zhyjfwbkrutet"},{"name":"读书笔记","_id":"ckn1qfpwj007ohyjfzvw4jhsv"},{"name":"大型网站技术架构","_id":"ckn1qfpwl007vhyjf5xdkcbu4"},{"name":"Redis","_id":"ckn1qfpws008fhyjf08j0t992"},{"name":"数据结构","_id":"ckn1qfpwv0091hyjfqpknw8r2"},{"name":"代码的艺术","_id":"ckn1qfpwv0095hyjfqfapncbz"},{"name":"设计原则","_id":"ckn1qfpww009bhyjfciw6ixx1"},{"name":"单元测试","_id":"ckn1qfpwx009fhyjfvm75v6gy"},{"name":"项目管理","_id":"ckn1qfpzg00dlhyjfoa2s92j7"},{"name":"敏捷开发","_id":"ckn1qfpzj00dthyjf1xemspyb"},{"name":"工时评估","_id":"ckn1qfpzl00dzhyjfg6xe0lc1"},{"name":"团队方法论","_id":"ckn1qfpzn00e7hyjf7kcar3kf"},{"name":"监控告警体系","_id":"ckn1qfpzp00eghyjftk6hg3ut"},{"name":"分层架构、DDD","_id":"ckn1qfpzs00eqhyjf45z3p6v0"},{"name":"RESTful","_id":"ckn1qfq0100fbhyjfzedx3kym"},{"name":"消息队列","_id":"ckn1qfq0c00g9hyjfyi1b7goo"},{"name":"RabbitMQ","_id":"ckn1qfq0c00gdhyjfy3j21h4a"},{"name":"散列表","_id":"ckn1qfq0d00gghyjfpgyugv0m"}]}}